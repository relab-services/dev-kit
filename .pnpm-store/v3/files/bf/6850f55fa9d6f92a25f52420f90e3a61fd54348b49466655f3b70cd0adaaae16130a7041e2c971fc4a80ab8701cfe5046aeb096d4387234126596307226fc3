//-----------------------------------------------------------------------------
// Options
//-----------------------------------------------------------------------------

/**
 * The mode that Momoa runs in:
 * - "json" for regular JSON
 * - "jsonc" for JSON with C-style comments
 */
type Mode$1 = "json" | "jsonc";

/**
 * Tokenization options.
 */
interface TokenizeOptions$1 {

    /**
     * The mode to tokenize in.
     */
    readonly mode: Mode$1;

    /**
     * When true, includes the `range` key on each token.
     */
    readonly ranges: boolean;
}

/**
 * Parse options.
 */
interface ParseOptions$1 {

    /**
     * The mode to parse in.
     */
    readonly mode: Mode$1;

    /**
     * When true, includes the `range` key on each node and token.
     */
    readonly ranges: boolean;

    /**
     * When true, includes the `tokens` key on the document node containing
     * all of the tokens used during parsing.
     */
    readonly tokens: boolean;
}

//-----------------------------------------------------------------------------
// Nodes
//-----------------------------------------------------------------------------

interface Node$1 {
    type: string;
    loc?: LocationRange;
    range?: Range;
}

/**
 * The root node of a JSON document.
 */
interface DocumentNode$1 extends Node$1 {
    type: "Document";
    body: ValueNode$1;
}

interface NullNode$1 extends Node$1 {
    type: "Null";
}

interface LiteralNode<T> extends Node$1 {
    value: T;
}

/**
 * Represents a JSON string.
 */
interface StringNode$1 extends LiteralNode<string> {
    type: "String";
}

/**
 * Represents a JSON number.
 */
interface NumberNode$1 extends LiteralNode<number> {
    type: "Number";
}

/**
 * Represents a JSON boolean.
 */
interface BooleanNode$1 extends LiteralNode<boolean> {
    type: "Boolean";
}

/**
 * Represents an element of a JSON array.
 */
interface ElementNode$1 extends Node$1 {
    type: "Element";
    value: ValueNode$1;
}

/**
 * Represents a JSON array.
 */
interface ArrayNode$1 extends Node$1 {
    type: "Array";
    elements: Array<ElementNode$1>;
}

/**
 * Represents a member of a JSON object.
 */
interface MemberNode$1 extends Node$1 {
    type: "Member";
    name: StringNode$1;
    value: ValueNode$1;
}

/**
 * Represents a JSON object.
 */
interface ObjectNode$1 extends Node$1 {
    type: "Object";
    members: Array<MemberNode$1>;
}

/**
 * Any node that represents a JSON value.
 */
type ValueNode$1 = ArrayNode$1 | ObjectNode$1 | 
    BooleanNode$1 | StringNode$1 | NumberNode$1 | NullNode$1;

/**
 * Any node that represents the container for a JSON value.
 */
type ContainerNode = DocumentNode$1 | MemberNode$1 | ElementNode$1;

/**
 * Any valid AST node.
 */
type AnyNode$1 = ValueNode$1 | ContainerNode;

/**
 * Additional information about an AST node.
 */
interface NodeParts$1 {
    loc?: LocationRange;
    range?: Range;
}

//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------

/**
 * Values that can be represented in JSON.
 */
type JSONValue$1 =
    | Array<JSONValue$1>
    | boolean
    | number
    | string
    | { [property: string]: JSONValue$1 }
    | null;

//-----------------------------------------------------------------------------
// Tokens
//-----------------------------------------------------------------------------

/**
 * A token used to during JSON parsing.
 */
interface Token$1 {
    type: TokenType$1;
    loc: LocationRange;
    range?: Range;
}

/**
 * The type of token.
 */
type TokenType$1 = "Number" | "String" | "Boolean" | "Colon" | "LBrace" |
    "RBrace" | "RBracket" | "LBracket" | "Comma" | "Null" | "LineComment" |
    "BlockComment";

//-----------------------------------------------------------------------------
// Location Related
//-----------------------------------------------------------------------------

/**
 * The start and stop location for a token or node inside the source text.
 */
interface LocationRange {
    start: Location$1;
    end: Location$1;
}

/**
 * A cursor location inside the source text.
 */
interface Location$1 {
    line: number;
    column: number;
    offset: number;
}

/**
 * The start and stop offset for a given node or token inside the source text.
 */
type Range = number[];

type FilterPredicate = (node: Node, index: number, array: Array<Node>) => boolean;
type AnyNode = AnyNode$1;
type JSONValue = JSONValue$1;
type TokenType = TokenType$1;
type Location = Location$1;
type Token = Token$1;
type TokenizeOptions = TokenizeOptions$1;
type NodeParts = NodeParts$1;
type DocumentNode = DocumentNode$1;
type StringNode = StringNode$1;
type NumberNode = NumberNode$1;
type BooleanNode = BooleanNode$1;
type MemberNode = MemberNode$1;
type ObjectNode = ObjectNode$1;
type ElementNode = ElementNode$1;
type ArrayNode = ArrayNode$1;
type NullNode = NullNode$1;
type ValueNode = ValueNode$1;
type Node = Node$1;
type Mode = Mode$1;
type ParseOptions = ParseOptions$1;
/**
 * @fileoverview Evaluator for Momoa AST.
 * @author Nicholas C. Zakas
 */
/** @typedef {import("./typings").AnyNode} AnyNode */
/** @typedef {import("./typings").JSONValue} JSONValue */
/**
 * Evaluates a Momoa AST node into a JavaScript value.
 * @param {AnyNode} node The node to interpet.
 * @returns {JSONValue} The JavaScript value for the node.
 */
declare function evaluate(node: AnyNode): JSONValue;
/**
 * @callback FilterPredicate
 * @param {Node} node
 * @param {number} index
 * @param {Array<Node>} array
 * @returns {boolean}
 */
/**
 * Creates an iterator over the given AST.
 * @param {Node} root The root AST node to traverse.
 * @param {FilterPredicate} [filter] A filter function to determine which steps to
 *      return;
 * @returns {Iterator} An iterator over the AST.
 */
declare function iterator(root: Node, filter?: FilterPredicate): Iterator<any, any, undefined>;
/**
 *
 * @param {string} text The text to parse.
 * @param {ParseOptions} [options] The options object.
 * @returns {DocumentNode} The AST representing the parsed JSON.
 * @throws {Error} When there is a parsing error.
 */
declare function parse(text: string, options?: ParseOptions): DocumentNode;
/**
 * @fileoverview Printer for Momoa AST.
 * @author Nicholas C. Zakas
 */
/**
 * Converts a Momoa AST back into a JSON string.
 * @param {AnyNode} node The node to print.
 * @param {Object} options Options for the print.
 * @param {number} [options.indent=0] The number of spaces to indent each line. If
 *      greater than 0, then newlines and indents will be added to output.
 * @returns {string} The JSON representation of the AST.
 */
declare function print(node: AnyNode, { indent }?: {
    indent?: number;
}): string;
/**
 * Creates an iterator over the tokens representing the source text.
 * @param {string} text The source text to tokenize.
 * @param {TokenizeOptions} options Options for doing the tokenization.
 * @returns {Array<Token>} An iterator over the tokens.
 */
declare function tokenize(text: string, options: TokenizeOptions): Array<Token>;
/**
 * Traverses an AST from the given node.
 * @param {Node} root The node to traverse from
 * @param {Object} visitor An object with an `enter` and `exit` method.
 */
declare function traverse(root: Node, visitor: any): void;
declare namespace types {
    /**
     * Creates a document node.
     * @param {ValueNode} body The body of the document.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {DocumentNode} The document node.
     */
    export function document(body: ValueNode$1, parts?: NodeParts$1): DocumentNode$1;
    /**
     * Creates a string node.
     * @param {string} value The value for the string.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {StringNode} The string node.
     */
    export function string(value: string, parts?: NodeParts$1): StringNode$1;
    /**
     * Creates a number node.
     * @param {number} value The value for the number.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {NumberNode} The number node.
     */
    export function number(value: number, parts?: NodeParts$1): NumberNode$1;
    /**
     * Creates a boolean node.
     * @param {boolean} value The value for the boolean.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {BooleanNode} The boolean node.
     */
    export function boolean(value: boolean, parts?: NodeParts$1): BooleanNode$1;
    /**
     * Creates a null node.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {NullNode} The null node.
     */
    function _null(parts?: NodeParts$1): NullNode$1;
    export { _null as null };
    /**
     * Creates an array node.
     * @param {Array<ElementNode>} elements The elements to add.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {ArrayNode} The array node.
     */
    export function array(elements: ElementNode$1[], parts?: NodeParts$1): ArrayNode$1;
    /**
     * Creates an element node.
     * @param {ValueNode} value The value for the element.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {ElementNode} The element node.
     */
    export function element(value: ValueNode$1, parts?: NodeParts$1): ElementNode$1;
    /**
     * Creates an object node.
     * @param {Array<MemberNode>} members The members to add.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {ObjectNode} The object node.
     */
    export function object(members: MemberNode$1[], parts?: NodeParts$1): ObjectNode$1;
    /**
     * Creates a member node.
     * @param {StringNode} name The name for the member.
     * @param {ValueNode} value The value for the member.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {MemberNode} The member node.
     */
    export function member(name: StringNode$1, value: ValueNode$1, parts?: NodeParts$1): MemberNode$1;
}

export { AnyNode, ArrayNode, BooleanNode, DocumentNode, ElementNode, FilterPredicate, JSONValue, Location, MemberNode, Mode, Node, NodeParts, NullNode, NumberNode, ObjectNode, ParseOptions, StringNode, Token, TokenType, TokenizeOptions, ValueNode, evaluate, iterator, parse, print, tokenize, traverse, types };
