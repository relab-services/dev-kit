import { OpenAPI } from 'openapi-types';
import { OpenAPIV2 } from 'openapi-types';
import { OpenAPIV3 } from 'openapi-types';
import { OpenAPIV3_1 } from 'openapi-types';

export declare type AjvOptions = {
    strict?: boolean | 'log';
};

export declare type AnyObject = Record<string, any>;

/**
 * Get versions of the OpenAPI specification.
 */
export declare function details(specification: AnyObject): {
    version: "2.0" | "3.0" | "3.1";
    specificationType: string;
    specificationVersion: string;
};

declare type EmptyObject = Record<string, never>;

export declare type ErrorObject = {
    start: {
        line: number;
        column: number;
        offset: number;
    };
    error: string;
    path: string;
};

/**
 * Not literally a filesystem, but a list of files with their content.
 * This is an abstraction layer to handle multiple files in the browser (without access to the hard disk).
 */
export declare type Filesystem = FilesystemEntry[];

/**
 * Holds all information about a single file (doesn’t have to be a literal file, see Filesystem).
 */
export declare type FilesystemEntry = {
    dir: string;
    isEntrypoint: boolean;
    references: string[];
    filename: string;
    specification: AnyObject;
};

/**
 * Filter the specification based on the callback
 */
export declare function filter(specification: AnyObject, callback: (schema: AnyObject) => boolean): AnyObject;

/**
 * Walks through the specification and returns all references as an array.
 *
 * Warning: Doesn’t return internal references.
 */
export declare function getListOfReferences(specification: AnyObject): string[];

declare interface IJsonSchema {
    id?: string;
    $schema?: string;
    title?: string;
    description?: string;
    multipleOf?: number;
    maximum?: number;
    exclusiveMaximum?: boolean;
    minimum?: number;
    exclusiveMinimum?: boolean;
    maxLength?: number;
    minLength?: number;
    pattern?: string;
    additionalItems?: boolean | IJsonSchema;
    items?: IJsonSchema | IJsonSchema[];
    maxItems?: number;
    minItems?: number;
    uniqueItems?: boolean;
    maxProperties?: number;
    minProperties?: number;
    required?: string[];
    additionalProperties?: boolean | IJsonSchema;
    definitions?: {
        [name: string]: IJsonSchema;
    };
    properties?: {
        [name: string]: IJsonSchema;
    };
    patternProperties?: {
        [name: string]: IJsonSchema;
    };
    dependencies?: {
        [name: string]: IJsonSchema | string[];
    };
    enum?: any[];
    type?: string | string[];
    allOf?: IJsonSchema[];
    anyOf?: IJsonSchema[];
    oneOf?: IJsonSchema[];
    not?: IJsonSchema;
    $ref?: string;
}

/**
 * Check if the value is a filesystem
 */
export declare function isFilesystem(value: any): boolean;

declare function loadAction(specification: string | AnyObject): {
    get: () => AnyObject;
    details: () => {
        version: "2.0" | "3.0" | "3.1";
        specificationType: string;
        specificationVersion: string;
    };
    filter: (callback: (Specification: AnyObject) => boolean) => {
        get: () => AnyObject;
        details: () => {
            version: "2.0" | "3.0" | "3.1";
            specificationType: string;
            specificationVersion: string;
        };
        filter: () => any;
        upgrade: () => {
            get: () => AnyObject;
            details: () => {
                version: "2.0" | "3.0" | "3.1";
                specificationType: string;
                specificationVersion: string;
            };
            filter: (callback: (Specification: AnyObject) => boolean) => any;
            validate: () => Promise<{
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                get: () => AnyObject;
                details: () => {
                    version: "2.0" | "3.0" | "3.1";
                    specificationType: string;
                    specificationVersion: string;
                };
                resolve: () => Promise<{
                    filter: (callback: (Specification: AnyObject) => boolean) => any;
                    toJson: () => string;
                    toYaml: () => string;
                    valid: boolean;
                    version: string;
                    specification?: OpenAPI.Document<{}>;
                    schema?: ResolvedOpenAPI.Document<EmptyObject>;
                    errors?: ErrorObject[];
                }>;
                toJson: () => string;
                toYaml: () => string;
                valid: boolean;
                specification?: OpenAPI.Document<{}>;
                version?: string;
                errors?: ErrorObject[];
            }>;
            resolve: () => Promise<{
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                toJson: () => string;
                toYaml: () => string;
                valid: boolean;
                version: string;
                specification?: OpenAPI.Document<{}>;
                schema?: ResolvedOpenAPI.Document<EmptyObject>;
                errors?: ErrorObject[];
            }>;
            toJson: () => string;
            toYaml: () => string;
        };
        validate: () => Promise<{
            filter: (callback: (Specification: AnyObject) => boolean) => any;
            get: () => AnyObject;
            details: () => {
                version: "2.0" | "3.0" | "3.1";
                specificationType: string;
                specificationVersion: string;
            };
            resolve: () => Promise<{
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                toJson: () => string;
                toYaml: () => string;
                valid: boolean;
                version: string;
                specification?: OpenAPI.Document<{}>;
                schema?: ResolvedOpenAPI.Document<EmptyObject>;
                errors?: ErrorObject[];
            }>;
            toJson: () => string;
            toYaml: () => string;
            valid: boolean;
            specification?: OpenAPI.Document<{}>;
            version?: string;
            errors?: ErrorObject[];
        }>;
        resolve: () => Promise<{
            filter: (callback: (Specification: AnyObject) => boolean) => any;
            toJson: () => string;
            toYaml: () => string;
            valid: boolean;
            version: string;
            specification?: OpenAPI.Document<{}>;
            schema?: ResolvedOpenAPI.Document<EmptyObject>;
            errors?: ErrorObject[];
        }>;
        toJson: () => string;
        toYaml: () => string;
    };
    upgrade: () => {
        get: () => AnyObject;
        details: () => {
            version: "2.0" | "3.0" | "3.1";
            specificationType: string;
            specificationVersion: string;
        };
        filter: (callback: (Specification: AnyObject) => boolean) => {
            get: () => AnyObject;
            details: () => {
                version: "2.0" | "3.0" | "3.1";
                specificationType: string;
                specificationVersion: string;
            };
            filter: () => any;
            upgrade: () => any;
            validate: () => Promise<{
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                get: () => AnyObject;
                details: () => {
                    version: "2.0" | "3.0" | "3.1";
                    specificationType: string;
                    specificationVersion: string;
                };
                resolve: () => Promise<{
                    filter: (callback: (Specification: AnyObject) => boolean) => any;
                    toJson: () => string;
                    toYaml: () => string;
                    valid: boolean;
                    version: string;
                    specification?: OpenAPI.Document<{}>;
                    schema?: ResolvedOpenAPI.Document<EmptyObject>;
                    errors?: ErrorObject[];
                }>;
                toJson: () => string;
                toYaml: () => string;
                valid: boolean;
                specification?: OpenAPI.Document<{}>;
                version?: string;
                errors?: ErrorObject[];
            }>;
            resolve: () => Promise<{
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                toJson: () => string;
                toYaml: () => string;
                valid: boolean;
                version: string;
                specification?: OpenAPI.Document<{}>;
                schema?: ResolvedOpenAPI.Document<EmptyObject>;
                errors?: ErrorObject[];
            }>;
            toJson: () => string;
            toYaml: () => string;
        };
        validate: () => Promise<{
            filter: (callback: (Specification: AnyObject) => boolean) => {
                get: () => AnyObject;
                details: () => {
                    version: "2.0" | "3.0" | "3.1";
                    specificationType: string;
                    specificationVersion: string;
                };
                filter: () => any;
                upgrade: () => any;
                validate: () => Promise<any>;
                resolve: () => Promise<{
                    filter: (callback: (Specification: AnyObject) => boolean) => any;
                    toJson: () => string;
                    toYaml: () => string;
                    valid: boolean;
                    version: string;
                    specification?: OpenAPI.Document<{}>;
                    schema?: ResolvedOpenAPI.Document<EmptyObject>;
                    errors?: ErrorObject[];
                }>;
                toJson: () => string;
                toYaml: () => string;
            };
            get: () => AnyObject;
            details: () => {
                version: "2.0" | "3.0" | "3.1";
                specificationType: string;
                specificationVersion: string;
            };
            resolve: () => Promise<{
                filter: (callback: (Specification: AnyObject) => boolean) => {
                    get: () => AnyObject;
                    details: () => {
                        version: "2.0" | "3.0" | "3.1";
                        specificationType: string;
                        specificationVersion: string;
                    };
                    filter: () => any;
                    upgrade: () => any;
                    validate: () => Promise<any>;
                    resolve: () => Promise<any>;
                    toJson: () => string;
                    toYaml: () => string;
                };
                toJson: () => string;
                toYaml: () => string;
                valid: boolean;
                version: string;
                specification?: OpenAPI.Document<{}>;
                schema?: ResolvedOpenAPI.Document<EmptyObject>;
                errors?: ErrorObject[];
            }>;
            toJson: () => string;
            toYaml: () => string;
            valid: boolean;
            specification?: OpenAPI.Document<{}>;
            version?: string;
            errors?: ErrorObject[];
        }>;
        resolve: () => Promise<{
            filter: (callback: (Specification: AnyObject) => boolean) => {
                get: () => AnyObject;
                details: () => {
                    version: "2.0" | "3.0" | "3.1";
                    specificationType: string;
                    specificationVersion: string;
                };
                filter: () => any;
                upgrade: () => any;
                validate: () => Promise<{
                    filter: (callback: (Specification: AnyObject) => boolean) => any;
                    get: () => AnyObject;
                    details: () => {
                        version: "2.0" | "3.0" | "3.1";
                        specificationType: string;
                        specificationVersion: string;
                    };
                    resolve: () => Promise<any>;
                    toJson: () => string;
                    toYaml: () => string;
                    valid: boolean;
                    specification?: OpenAPI.Document<{}>;
                    version?: string;
                    errors?: ErrorObject[];
                }>;
                resolve: () => Promise<any>;
                toJson: () => string;
                toYaml: () => string;
            };
            toJson: () => string;
            toYaml: () => string;
            valid: boolean;
            version: string;
            specification?: OpenAPI.Document<{}>;
            schema?: ResolvedOpenAPI.Document<EmptyObject>;
            errors?: ErrorObject[];
        }>;
        toJson: () => string;
        toYaml: () => string;
    };
    validate: () => Promise<{
        filter: (callback: (Specification: AnyObject) => boolean) => {
            get: () => AnyObject;
            details: () => {
                version: "2.0" | "3.0" | "3.1";
                specificationType: string;
                specificationVersion: string;
            };
            filter: () => any;
            upgrade: () => {
                get: () => AnyObject;
                details: () => {
                    version: "2.0" | "3.0" | "3.1";
                    specificationType: string;
                    specificationVersion: string;
                };
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                validate: () => Promise<any>;
                resolve: () => Promise<{
                    filter: (callback: (Specification: AnyObject) => boolean) => any;
                    toJson: () => string;
                    toYaml: () => string;
                    valid: boolean;
                    version: string;
                    specification?: OpenAPI.Document<{}>;
                    schema?: ResolvedOpenAPI.Document<EmptyObject>;
                    errors?: ErrorObject[];
                }>;
                toJson: () => string;
                toYaml: () => string;
            };
            validate: () => Promise<any>;
            resolve: () => Promise<{
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                toJson: () => string;
                toYaml: () => string;
                valid: boolean;
                version: string;
                specification?: OpenAPI.Document<{}>;
                schema?: ResolvedOpenAPI.Document<EmptyObject>;
                errors?: ErrorObject[];
            }>;
            toJson: () => string;
            toYaml: () => string;
        };
        get: () => AnyObject;
        details: () => {
            version: "2.0" | "3.0" | "3.1";
            specificationType: string;
            specificationVersion: string;
        };
        resolve: () => Promise<{
            filter: (callback: (Specification: AnyObject) => boolean) => {
                get: () => AnyObject;
                details: () => {
                    version: "2.0" | "3.0" | "3.1";
                    specificationType: string;
                    specificationVersion: string;
                };
                filter: () => any;
                upgrade: () => {
                    get: () => AnyObject;
                    details: () => {
                        version: "2.0" | "3.0" | "3.1";
                        specificationType: string;
                        specificationVersion: string;
                    };
                    filter: (callback: (Specification: AnyObject) => boolean) => any;
                    validate: () => Promise<any>;
                    resolve: () => Promise<any>;
                    toJson: () => string;
                    toYaml: () => string;
                };
                validate: () => Promise<any>;
                resolve: () => Promise<any>;
                toJson: () => string;
                toYaml: () => string;
            };
            toJson: () => string;
            toYaml: () => string;
            valid: boolean;
            version: string;
            specification?: OpenAPI.Document<{}>;
            schema?: ResolvedOpenAPI.Document<EmptyObject>;
            errors?: ErrorObject[];
        }>;
        toJson: () => string;
        toYaml: () => string;
        valid: boolean;
        specification?: OpenAPI.Document<{}>;
        version?: string;
        errors?: ErrorObject[];
    }>;
    resolve: () => Promise<{
        filter: (callback: (Specification: AnyObject) => boolean) => {
            get: () => AnyObject;
            details: () => {
                version: "2.0" | "3.0" | "3.1";
                specificationType: string;
                specificationVersion: string;
            };
            filter: () => any;
            upgrade: () => {
                get: () => AnyObject;
                details: () => {
                    version: "2.0" | "3.0" | "3.1";
                    specificationType: string;
                    specificationVersion: string;
                };
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                validate: () => Promise<{
                    filter: (callback: (Specification: AnyObject) => boolean) => any;
                    get: () => AnyObject;
                    details: () => {
                        version: "2.0" | "3.0" | "3.1";
                        specificationType: string;
                        specificationVersion: string;
                    };
                    resolve: () => Promise<any>;
                    toJson: () => string;
                    toYaml: () => string;
                    valid: boolean;
                    specification?: OpenAPI.Document<{}>;
                    version?: string;
                    errors?: ErrorObject[];
                }>;
                resolve: () => Promise<any>;
                toJson: () => string;
                toYaml: () => string;
            };
            validate: () => Promise<{
                filter: (callback: (Specification: AnyObject) => boolean) => any;
                get: () => AnyObject;
                details: () => {
                    version: "2.0" | "3.0" | "3.1";
                    specificationType: string;
                    specificationVersion: string;
                };
                resolve: () => Promise<any>;
                toJson: () => string;
                toYaml: () => string;
                valid: boolean;
                specification?: OpenAPI.Document<{}>;
                version?: string;
                errors?: ErrorObject[];
            }>;
            resolve: () => Promise<any>;
            toJson: () => string;
            toYaml: () => string;
        };
        toJson: () => string;
        toYaml: () => string;
        valid: boolean;
        version: string;
        specification?: OpenAPI.Document<{}>;
        schema?: ResolvedOpenAPI.Document<EmptyObject>;
        errors?: ErrorObject[];
    }>;
    toJson: () => string;
    toYaml: () => string;
};

/**
 * Load a given file from the filesystem, and all its references. (Node-only)
 */
export declare function loadFiles(file: string, basePath?: string): any[];

/**
 * Normalize the OpenAPI specification to a JavaScript object.
 * Don’t touch the object if it’s a `Filesystem` (multiple files).
 */
export declare function normalize(specification: string | AnyObject | Filesystem): AnyObject | Filesystem;

export { OpenAPI }

export declare function openapi(): {
    load: typeof loadAction;
};

export { OpenAPIV2 }

export { OpenAPIV3 }

export { OpenAPIV3_1 }

/**
 * Validates an OpenAPI schema and resolves all references.
 */
export declare function resolve(value: string | AnyObject | Filesystem): Promise<ResolveResult>;

/**
 * These types are copied from 'openapi-types', but the `ReferenceObject` type is removed.
 * After an ResolvedOpenAPI schema is parsed, all references are resolved and replaced with the actual object.
 */
export declare namespace ResolvedOpenAPI {
    export type Document<T extends {} = EmptyObject> = ResolvedOpenAPIV2.Document<T> | ResolvedOpenAPIV3.Document<T> | ResolvedOpenAPIV3_1.Document<T>;
    export type Operation<T extends {} = EmptyObject> = ResolvedOpenAPIV2.OperationObject<T> | ResolvedOpenAPIV3.OperationObject<T> | ResolvedOpenAPIV3_1.OperationObject<T>;
    export type Parameter = ResolvedOpenAPIV3_1.ParameterObject | ResolvedOpenAPIV3.ParameterObject | ResolvedOpenAPIV2.Parameter;
    export type Parameters = ResolvedOpenAPIV3_1.ParameterObject[] | ResolvedOpenAPIV3.ParameterObject[] | ResolvedOpenAPIV2.Parameter[];
    export interface Request {
        body?: any;
        headers?: object;
        params?: object;
        query?: object;
    }
}

export declare namespace ResolvedOpenAPIV2 {
    export interface Document<T extends {} = EmptyObject> {
        'basePath'?: string;
        'consumes'?: MimeTypes;
        'definitions'?: DefinitionsObject;
        'externalDocs'?: ExternalDocumentationObject;
        'host'?: string;
        'info': InfoObject;
        'parameters'?: ParametersDefinitionsObject;
        'paths': PathsObject<T>;
        'produces'?: MimeTypes;
        'responses'?: ResponsesDefinitionsObject;
        'schemes'?: string[];
        'security'?: SecurityRequirementObject[];
        'securityDefinitions'?: SecurityDefinitionsObject;
        'swagger': string;
        'tags'?: TagObject[];
        'x-express-openapi-additional-middleware'?: (((request: any, response: any, next: any) => Promise<void>) | ((request: any, response: any, next: any) => void))[];
        'x-express-openapi-validation-strict'?: boolean;
        'components': undefined;
    }
    export interface TagObject {
        name: string;
        description?: string;
        externalDocs?: ExternalDocumentationObject;
    }
    export interface SecuritySchemeObjectBase {
        type: 'basic' | 'apiKey' | 'oauth2';
        description?: string;
    }
    export interface SecuritySchemeBasic extends SecuritySchemeObjectBase {
        type: 'basic';
    }
    export interface SecuritySchemeApiKey extends SecuritySchemeObjectBase {
        type: 'apiKey';
        name: string;
        in: string;
    }
    export type SecuritySchemeOauth2 = SecuritySchemeOauth2Implicit | SecuritySchemeOauth2AccessCode | SecuritySchemeOauth2Password | SecuritySchemeOauth2Application;
    export interface ScopesObject {
        [index: string]: any;
    }
    export interface SecuritySchemeOauth2Base extends SecuritySchemeObjectBase {
        type: 'oauth2';
        flow: 'implicit' | 'password' | 'application' | 'accessCode';
        scopes: ScopesObject;
    }
    export interface SecuritySchemeOauth2Implicit extends SecuritySchemeOauth2Base {
        flow: 'implicit';
        authorizationUrl: string;
    }
    export interface SecuritySchemeOauth2AccessCode extends SecuritySchemeOauth2Base {
        flow: 'accessCode';
        authorizationUrl: string;
        tokenUrl: string;
    }
    export interface SecuritySchemeOauth2Password extends SecuritySchemeOauth2Base {
        flow: 'password';
        tokenUrl: string;
    }
    export interface SecuritySchemeOauth2Application extends SecuritySchemeOauth2Base {
        flow: 'application';
        tokenUrl: string;
    }
    export type SecuritySchemeObject = SecuritySchemeBasic | SecuritySchemeApiKey | SecuritySchemeOauth2;
    export interface SecurityDefinitionsObject {
        [index: string]: SecuritySchemeObject;
    }
    export interface SecurityRequirementObject {
        [index: string]: string[];
    }
    export interface ReferenceObject {
        $ref: string;
    }
    export type Response = ResponseObject;
    export interface ResponsesDefinitionsObject {
        [index: string]: ResponseObject;
    }
    export type Schema = SchemaObject;
    export interface ResponseObject {
        description: string;
        schema?: Schema;
        headers?: HeadersObject;
        examples?: ExampleObject;
        content: undefined;
    }
    export interface HeadersObject {
        [index: string]: HeaderObject;
    }
    export interface HeaderObject extends ItemsObject {
        description?: string;
    }
    export interface ExampleObject {
        [index: string]: any;
    }
    export interface ResponseObject {
        description: string;
        schema?: Schema;
        headers?: HeadersObject;
        examples?: ExampleObject;
    }
    export type OperationObject<T extends {} = EmptyObject> = {
        tags?: string[];
        summary?: string;
        description?: string;
        externalDocs?: ExternalDocumentationObject;
        operationId?: string;
        consumes?: MimeTypes;
        produces?: MimeTypes;
        parameters?: Parameters;
        responses: ResponsesObject;
        schemes?: string[];
        deprecated?: boolean;
        security?: SecurityRequirementObject[];
    } & T;
    export interface ResponsesObject {
        [index: string]: Response | undefined;
        default?: Response;
    }
    export type Parameters = (ReferenceObject | Parameter)[];
    export type Parameter = InBodyParameterObject | GeneralParameterObject;
    export interface InBodyParameterObject extends ParameterObject {
        schema: Schema;
    }
    export interface GeneralParameterObject extends ParameterObject, ItemsObject {
        allowEmptyValue?: boolean;
    }
    export enum HttpMethods {
        GET = "get",
        PUT = "put",
        POST = "post",
        DELETE = "delete",
        OPTIONS = "options",
        HEAD = "head",
        PATCH = "patch"
    }
    export type PathItemObject<T extends {} = EmptyObject> = {
        $ref?: string;
        parameters?: Parameters;
    } & {
        [method in HttpMethods]?: OperationObject<T>;
    };
    export interface PathsObject<T extends {} = EmptyObject> {
        [index: string]: PathItemObject<T>;
    }
    export interface ParametersDefinitionsObject {
        [index: string]: ParameterObject;
    }
    export interface ParameterObject {
        name: string;
        in: string;
        description?: string;
        required?: boolean;
        [index: string]: any;
    }
    export type MimeTypes = string[];
    export interface DefinitionsObject {
        [index: string]: SchemaObject;
    }
    export interface SchemaObject extends IJsonSchema {
        [index: string]: any;
        discriminator?: string;
        readOnly?: boolean;
        xml?: XMLObject;
        externalDocs?: ExternalDocumentationObject;
        example?: any;
        default?: any;
        items?: ItemsObject;
        properties?: {
            [name: string]: SchemaObject;
        };
    }
    export interface ExternalDocumentationObject {
        [index: string]: any;
        description?: string;
        url: string;
    }
    export interface ItemsObject {
        type: string;
        format?: string;
        items?: ItemsObject;
        collectionFormat?: string;
        default?: any;
        maximum?: number;
        exclusiveMaximum?: boolean;
        minimum?: number;
        exclusiveMinimum?: boolean;
        maxLength?: number;
        minLength?: number;
        pattern?: string;
        maxItems?: number;
        minItems?: number;
        uniqueItems?: boolean;
        enum?: any[];
        multipleOf?: number;
        $ref?: string;
    }
    export interface XMLObject {
        [index: string]: any;
        name?: string;
        namespace?: string;
        prefix?: string;
        attribute?: boolean;
        wrapped?: boolean;
    }
    export interface InfoObject {
        title: string;
        description?: string;
        termsOfService?: string;
        contact?: ContactObject;
        license?: LicenseObject;
        version: string;
    }
    export interface ContactObject {
        name?: string;
        url?: string;
        email?: string;
    }
    export interface LicenseObject {
        name: string;
        url?: string;
    }
}

export declare namespace ResolvedOpenAPIV3 {
    export interface Document<T extends {} = EmptyObject> {
        'Resolvedopenapi': string;
        'info': InfoObject;
        'servers'?: ServerObject[];
        'paths': PathsObject<T>;
        'components'?: ComponentsObject;
        'security'?: SecurityRequirementObject[];
        'tags'?: TagObject[];
        'externalDocs'?: ExternalDocumentationObject;
        'x-express-openapi-additional-middleware'?: (((request: any, response: any, next: any) => Promise<void>) | ((request: any, response: any, next: any) => void))[];
        'x-express-openapi-validation-strict'?: boolean;
    }
    export interface InfoObject {
        title: string;
        description?: string;
        termsOfService?: string;
        contact?: ContactObject;
        license?: LicenseObject;
        version: string;
    }
    export interface ContactObject {
        name?: string;
        url?: string;
        email?: string;
    }
    export interface LicenseObject {
        name: string;
        url?: string;
    }
    export interface ServerObject {
        url: string;
        description?: string;
        variables?: {
            [variable: string]: ServerVariableObject;
        };
    }
    export interface ServerVariableObject {
        enum?: string[];
        default: string;
        description?: string;
    }
    export interface PathsObject<T extends {} = EmptyObject, P extends {} = EmptyObject> {
        [pattern: string]: (PathItemObject<T> & P) | undefined;
    }
    export enum HttpMethods {
        GET = "get",
        PUT = "put",
        POST = "post",
        DELETE = "delete",
        OPTIONS = "options",
        HEAD = "head",
        PATCH = "patch",
        TRACE = "trace"
    }
    export type PathItemObject<T extends {} = EmptyObject> = {
        $ref?: string;
        summary?: string;
        description?: string;
        servers?: ServerObject[];
        parameters?: ParameterObject[];
    } & {
        [method in HttpMethods]?: OperationObject<T>;
    };
    export type OperationObject<T extends {} = EmptyObject> = {
        tags?: string[];
        summary?: string;
        description?: string;
        externalDocs?: ExternalDocumentationObject;
        operationId?: string;
        parameters?: ParameterObject[];
        requestBody?: RequestBodyObject;
        responses: ResponsesObject;
        callbacks?: {
            [callback: string]: CallbackObject;
        };
        deprecated?: boolean;
        security?: SecurityRequirementObject[];
        servers?: ServerObject[];
    } & T;
    export interface ExternalDocumentationObject {
        description?: string;
        url: string;
    }
    export interface ParameterObject extends ParameterBaseObject {
        name: string;
        in: string;
    }
    export interface HeaderObject extends ParameterBaseObject {
    }
    export interface ParameterBaseObject {
        description?: string;
        required?: boolean;
        deprecated?: boolean;
        allowEmptyValue?: boolean;
        style?: string;
        explode?: boolean;
        allowReserved?: boolean;
        schema?: SchemaObject;
        example?: any;
        examples?: {
            [media: string]: ExampleObject;
        };
        content?: {
            [media: string]: MediaTypeObject;
        };
    }
    export type NonArraySchemaObjectType = 'boolean' | 'object' | 'number' | 'string' | 'integer';
    export type ArraySchemaObjectType = 'array';
    export type SchemaObject = ArraySchemaObject | NonArraySchemaObject;
    export interface ArraySchemaObject extends BaseSchemaObject {
        type: ArraySchemaObjectType;
        items: SchemaObject;
    }
    export interface NonArraySchemaObject extends BaseSchemaObject {
        type?: NonArraySchemaObjectType;
    }
    export interface BaseSchemaObject {
        title?: string;
        description?: string;
        format?: string;
        default?: any;
        multipleOf?: number;
        maximum?: number;
        exclusiveMaximum?: boolean;
        minimum?: number;
        exclusiveMinimum?: boolean;
        maxLength?: number;
        minLength?: number;
        pattern?: string;
        additionalProperties?: boolean | SchemaObject;
        maxItems?: number;
        minItems?: number;
        uniqueItems?: boolean;
        maxProperties?: number;
        minProperties?: number;
        required?: string[];
        enum?: any[];
        properties?: {
            [name: string]: SchemaObject;
        };
        allOf?: SchemaObject[];
        oneOf?: SchemaObject[];
        anyOf?: SchemaObject[];
        not?: SchemaObject;
        nullable?: boolean;
        discriminator?: DiscriminatorObject;
        readOnly?: boolean;
        writeOnly?: boolean;
        xml?: XMLObject;
        externalDocs?: ExternalDocumentationObject;
        example?: any;
        deprecated?: boolean;
    }
    export interface DiscriminatorObject {
        propertyName: string;
        mapping?: {
            [value: string]: string;
        };
    }
    export interface XMLObject {
        name?: string;
        namespace?: string;
        prefix?: string;
        attribute?: boolean;
        wrapped?: boolean;
    }
    export interface ExampleObject {
        summary?: string;
        description?: string;
        value?: any;
        externalValue?: string;
    }
    export interface MediaTypeObject {
        schema?: SchemaObject;
        example?: any;
        examples?: {
            [media: string]: ExampleObject;
        };
        encoding?: {
            [media: string]: EncodingObject;
        };
    }
    export interface EncodingObject {
        contentType?: string;
        headers?: {
            [header: string]: HeaderObject;
        };
        style?: string;
        explode?: boolean;
        allowReserved?: boolean;
    }
    export interface RequestBodyObject {
        description?: string;
        content: {
            [media: string]: MediaTypeObject;
        };
        required?: boolean;
    }
    export interface ResponsesObject {
        [code: string]: ResponseObject;
    }
    export interface ResponseObject {
        description: string;
        headers?: {
            [header: string]: HeaderObject;
        };
        content?: {
            [media: string]: MediaTypeObject;
        };
        links?: {
            [link: string]: LinkObject;
        };
    }
    export interface LinkObject {
        operationRef?: string;
        operationId?: string;
        parameters?: {
            [parameter: string]: any;
        };
        requestBody?: any;
        description?: string;
        server?: ServerObject;
    }
    export interface CallbackObject {
        [url: string]: PathItemObject;
    }
    export interface SecurityRequirementObject {
        [name: string]: string[];
    }
    export interface ComponentsObject {
        schemas?: {
            [key: string]: SchemaObject;
        };
        responses?: {
            [key: string]: ResponseObject;
        };
        parameters?: {
            [key: string]: ParameterObject;
        };
        examples?: {
            [key: string]: ExampleObject;
        };
        requestBodies?: {
            [key: string]: RequestBodyObject;
        };
        headers?: {
            [key: string]: HeaderObject;
        };
        securitySchemes?: {
            [key: string]: SecuritySchemeObject;
        };
        links?: {
            [key: string]: LinkObject;
        };
        callbacks?: {
            [key: string]: CallbackObject;
        };
    }
    export type SecuritySchemeObject = HttpSecurityScheme | ApiKeySecurityScheme | OAuth2SecurityScheme | OpenIdSecurityScheme;
    export interface HttpSecurityScheme {
        type: 'http';
        description?: string;
        scheme: string;
        bearerFormat?: string;
    }
    export interface ApiKeySecurityScheme {
        type: 'apiKey';
        description?: string;
        name: string;
        in: string;
    }
    export interface OAuth2SecurityScheme {
        type: 'oauth2';
        description?: string;
        flows: {
            implicit?: {
                authorizationUrl: string;
                refreshUrl?: string;
                scopes: {
                    [scope: string]: string;
                };
            };
            password?: {
                tokenUrl: string;
                refreshUrl?: string;
                scopes: {
                    [scope: string]: string;
                };
            };
            clientCredentials?: {
                tokenUrl: string;
                refreshUrl?: string;
                scopes: {
                    [scope: string]: string;
                };
            };
            authorizationCode?: {
                authorizationUrl: string;
                tokenUrl: string;
                refreshUrl?: string;
                scopes: {
                    [scope: string]: string;
                };
            };
        };
    }
    export interface OpenIdSecurityScheme {
        type: 'openIdConnect';
        description?: string;
        openIdConnectUrl: string;
    }
    export interface TagObject {
        name: string;
        description?: string;
        externalDocs?: ExternalDocumentationObject;
    }
}

export declare namespace ResolvedOpenAPIV3_1 {
    export type Modify<T, R> = Omit<T, keyof R> & R;
    export type PathsWebhooksComponents<T extends {} = EmptyObject> = {
        paths: PathsObject<T>;
        webhooks: Record<string, PathItemObject>;
        components: ComponentsObject;
    };
    export type Document<T extends {} = EmptyObject> = Modify<Omit<ResolvedOpenAPIV3.Document<T>, 'paths' | 'components'>, {
        info: InfoObject;
        jsonSchemaDialect?: string;
        servers?: ServerObject[];
    } & ((Pick<PathsWebhooksComponents<T>, 'paths'> & Omit<Partial<PathsWebhooksComponents<T>>, 'paths'>) | (Pick<PathsWebhooksComponents<T>, 'webhooks'> & Omit<Partial<PathsWebhooksComponents<T>>, 'webhooks'>) | (Pick<PathsWebhooksComponents<T>, 'components'> & Omit<Partial<PathsWebhooksComponents<T>>, 'components'>))>;
    export type InfoObject = Modify<ResolvedOpenAPIV3.InfoObject, {
        summary?: string;
        license?: LicenseObject;
    }>;
    export type ContactObject = ResolvedOpenAPIV3.ContactObject;
    export type LicenseObject = Modify<ResolvedOpenAPIV3.LicenseObject, {
        identifier?: string;
    }>;
    export type ServerObject = Modify<ResolvedOpenAPIV3.ServerObject, {
        url: string;
        description?: string;
        variables?: Record<string, ServerVariableObject>;
    }>;
    export type ServerVariableObject = Modify<ResolvedOpenAPIV3.ServerVariableObject, {
        enum?: [string, ...string[]];
    }>;
    export type PathsObject<T extends {} = EmptyObject, P extends {} = EmptyObject> = Record<string, (PathItemObject<T> & P) | undefined>;
    export type HttpMethods = ResolvedOpenAPIV3.HttpMethods;
    export type PathItemObject<T extends {} = EmptyObject> = Modify<ResolvedOpenAPIV3.PathItemObject<T>, {
        servers?: ServerObject[];
        parameters?: ParameterObject[];
    }> & {
        [method in HttpMethods]?: OperationObject<T>;
    };
    export type OperationObject<T extends {} = EmptyObject> = Modify<ResolvedOpenAPIV3.OperationObject<T>, {
        parameters?: ParameterObject[];
        requestBody?: RequestBodyObject;
        responses?: ResponsesObject;
        callbacks?: Record<string, CallbackObject>;
        servers?: ServerObject[];
    }> & T;
    export type ExternalDocumentationObject = ResolvedOpenAPIV3.ExternalDocumentationObject;
    export type ParameterObject = ResolvedOpenAPIV3.ParameterObject;
    export type HeaderObject = ResolvedOpenAPIV3.HeaderObject;
    export type ParameterBaseObject = ResolvedOpenAPIV3.ParameterBaseObject;
    export type NonArraySchemaObjectType = ResolvedOpenAPIV3.NonArraySchemaObjectType | 'null';
    export type ArraySchemaObjectType = ResolvedOpenAPIV3.ArraySchemaObjectType;
    /**
     * There is no way to tell typescript to require items when type is either 'array' or array containing 'array' type
     * 'items' will be always visible as optional
     * Casting schema object to ArraySchemaObject or NonArraySchemaObject will work fine
     */
    export type SchemaObject = ArraySchemaObject | NonArraySchemaObject | MixedSchemaObject;
    export interface ArraySchemaObject extends BaseSchemaObject {
        type: ArraySchemaObjectType;
        items: SchemaObject;
    }
    export interface NonArraySchemaObject extends BaseSchemaObject {
        type?: NonArraySchemaObjectType;
    }
    export interface MixedSchemaObject extends BaseSchemaObject {
        type?: (ArraySchemaObjectType | NonArraySchemaObjectType)[];
        items?: SchemaObject;
    }
    export type BaseSchemaObject = Modify<Omit<ResolvedOpenAPIV3.BaseSchemaObject, 'nullable'>, {
        examples?: ResolvedOpenAPIV3.BaseSchemaObject['example'][];
        exclusiveMinimum?: boolean | number;
        exclusiveMaximum?: boolean | number;
        contentMediaType?: string;
        $schema?: string;
        additionalProperties?: boolean | SchemaObject;
        properties?: {
            [name: string]: SchemaObject;
        };
        allOf?: SchemaObject[];
        oneOf?: SchemaObject[];
        anyOf?: SchemaObject[];
        not?: SchemaObject;
        discriminator?: DiscriminatorObject;
        externalDocs?: ExternalDocumentationObject;
        xml?: XMLObject;
        const?: any;
    }>;
    export type DiscriminatorObject = ResolvedOpenAPIV3.DiscriminatorObject;
    export type XMLObject = ResolvedOpenAPIV3.XMLObject;
    export type ExampleObject = ResolvedOpenAPIV3.ExampleObject;
    export type MediaTypeObject = Modify<ResolvedOpenAPIV3.MediaTypeObject, {
        schema?: SchemaObject;
        examples?: Record<string, ExampleObject>;
    }>;
    export type EncodingObject = ResolvedOpenAPIV3.EncodingObject;
    export type RequestBodyObject = Modify<ResolvedOpenAPIV3.RequestBodyObject, {
        content: {
            [media: string]: MediaTypeObject;
        };
    }>;
    export type ResponsesObject = Record<string, ResponseObject>;
    export type ResponseObject = Modify<ResolvedOpenAPIV3.ResponseObject, {
        headers?: {
            [header: string]: HeaderObject;
        };
        content?: {
            [media: string]: MediaTypeObject;
        };
        links?: {
            [link: string]: LinkObject;
        };
    }>;
    export type LinkObject = Modify<ResolvedOpenAPIV3.LinkObject, {
        server?: ServerObject;
    }>;
    export type CallbackObject = Record<string, PathItemObject>;
    export type SecurityRequirementObject = ResolvedOpenAPIV3.SecurityRequirementObject;
    export type ComponentsObject = Modify<ResolvedOpenAPIV3.ComponentsObject, {
        schemas?: Record<string, SchemaObject>;
        responses?: Record<string, ResponseObject>;
        parameters?: Record<string, ParameterObject>;
        examples?: Record<string, ExampleObject>;
        requestBodies?: Record<string, RequestBodyObject>;
        headers?: Record<string, HeaderObject>;
        securitySchemes?: Record<string, SecuritySchemeObject>;
        links?: Record<string, LinkObject>;
        callbacks?: Record<string, CallbackObject>;
        pathItems?: Record<string, PathItemObject>;
    }>;
    export type SecuritySchemeObject = ResolvedOpenAPIV3.SecuritySchemeObject;
    export type HttpSecurityScheme = ResolvedOpenAPIV3.HttpSecurityScheme;
    export type ApiKeySecurityScheme = ResolvedOpenAPIV3.ApiKeySecurityScheme;
    export type OAuth2SecurityScheme = ResolvedOpenAPIV3.OAuth2SecurityScheme;
    export type OpenIdSecurityScheme = ResolvedOpenAPIV3.OpenIdSecurityScheme;
    export type TagObject = ResolvedOpenAPIV3.TagObject;
}

/**
 * Takes a specification and resolves all references.
 */
export declare function resolveReferences(input: AnyObject): ResolvedOpenAPI.Document<EmptyObject>;

export declare type ResolveResult = {
    valid: boolean;
    version: string | undefined;
    specification?: OpenAPI.Document;
    schema?: ResolvedOpenAPI.Document;
    errors?: ErrorObject[];
};

declare type SupportedVersion = (typeof supportedVersions)[number];

/**
 * A list of the supported OpenAPI versions
 */
declare const supportedVersions: readonly ["2.0", "3.0", "3.1"];

export declare const toJson: (value: AnyObject) => string;

export declare const toYaml: (value: AnyObject) => string;

/**
 * Recursively traverses the specification and applies the transform function to each node.
 */
export declare function traverse(specification: AnyObject, transform: (specification: AnyObject) => AnyObject): AnyObject;

/**
 * Upgrade specification to OpenAPI 3.1.0
 */
export declare function upgrade(specification: AnyObject): AnyObject;

/**
 * Upgrade from OpenAPI 3.0.x to 3.1.0
 *
 * https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0
 */
export declare function upgradeFromThreeToThreeOne(specification: AnyObject): AnyObject;

/**
 * Upgrade Swagger 2.0 to OpenAPI 3.0
 *
 * https://swagger.io/blog/news/whats-new-in-openapi-3-0/
 */
export declare function upgradeFromTwoToThree(specification: AnyObject): AnyObject;

/**
 * Validates an OpenAPI schema.
 */
export declare function validate(value: string | AnyObject | Filesystem): Promise<ValidateResult>;

export declare type ValidateResult = {
    valid: boolean;
    specification?: OpenAPI.Document;
    version?: string;
    errors?: ErrorObject[];
};

export declare class Validator {
    version: string;
    static supportedVersions: readonly ["2.0", "3.0", "3.1"];
    protected ajvValidators: Record<string, ((specification: AnyObject) => boolean) & {
        errors: string;
    }>;
    protected externalRefs: Record<string, AnyObject>;
    protected errors: string;
    protected specificationVersion: string;
    protected specificationType: string;
    specification: AnyObject;
    resolveReferences(filesystem?: Filesystem): ResolvedOpenAPI.Document<EmptyObject>;
    /**
     * Checks whether a specification is valid and all references can be resolved.
     */
    validate(filesystem: Filesystem): Promise<ValidateResult>;
    /**
     * Ajv JSON schema validator
     */
    getAjvValidator(version: SupportedVersion): Promise<any>;
}

export { }
