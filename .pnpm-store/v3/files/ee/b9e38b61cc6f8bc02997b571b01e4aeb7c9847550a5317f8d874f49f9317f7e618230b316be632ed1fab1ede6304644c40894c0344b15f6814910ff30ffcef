var Rw = Object.defineProperty;
var jw = (r, e, t) => e in r ? Rw(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var qp = (r, e, t) => (jw(r, typeof e != "symbol" ? e + "" : e, t), t);
import { defineComponent as Q, openBlock as S, createBlock as U, resolveDynamicComponent as br, unref as $, createElementBlock as E, Fragment as Z, createCommentVNode as z, withCtx as P, createTextVNode as J, toDisplayString as ee, onMounted as vr, useCssModule as I0, renderSlot as te, reactive as $r, readonly as td, ref as ie, computed as oe, normalizeStyle as os, normalizeProps as cr, guardReactiveProps as ur, createElementVNode as V, createVNode as R, normalizeClass as xe, useAttrs as Co, nextTick as Ai, onUnmounted as N0, watch as Le, watchEffect as Ei, renderList as we, shallowRef as Lw, getCurrentScope as Bw, onScopeDispose as Fw, shallowReadonly as Bn, mergeProps as En, onServerPrefetch as On, useSSRContext as aa, defineAsyncComponent as M0, useCssVars as Vw, createStaticVNode as la, Teleport as Uw, pushScopeId as It, popScopeId as Nt, withModifiers as ca, toValue as Hp, withDirectives as Ao, vShow as yc, inject as xh, createSlots as ua, vModelSelect as zw, vModelCheckbox as qw, onBeforeMount as Hw, getCurrentInstance as Kw, provide as Kp, toRef as rd, isRef as Ww, createApp as Gw } from "vue";
import { Dialog as Jw, DialogPanel as Yw, DialogTitle as Xw, DialogDescription as Qw, Listbox as Zw, ListboxButton as ek, ListboxOptions as tk, ListboxOption as rk, Disclosure as Ch, DisclosureButton as Ah, DisclosurePanel as Eh, TabGroup as sk, TabList as nk, Tab as ok, provideUseId as ik } from "@headlessui/vue";
import { useEventBus as Oh, useMediaQuery as Th, useIntersectionObserver as ak, useElementHover as lk, computedAsync as ck, useMutationObserver as uk, useResizeObserver as dk, useDebounceFn as hk, useMagicKeys as D0, whenever as bl } from "@vueuse/core";
import { AxiosHeaders as fk } from "axios";
import ii from "prismjs";
import pk from "@vcarl/remark-headings";
import R0, { slug as Ph } from "github-slugger";
import j0 from "remark-parse";
import mk from "remark-stringify";
import { unified as L0 } from "unified";
import { createHead as gk, useSeoMeta as yk } from "unhead";
import { availableTargets as bk, HTTPSnippet as vk } from "httpsnippet-lite";
import wk from "rehype-external-links";
import kk from "rehype-format";
import Sk from "rehype-highlight";
import $k from "rehype-raw";
import _k, { defaultSchema as fu } from "rehype-sanitize";
import xk from "rehype-stringify";
import Ck from "remark-gfm";
import Ak from "remark-rehype";
import Ek from "fuse.js";
const Ok = ":root{--scalar-text-decoration: underline;--scalar-text-decoration-hover: underline}.light-mode,.light-mode .dark-mode{--scalar-background-1: #f9f9f9;--scalar-background-2: #f1f1f1;--scalar-background-3: #e7e7e7;--scalar-background-card: #fff;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: var(--scalar-color-1);--scalar-background-accent: var(--scalar-background-3);--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #131313;--scalar-background-2: #1d1d1d;--scalar-background-3: #272727;--scalar-background-card: #1d1d1d;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: var(--scalar-color-1);--scalar-background-accent: var(--scalar-background-3);--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color);--scalar-sidebar-indent-border: var(--scalar-sidebar-border-color);--scalar-sidebar-indent-border-hover: var(--scalar-sidebar-border-color);--scalar-sidebar-indent-border-active: var(--scalar-sidebar-border-color)}.light-mode .dark-mode,.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dd2f2c;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.scalar-api-client__item,.scalar-card,.dark-mode .dark-mode.scalar-card{--scalar-background-1: var(--scalar-background-card);--scalar-background-2: var(--scalar-background-1);--scalar-background-3: var(--scalar-background-1)}.dark-mode .dark-mode.scalar-card{--scalar-background-3: var(--scalar-background-3)}.t-doc__sidebar{--scalar-color-green: var(--scalar-color-1);--scalar-color-red: var(--scalar-color-1);--scalar-color-yellow: var(--scalar-color-1);--scalar-color-blue: var(--scalar-color-1);--scalar-color-orange: var(--scalar-color-1);--scalar-color-purple: var(--scalar-color-1)}", Tk = ":root{--scalar-text-decoration: underline;--scalar-text-decoration-hover: underline}.light-mode{--scalar-background-1: #f0f2f5;--scalar-background-2: #eaecf0;--scalar-background-3: #e0e2e6;--scalar-border-color: rgb(228, 228, 231);--scalar-color-1: rgb(9, 9, 11);--scalar-color-2: rgb(113, 113, 122);--scalar-color-3: rgba(25, 25, 28, .5);--scalar-color-accent: var(--scalar-color-1);--scalar-background-accent: #8ab4f81f;--scalar-code-language-color-supersede: var(--scalar-color-1)}.light-mode .scalar-card.dark-mode,.dark-mode{--scalar-background-1: #000e23;--scalar-background-2: #01132e;--scalar-background-3: #03193b;--scalar-border-color: rgba(255, 255, 255, .12);--scalar-color-1: #fafafa;--scalar-color-2: rgb(161, 161, 170);--scalar-color-3: rgba(255, 255, 255, .533);--scalar-color-accent: var(--scalar-color-1);--scalar-background-accent: #8ab4f81f;--scalar-code-language-color-supersede: var(--scalar-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-3);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: rgba(255, 255, 255, .1);--scalar-sidebar-search-border-color: var(--scalar-border-color);--scalar-sidebar-search-color: var(--scalar-color-3);z-index:1}.light-mode .t-doc__sidebar{--scalar-sidebar-search-background: white}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: rgba(69, 255, 165, .823);--scalar-color-red: #ff8589;--scalar-color-yellow: #ffcc4d;--scalar-color-blue: #6bc1fe;--scalar-color-orange: #f98943;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}@keyframes headerbackground{0%{background:transparent;-webkit-backdrop-filter:none;backdrop-filter:none}to{background:var(--header-background-1);-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.section-flare-item:nth-of-type(1){--c1: #ffffff;--c2: #babfd8;--c3: #2e8bb2;--c4: #1a8593;--c5: #0a143e;--c6: #0a0f52;--c7: #2341b8;--solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6), var(--c7);--solid-wrap: var(--solid), var(--c1);--trans: var(--c1), transparent, var(--c2), transparent, var(--c3), transparent, var(--c4), transparent, var(--c5), transparent, var(--c6), transparent, var(--c7);--trans-wrap: var(--trans), transparent, var(--c1);background:radial-gradient(circle,var(--trans)),conic-gradient(from 180deg,var(--trans-wrap)),radial-gradient(circle,var(--trans)),conic-gradient(var(--solid-wrap));width:70vw;height:700px;border-radius:50%;filter:blur(100px);z-index:0;right:0;position:absolute;transform:rotate(-45deg);top:-300px;opacity:.3}.section-flare-item:nth-of-type(3){--star-color: #6b9acc;--star-color2: #446b8d;--star-color3: #3e5879;background-image:radial-gradient(2px 2px at 20px 30px,var(--star-color2),rgba(0,0,0,0)),radial-gradient(2px 2px at 40px 70px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 50px 160px,var(--star-color3),rgba(0,0,0,0)),radial-gradient(2px 2px at 90px 40px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 130px 80px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 160px 120px,var(--star-color3),rgba(0,0,0,0));background-repeat:repeat;background-size:200px 200px;width:100%;height:100%;-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%)}.section-flare{top:-150px!important;height:100vh;background:linear-gradient(#000,var(--scalar-background-1));width:100vw}.light-mode .section-flare{display:none}.light-mode .scalar-card{--scalar-background-1: #fff;--scalar-background-2: #fff;--scalar-background-3: #fff}", Pk = ':root{--scalar-text-decoration: underline;--scalar-text-decoration-hover: underline}.light-mode{--scalar-color-1: rgb(9, 9, 11);--scalar-color-2: rgb(113, 113, 122);--scalar-color-3: rgba(25, 25, 28, .5);--scalar-color-accent: var(--scalar-color-1);--scalar-background-1: #fff;--scalar-background-2: #f4f4f5;--scalar-background-3: #e3e3e6;--scalar-background-accent: #8ab4f81f;--scalar-border-color: rgb(228, 228, 231);--scalar-code-language-color-supersede: var(--scalar-color-1)}.dark-mode{--scalar-color-1: #fafafa;--scalar-color-2: rgb(161, 161, 170);--scalar-color-3: rgba(255, 255, 255, .533);--scalar-color-accent: var(--scalar-color-1);--scalar-background-1: #09090b;--scalar-background-2: #18181b;--scalar-background-3: #2c2c30;--scalar-background-accent: #8ab4f81f;--scalar-border-color: rgba(255, 255, 255, .12);--scalar-code-language-color-supersede: var(--scalar-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-3);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-border-color: var(--scalar-border-color);--scalar-sidebar-search-color: var(--scalar-color-3)}.light-mode .t-doc__sidebar{--scalar-sidebar-item-active-background: var(--scalar-background-2)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: rgba(69, 255, 165, .823);--scalar-color-red: #ff8589;--scalar-color-yellow: #ffcc4d;--scalar-color-blue: #6bc1fe;--scalar-color-orange: #f98943;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.examples .scalar-card-footer{--scalar-background-3: transparent;padding-top:0}.section-flare{width:100vw;height:550px;position:relative}.section-flare-item:nth-of-type(1){position:absolute;width:100vw;height:550px;--stripesDark: repeating-linear-gradient( 100deg, #000 0%, #000 7%, transparent 10%, transparent 12%, #000 16% );--rainbow: repeating-linear-gradient( 100deg, #fff 10%, #fff 16%, #fff 22%, #fff 30% );background-image:var(--stripesDark),var(--rainbow);background-size:300%,200%;background-position:50% 50%,50% 50%;filter:invert(100%);-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);pointer-events:none;opacity:.07}.dark-mode .section-flare-item:nth-of-type(1){background-image:var(--stripesDark),var(--rainbow);filter:opacity(50%) saturate(200%);opacity:.25;height:350px}.section-flare-item:nth-of-type(1):after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;background-image:var(--stripesDark),var(--rainbow);background-size:200%,100%;background-attachment:fixed;mix-blend-mode:difference}.dark-mode .section-flare:after{background-image:var(--stripesDark),var(--rainbow)}.section-flare-item:nth-of-type(2){--star-color: #fff;--star-color2: #fff;--star-color3: #fff;width:100%;height:100%;position:absolute;background-image:radial-gradient(2px 2px at 20px 30px,var(--star-color2),rgba(0,0,0,0)),radial-gradient(2px 2px at 40px 70px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 50px 160px,var(--star-color3),rgba(0,0,0,0)),radial-gradient(2px 2px at 90px 40px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 130px 80px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 160px 120px,var(--star-color3),rgba(0,0,0,0));background-repeat:repeat;background-size:200px 200px;-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);opacity:.2}', B0 = ".light-mode{--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #8ab4f81f;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #0099ff;--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #0f0f0f;--scalar-background-2: #1a1a1a;--scalar-background-3: #272727;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: #3ea6ff;--scalar-background-accent: #3ea6ff1f;--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-2);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}", Ik = ".light-mode{--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #7070ff;--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #7070ff1f;--scalar-border-color: rgba(0, 0, 0, .1);--scalar-code-language-color-supersede: var(--scalar-color-3)}.dark-mode{--scalar-color-1: #f7f8f8;--scalar-color-2: rgb(180, 188, 208);--scalar-color-3: #b4bcd099;--scalar-color-accent: #828fff;--scalar-background-1: #000212;--scalar-background-2: rgba(255, 255, 255, .05);--scalar-background-3: rgba(255, 255, 255, .09);--scalar-background-accent: #8ab4f81f;--scalar-border-color: #242537;--scalar-code-language-color-supersede: var(--scalar-color-3)}.light-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: rgba(0, 0, 0, .05);--scalar-sidebar-search-border-color: 1px solid rgba(0, 0, 0, .05);--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-background-2: rgba(0, 0, 0, .03)}.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: rgba(255, 255, 255, .1);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: rgba(255, 255, 255, .1);--scalar-sidebar-search-border-color: 1px solid rgba(255, 255, 255, .05);--scalar-sidebar-search-color: var(--scalar-color-3)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.sidebar-search{-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}@keyframes headerbackground{0%{background:transparent;-webkit-backdrop-filter:none;backdrop-filter:none}to{background:var(--header-background-1);-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}}.dark-mode .scalar-card{background:#ffffff0d!important}.dark-mode .scalar-card *{--scalar-background-2: transparent !important;--scalar-background-1: transparent !important}.light-mode .dark-mode.scalar-card *,.light-mode .dark-mode.scalar-card{--scalar-background-1: #0d0f1e !important;--scalar-background-2: #0d0f1e !important;--scalar-background-3: #191b29 !important}.light-mode .dark-mode.scalar-card{background:#191b29!important}.badge{box-shadow:0 0 0 1px var(--scalar-border-color);margin-right:6px}.table-row.required-parameter .table-row-item:nth-of-type(2):after{background:transparent;box-shadow:none}.section-flare{width:100vw;background:radial-gradient(ellipse 80% 50% at 50% -20%,rgba(120,119,198,.3),transparent);height:100vh}", Nk = ":root{--scalar-text-decoration: underline;--scalar-text-decoration-hover: underline}.light-mode{--scalar-background-1: #f9f6f0;--scalar-background-2: #f2efe8;--scalar-background-3: #e9e7e2;--scalar-border-color: rgba(203, 165, 156, .6);--scalar-color-1: #c75549;--scalar-color-2: #c75549;--scalar-color-3: #c75549;--scalar-color-accent: #c75549;--scalar-background-accent: #dcbfa81f;--scalar-code-language-color-supersede: var(--scalar-color-1)}.dark-mode{--scalar-background-1: #140507;--scalar-background-2: #20090c;--scalar-background-3: #321116;--scalar-border-color: rgba(255, 255, 255, .1);--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: rgba(255, 255, 255, .9);--scalar-background-accent: #441313;--scalar-code-language-color-supersede: var(--scalar-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-3);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: rgba(255, 255, 255, .1);--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color);z-index:1}.light-mode{--scalar-color-green: #09533a;--scalar-color-red: #aa181d;--scalar-color-yellow: #ab8d2b;--scalar-color-blue: #19689a;--scalar-color-orange: #b26c34;--scalar-color-purple: #4c2191;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: rgba(69, 255, 165, .823);--scalar-color-red: #ff8589;--scalar-color-yellow: #ffcc4d;--scalar-color-blue: #6bc1fe;--scalar-color-orange: #f98943;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.light-mode .t-doc__sidebar{--scalar-sidebar-search-background: white}.examples .scalar-card-footer{--scalar-background-3: transparent;padding-top:0}.section-flare-item:nth-of-type(1){background:#d25019;width:80vw;height:500px;margin-top:-150px;border-radius:50%;filter:blur(100px);z-index:0}.light-mode .section-flare{display:none}.section-flare{top:-150px!important;height:100vh;right:-400px!important;left:initial}", Mk = ".light-mode{color-scheme:light;--scalar-color-1: #000000;--scalar-color-2: #000000;--scalar-color-3: #000000;--scalar-color-accent: #645b0f;--scalar-background-1: #ccc9b3;--scalar-background-2: #c2bfaa;--scalar-background-3: #b8b5a1;--scalar-background-accent: #000000;--scalar-border-color: rgba(0, 0, 0, .2);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-lifted-brightness: 1;--scalar-backdrop-brightness: 1;--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, var(--scalar-border-color) 0px 0 0 1px;--scalar-button-1: rgb(49 53 56);--scalar-button-1-color: #fff;--scalar-button-1-hover: rgb(28 31 33);--scalar-color-red: #b91c1c;--scalar-color-orange: #a16207;--scalar-color-green: #047857;--scalar-color-blue: #1d4ed8;--scalar-color-orange: #c2410c;--scalar-color-purple: #6d28d9}.dark-mode{color-scheme:dark;--scalar-color-1: #fffef3;--scalar-color-2: #fffef3;--scalar-color-3: #fffef3;--scalar-color-accent: #c3b531;--scalar-background-1: #313332;--scalar-background-2: #393b3a;--scalar-background-3: #414342;--scalar-background-accent: #fffef3;--scalar-border-color: rgba(255, 255, 255, .1);--scalar-scrollbar-color: rgba(255, 255, 255, .24);--scalar-scrollbar-color-active: rgba(255, 255, 255, .48);--scalar-lifted-brightness: 1.45;--scalar-backdrop-brightness: .5;--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-button-1: #f6f6f6;--scalar-button-1-color: #000;--scalar-button-1-hover: #e7e7e7;--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9}.light-mode .t-doc__sidebar,.dark-mode .sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-sidebar-background-1);--scalar-sidebar-search-background: var(--scalar-background-3);--scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);--scalar-sidebar-search--color: var(--scalar-color-3)}", Dk = ".light-mode{--scalar-background-1: #fff;--scalar-background-2: #f5f6f8;--scalar-background-3: #eceef1;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #5469d4;--scalar-background-accent: #5469d41f;--scalar-border-color: rgba(215, 215, 206, .5)}.dark-mode{--scalar-background-1: #15171c;--scalar-background-2: #1c1e24;--scalar-background-3: #22252b;--scalar-color-1: #fafafa;--scalar-color-2: #c9ced8;--scalar-color-3: #8c99ad;--scalar-color-accent: #5469d4;--scalar-background-accent: #5469d41f;--scalar-border-color: rgba(255, 255, 255, .12)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-3);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: var(--scalar-background-1);--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #17803d;--scalar-color-red: #e10909;--scalar-color-yellow: #edbe20;--scalar-color-blue: #1763a6;--scalar-color-orange: #e25b09;--scalar-color-purple: #5c3993;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #30a159;--scalar-color-red: #dc1b19;--scalar-color-yellow: #eec644;--scalar-color-blue: #2b7abf;--scalar-color-orange: #f07528;--scalar-color-purple: #7a59b1;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}", Rk = ".light-mode{--scalar-background-1: #f3f3ee;--scalar-background-2: #e8e8e3;--scalar-background-3: #e4e4df;--scalar-border-color: rgba(215, 215, 206, .5);--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #1763a6;--scalar-background-accent: #1f648e1f}.dark-mode{--scalar-background-1: #09090b;--scalar-background-2: #18181b;--scalar-background-3: #2c2c30;--scalar-border-color: rgba(255, 255, 255, .12);--scalar-color-1: #fafafa;--scalar-color-2: rgb(161, 161, 170);--scalar-color-3: rgba(255, 255, 255, .533);--scalar-color-accent: #4eb3ec;--scalar-background-accent: #8ab4f81f}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-3);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: var(--scalar-background-1);--scalar-sidebar-search-border-color: var(--scalar-border-color);--scalar-sidebar-search-color: var(--scalar-color-3)}.light-mode{--scalar-color-green: #17803d;--scalar-color-red: #e10909;--scalar-color-yellow: #edbe20;--scalar-color-blue: #1763a6;--scalar-color-orange: #e25b09;--scalar-color-purple: #5c3993;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #30a159;--scalar-color-red: #dc1b19;--scalar-color-yellow: #eec644;--scalar-color-blue: #2b7abf;--scalar-color-orange: #f07528;--scalar-color-purple: #7a59b1;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}", jk = ".light-mode{color-scheme:light;--scalar-color-1: #584c27;--scalar-color-2: #616161;--scalar-color-3: #a89f84;--scalar-color-accent: #b58900;--scalar-background-1: #fdf6e3;--scalar-background-2: #eee8d5;--scalar-background-3: #ddd6c1;--scalar-background-accent: #b589001f;--scalar-border-color: #ded8c8;--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-lifted-brightness: 1;--scalar-backdrop-brightness: 1;--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-button-1: rgb(49 53 56);--scalar-button-1-color: #fff;--scalar-button-1-hover: rgb(28 31 33);--scalar-color-red: #b91c1c;--scalar-color-orange: #a16207;--scalar-color-green: #047857;--scalar-color-blue: #1d4ed8;--scalar-color-orange: #c2410c;--scalar-color-purple: #6d28d9}.dark-mode{color-scheme:dark;--scalar-color-1: #fff;--scalar-color-2: #cccccc;--scalar-color-3: #6d8890;--scalar-color-accent: #007acc;--scalar-background-1: #00212b;--scalar-background-2: #012b36;--scalar-background-3: #004052;--scalar-background-accent: #015a6f;--scalar-border-color: rgba(255, 255, 255, .1);--scalar-scrollbar-color: rgba(255, 255, 255, .24);--scalar-scrollbar-color-active: rgba(255, 255, 255, .48);--scalar-lifted-brightness: 1.45;--scalar-backdrop-brightness: .5;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-button-1: #f6f6f6;--scalar-button-1-color: #000;--scalar-button-1-hover: #e7e7e7;--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9}.light-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: var(--scalar-background-2);--scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);--scalar-sidebar-search--color: var(--scalar-color-3)}.dark-mode .sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-sidebar-color-1);--scalar-sidebar-search-background: var(--scalar-background-2);--scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);--scalar-sidebar-search--color: var(--scalar-color-3)}", Lk = '@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-cyrillic-ext.woff2) format("woff2");unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-cyrillic.woff2) format("woff2");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-greek-ext.woff2) format("woff2");unicode-range:U+1F00-1FFF}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-greek.woff2) format("woff2");unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-vietnamese.woff2) format("woff2");unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-latin-ext.woff2) format("woff2");unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-latin.woff2) format("woff2");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-cyrillic-ext.woff2) format("woff2");unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-cyrillic.woff2) format("woff2");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-greek.woff2) format("woff2");unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-vietnamese.woff2) format("woff2");unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-latin-ext.woff2) format("woff2");unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-latin.woff2) format("woff2");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}', Bk = /* @__PURE__ */ Q({
  __name: "DefaultFonts",
  setup(r) {
    return (e, t) => (S(), U(br("style"), { innerHTML: $(Lk) }, null, 8, ["innerHTML"]));
  }
}), Fk = /* @__PURE__ */ Q({
  __name: "ThemeStyles",
  props: {
    id: {},
    withDefaultFonts: { type: Boolean, default: !0 }
  },
  setup(r) {
    return (e, t) => (S(), E(Z, null, [
      e.withDefaultFonts ? (S(), U(Bk, { key: 0 })) : z("", !0),
      e.id !== "none" ? (S(), U(br("style"), { key: 1 }, {
        default: P(() => [
          J(ee($(Zk)(e.id, { layer: "scalar-theme" })), 1)
        ]),
        _: 1
      })) : z("", !0)
    ], 64));
  }
});
function F0(r, e) {
  vr(() => {
    if (!document.body)
      return;
    const t = document.querySelector(r);
    t == null || t.classList.add(e);
  });
}
const Vk = /* @__PURE__ */ Q({
  __name: "ResetStyles",
  setup(r) {
    const { reset: e } = I0();
    return F0("#headlessui-portal-root", e), (t, s) => te(t.$slots, "default", { styles: $(e) });
  }
}), Uk = "_reset_1w0av_3", zk = {
  reset: Uk
}, ne = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [s, n] of e)
    t[s] = n;
  return t;
}, qk = {
  $style: zk
}, V0 = /* @__PURE__ */ ne(Vk, [["__cssModules", qk]]), Hk = /* @__PURE__ */ Q({
  __name: "ScrollbarStyles",
  setup(r) {
    const { scrollbars: e } = I0();
    return F0("#headlessui-portal-root", e), (t, s) => te(t.$slots, "default", { styles: $(e) });
  }
}), Kk = "_scrollbars_3tunk_3", Wk = {
  scrollbars: Kk
}, Gk = {
  $style: Wk
}, Jk = /* @__PURE__ */ ne(Hk, [["__cssModules", Gk]]), U0 = [
  ["--theme-", "--scalar-"],
  ["--sidebar-", "--scalar-sidebar-"]
], Yk = U0.map(([r]) => r);
function Xk(r) {
  return Yk.some((t) => r.includes(t)) ? (console.warn(
    "DEPRECATION WARNING: It looks like you're using legacy CSS variables in your custom CSS string. Please migrate them to use the updated prefixes. See https://github.com/scalar/scalar#theme-prefix-changes"
  ), U0.reduce((t, [s, n]) => t.replaceAll(s, n), r)) : r;
}
const Wp = {
  default: "Default",
  alternate: "Alternate",
  moon: "Moon",
  purple: "Purple",
  solarized: "Solarized",
  bluePlanet: "Blue Planet",
  saturn: "Saturn",
  kepler: "Kepler-11e",
  mars: "Mars",
  deepSpace: "Deep Space",
  none: ""
}, Qk = {
  alternate: Ok,
  default: B0,
  moon: Mk,
  purple: Dk,
  solarized: jk,
  bluePlanet: Tk,
  deepSpace: Pk,
  saturn: Rk,
  kepler: Ik,
  mars: Nk
}, Zk = (r, e) => {
  if (r === "none")
    return "";
  const t = Qk[r || "default"] ?? B0;
  return e != null && e.layer ? `@layer ${e.layer} {
${t}}` : t;
};
function eS() {
  return {
    showApiClient: !1,
    activeApiClientEndpointId: "",
    activeItem: {},
    snippetType: "javascript"
  };
}
const Es = $r(eS());
function tS(r, e = !1) {
  e ? Es.showApiClient = !0 : Es.showApiClient = !Es.showApiClient, r && (Es.activeItem = r);
}
function rS() {
  Es.showApiClient = !1;
}
function sS(r) {
  Es.activeApiClientEndpointId = r;
}
function nS(r) {
  Es.snippetType = r;
}
const Ih = () => ({
  state: td(Es),
  toggleApiClient: tS,
  setActiveApiClientEndpointId: sS,
  setSnippetType: nS,
  hideApiClient: rS
}), Nh = (r) => {
  let e = 0, t = 0, s = 0;
  if (!(r != null && r.length))
    return t;
  for (s = 0; s < r.length; s++)
    e = r.charCodeAt(s), t = (t << 5) - t + e, t |= 0;
  return t;
}, sd = () => ({}), Eo = typeof window < "u" ? window.__SCALAR__ ?? sd() : sd(), Mh = Symbol.for("yaml.alias"), oS = Symbol.for("yaml.document"), mn = Symbol.for("yaml.map"), z0 = Symbol.for("yaml.pair"), Dh = Symbol.for("yaml.scalar"), da = Symbol.for("yaml.seq"), Kr = Symbol.for("yaml.node.type"), Oo = (r) => !!r && typeof r == "object" && r[Kr] === Mh, bc = (r) => !!r && typeof r == "object" && r[Kr] === oS, q0 = (r) => !!r && typeof r == "object" && r[Kr] === mn, vt = (r) => !!r && typeof r == "object" && r[Kr] === z0, dt = (r) => !!r && typeof r == "object" && r[Kr] === Dh, Rh = (r) => !!r && typeof r == "object" && r[Kr] === da;
function Ut(r) {
  if (r && typeof r == "object")
    switch (r[Kr]) {
      case mn:
      case da:
        return !0;
    }
  return !1;
}
function jt(r) {
  if (r && typeof r == "object")
    switch (r[Kr]) {
      case Mh:
      case mn:
      case Dh:
      case da:
        return !0;
    }
  return !1;
}
const iS = (r) => (dt(r) || Ut(r)) && !!r.anchor, Zs = Symbol("break visit"), aS = Symbol("skip children"), Oi = Symbol("remove node");
function Ui(r, e) {
  const t = lS(e);
  bc(r) ? Wn(null, r.contents, t, Object.freeze([r])) === Oi && (r.contents = null) : Wn(null, r, t, Object.freeze([]));
}
Ui.BREAK = Zs;
Ui.SKIP = aS;
Ui.REMOVE = Oi;
function Wn(r, e, t, s) {
  const n = cS(r, e, t, s);
  if (jt(n) || vt(n))
    return uS(r, s, n), Wn(r, n, t, s);
  if (typeof n != "symbol") {
    if (Ut(e)) {
      s = Object.freeze(s.concat(e));
      for (let o = 0; o < e.items.length; ++o) {
        const i = Wn(o, e.items[o], t, s);
        if (typeof i == "number")
          o = i - 1;
        else {
          if (i === Zs)
            return Zs;
          i === Oi && (e.items.splice(o, 1), o -= 1);
        }
      }
    } else if (vt(e)) {
      s = Object.freeze(s.concat(e));
      const o = Wn("key", e.key, t, s);
      if (o === Zs)
        return Zs;
      o === Oi && (e.key = null);
      const i = Wn("value", e.value, t, s);
      if (i === Zs)
        return Zs;
      i === Oi && (e.value = null);
    }
  }
  return n;
}
function lS(r) {
  return typeof r == "object" && (r.Collection || r.Node || r.Value) ? Object.assign({
    Alias: r.Node,
    Map: r.Node,
    Scalar: r.Node,
    Seq: r.Node
  }, r.Value && {
    Map: r.Value,
    Scalar: r.Value,
    Seq: r.Value
  }, r.Collection && {
    Map: r.Collection,
    Seq: r.Collection
  }, r) : r;
}
function cS(r, e, t, s) {
  var n, o, i, a, l;
  if (typeof t == "function")
    return t(r, e, s);
  if (q0(e))
    return (n = t.Map) == null ? void 0 : n.call(t, r, e, s);
  if (Rh(e))
    return (o = t.Seq) == null ? void 0 : o.call(t, r, e, s);
  if (vt(e))
    return (i = t.Pair) == null ? void 0 : i.call(t, r, e, s);
  if (dt(e))
    return (a = t.Scalar) == null ? void 0 : a.call(t, r, e, s);
  if (Oo(e))
    return (l = t.Alias) == null ? void 0 : l.call(t, r, e, s);
}
function uS(r, e, t) {
  const s = e[e.length - 1];
  if (Ut(s))
    s.items[r] = t;
  else if (vt(s))
    r === "key" ? s.key = t : s.value = t;
  else if (bc(s))
    s.contents = t;
  else {
    const n = Oo(s) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${n} parent`);
  }
}
function H0(r) {
  if (/[\x00-\x19\s,[\]{}]/.test(r)) {
    const t = `Anchor must not contain whitespace or control characters: ${JSON.stringify(r)}`;
    throw new Error(t);
  }
  return !0;
}
function bi(r, e, t, s) {
  if (s && typeof s == "object")
    if (Array.isArray(s))
      for (let n = 0, o = s.length; n < o; ++n) {
        const i = s[n], a = bi(r, s, String(n), i);
        a === void 0 ? delete s[n] : a !== i && (s[n] = a);
      }
    else if (s instanceof Map)
      for (const n of Array.from(s.keys())) {
        const o = s.get(n), i = bi(r, s, n, o);
        i === void 0 ? s.delete(n) : i !== o && s.set(n, i);
      }
    else if (s instanceof Set)
      for (const n of Array.from(s)) {
        const o = bi(r, s, n, n);
        o === void 0 ? s.delete(n) : o !== n && (s.delete(n), s.add(o));
      }
    else
      for (const [n, o] of Object.entries(s)) {
        const i = bi(r, s, n, o);
        i === void 0 ? delete s[n] : i !== o && (s[n] = i);
      }
  return r.call(e, t, s);
}
function gr(r, e, t) {
  if (Array.isArray(r))
    return r.map((s, n) => gr(s, String(n), t));
  if (r && typeof r.toJSON == "function") {
    if (!t || !iS(r))
      return r.toJSON(e, t);
    const s = { aliasCount: 0, count: 1, res: void 0 };
    t.anchors.set(r, s), t.onCreate = (o) => {
      s.res = o, delete t.onCreate;
    };
    const n = r.toJSON(e, t);
    return t.onCreate && t.onCreate(n), n;
  }
  return typeof r == "bigint" && !(t != null && t.keep) ? Number(r) : r;
}
class jh {
  constructor(e) {
    Object.defineProperty(this, Kr, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: t, maxAliasCount: s, onAnchor: n, reviver: o } = {}) {
    if (!bc(e))
      throw new TypeError("A document argument is required");
    const i = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: !0,
      mapAsMap: t === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof s == "number" ? s : 100
    }, a = gr(this, "", i);
    if (typeof n == "function")
      for (const { count: l, res: c } of i.anchors.values())
        n(c, l);
    return typeof o == "function" ? bi(o, { "": a }, "", a) : a;
  }
}
class dS extends jh {
  constructor(e) {
    super(Mh), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e) {
    let t;
    return Ui(e, {
      Node: (s, n) => {
        if (n === this)
          return Ui.BREAK;
        n.anchor === this.source && (t = n);
      }
    }), t;
  }
  toJSON(e, t) {
    if (!t)
      return { source: this.source };
    const { anchors: s, doc: n, maxAliasCount: o } = t, i = this.resolve(n);
    if (!i) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let a = s.get(i);
    if (a || (gr(i, null, t), a = s.get(i)), !a || a.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (o >= 0 && (a.count += 1, a.aliasCount === 0 && (a.aliasCount = vl(n, i, s)), a.count * a.aliasCount > o)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return a.res;
  }
  toString(e, t, s) {
    const n = `*${this.source}`;
    if (e) {
      if (H0(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const o = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(o);
      }
      if (e.implicitKey)
        return `${n} `;
    }
    return n;
  }
}
function vl(r, e, t) {
  if (Oo(e)) {
    const s = e.resolve(r), n = t && s && t.get(s);
    return n ? n.count * n.aliasCount : 0;
  } else if (Ut(e)) {
    let s = 0;
    for (const n of e.items) {
      const o = vl(r, n, t);
      o > s && (s = o);
    }
    return s;
  } else if (vt(e)) {
    const s = vl(r, e.key, t), n = vl(r, e.value, t);
    return Math.max(s, n);
  }
  return 1;
}
const K0 = (r) => !r || typeof r != "function" && typeof r != "object";
class it extends jh {
  constructor(e) {
    super(Dh), this.value = e;
  }
  toJSON(e, t) {
    return t != null && t.keep ? this.value : gr(this.value, e, t);
  }
  toString() {
    return String(this.value);
  }
}
it.BLOCK_FOLDED = "BLOCK_FOLDED";
it.BLOCK_LITERAL = "BLOCK_LITERAL";
it.PLAIN = "PLAIN";
it.QUOTE_DOUBLE = "QUOTE_DOUBLE";
it.QUOTE_SINGLE = "QUOTE_SINGLE";
const hS = "tag:yaml.org,2002:";
function fS(r, e, t) {
  if (e) {
    const s = t.filter((o) => o.tag === e), n = s.find((o) => !o.format) ?? s[0];
    if (!n)
      throw new Error(`Tag ${e} not found`);
    return n;
  }
  return t.find((s) => {
    var n;
    return ((n = s.identify) == null ? void 0 : n.call(s, r)) && !s.format;
  });
}
function Bl(r, e, t) {
  var d, h, f;
  if (bc(r) && (r = r.contents), jt(r))
    return r;
  if (vt(r)) {
    const m = (h = (d = t.schema[mn]).createNode) == null ? void 0 : h.call(d, t.schema, null, t);
    return m.items.push(r), m;
  }
  (r instanceof String || r instanceof Number || r instanceof Boolean || typeof BigInt < "u" && r instanceof BigInt) && (r = r.valueOf());
  const { aliasDuplicateObjects: s, onAnchor: n, onTagObj: o, schema: i, sourceObjects: a } = t;
  let l;
  if (s && r && typeof r == "object") {
    if (l = a.get(r), l)
      return l.anchor || (l.anchor = n(r)), new dS(l.anchor);
    l = { anchor: null, node: null }, a.set(r, l);
  }
  e != null && e.startsWith("!!") && (e = hS + e.slice(2));
  let c = fS(r, e, i.tags);
  if (!c) {
    if (r && typeof r.toJSON == "function" && (r = r.toJSON()), !r || typeof r != "object") {
      const m = new it(r);
      return l && (l.node = m), m;
    }
    c = r instanceof Map ? i[mn] : Symbol.iterator in Object(r) ? i[da] : i[mn];
  }
  o && (o(c), delete t.onTagObj);
  const u = c != null && c.createNode ? c.createNode(t.schema, r, t) : typeof ((f = c == null ? void 0 : c.nodeClass) == null ? void 0 : f.from) == "function" ? c.nodeClass.from(t.schema, r, t) : new it(r);
  return e ? u.tag = e : c.default || (u.tag = c.tag), l && (l.node = u), u;
}
function Gp(r, e, t) {
  let s = t;
  for (let n = e.length - 1; n >= 0; --n) {
    const o = e[n];
    if (typeof o == "number" && Number.isInteger(o) && o >= 0) {
      const i = [];
      i[o] = s, s = i;
    } else
      s = /* @__PURE__ */ new Map([[o, s]]);
  }
  return Bl(s, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: r,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const pS = (r) => r == null || typeof r == "object" && !!r[Symbol.iterator]().next().done;
class Lh extends jh {
  constructor(e, t) {
    super(e), Object.defineProperty(this, "schema", {
      value: t,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (t.schema = e), t.items = t.items.map((s) => jt(s) || vt(s) ? s.clone(e) : s), this.range && (t.range = this.range.slice()), t;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, t) {
    if (pS(e))
      this.add(t);
    else {
      const [s, ...n] = e, o = this.get(s, !0);
      if (Ut(o))
        o.addIn(n, t);
      else if (o === void 0 && this.schema)
        this.set(s, Gp(this.schema, n, t));
      else
        throw new Error(`Expected YAML collection at ${s}. Remaining path: ${n}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [t, ...s] = e;
    if (s.length === 0)
      return this.delete(t);
    const n = this.get(t, !0);
    if (Ut(n))
      return n.deleteIn(s);
    throw new Error(`Expected YAML collection at ${t}. Remaining path: ${s}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, t) {
    const [s, ...n] = e, o = this.get(s, !0);
    return n.length === 0 ? !t && dt(o) ? o.value : o : Ut(o) ? o.getIn(n, t) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((t) => {
      if (!vt(t))
        return !1;
      const s = t.value;
      return s == null || e && dt(s) && s.value == null && !s.commentBefore && !s.comment && !s.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [t, ...s] = e;
    if (s.length === 0)
      return this.has(t);
    const n = this.get(t, !0);
    return Ut(n) ? n.hasIn(s) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, t) {
    const [s, ...n] = e;
    if (n.length === 0)
      this.set(s, t);
    else {
      const o = this.get(s, !0);
      if (Ut(o))
        o.setIn(n, t);
      else if (o === void 0 && this.schema)
        this.set(s, Gp(this.schema, n, t));
      else
        throw new Error(`Expected YAML collection at ${s}. Remaining path: ${n}`);
    }
  }
}
Lh.maxFlowStringSingleLineLength = 60;
const mS = (r) => r.replace(/^(?!$)(?: $)?/gm, "#");
function zi(r, e) {
  return /^\n+$/.test(r) ? r.substring(1) : e ? r.replace(/^(?! *$)/gm, e) : r;
}
const Gn = (r, e, t) => r.endsWith(`
`) ? zi(t, e) : t.includes(`
`) ? `
` + zi(t, e) : (r.endsWith(" ") ? "" : " ") + t, W0 = "flow", nd = "block", wl = "quoted";
function vc(r, e, t = "flow", { indentAtStart: s, lineWidth: n = 80, minContentWidth: o = 20, onFold: i, onOverflow: a } = {}) {
  if (!n || n < 0)
    return r;
  const l = Math.max(1 + o, 1 + n - e.length);
  if (r.length <= l)
    return r;
  const c = [], u = {};
  let d = n - e.length;
  typeof s == "number" && (s > n - Math.max(2, o) ? c.push(0) : d = n - s);
  let h, f, m = !1, g = -1, p = -1, y = -1;
  t === nd && (g = Jp(r, g, e.length), g !== -1 && (d = g + l));
  for (let v; v = r[g += 1]; ) {
    if (t === wl && v === "\\") {
      switch (p = g, r[g + 1]) {
        case "x":
          g += 3;
          break;
        case "u":
          g += 5;
          break;
        case "U":
          g += 9;
          break;
        default:
          g += 1;
      }
      y = g;
    }
    if (v === `
`)
      t === nd && (g = Jp(r, g, e.length)), d = g + e.length + l, h = void 0;
    else {
      if (v === " " && f && f !== " " && f !== `
` && f !== "	") {
        const k = r[g + 1];
        k && k !== " " && k !== `
` && k !== "	" && (h = g);
      }
      if (g >= d)
        if (h)
          c.push(h), d = h + l, h = void 0;
        else if (t === wl) {
          for (; f === " " || f === "	"; )
            f = v, v = r[g += 1], m = !0;
          const k = g > y + 1 ? g - 2 : p - 1;
          if (u[k])
            return r;
          c.push(k), u[k] = !0, d = k + l, h = void 0;
        } else
          m = !0;
    }
    f = v;
  }
  if (m && a && a(), c.length === 0)
    return r;
  i && i();
  let b = r.slice(0, c[0]);
  for (let v = 0; v < c.length; ++v) {
    const k = c[v], _ = c[v + 1] || r.length;
    k === 0 ? b = `
${e}${r.slice(0, _)}` : (t === wl && u[k] && (b += `${r[k]}\\`), b += `
${e}${r.slice(k + 1, _)}`);
  }
  return b;
}
function Jp(r, e, t) {
  let s = e, n = e + 1, o = r[n];
  for (; o === " " || o === "	"; )
    if (e < n + t)
      o = r[++e];
    else {
      do
        o = r[++e];
      while (o && o !== `
`);
      s = e, n = e + 1, o = r[n];
    }
  return s;
}
const wc = (r, e) => ({
  indentAtStart: e ? r.indent.length : r.indentAtStart,
  lineWidth: r.options.lineWidth,
  minContentWidth: r.options.minContentWidth
}), kc = (r) => /^(%|---|\.\.\.)/m.test(r);
function gS(r, e, t) {
  if (!e || e < 0)
    return !1;
  const s = e - t, n = r.length;
  if (n <= s)
    return !1;
  for (let o = 0, i = 0; o < n; ++o)
    if (r[o] === `
`) {
      if (o - i > s)
        return !0;
      if (i = o + 1, n - i <= s)
        return !1;
    }
  return !0;
}
function Ti(r, e) {
  const t = JSON.stringify(r);
  if (e.options.doubleQuotedAsJSON)
    return t;
  const { implicitKey: s } = e, n = e.options.doubleQuotedMinMultiLineLength, o = e.indent || (kc(r) ? "  " : "");
  let i = "", a = 0;
  for (let l = 0, c = t[l]; c; c = t[++l])
    if (c === " " && t[l + 1] === "\\" && t[l + 2] === "n" && (i += t.slice(a, l) + "\\ ", l += 1, a = l, c = "\\"), c === "\\")
      switch (t[l + 1]) {
        case "u":
          {
            i += t.slice(a, l);
            const u = t.substr(l + 2, 4);
            switch (u) {
              case "0000":
                i += "\\0";
                break;
              case "0007":
                i += "\\a";
                break;
              case "000b":
                i += "\\v";
                break;
              case "001b":
                i += "\\e";
                break;
              case "0085":
                i += "\\N";
                break;
              case "00a0":
                i += "\\_";
                break;
              case "2028":
                i += "\\L";
                break;
              case "2029":
                i += "\\P";
                break;
              default:
                u.substr(0, 2) === "00" ? i += "\\x" + u.substr(2) : i += t.substr(l, 6);
            }
            l += 5, a = l + 1;
          }
          break;
        case "n":
          if (s || t[l + 2] === '"' || t.length < n)
            l += 1;
          else {
            for (i += t.slice(a, l) + `

`; t[l + 2] === "\\" && t[l + 3] === "n" && t[l + 4] !== '"'; )
              i += `
`, l += 2;
            i += o, t[l + 2] === " " && (i += "\\"), l += 1, a = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return i = a ? i + t.slice(a) : t, s ? i : vc(i, o, wl, wc(e, !1));
}
function od(r, e) {
  if (e.options.singleQuote === !1 || e.implicitKey && r.includes(`
`) || /[ \t]\n|\n[ \t]/.test(r))
    return Ti(r, e);
  const t = e.indent || (kc(r) ? "  " : ""), s = "'" + r.replace(/'/g, "''").replace(/\n+/g, `$&
${t}`) + "'";
  return e.implicitKey ? s : vc(s, t, W0, wc(e, !1));
}
function Jn(r, e) {
  const { singleQuote: t } = e.options;
  let s;
  if (t === !1)
    s = Ti;
  else {
    const n = r.includes('"'), o = r.includes("'");
    n && !o ? s = od : o && !n ? s = Ti : s = t ? od : Ti;
  }
  return s(r, e);
}
let id;
try {
  id = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  id = /\n+(?!\n|$)/g;
}
function kl({ comment: r, type: e, value: t }, s, n, o) {
  const { blockQuote: i, commentString: a, lineWidth: l } = s.options;
  if (!i || /\n[\t ]+$/.test(t) || /^\s*$/.test(t))
    return Jn(t, s);
  const c = s.indent || (s.forceBlockIndent || kc(t) ? "  " : ""), u = i === "literal" ? !0 : i === "folded" || e === it.BLOCK_FOLDED ? !1 : e === it.BLOCK_LITERAL ? !0 : !gS(t, l, c.length);
  if (!t)
    return u ? `|
` : `>
`;
  let d, h;
  for (h = t.length; h > 0; --h) {
    const w = t[h - 1];
    if (w !== `
` && w !== "	" && w !== " ")
      break;
  }
  let f = t.substring(h);
  const m = f.indexOf(`
`);
  m === -1 ? d = "-" : t === f || m !== f.length - 1 ? (d = "+", o && o()) : d = "", f && (t = t.slice(0, -f.length), f[f.length - 1] === `
` && (f = f.slice(0, -1)), f = f.replace(id, `$&${c}`));
  let g = !1, p, y = -1;
  for (p = 0; p < t.length; ++p) {
    const w = t[p];
    if (w === " ")
      g = !0;
    else if (w === `
`)
      y = p;
    else
      break;
  }
  let b = t.substring(0, y < p ? y + 1 : p);
  b && (t = t.substring(b.length), b = b.replace(/\n+/g, `$&${c}`));
  let k = (u ? "|" : ">") + (g ? c ? "2" : "1" : "") + d;
  if (r && (k += " " + a(r.replace(/ ?[\r\n]+/g, " ")), n && n()), u)
    return t = t.replace(/\n+/g, `$&${c}`), `${k}
${c}${b}${t}${f}`;
  t = t.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`);
  const _ = vc(`${b}${t}${f}`, c, nd, wc(s, !0));
  return `${k}
${c}${_}`;
}
function yS(r, e, t, s) {
  const { type: n, value: o } = r, { actualString: i, implicitKey: a, indent: l, indentStep: c, inFlow: u } = e;
  if (a && o.includes(`
`) || u && /[[\]{},]/.test(o))
    return Jn(o, e);
  if (!o || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))
    return a || u || !o.includes(`
`) ? Jn(o, e) : kl(r, e, t, s);
  if (!a && !u && n !== it.PLAIN && o.includes(`
`))
    return kl(r, e, t, s);
  if (kc(o)) {
    if (l === "")
      return e.forceBlockIndent = !0, kl(r, e, t, s);
    if (a && l === c)
      return Jn(o, e);
  }
  const d = o.replace(/\n+/g, `$&
${l}`);
  if (i) {
    const h = (g) => {
      var p;
      return g.default && g.tag !== "tag:yaml.org,2002:str" && ((p = g.test) == null ? void 0 : p.test(d));
    }, { compat: f, tags: m } = e.doc.schema;
    if (m.some(h) || f != null && f.some(h))
      return Jn(o, e);
  }
  return a ? d : vc(d, l, W0, wc(e, !1));
}
function bS(r, e, t, s) {
  const { implicitKey: n, inFlow: o } = e, i = typeof r.value == "string" ? r : Object.assign({}, r, { value: String(r.value) });
  let { type: a } = r;
  a !== it.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(i.value) && (a = it.QUOTE_DOUBLE);
  const l = (u) => {
    switch (u) {
      case it.BLOCK_FOLDED:
      case it.BLOCK_LITERAL:
        return n || o ? Jn(i.value, e) : kl(i, e, t, s);
      case it.QUOTE_DOUBLE:
        return Ti(i.value, e);
      case it.QUOTE_SINGLE:
        return od(i.value, e);
      case it.PLAIN:
        return yS(i, e, t, s);
      default:
        return null;
    }
  };
  let c = l(a);
  if (c === null) {
    const { defaultKeyType: u, defaultStringType: d } = e.options, h = n && u || d;
    if (c = l(h), c === null)
      throw new Error(`Unsupported default string type ${h}`);
  }
  return c;
}
function vS(r, e) {
  const t = Object.assign({
    blockQuote: !0,
    commentString: mS,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, r.schema.toStringOptions, e);
  let s;
  switch (t.collectionStyle) {
    case "block":
      s = !1;
      break;
    case "flow":
      s = !0;
      break;
    default:
      s = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: r,
    flowCollectionPadding: t.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof t.indent == "number" ? " ".repeat(t.indent) : "  ",
    inFlow: s,
    options: t
  };
}
function wS(r, e) {
  var n;
  if (e.tag) {
    const o = r.filter((i) => i.tag === e.tag);
    if (o.length > 0)
      return o.find((i) => i.format === e.format) ?? o[0];
  }
  let t, s;
  if (dt(e)) {
    s = e.value;
    const o = r.filter((i) => {
      var a;
      return (a = i.identify) == null ? void 0 : a.call(i, s);
    });
    t = o.find((i) => i.format === e.format) ?? o.find((i) => !i.format);
  } else
    s = e, t = r.find((o) => o.nodeClass && s instanceof o.nodeClass);
  if (!t) {
    const o = ((n = s == null ? void 0 : s.constructor) == null ? void 0 : n.name) ?? typeof s;
    throw new Error(`Tag not resolved for ${o} value`);
  }
  return t;
}
function kS(r, e, { anchors: t, doc: s }) {
  if (!s.directives)
    return "";
  const n = [], o = (dt(r) || Ut(r)) && r.anchor;
  o && H0(o) && (t.add(o), n.push(`&${o}`));
  const i = r.tag ? r.tag : e.default ? null : e.tag;
  return i && n.push(s.directives.tagString(i)), n.join(" ");
}
function Fl(r, e, t, s) {
  var l;
  if (vt(r))
    return r.toString(e, t, s);
  if (Oo(r)) {
    if (e.doc.directives)
      return r.toString(e);
    if ((l = e.resolvedAliases) != null && l.has(r))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(r) : e.resolvedAliases = /* @__PURE__ */ new Set([r]), r = r.resolve(e.doc);
  }
  let n;
  const o = jt(r) ? r : e.doc.createNode(r, { onTagObj: (c) => n = c });
  n || (n = wS(e.doc.schema.tags, o));
  const i = kS(o, n, e);
  i.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + i.length + 1);
  const a = typeof n.stringify == "function" ? n.stringify(o, e, t, s) : dt(o) ? bS(o, e, t, s) : o.toString(e, t, s);
  return i ? dt(o) || a[0] === "{" || a[0] === "[" ? `${i} ${a}` : `${i}
${e.indent}${a}` : a;
}
function SS({ key: r, value: e }, t, s, n) {
  const { allNullValues: o, doc: i, indent: a, indentStep: l, options: { commentString: c, indentSeq: u, simpleKeys: d } } = t;
  let h = jt(r) && r.comment || null;
  if (d) {
    if (h)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (Ut(r)) {
      const x = "With simple keys, collection cannot be used as a key value";
      throw new Error(x);
    }
  }
  let f = !d && (!r || h && e == null && !t.inFlow || Ut(r) || (dt(r) ? r.type === it.BLOCK_FOLDED || r.type === it.BLOCK_LITERAL : typeof r == "object"));
  t = Object.assign({}, t, {
    allNullValues: !1,
    implicitKey: !f && (d || !o),
    indent: a + l
  });
  let m = !1, g = !1, p = Fl(r, t, () => m = !0, () => g = !0);
  if (!f && !t.inFlow && p.length > 1024) {
    if (d)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    f = !0;
  }
  if (t.inFlow) {
    if (o || e == null)
      return m && s && s(), p === "" ? "?" : f ? `? ${p}` : p;
  } else if (o && !d || e == null && f)
    return p = `? ${p}`, h && !m ? p += Gn(p, t.indent, c(h)) : g && n && n(), p;
  m && (h = null), f ? (h && (p += Gn(p, t.indent, c(h))), p = `? ${p}
${a}:`) : (p = `${p}:`, h && (p += Gn(p, t.indent, c(h))));
  let y, b, v;
  jt(e) ? (y = !!e.spaceBefore, b = e.commentBefore, v = e.comment) : (y = !1, b = null, v = null, e && typeof e == "object" && (e = i.createNode(e))), t.implicitKey = !1, !f && !h && dt(e) && (t.indentAtStart = p.length + 1), g = !1, !u && l.length >= 2 && !t.inFlow && !f && Rh(e) && !e.flow && !e.tag && !e.anchor && (t.indent = t.indent.substring(2));
  let k = !1;
  const _ = Fl(e, t, () => k = !0, () => g = !0);
  let w = " ";
  if (h || y || b) {
    if (w = y ? `
` : "", b) {
      const x = c(b);
      w += `
${zi(x, t.indent)}`;
    }
    _ === "" && !t.inFlow ? w === `
` && (w = `

`) : w += `
${t.indent}`;
  } else if (!f && Ut(e)) {
    const x = _[0], T = _.indexOf(`
`), j = T !== -1, B = t.inFlow ?? e.flow ?? e.items.length === 0;
    if (j || !B) {
      let W = !1;
      if (j && (x === "&" || x === "!")) {
        let L = _.indexOf(" ");
        x === "&" && L !== -1 && L < T && _[L + 1] === "!" && (L = _.indexOf(" ", L + 1)), (L === -1 || T < L) && (W = !0);
      }
      W || (w = `
${t.indent}`);
    }
  } else
    (_ === "" || _[0] === `
`) && (w = "");
  return p += w + _, t.inFlow ? k && s && s() : v && !k ? p += Gn(p, t.indent, c(v)) : g && n && n(), p;
}
function $S(r, e) {
  (r === "debug" || r === "warn") && (typeof process < "u" && process.emitWarning ? process.emitWarning(e) : console.warn(e));
}
const Yp = "<<";
function G0(r, e, { key: t, value: s }) {
  if (r != null && r.doc.schema.merge && _S(t))
    if (s = Oo(s) ? s.resolve(r.doc) : s, Rh(s))
      for (const n of s.items)
        pu(r, e, n);
    else if (Array.isArray(s))
      for (const n of s)
        pu(r, e, n);
    else
      pu(r, e, s);
  else {
    const n = gr(t, "", r);
    if (e instanceof Map)
      e.set(n, gr(s, n, r));
    else if (e instanceof Set)
      e.add(n);
    else {
      const o = xS(t, n, r), i = gr(s, o, r);
      o in e ? Object.defineProperty(e, o, {
        value: i,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : e[o] = i;
    }
  }
  return e;
}
const _S = (r) => r === Yp || dt(r) && r.value === Yp && (!r.type || r.type === it.PLAIN);
function pu(r, e, t) {
  const s = r && Oo(t) ? t.resolve(r.doc) : t;
  if (!q0(s))
    throw new Error("Merge sources must be maps or map aliases");
  const n = s.toJSON(null, r, Map);
  for (const [o, i] of n)
    e instanceof Map ? e.has(o) || e.set(o, i) : e instanceof Set ? e.add(o) : Object.prototype.hasOwnProperty.call(e, o) || Object.defineProperty(e, o, {
      value: i,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return e;
}
function xS(r, e, t) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (jt(r) && (t != null && t.doc)) {
    const s = vS(t.doc, {});
    s.anchors = /* @__PURE__ */ new Set();
    for (const o of t.anchors.keys())
      s.anchors.add(o.anchor);
    s.inFlow = !0, s.inStringifyKey = !0;
    const n = r.toString(s);
    if (!t.mapKeyWarned) {
      let o = JSON.stringify(n);
      o.length > 40 && (o = o.substring(0, 36) + '..."'), $S(t.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${o}. Set mapAsMap: true to use object keys.`), t.mapKeyWarned = !0;
    }
    return n;
  }
  return JSON.stringify(e);
}
function Bh(r, e, t) {
  const s = Bl(r, void 0, t), n = Bl(e, void 0, t);
  return new es(s, n);
}
class es {
  constructor(e, t = null) {
    Object.defineProperty(this, Kr, { value: z0 }), this.key = e, this.value = t;
  }
  clone(e) {
    let { key: t, value: s } = this;
    return jt(t) && (t = t.clone(e)), jt(s) && (s = s.clone(e)), new es(t, s);
  }
  toJSON(e, t) {
    const s = t != null && t.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return G0(t, s, this);
  }
  toString(e, t, s) {
    return e != null && e.doc ? SS(this, e, t, s) : JSON.stringify(this);
  }
}
function J0(r, e, t) {
  return (e.inFlow ?? r.flow ? AS : CS)(r, e, t);
}
function CS({ comment: r, items: e }, t, { blockItemPrefix: s, flowChars: n, itemIndent: o, onChompKeep: i, onComment: a }) {
  const { indent: l, options: { commentString: c } } = t, u = Object.assign({}, t, { indent: o, type: null });
  let d = !1;
  const h = [];
  for (let m = 0; m < e.length; ++m) {
    const g = e[m];
    let p = null;
    if (jt(g))
      !d && g.spaceBefore && h.push(""), Vl(t, h, g.commentBefore, d), g.comment && (p = g.comment);
    else if (vt(g)) {
      const b = jt(g.key) ? g.key : null;
      b && (!d && b.spaceBefore && h.push(""), Vl(t, h, b.commentBefore, d));
    }
    d = !1;
    let y = Fl(g, u, () => p = null, () => d = !0);
    p && (y += Gn(y, o, c(p))), d && p && (d = !1), h.push(s + y);
  }
  let f;
  if (h.length === 0)
    f = n.start + n.end;
  else {
    f = h[0];
    for (let m = 1; m < h.length; ++m) {
      const g = h[m];
      f += g ? `
${l}${g}` : `
`;
    }
  }
  return r ? (f += `
` + zi(c(r), l), a && a()) : d && i && i(), f;
}
function AS({ items: r }, e, { flowChars: t, itemIndent: s }) {
  const { indent: n, indentStep: o, flowCollectionPadding: i, options: { commentString: a } } = e;
  s += o;
  const l = Object.assign({}, e, {
    indent: s,
    inFlow: !0,
    type: null
  });
  let c = !1, u = 0;
  const d = [];
  for (let m = 0; m < r.length; ++m) {
    const g = r[m];
    let p = null;
    if (jt(g))
      g.spaceBefore && d.push(""), Vl(e, d, g.commentBefore, !1), g.comment && (p = g.comment);
    else if (vt(g)) {
      const b = jt(g.key) ? g.key : null;
      b && (b.spaceBefore && d.push(""), Vl(e, d, b.commentBefore, !1), b.comment && (c = !0));
      const v = jt(g.value) ? g.value : null;
      v ? (v.comment && (p = v.comment), v.commentBefore && (c = !0)) : g.value == null && (b != null && b.comment) && (p = b.comment);
    }
    p && (c = !0);
    let y = Fl(g, l, () => p = null);
    m < r.length - 1 && (y += ","), p && (y += Gn(y, s, a(p))), !c && (d.length > u || y.includes(`
`)) && (c = !0), d.push(y), u = d.length;
  }
  const { start: h, end: f } = t;
  if (d.length === 0)
    return h + f;
  if (!c) {
    const m = d.reduce((g, p) => g + p.length + 2, 2);
    c = e.options.lineWidth > 0 && m > e.options.lineWidth;
  }
  if (c) {
    let m = h;
    for (const g of d)
      m += g ? `
${o}${n}${g}` : `
`;
    return `${m}
${n}${f}`;
  } else
    return `${h}${i}${d.join(" ")}${i}${f}`;
}
function Vl({ indent: r, options: { commentString: e } }, t, s, n) {
  if (s && n && (s = s.replace(/^\n+/, "")), s) {
    const o = zi(e(s), r);
    t.push(o.trimStart());
  }
}
function on(r, e) {
  const t = dt(e) ? e.value : e;
  for (const s of r)
    if (vt(s) && (s.key === e || s.key === t || dt(s.key) && s.key.value === t))
      return s;
}
class Hn extends Lh {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(mn, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, t, s) {
    const { keepUndefined: n, replacer: o } = s, i = new this(e), a = (l, c) => {
      if (typeof o == "function")
        c = o.call(t, l, c);
      else if (Array.isArray(o) && !o.includes(l))
        return;
      (c !== void 0 || n) && i.items.push(Bh(l, c, s));
    };
    if (t instanceof Map)
      for (const [l, c] of t)
        a(l, c);
    else if (t && typeof t == "object")
      for (const l of Object.keys(t))
        a(l, t[l]);
    return typeof e.sortMapEntries == "function" && i.items.sort(e.sortMapEntries), i;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, t) {
    var i;
    let s;
    vt(e) ? s = e : !e || typeof e != "object" || !("key" in e) ? s = new es(e, e == null ? void 0 : e.value) : s = new es(e.key, e.value);
    const n = on(this.items, s.key), o = (i = this.schema) == null ? void 0 : i.sortMapEntries;
    if (n) {
      if (!t)
        throw new Error(`Key ${s.key} already set`);
      dt(n.value) && K0(s.value) ? n.value.value = s.value : n.value = s.value;
    } else if (o) {
      const a = this.items.findIndex((l) => o(s, l) < 0);
      a === -1 ? this.items.push(s) : this.items.splice(a, 0, s);
    } else
      this.items.push(s);
  }
  delete(e) {
    const t = on(this.items, e);
    return t ? this.items.splice(this.items.indexOf(t), 1).length > 0 : !1;
  }
  get(e, t) {
    const s = on(this.items, e), n = s == null ? void 0 : s.value;
    return (!t && dt(n) ? n.value : n) ?? void 0;
  }
  has(e) {
    return !!on(this.items, e);
  }
  set(e, t) {
    this.add(new es(e, t), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, t, s) {
    const n = s ? new s() : t != null && t.mapAsMap ? /* @__PURE__ */ new Map() : {};
    t != null && t.onCreate && t.onCreate(n);
    for (const o of this.items)
      G0(t, n, o);
    return n;
  }
  toString(e, t, s) {
    if (!e)
      return JSON.stringify(this);
    for (const n of this.items)
      if (!vt(n))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(n)} instead`);
    return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), J0(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: s,
      onComment: t
    });
  }
}
class Y0 extends Lh {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(da, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const t = Fa(e);
    return typeof t != "number" ? !1 : this.items.splice(t, 1).length > 0;
  }
  get(e, t) {
    const s = Fa(e);
    if (typeof s != "number")
      return;
    const n = this.items[s];
    return !t && dt(n) ? n.value : n;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const t = Fa(e);
    return typeof t == "number" && t < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, t) {
    const s = Fa(e);
    if (typeof s != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const n = this.items[s];
    dt(n) && K0(t) ? n.value = t : this.items[s] = t;
  }
  toJSON(e, t) {
    const s = [];
    t != null && t.onCreate && t.onCreate(s);
    let n = 0;
    for (const o of this.items)
      s.push(gr(o, String(n++), t));
    return s;
  }
  toString(e, t, s) {
    return e ? J0(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: s,
      onComment: t
    }) : JSON.stringify(this);
  }
  static from(e, t, s) {
    const { replacer: n } = s, o = new this(e);
    if (t && Symbol.iterator in Object(t)) {
      let i = 0;
      for (let a of t) {
        if (typeof n == "function") {
          const l = t instanceof Set ? a : String(i++);
          a = n.call(t, l, a);
        }
        o.items.push(Bl(a, void 0, s));
      }
    }
    return o;
  }
}
function Fa(r) {
  let e = dt(r) ? r.value : r;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
function ES(r, e, t) {
  const { replacer: s } = t, n = new Y0(r);
  n.tag = "tag:yaml.org,2002:pairs";
  let o = 0;
  if (e && Symbol.iterator in Object(e))
    for (let i of e) {
      typeof s == "function" && (i = s.call(e, String(o++), i));
      let a, l;
      if (Array.isArray(i))
        if (i.length === 2)
          a = i[0], l = i[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${i}`);
      else if (i && i instanceof Object) {
        const c = Object.keys(i);
        if (c.length === 1)
          a = c[0], l = i[a];
        else
          throw new TypeError(`Expected tuple with one key, not ${c.length} keys`);
      } else
        a = i;
      n.items.push(Bh(a, l, t));
    }
  return n;
}
class Fh extends Y0 {
  constructor() {
    super(), this.add = Hn.prototype.add.bind(this), this.delete = Hn.prototype.delete.bind(this), this.get = Hn.prototype.get.bind(this), this.has = Hn.prototype.has.bind(this), this.set = Hn.prototype.set.bind(this), this.tag = Fh.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, t) {
    if (!t)
      return super.toJSON(e);
    const s = /* @__PURE__ */ new Map();
    t != null && t.onCreate && t.onCreate(s);
    for (const n of this.items) {
      let o, i;
      if (vt(n) ? (o = gr(n.key, "", t), i = gr(n.value, o, t)) : o = gr(n, "", t), s.has(o))
        throw new Error("Ordered maps must not include duplicate keys");
      s.set(o, i);
    }
    return s;
  }
  static from(e, t, s) {
    const n = ES(e, t, s), o = new this();
    return o.items = n.items, o;
  }
}
Fh.tag = "tag:yaml.org,2002:omap";
class Vh extends Hn {
  constructor(e) {
    super(e), this.tag = Vh.tag;
  }
  add(e) {
    let t;
    vt(e) ? t = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? t = new es(e.key, null) : t = new es(e, null), on(this.items, t.key) || this.items.push(t);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, t) {
    const s = on(this.items, e);
    return !t && vt(s) ? dt(s.key) ? s.key.value : s.key : s;
  }
  set(e, t) {
    if (typeof t != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof t}`);
    const s = on(this.items, e);
    s && !t ? this.items.splice(this.items.indexOf(s), 1) : !s && t && this.items.push(new es(e));
  }
  toJSON(e, t) {
    return super.toJSON(e, t, Set);
  }
  toString(e, t, s) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, e, { allNullValues: !0 }), t, s);
    throw new Error("Set items must all have null values");
  }
  static from(e, t, s) {
    const { replacer: n } = s, o = new this(e);
    if (t && Symbol.iterator in Object(t))
      for (let i of t)
        typeof n == "function" && (i = n.call(t, i, i)), o.items.push(Bh(i, null, s));
    return o;
  }
}
Vh.tag = "tag:yaml.org,2002:set";
const X0 = {
  /** Parse and throw if the return value is not an object */
  parse: (r) => {
    const e = JSON.parse(r);
    if (typeof e != "object")
      throw Error("Invalid JSON object");
    return e;
  },
  /** Parse and return a fallback on failure */
  parseSafe(r, e) {
    try {
      return X0.parse(r);
    } catch (t) {
      return typeof e == "function" ? e(t) : e;
    }
  },
  stringify: (r) => JSON.stringify(r)
}, OS = (r) => typeof r != "string" ? !1 : !!X0.parseSafe(r, !1);
function TS(r) {
  if (r.trim()[0] !== "{")
    return r;
  try {
    return JSON.stringify(JSON.parse(r), null, 2);
  } catch {
    return r;
  }
}
const PS = "https://api.scalar.com/request-proxy", IS = "https://proxy.scalar.com";
function NS(r, e) {
  return `${r}?scalar_url=${encodeURI(e)}`;
}
async function Xp(r, e) {
  e === PS && (e = IS);
  const t = await fetch(e ? NS(e, r) : r);
  return t.status !== 200 && (console.error(
    `[fetchSpecFromUrl] Failed to fetch the specification at ${r} (Status: ${t.status})`
  ), e || console.warn(
    `[fetchSpecFromUrl] Tried to fetch the specification (url: ${r}) without a proxy. Are the CORS headers configured to allow cross-domain requests? https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS`
  )), TS(await t.text());
}
function MS(r, e = "") {
  return {
    // 'date-time': '1970-01-01T00:00:00Z',
    "date-time": (/* @__PURE__ */ new Date()).toISOString(),
    // 'date': '1970-01-01',
    date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
    email: "hello@example.com",
    hostname: "example.com",
    // https://tools.ietf.org/html/rfc6531#section-3.3
    "idn-email": "jane.doe@example.com",
    // https://tools.ietf.org/html/rfc5890#section-2.3.2.3
    "idn-hostname": "example.com",
    ipv4: "127.0.0.1",
    ipv6: "51d4:7fab:bfbf:b7d7:b2cb:d4b4:3dad:d998",
    "iri-reference": "/entitiy/1",
    // https://tools.ietf.org/html/rfc3987
    iri: "https://example.com/entity/123",
    "json-pointer": "/nested/objects",
    password: "super-secret",
    regex: "/[a-z]/",
    // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01
    "relative-json-pointer": "1/nested/objects",
    // full-time in https://tools.ietf.org/html/rfc3339#section-5.6
    // 'time': '00:00:00Z',
    time: (/* @__PURE__ */ new Date()).toISOString().split("T")[1].split(".")[0],
    // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1
    "uri-reference": "../folder",
    "uri-template": "https://example.com/{id}",
    uri: "https://example.com",
    uuid: "123e4567-e89b-12d3-a456-426614174000"
  }[r.format] ?? e;
}
const at = (r, e, t = 0, s, n) => {
  var l, c, u, d, h, f;
  if (t > 5)
    return null;
  const o = !!(e != null && e.emptyString);
  if ((e == null ? void 0 : e.mode) === "write" && r.readOnly || (e == null ? void 0 : e.mode) === "read" && r.writeOnly)
    return;
  if (r["x-variable"]) {
    const m = (l = e == null ? void 0 : e.variables) == null ? void 0 : l[r["x-variable"]];
    if (m !== void 0)
      return r.type === "number" || r.type === "integer" ? parseInt(m, 10) : m;
  }
  if (Array.isArray(r.examples) && r.examples.length > 0)
    return r.examples[0];
  if (r.example !== void 0)
    return r.example;
  if (r.default !== void 0)
    return r.default;
  if (r.enum !== void 0)
    return r.enum[0];
  if (!(r.type === "object" || r.type === "array") && (e == null ? void 0 : e.omitEmptyAndOptionalProperties) === !0 && !(r.required === !0 || (s == null ? void 0 : s.required) === !0 || ((c = s == null ? void 0 : s.required) == null ? void 0 : c.includes(n ?? r.name))))
    return;
  if (r.type === "object" || r.properties !== void 0) {
    const m = {};
    if (r.properties !== void 0 && Object.keys(r.properties).forEach((g) => {
      var b;
      const p = r.properties[g], y = e != null && e.xml ? (b = p.xml) == null ? void 0 : b.name : void 0;
      m[y ?? g] = at(
        p,
        e,
        t + 1,
        r,
        g
      ), typeof m[y ?? g] > "u" && delete m[y ?? g];
    }), r.anyOf !== void 0 ? Object.assign(
      m,
      at(r.anyOf[0]),
      e,
      t + 1
    ) : r.oneOf !== void 0 ? Object.assign(
      m,
      at(r.oneOf[0]),
      e,
      t + 1
    ) : r.allOf !== void 0 && Object.assign(
      m,
      ...r.allOf.map(
        (g) => at(g, e, t + 1, r)
      ).filter((g) => g !== void 0)
    ), r.additionalProperties !== void 0 && r.additionalProperties !== !1) {
      const g = at(
        r.additionalProperties,
        e,
        t + 1
      );
      if (g && typeof g == "object" && !Array.isArray(g))
        return {
          ...m,
          ...at(
            r.additionalProperties,
            e,
            t + 1
          )
        };
      if (g === null)
        return null;
      const p = at(
        r.additionalProperties,
        {
          ...e,
          // Let’s just add the additionalProperties, even if they are optional.
          omitEmptyAndOptionalProperties: !1
        },
        t + 1
      );
      return {
        ...m,
        ...p === void 0 ? {} : { "{{key}}": p }
      };
    }
    return m;
  }
  if (r.type === "array" || r.items !== void 0) {
    const m = (d = (u = r == null ? void 0 : r.items) == null ? void 0 : u.xml) == null ? void 0 : d.name, g = !!(e != null && e.xml && ((h = r.xml) != null && h.wrapped) && m);
    if (r.example !== void 0)
      return g ? { [m]: r.example } : r.example;
    if (r.items) {
      const p = ["anyOf", "oneOf", "allOf"];
      for (const y of p) {
        if (!r.items[y])
          continue;
        const v = (["anyOf", "oneOf"].includes(y) ? (
          // Use the first item only
          r.items[y].slice(0, 1)
        ) : (
          // Use all items
          r.items[y]
        )).map(
          (k) => at(k, e, t + 1, r)
        ).filter((k) => k !== void 0);
        return g ? [{ [m]: v }] : v;
      }
    }
    if ((f = r.items) != null && f.type) {
      const p = at(
        r.items,
        e,
        t + 1
      );
      return g ? [{ [m]: p }] : [p];
    }
    return [];
  }
  const a = {
    string: o ? MS(r, e == null ? void 0 : e.emptyString) : "",
    boolean: !0,
    integer: r.min ?? 1,
    number: r.min ?? 1,
    array: []
  };
  if (r.type !== void 0 && a[r.type] !== void 0)
    return a[r.type];
  if (Array.isArray(r.oneOf) && r.oneOf.length > 0) {
    const m = r.oneOf[0];
    return at(m, e, t + 1);
  }
  if (Array.isArray(r.allOf)) {
    let m = null;
    return r.allOf.forEach((g) => {
      const p = at(g, e, t + 1);
      m = typeof p == "object" && typeof m == "object" ? {
        ...m ?? {},
        ...p
      } : Array.isArray(p) && Array.isArray(m) ? [...m ?? {}, ...p] : p;
    }), m;
  }
  if (Array.isArray(r.type)) {
    if (r.type.includes("null"))
      return null;
    const m = a[r.type[0]];
    if (m !== void 0)
      return m;
  }
  return console.warn(`[getExampleFromSchema] Unknown property type "${r.type}".`), null;
}, Q0 = (...r) => {
  let e = {
    httpVersion: "1.1",
    method: "GET",
    url: "",
    path: "",
    headers: [],
    headersSize: -1,
    queryString: [],
    cookies: [],
    bodySize: -1
  };
  r.forEach((i) => {
    e = {
      ...e,
      ...i,
      headers: [...e.headers, ...i.headers ?? []],
      queryString: [
        ...e.queryString,
        ...i.queryString ?? []
      ],
      cookies: [...e.cookies, ...i.cookies ?? []]
    };
  });
  const t = e.headers.reduce(
    (i, { name: a, value: l }) => (i[a] = l, i),
    {}
  ), s = fk.from(t).normalize(!0);
  e.headers = Object.entries(s).map(
    ([i, a]) => ({ name: i, value: a })
  );
  const { path: n, ...o } = e;
  return n ? {
    ...o,
    url: `${e.url}${n}`
  } : o;
};
function ro(r, e, t = !0) {
  var o;
  return [
    ...r.pathParameters || [],
    ...((o = r.information) == null ? void 0 : o.parameters) || []
  ].filter((i) => i.in === e).filter(
    (i) => t && i.required || !t
  ).map((i) => ({
    name: i.name,
    description: i.description ?? null,
    value: i.example ? i.example : i.schema ? at(i.schema, { mode: "write" }) : "",
    required: i.required ?? !1,
    enabled: i.required ?? !1
  })).sort((i, a) => i.required && !a.required ? -1 : !i.required && a.required ? 1 : 0);
}
function DS(r, e) {
  const t = function(n, o, i) {
    let a = "";
    if (n instanceof Array)
      for (let l = 0, c = n.length; l < c; l++)
        a += i + t(n[l], o, i + "	") + `
`;
    else if (typeof n == "object") {
      let l = !1;
      a += i + "<" + o;
      for (const c in n)
        c.charAt(0) == "@" ? a += " " + c.substr(1) + '="' + n[c].toString() + '"' : l = !0;
      if (a += l ? ">" : "/>", l) {
        for (const c in n)
          c == "#text" ? a += n[c] : c == "#cdata" ? a += "<![CDATA[" + n[c] + "]]>" : c.charAt(0) != "@" && (a += t(n[c], c, i + "	"));
        a += (a.charAt(a.length - 1) == `
` ? i : "") + "</" + o + ">";
      }
    } else
      a += i + "<" + o + ">" + n.toString() + "</" + o + ">";
    return a;
  };
  let s = "";
  for (const n in r)
    s += t(r[n], n, "");
  return e ? s.replace(/\t/g, e) : s.replace(/\t|\n/g, "");
}
function RS(r) {
  if (typeof r == "string")
    return r.replace(/;.*$/, "").replace(/\/.+\+/, "/").trim();
}
function Z0(r) {
  if (!r)
    return r;
  const e = {
    ...r
  };
  return Object.keys(e).forEach((t) => {
    const s = RS(t);
    s !== void 0 && (e[s] = e[t], t !== s && delete e[t]);
  }), e;
}
const qi = (r) => {
  try {
    return JSON.stringify(typeof r == "string" ? JSON.parse(r) : r, null, 2);
  } catch {
    return console.log("[prettyPrintJson] Error parsing JSON", r), r;
  }
};
function jS(r, e) {
  var f, m, g, p;
  const t = [
    "application/json",
    "application/octet-stream",
    "application/x-www-form-urlencoded",
    "application/xml",
    "multipart/form-data",
    "text/plain"
  ], s = (m = (f = r.information) == null ? void 0 : f.requestBody) == null ? void 0 : m.content, n = Z0(s), o = t.find(
    (y) => !!(n != null && n[y])
  ), i = (g = n == null ? void 0 : n["application/json"]) == null ? void 0 : g.examples, a = (p = i ?? {}) == null ? void 0 : p[e ?? Object.keys(i ?? {})[0]];
  if (a)
    return {
      postData: {
        mimeType: "application/json",
        text: qi(a == null ? void 0 : a.value)
      }
    };
  const l = ro(r, "body", !1);
  if (l.length > 0)
    return {
      postData: {
        mimeType: "application/json",
        text: qi(l[0].value)
      }
    };
  const c = ro(
    r,
    "formData",
    !1
  );
  if (c.length > 0)
    return {
      postData: {
        mimeType: "application/x-www-form-urlencoded",
        params: c.map((y) => ({
          name: y.name,
          value: y.value
        }))
      }
    };
  if (!o)
    return {
      postData: void 0
    };
  const u = n == null ? void 0 : n[o], d = [
    {
      name: "Content-Type",
      value: o
    }
  ], h = u != null && u.example ? u == null ? void 0 : u.example : void 0;
  if (o === "application/json") {
    const y = u != null && u.schema ? at(u == null ? void 0 : u.schema, {
      mode: "write",
      omitEmptyAndOptionalProperties: !0
    }) : null, b = h ?? y;
    return {
      headers: d,
      postData: {
        mimeType: o,
        text: typeof b == "string" ? b : JSON.stringify(b, null, 2)
      }
    };
  }
  if (o === "application/xml") {
    const y = u != null && u.schema ? at(u == null ? void 0 : u.schema, {
      xml: !0,
      mode: "write",
      omitEmptyAndOptionalProperties: !0
    }) : null;
    return {
      headers: d,
      postData: {
        mimeType: o,
        text: h ?? DS(y, "  ")
      }
    };
  }
  if (o === "application/octet-stream")
    return {
      headers: d,
      postData: {
        mimeType: o,
        text: "BINARY"
      }
    };
  if (o === "text/plain") {
    const y = u != null && u.schema ? at(u == null ? void 0 : u.schema, {
      xml: !0,
      mode: "write",
      omitEmptyAndOptionalProperties: !0
    }) : null;
    return {
      headers: d,
      postData: {
        mimeType: o,
        text: h ?? y ?? ""
      }
    };
  }
  if (o === "application/x-www-form-urlencoded")
    return {
      headers: d,
      postData: {
        mimeType: o
        // TODO: We have an object, but how do we get that kind of array from the object?
        // Don’t forget to include nested properties … :|
        // params: [
        //   {
        //     name: 'foo',
        //     value: 'bar',
        //   },
        // ],
      }
    };
  if (o === "multipart/form-data")
    return {
      headers: d,
      postData: {
        mimeType: o
        // TODO: We have an object, but how do we get that kind of array from the object?
        // Don’t forget to include nested properties … :|
        // params: [
        //   {
        //     name: 'foo',
        //     value: 'bar',
        //   },
        // ],
      }
    };
}
const ad = (r, e, t) => {
  let s = r.path;
  if ((e == null ? void 0 : e.replaceVariables) === !0) {
    const o = s.match(/{(.*?)}/g);
    o && o.forEach((i) => {
      const a = i.replace(/{|}/g, "");
      s = s.replace(i, `__${a.toUpperCase()}__`);
    });
  }
  const n = jS(r, t);
  return {
    method: r.httpVerb.toUpperCase(),
    path: s,
    headers: [
      ...ro(r, "header", e == null ? void 0 : e.requiredOnly),
      ...(n == null ? void 0 : n.headers) ?? []
    ],
    // TODO: Sorry, something is off here and I don’t get it.
    // @ts-ignore
    postData: n == null ? void 0 : n.postData,
    queryString: ro(
      r,
      "query",
      e == null ? void 0 : e.requiredOnly
    ),
    cookies: ro(
      r,
      "cookie",
      e == null ? void 0 : e.requiredOnly
    )
  };
}, LS = () => ({
  preferredSecurityScheme: null,
  // In case the spec has no security and the user would like to add some
  customSecurity: !1,
  http: {
    basic: {
      username: "",
      password: ""
    },
    bearer: {
      token: ""
    }
  },
  apiKey: {
    token: ""
  },
  oAuth2: {
    username: "",
    password: "",
    clientId: "",
    scopes: [],
    accessToken: "",
    state: ""
  }
}), ey = $r(
  Eo["useGlobalStore-authentication"] ?? LS()
), BS = (r) => Object.assign(ey, r), ha = () => ({
  authentication: ey,
  setAuthentication: BS
}), FS = () => ({
  // @ts-ignore
  operation: {},
  globalSecurity: []
}), Hi = $r(FS()), VS = (r) => {
  Object.assign(Hi, {
    ...Hi,
    operation: r
  });
}, US = (r) => {
  Object.assign(Hi, {
    ...Hi,
    globalSecurity: r
  });
}, ty = () => ({
  openApi: Hi,
  setOperation: VS,
  setGlobalSecurity: US
}), zS = () => ({
  name: "",
  url: "",
  type: "GET",
  path: "",
  variables: [],
  headers: [],
  query: [],
  body: "",
  formData: []
}), Sc = $r({}), ry = ie([]), po = ie(""), Uh = $r(zS()), qS = (r) => {
  Sc[r.responseId] = r, po.value = r.responseId, ry.value.unshift(r.responseId);
}, HS = (r) => {
  po.value = r;
  const { request: e } = Sc[r], t = JSON.parse(JSON.stringify(e));
  t.body = JSON.stringify(e.body, null, 2), Object.assign(Uh, t);
}, KS = oe(
  () => po.value ? Sc[po.value].response : null
), WS = (r) => {
  Object.assign(Uh, r);
}, GS = () => {
  po.value = "";
}, JS = ie(!0), YS = () => ({
  readOnly: JS,
  activeRequest: Uh,
  activeResponse: KS,
  requestHistory: Sc,
  requestHistoryOrder: ry,
  activeRequestId: po,
  setActiveResponse: HS,
  resetActiveResponse: GS,
  addRequestToHistory: qS,
  setActiveRequest: WS
}), XS = () => ({
  selectedServer: null,
  servers: [],
  variables: []
}), ld = $r(XS()), QS = (r) => {
  Object.assign(ld, {
    ...ld,
    ...r
  });
}, To = () => ({
  server: ld,
  setServer: QS
}), sy = [
  "GET",
  "POST",
  "PUT",
  "HEAD",
  "DELETE",
  "PATCH",
  "OPTIONS",
  "CONNECT",
  "TRACE"
];
function Qp(r) {
  return sy.includes(r);
}
const ZS = {
  POST: "var(--scalar-color-green)",
  DELETE: "var(--scalar-color-red)",
  PATCH: "var(--scalar-color-yellow)",
  GET: "var(--scalar-color-blue)",
  PUT: "var(--scalar-color-orange)",
  OPTIONS: "var(--scalar-color-purple)",
  HEAD: "var(--scalar-color-2)",
  CONNECT: "var(--scalar-color-2)",
  TRACE: "var(--scalar-color-2)"
}, e2 = {
  POST: "POST",
  DELETE: "DEL",
  PATCH: "PATCH",
  GET: "GET",
  PUT: "PUT",
  OPTIONS: "OPTS",
  HEAD: "HEAD",
  CONNECT: "CONN",
  TRACE: "TRACE"
}, Po = /* @__PURE__ */ Q({
  __name: "HttpMethod",
  props: {
    as: {},
    property: {},
    short: { type: Boolean },
    method: {}
  },
  setup(r) {
    const e = r, t = oe(() => e.method.trim().toUpperCase()), s = oe(() => Qp(t.value) ? e2[t.value] : t.value.slice(0, 4)), n = oe(() => Qp(t.value) ? ZS[t.value] : "var(--scalar-color-ghost)");
    return (o, i) => (S(), U(br(o.as ?? "span"), {
      style: os({ [o.property || "color"]: n.value })
    }, {
      default: P(() => [
        te(o.$slots, "default", cr(ur({ normalized: t.value, abbreviated: s.value, color: n.value })), () => [
          J(ee(o.short ? s.value : t.value), 1)
        ])
      ]),
      _: 3
    }, 8, ["style"]));
  }
});
class je {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, s) {
    [e, t] = mo(this, e, t);
    let n = [];
    return this.decompose(
      0,
      e,
      n,
      2
      /* Open.To */
    ), s.length && s.decompose(
      0,
      s.length,
      n,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      n,
      1
      /* Open.From */
    ), Dr.from(n, this.length - (t - e) + s.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = mo(this, e, t);
    let s = [];
    return this.decompose(e, t, s, 0), Dr.from(s, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), s = this.length - this.scanIdentical(e, -1), n = new Pi(this), o = new Pi(e);
    for (let i = t, a = t; ; ) {
      if (n.next(i), o.next(i), i = 0, n.lineBreak != o.lineBreak || n.done != o.done || n.value != o.value)
        return !1;
      if (a += n.value.length, n.done || a >= s)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Pi(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new ny(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let s;
    if (e == null)
      s = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let n = this.line(e).from;
      s = this.iterRange(n, Math.max(n, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new oy(s);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? je.empty : e.length <= 32 ? new rt(e) : Dr.from(rt.split(e, []));
  }
}
class rt extends je {
  constructor(e, t = t2(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, s, n) {
    for (let o = 0; ; o++) {
      let i = this.text[o], a = n + i.length;
      if ((t ? s : a) >= e)
        return new r2(n, a, s, i);
      n = a + 1, s++;
    }
  }
  decompose(e, t, s, n) {
    let o = e <= 0 && t >= this.length ? this : new rt(Zp(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (n & 1) {
      let i = s.pop(), a = Sl(o.text, i.text.slice(), 0, o.length);
      if (a.length <= 32)
        s.push(new rt(a, i.length + o.length));
      else {
        let l = a.length >> 1;
        s.push(new rt(a.slice(0, l)), new rt(a.slice(l)));
      }
    } else
      s.push(o);
  }
  replace(e, t, s) {
    if (!(s instanceof rt))
      return super.replace(e, t, s);
    [e, t] = mo(this, e, t);
    let n = Sl(this.text, Sl(s.text, Zp(this.text, 0, e)), t), o = this.length + s.length - (t - e);
    return n.length <= 32 ? new rt(n, o) : Dr.from(rt.split(n, []), o);
  }
  sliceString(e, t = this.length, s = `
`) {
    [e, t] = mo(this, e, t);
    let n = "";
    for (let o = 0, i = 0; o <= t && i < this.text.length; i++) {
      let a = this.text[i], l = o + a.length;
      o > e && i && (n += s), e < l && t > o && (n += a.slice(Math.max(0, e - o), t - o)), o = l + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let s = [], n = -1;
    for (let o of e)
      s.push(o), n += o.length + 1, s.length == 32 && (t.push(new rt(s, n)), s = [], n = -1);
    return n > -1 && t.push(new rt(s, n)), t;
  }
}
class Dr extends je {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let s of e)
      this.lines += s.lines;
  }
  lineInner(e, t, s, n) {
    for (let o = 0; ; o++) {
      let i = this.children[o], a = n + i.length, l = s + i.lines - 1;
      if ((t ? l : a) >= e)
        return i.lineInner(e, t, s, n);
      n = a + 1, s = l + 1;
    }
  }
  decompose(e, t, s, n) {
    for (let o = 0, i = 0; i <= t && o < this.children.length; o++) {
      let a = this.children[o], l = i + a.length;
      if (e <= l && t >= i) {
        let c = n & ((i <= e ? 1 : 0) | (l >= t ? 2 : 0));
        i >= e && l <= t && !c ? s.push(a) : a.decompose(e - i, t - i, s, c);
      }
      i = l + 1;
    }
  }
  replace(e, t, s) {
    if ([e, t] = mo(this, e, t), s.lines < this.lines)
      for (let n = 0, o = 0; n < this.children.length; n++) {
        let i = this.children[n], a = o + i.length;
        if (e >= o && t <= a) {
          let l = i.replace(e - o, t - o, s), c = this.lines - i.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let u = this.children.slice();
            return u[n] = l, new Dr(u, this.length - (t - e) + s.length);
          }
          return super.replace(o, a, l);
        }
        o = a + 1;
      }
    return super.replace(e, t, s);
  }
  sliceString(e, t = this.length, s = `
`) {
    [e, t] = mo(this, e, t);
    let n = "";
    for (let o = 0, i = 0; o < this.children.length && i <= t; o++) {
      let a = this.children[o], l = i + a.length;
      i > e && o && (n += s), e < l && t > i && (n += a.sliceString(e - i, t - i, s)), i = l + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Dr))
      return 0;
    let s = 0, [n, o, i, a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; n += t, o += t) {
      if (n == i || o == a)
        return s;
      let l = this.children[n], c = e.children[o];
      if (l != c)
        return s + l.scanIdentical(c, t);
      s += l.length + 1;
    }
  }
  static from(e, t = e.reduce((s, n) => s + n.length + 1, -1)) {
    let s = 0;
    for (let f of e)
      s += f.lines;
    if (s < 32) {
      let f = [];
      for (let m of e)
        m.flatten(f);
      return new rt(f, t);
    }
    let n = Math.max(
      32,
      s >> 5
      /* Tree.BranchShift */
    ), o = n << 1, i = n >> 1, a = [], l = 0, c = -1, u = [];
    function d(f) {
      let m;
      if (f.lines > o && f instanceof Dr)
        for (let g of f.children)
          d(g);
      else
        f.lines > i && (l > i || !l) ? (h(), a.push(f)) : f instanceof rt && l && (m = u[u.length - 1]) instanceof rt && f.lines + m.lines <= 32 ? (l += f.lines, c += f.length + 1, u[u.length - 1] = new rt(m.text.concat(f.text), m.length + 1 + f.length)) : (l + f.lines > n && h(), l += f.lines, c += f.length + 1, u.push(f));
    }
    function h() {
      l != 0 && (a.push(u.length == 1 ? u[0] : Dr.from(u, c)), c = -1, l = u.length = 0);
    }
    for (let f of e)
      d(f);
    return h(), a.length == 1 ? a[0] : new Dr(a, t);
  }
}
je.empty = /* @__PURE__ */ new rt([""], 0);
function t2(r) {
  let e = -1;
  for (let t of r)
    e += t.length + 1;
  return e;
}
function Sl(r, e, t = 0, s = 1e9) {
  for (let n = 0, o = 0, i = !0; o < r.length && n <= s; o++) {
    let a = r[o], l = n + a.length;
    l >= t && (l > s && (a = a.slice(0, s - n)), n < t && (a = a.slice(t - n)), i ? (e[e.length - 1] += a, i = !1) : e.push(a)), n = l + 1;
  }
  return e;
}
function Zp(r, e, t) {
  return Sl(r, [""], e, t);
}
class Pi {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof rt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let s = this.nodes.length - 1, n = this.nodes[s], o = this.offsets[s], i = o >> 1, a = n instanceof rt ? n.text.length : n.children.length;
      if (i == (t > 0 ? a : 0)) {
        if (s == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[s - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[s] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (n instanceof rt) {
        let l = n.text[i + (t < 0 ? -1 : 0)];
        if (this.offsets[s] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = n.children[i + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[s] += t) : (t < 0 && this.offsets[s]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof rt ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class ny {
  constructor(e, t, s) {
    this.value = "", this.done = !1, this.cursor = new Pi(e, t > s ? -1 : 1), this.pos = t > s ? e.length : 0, this.from = Math.min(t, s), this.to = Math.max(t, s);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let s = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > s && (e = s), s -= e;
    let { value: n } = this.cursor.next(e);
    return this.pos += (n.length + e) * t, this.value = n.length <= s ? n : t < 0 ? n.slice(n.length - s) : n.slice(0, s), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class oy {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: s, value: n } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : s ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = n, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (je.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Pi.prototype[Symbol.iterator] = ny.prototype[Symbol.iterator] = oy.prototype[Symbol.iterator] = function() {
  return this;
});
class r2 {
  /**
  @internal
  */
  constructor(e, t, s, n) {
    this.from = e, this.to = t, this.number = s, this.text = n;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function mo(r, e, t) {
  return e = Math.max(0, Math.min(r.length, e)), [e, Math.max(e, Math.min(r.length, t))];
}
let so = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((r) => r ? parseInt(r, 36) : 1);
for (let r = 1; r < so.length; r++)
  so[r] += so[r - 1];
function s2(r) {
  for (let e = 1; e < so.length; e += 2)
    if (so[e] > r)
      return so[e - 1] <= r;
  return !1;
}
function em(r) {
  return r >= 127462 && r <= 127487;
}
const tm = 8205;
function Lr(r, e, t = !0, s = !0) {
  return (t ? iy : n2)(r, e, s);
}
function iy(r, e, t) {
  if (e == r.length)
    return e;
  e && ay(r.charCodeAt(e)) && ly(r.charCodeAt(e - 1)) && e--;
  let s = Ii(r, e);
  for (e += cd(s); e < r.length; ) {
    let n = Ii(r, e);
    if (s == tm || n == tm || t && s2(n))
      e += cd(n), s = n;
    else if (em(n)) {
      let o = 0, i = e - 2;
      for (; i >= 0 && em(Ii(r, i)); )
        o++, i -= 2;
      if (o % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function n2(r, e, t) {
  for (; e > 0; ) {
    let s = iy(r, e - 2, t);
    if (s < e)
      return s;
    e--;
  }
  return 0;
}
function ay(r) {
  return r >= 56320 && r < 57344;
}
function ly(r) {
  return r >= 55296 && r < 56320;
}
function Ii(r, e) {
  let t = r.charCodeAt(e);
  if (!ly(t) || e + 1 == r.length)
    return t;
  let s = r.charCodeAt(e + 1);
  return ay(s) ? (t - 55296 << 10) + (s - 56320) + 65536 : t;
}
function gF(r) {
  return r <= 65535 ? String.fromCharCode(r) : (r -= 65536, String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320));
}
function cd(r) {
  return r < 65536 ? 1 : 2;
}
const ud = /\r\n?|\n/;
var zt = /* @__PURE__ */ function(r) {
  return r[r.Simple = 0] = "Simple", r[r.TrackDel = 1] = "TrackDel", r[r.TrackBefore = 2] = "TrackBefore", r[r.TrackAfter = 3] = "TrackAfter", r;
}(zt || (zt = {}));
class ts {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let s = this.sections[t + 1];
      e += s < 0 ? this.sections[t] : s;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, s = 0, n = 0; t < this.sections.length; ) {
      let o = this.sections[t++], i = this.sections[t++];
      i < 0 ? (e(s, n, o), n += o) : n += i, s += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    dd(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let s = this.sections[t++], n = this.sections[t++];
      n < 0 ? e.push(s, n) : e.push(n, s);
    }
    return new ts(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : cy(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : hd(this, e, t);
  }
  mapPos(e, t = -1, s = zt.Simple) {
    let n = 0, o = 0;
    for (let i = 0; i < this.sections.length; ) {
      let a = this.sections[i++], l = this.sections[i++], c = n + a;
      if (l < 0) {
        if (c > e)
          return o + (e - n);
        o += a;
      } else {
        if (s != zt.Simple && c >= e && (s == zt.TrackDel && n < e && c > e || s == zt.TrackBefore && n < e || s == zt.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !a)
          return e == n || t < 0 ? o : o + l;
        o += l;
      }
      n = c;
    }
    if (e > n)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let s = 0, n = 0; s < this.sections.length && n <= t; ) {
      let o = this.sections[s++], i = this.sections[s++], a = n + o;
      if (i >= 0 && n <= t && a >= e)
        return n < e && a > t ? "cover" : !0;
      n = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let s = this.sections[t++], n = this.sections[t++];
      e += (e ? " " : "") + s + (n >= 0 ? ":" + n : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ts(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new ts(e);
  }
}
class ft extends ts {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return dd(this, (t, s, n, o, i) => e = e.replace(n, n + (s - t), i), !1), e;
  }
  mapDesc(e, t = !1) {
    return hd(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), s = [];
    for (let n = 0, o = 0; n < t.length; n += 2) {
      let i = t[n], a = t[n + 1];
      if (a >= 0) {
        t[n] = a, t[n + 1] = i;
        let l = n >> 1;
        for (; s.length < l; )
          s.push(je.empty);
        s.push(i ? e.slice(o, o + i) : je.empty);
      }
      o += i;
    }
    return new ft(t, s);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : cy(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : hd(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    dd(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ts.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], s = [], n = [], o = new Ki(this);
    e:
      for (let i = 0, a = 0; ; ) {
        let l = i == e.length ? 1e9 : e[i++];
        for (; a < l || a == l && o.len == 0; ) {
          if (o.done)
            break e;
          let u = Math.min(o.len, l - a);
          kt(n, u, -1);
          let d = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
          kt(t, u, d), d > 0 && Os(s, t, o.text), o.forward(u), a += u;
        }
        let c = e[i++];
        for (; a < c; ) {
          if (o.done)
            break e;
          let u = Math.min(o.len, c - a);
          kt(t, u, -1), kt(n, u, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(u), a += u;
        }
      }
    return {
      changes: new ft(t, s),
      filtered: ts.create(n)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let s = this.sections[t], n = this.sections[t + 1];
      n < 0 ? e.push(s) : n == 0 ? e.push([s]) : e.push([s].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, s) {
    let n = [], o = [], i = 0, a = null;
    function l(u = !1) {
      if (!u && !n.length)
        return;
      i < t && kt(n, t - i, -1);
      let d = new ft(n, o);
      a = a ? a.compose(d.map(a)) : d, n = [], o = [], i = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let d of u)
          c(d);
      else if (u instanceof ft) {
        if (u.length != t)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${t})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: d, to: h = d, insert: f } = u;
        if (d > h || d < 0 || h > t)
          throw new RangeError(`Invalid change range ${d} to ${h} (in doc of length ${t})`);
        let m = f ? typeof f == "string" ? je.of(f.split(s || ud)) : f : je.empty, g = m.length;
        if (d == h && g == 0)
          return;
        d < i && l(), d > i && kt(n, d - i, -1), kt(n, h - d, g), Os(o, n, m), i = h;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new ft(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], s = [];
    for (let n = 0; n < e.length; n++) {
      let o = e[n];
      if (typeof o == "number")
        t.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((i, a) => a && typeof i != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          t.push(o[0], 0);
        else {
          for (; s.length < n; )
            s.push(je.empty);
          s[n] = je.of(o.slice(1)), t.push(o[0], s[n].length);
        }
      }
    }
    return new ft(t, s);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new ft(e, t);
  }
}
function kt(r, e, t, s = !1) {
  if (e == 0 && t <= 0)
    return;
  let n = r.length - 2;
  n >= 0 && t <= 0 && t == r[n + 1] ? r[n] += e : e == 0 && r[n] == 0 ? r[n + 1] += t : s ? (r[n] += e, r[n + 1] += t) : r.push(e, t);
}
function Os(r, e, t) {
  if (t.length == 0)
    return;
  let s = e.length - 2 >> 1;
  if (s < r.length)
    r[r.length - 1] = r[r.length - 1].append(t);
  else {
    for (; r.length < s; )
      r.push(je.empty);
    r.push(t);
  }
}
function dd(r, e, t) {
  let s = r.inserted;
  for (let n = 0, o = 0, i = 0; i < r.sections.length; ) {
    let a = r.sections[i++], l = r.sections[i++];
    if (l < 0)
      n += a, o += a;
    else {
      let c = n, u = o, d = je.empty;
      for (; c += a, u += l, l && s && (d = d.append(s[i - 2 >> 1])), !(t || i == r.sections.length || r.sections[i + 1] < 0); )
        a = r.sections[i++], l = r.sections[i++];
      e(n, c, o, u, d), n = c, o = u;
    }
  }
}
function hd(r, e, t, s = !1) {
  let n = [], o = s ? [] : null, i = new Ki(r), a = new Ki(e);
  for (let l = -1; ; )
    if (i.ins == -1 && a.ins == -1) {
      let c = Math.min(i.len, a.len);
      kt(n, c, -1), i.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (i.ins < 0 || l == i.i || i.off == 0 && (a.len < i.len || a.len == i.len && !t))) {
      let c = a.len;
      for (kt(n, a.ins, -1); c; ) {
        let u = Math.min(i.len, c);
        i.ins >= 0 && l < i.i && i.len <= u && (kt(n, 0, i.ins), o && Os(o, n, i.text), l = i.i), i.forward(u), c -= u;
      }
      a.next();
    } else if (i.ins >= 0) {
      let c = 0, u = i.len;
      for (; u; )
        if (a.ins == -1) {
          let d = Math.min(u, a.len);
          c += d, u -= d, a.forward(d);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      kt(n, c, l < i.i ? i.ins : 0), o && l < i.i && Os(o, n, i.text), l = i.i, i.forward(i.len - u);
    } else {
      if (i.done && a.done)
        return o ? ft.createSet(n, o) : ts.create(n);
      throw new Error("Mismatched change set lengths");
    }
}
function cy(r, e, t = !1) {
  let s = [], n = t ? [] : null, o = new Ki(r), i = new Ki(e);
  for (let a = !1; ; ) {
    if (o.done && i.done)
      return n ? ft.createSet(s, n) : ts.create(s);
    if (o.ins == 0)
      kt(s, o.len, 0, a), o.next();
    else if (i.len == 0 && !i.done)
      kt(s, 0, i.ins, a), n && Os(n, s, i.text), i.next();
    else {
      if (o.done || i.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(o.len2, i.len), c = s.length;
        if (o.ins == -1) {
          let u = i.ins == -1 ? -1 : i.off ? 0 : i.ins;
          kt(s, l, u, a), n && u && Os(n, s, i.text);
        } else
          i.ins == -1 ? (kt(s, o.off ? 0 : o.len, l, a), n && Os(n, s, o.textBit(l))) : (kt(s, o.off ? 0 : o.len, i.off ? 0 : i.ins, a), n && !i.off && Os(n, s, i.text));
        a = (o.ins > l || i.ins >= 0 && i.len > l) && (a || s.length > c), o.forward2(l), i.forward(l);
      }
    }
  }
}
class Ki {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? je.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, s = this.i - 2 >> 1;
    return s >= t.length && !e ? je.empty : t[s].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class an {
  constructor(e, t, s) {
    this.from = e, this.to = t, this.flags = s;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let s, n;
    return this.empty ? s = n = e.mapPos(this.from, t) : (s = e.mapPos(this.from, 1), n = e.mapPos(this.to, -1)), s == this.from && n == this.to ? this : new an(s, n, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return de.range(e, t);
    let s = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return de.range(this.anchor, s);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return de.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, s) {
    return new an(e, t, s);
  }
}
class de {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : de.create(this.ranges.map((s) => s.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let s = 0; s < this.ranges.length; s++)
      if (!this.ranges[s].eq(e.ranges[s], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new de([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return de.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let s = this.ranges.slice();
    return s[t] = e, de.create(s, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new de(e.ranges.map((t) => an.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new de([de.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let s = 0, n = 0; n < e.length; n++) {
      let o = e[n];
      if (o.empty ? o.from <= s : o.from < s)
        return de.normalized(e.slice(), t);
      s = o.to;
    }
    return new de(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, s, n) {
    return an.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (s == null ? 7 : Math.min(6, s)) | (n ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, s, n) {
    let o = (s ?? 16777215) << 6 | (n == null ? 7 : Math.min(6, n));
    return t < e ? an.create(t, e, 48 | o) : an.create(e, t, (t > e ? 8 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let s = e[t];
    e.sort((n, o) => n.from - o.from), t = e.indexOf(s);
    for (let n = 1; n < e.length; n++) {
      let o = e[n], i = e[n - 1];
      if (o.empty ? o.from <= i.to : o.from < i.to) {
        let a = i.from, l = Math.max(o.to, i.to);
        n <= t && t--, e.splice(--n, 2, o.anchor > o.head ? de.range(l, a) : de.range(a, l));
      }
    }
    return new de(e, t);
  }
}
function uy(r, e) {
  for (let t of r.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let zh = 0;
class pe {
  constructor(e, t, s, n, o) {
    this.combine = e, this.compareInput = t, this.compare = s, this.isStatic = n, this.id = zh++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new pe(e.combine || ((t) => t), e.compareInput || ((t, s) => t === s), e.compare || (e.combine ? (t, s) => t === s : qh), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new $l([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new $l(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new $l(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (s) => s), this.compute([e], (s) => t(s.field(e)));
  }
}
function qh(r, e) {
  return r == e || r.length == e.length && r.every((t, s) => t === e[s]);
}
class $l {
  constructor(e, t, s, n) {
    this.dependencies = e, this.facet = t, this.type = s, this.value = n, this.id = zh++;
  }
  dynamicSlot(e) {
    var t;
    let s = this.value, n = this.facet.compareInput, o = this.id, i = e[o] >> 1, a = this.type == 2, l = !1, c = !1, u = [];
    for (let d of this.dependencies)
      d == "doc" ? l = !0 : d == "selection" ? c = !0 : ((t = e[d.id]) !== null && t !== void 0 ? t : 1) & 1 || u.push(e[d.id]);
    return {
      create(d) {
        return d.values[i] = s(d), 1;
      },
      update(d, h) {
        if (l && h.docChanged || c && (h.docChanged || h.selection) || fd(d, u)) {
          let f = s(d);
          if (a ? !rm(f, d.values[i], n) : !n(f, d.values[i]))
            return d.values[i] = f, 1;
        }
        return 0;
      },
      reconfigure: (d, h) => {
        let f, m = h.config.address[o];
        if (m != null) {
          let g = zl(h, m);
          if (this.dependencies.every((p) => p instanceof pe ? h.facet(p) === d.facet(p) : p instanceof zs ? h.field(p, !1) == d.field(p, !1) : !0) || (a ? rm(f = s(d), g, n) : n(f = s(d), g)))
            return d.values[i] = g, 0;
        } else
          f = s(d);
        return d.values[i] = f, 1;
      }
    };
  }
}
function rm(r, e, t) {
  if (r.length != e.length)
    return !1;
  for (let s = 0; s < r.length; s++)
    if (!t(r[s], e[s]))
      return !1;
  return !0;
}
function fd(r, e) {
  let t = !1;
  for (let s of e)
    Ni(r, s) & 1 && (t = !0);
  return t;
}
function o2(r, e, t) {
  let s = t.map((l) => r[l.id]), n = t.map((l) => l.type), o = s.filter((l) => !(l & 1)), i = r[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < s.length; u++) {
      let d = zl(l, s[u]);
      if (n[u] == 2)
        for (let h of d)
          c.push(h);
      else
        c.push(d);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of s)
        Ni(l, c);
      return l.values[i] = a(l), 1;
    },
    update(l, c) {
      if (!fd(l, o))
        return 0;
      let u = a(l);
      return e.compare(u, l.values[i]) ? 0 : (l.values[i] = u, 1);
    },
    reconfigure(l, c) {
      let u = fd(l, s), d = c.config.facets[e.id], h = c.facet(e);
      if (d && !u && qh(t, d))
        return l.values[i] = h, 0;
      let f = a(l);
      return e.compare(f, h) ? (l.values[i] = h, 0) : (l.values[i] = f, 1);
    }
  };
}
const sm = /* @__PURE__ */ pe.define({ static: !0 });
class zs {
  constructor(e, t, s, n, o) {
    this.id = e, this.createF = t, this.updateF = s, this.compareF = n, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new zs(zh++, e.create, e.update, e.compare || ((s, n) => s === n), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(sm).find((s) => s.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (s) => (s.values[t] = this.create(s), 1),
      update: (s, n) => {
        let o = s.values[t], i = this.updateF(o, n);
        return this.compareF(o, i) ? 0 : (s.values[t] = i, 1);
      },
      reconfigure: (s, n) => n.config.address[this.id] != null ? (s.values[t] = n.field(this), 0) : (s.values[t] = this.create(s), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, sm.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const en = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ai(r) {
  return (e) => new dy(e, r);
}
const Hh = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ ai(en.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ ai(en.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ ai(en.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ ai(en.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ ai(en.lowest)
};
class dy {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class $c {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new pd(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return $c.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class pd {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Ul {
  constructor(e, t, s, n, o, i) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = s, this.address = n, this.staticValues = o, this.facets = i, this.statusTemplate = []; this.statusTemplate.length < s.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, s) {
    let n = [], o = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ new Map();
    for (let h of i2(e, t, i))
      h instanceof zs ? n.push(h) : (o[h.facet.id] || (o[h.facet.id] = [])).push(h);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let h of n)
      a[h.id] = c.length << 1, c.push((f) => h.slot(f));
    let u = s == null ? void 0 : s.config.facets;
    for (let h in o) {
      let f = o[h], m = f[0].facet, g = u && u[h] || [];
      if (f.every(
        (p) => p.type == 0
        /* Provider.Static */
      ))
        if (a[m.id] = l.length << 1 | 1, qh(g, f))
          l.push(s.facet(m));
        else {
          let p = m.combine(f.map((y) => y.value));
          l.push(s && m.compare(p, s.facet(m)) ? s.facet(m) : p);
        }
      else {
        for (let p of f)
          p.type == 0 ? (a[p.id] = l.length << 1 | 1, l.push(p.value)) : (a[p.id] = c.length << 1, c.push((y) => p.dynamicSlot(y)));
        a[m.id] = c.length << 1, c.push((p) => o2(p, m, f));
      }
    }
    let d = c.map((h) => h(a));
    return new Ul(e, i, d, a, l, o);
  }
}
function i2(r, e, t) {
  let s = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function o(i, a) {
    let l = n.get(i);
    if (l != null) {
      if (l <= a)
        return;
      let c = s[l].indexOf(i);
      c > -1 && s[l].splice(c, 1), i instanceof pd && t.delete(i.compartment);
    }
    if (n.set(i, a), Array.isArray(i))
      for (let c of i)
        o(c, a);
    else if (i instanceof pd) {
      if (t.has(i.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(i.compartment) || i.inner;
      t.set(i.compartment, c), o(c, a);
    } else if (i instanceof dy)
      o(i.inner, i.prec);
    else if (i instanceof zs)
      s[a].push(i), i.provides && o(i.provides, a);
    else if (i instanceof $l)
      s[a].push(i), i.facet.extensions && o(i.facet.extensions, en.default);
    else {
      let c = i.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${i}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(c, a);
    }
  }
  return o(r, en.default), s.reduce((i, a) => i.concat(a));
}
function Ni(r, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, s = r.status[t];
  if (s == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (s & 2)
    return s;
  r.status[t] = 4;
  let n = r.computeSlot(r, r.config.dynamicSlots[t]);
  return r.status[t] = 2 | n;
}
function zl(r, e) {
  return e & 1 ? r.config.staticValues[e >> 1] : r.values[e >> 1];
}
const hy = /* @__PURE__ */ pe.define(), md = /* @__PURE__ */ pe.define({
  combine: (r) => r.some((e) => e),
  static: !0
}), fy = /* @__PURE__ */ pe.define({
  combine: (r) => r.length ? r[0] : void 0,
  static: !0
}), py = /* @__PURE__ */ pe.define(), my = /* @__PURE__ */ pe.define(), gy = /* @__PURE__ */ pe.define(), yy = /* @__PURE__ */ pe.define({
  combine: (r) => r.length ? r[0] : !1
});
class Io {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new a2();
  }
}
class a2 {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Io(this, e);
  }
}
class l2 {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new pt(this, e);
  }
}
class pt {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new pt(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new l2(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let s = [];
    for (let n of e) {
      let o = n.map(t);
      o && s.push(o);
    }
    return s;
  }
}
pt.reconfigure = /* @__PURE__ */ pt.define();
pt.appendConfig = /* @__PURE__ */ pt.define();
class $t {
  constructor(e, t, s, n, o, i) {
    this.startState = e, this.changes = t, this.selection = s, this.effects = n, this.annotations = o, this.scrollIntoView = i, this._doc = null, this._state = null, s && uy(s, t.newLength), o.some((a) => a.type == $t.time) || (this.annotations = o.concat($t.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, s, n, o, i) {
    return new $t(e, t, s, n, o, i);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation($t.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
$t.time = /* @__PURE__ */ Io.define();
$t.userEvent = /* @__PURE__ */ Io.define();
$t.addToHistory = /* @__PURE__ */ Io.define();
$t.remote = /* @__PURE__ */ Io.define();
function c2(r, e) {
  let t = [];
  for (let s = 0, n = 0; ; ) {
    let o, i;
    if (s < r.length && (n == e.length || e[n] >= r[s]))
      o = r[s++], i = r[s++];
    else if (n < e.length)
      o = e[n++], i = e[n++];
    else
      return t;
    !t.length || t[t.length - 1] < o ? t.push(o, i) : t[t.length - 1] < i && (t[t.length - 1] = i);
  }
}
function by(r, e, t) {
  var s;
  let n, o, i;
  return t ? (n = e.changes, o = ft.empty(e.changes.length), i = r.changes.compose(e.changes)) : (n = e.changes.map(r.changes), o = r.changes.mapDesc(e.changes, !0), i = r.changes.compose(n)), {
    changes: i,
    selection: e.selection ? e.selection.map(o) : (s = r.selection) === null || s === void 0 ? void 0 : s.map(n),
    effects: pt.mapEffects(r.effects, n).concat(pt.mapEffects(e.effects, o)),
    annotations: r.annotations.length ? r.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: r.scrollIntoView || e.scrollIntoView
  };
}
function gd(r, e, t) {
  let s = e.selection, n = no(e.annotations);
  return e.userEvent && (n = n.concat($t.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof ft ? e.changes : ft.of(e.changes || [], t, r.facet(fy)),
    selection: s && (s instanceof de ? s : de.single(s.anchor, s.head)),
    effects: no(e.effects),
    annotations: n,
    scrollIntoView: !!e.scrollIntoView
  };
}
function vy(r, e, t) {
  let s = gd(r, e.length ? e[0] : {}, r.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === !1 && (t = !1);
    let i = !!e[o].sequential;
    s = by(s, gd(r, e[o], i ? s.changes.newLength : r.doc.length), i);
  }
  let n = $t.create(r, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return d2(t ? u2(n) : n);
}
function u2(r) {
  let e = r.startState, t = !0;
  for (let n of e.facet(py)) {
    let o = n(r);
    if (o === !1) {
      t = !1;
      break;
    }
    Array.isArray(o) && (t = t === !0 ? o : c2(t, o));
  }
  if (t !== !0) {
    let n, o;
    if (t === !1)
      o = r.changes.invertedDesc, n = ft.empty(e.doc.length);
    else {
      let i = r.changes.filter(t);
      n = i.changes, o = i.filtered.mapDesc(i.changes).invertedDesc;
    }
    r = $t.create(e, n, r.selection && r.selection.map(o), pt.mapEffects(r.effects, o), r.annotations, r.scrollIntoView);
  }
  let s = e.facet(my);
  for (let n = s.length - 1; n >= 0; n--) {
    let o = s[n](r);
    o instanceof $t ? r = o : Array.isArray(o) && o.length == 1 && o[0] instanceof $t ? r = o[0] : r = vy(e, no(o), !1);
  }
  return r;
}
function d2(r) {
  let e = r.startState, t = e.facet(gy), s = r;
  for (let n = t.length - 1; n >= 0; n--) {
    let o = t[n](r);
    o && Object.keys(o).length && (s = by(s, gd(e, o, r.changes.newLength), !0));
  }
  return s == r ? r : $t.create(e, r.changes, r.selection, s.effects, s.annotations, s.scrollIntoView);
}
const h2 = [];
function no(r) {
  return r == null ? h2 : Array.isArray(r) ? r : [r];
}
var Qr = /* @__PURE__ */ function(r) {
  return r[r.Word = 0] = "Word", r[r.Space = 1] = "Space", r[r.Other = 2] = "Other", r;
}(Qr || (Qr = {}));
const f2 = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let yd;
try {
  yd = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function p2(r) {
  if (yd)
    return yd.test(r);
  for (let e = 0; e < r.length; e++) {
    let t = r[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || f2.test(t)))
      return !0;
  }
  return !1;
}
function m2(r) {
  return (e) => {
    if (!/\S/.test(e))
      return Qr.Space;
    if (p2(e))
      return Qr.Word;
    for (let t = 0; t < r.length; t++)
      if (e.indexOf(r[t]) > -1)
        return Qr.Word;
    return Qr.Other;
  };
}
class Me {
  constructor(e, t, s, n, o, i) {
    this.config = e, this.doc = t, this.selection = s, this.values = n, this.status = e.statusTemplate.slice(), this.computeSlot = o, i && (i._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Ni(this, a << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let s = this.config.address[e.id];
    if (s == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Ni(this, s), zl(this, s);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return vy(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: s, compartments: n } = t;
    for (let a of e.effects)
      a.is($c.reconfigure) ? (t && (n = /* @__PURE__ */ new Map(), t.compartments.forEach((l, c) => n.set(c, l)), t = null), n.set(a.value.compartment, a.value.extension)) : a.is(pt.reconfigure) ? (t = null, s = a.value) : a.is(pt.appendConfig) && (t = null, s = no(s).concat(a.value));
    let o;
    t ? o = e.startState.values.slice() : (t = Ul.resolve(s, n, this), o = new Me(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let i = e.startState.facet(md) ? e.newSelection : e.newSelection.asSingle();
    new Me(t, e.newDoc, i, o, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: de.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, s = e(t.ranges[0]), n = this.changes(s.changes), o = [s.range], i = no(s.effects);
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]), c = this.changes(l.changes), u = c.map(n);
      for (let h = 0; h < a; h++)
        o[h] = o[h].map(u);
      let d = n.mapDesc(c, !0);
      o.push(l.range.map(d)), n = n.compose(u), i = pt.mapEffects(i, u).concat(pt.mapEffects(no(l.effects), d));
    }
    return {
      changes: n,
      selection: de.create(o, t.mainIndex),
      effects: i
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof ft ? e : ft.of(e, this.doc.length, this.facet(Me.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return je.of(e.split(this.facet(Me.lineSeparator) || ud));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Ni(this, t), zl(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let s in e) {
        let n = e[s];
        n instanceof zs && this.config.address[n.id] != null && (t[s] = n.spec.toJSON(this.field(e[s]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, s) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (s) {
      for (let o in s)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let i = s[o], a = e[o];
          n.push(i.init((l) => i.spec.fromJSON(a, l)));
        }
    }
    return Me.create({
      doc: e.doc,
      selection: de.fromJSON(e.selection),
      extensions: t.extensions ? n.concat([t.extensions]) : n
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Ul.resolve(e.extensions || [], /* @__PURE__ */ new Map()), s = e.doc instanceof je ? e.doc : je.of((e.doc || "").split(t.staticFacet(Me.lineSeparator) || ud)), n = e.selection ? e.selection instanceof de ? e.selection : de.single(e.selection.anchor, e.selection.head) : de.single(0);
    return uy(n, s.length), t.staticFacet(md) || (n = n.asSingle()), new Me(t, s, n, t.dynamicSlots.map(() => null), (o, i) => i.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Me.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Me.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(yy);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let s of this.facet(Me.phrases))
      if (Object.prototype.hasOwnProperty.call(s, e)) {
        e = s[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (s, n) => {
      if (n == "$")
        return "$";
      let o = +(n || 1);
      return !o || o > t.length ? s : t[o - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, s = -1) {
    let n = [];
    for (let o of this.facet(hy))
      for (let i of o(this, t, s))
        Object.prototype.hasOwnProperty.call(i, e) && n.push(i[e]);
    return n;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return m2(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: s, length: n } = this.doc.lineAt(e), o = this.charCategorizer(e), i = e - s, a = e - s;
    for (; i > 0; ) {
      let l = Lr(t, i, !1);
      if (o(t.slice(l, i)) != Qr.Word)
        break;
      i = l;
    }
    for (; a < n; ) {
      let l = Lr(t, a);
      if (o(t.slice(a, l)) != Qr.Word)
        break;
      a = l;
    }
    return i == a ? null : de.range(i + s, a + s);
  }
}
Me.allowMultipleSelections = md;
Me.tabSize = /* @__PURE__ */ pe.define({
  combine: (r) => r.length ? r[0] : 4
});
Me.lineSeparator = fy;
Me.readOnly = yy;
Me.phrases = /* @__PURE__ */ pe.define({
  compare(r, e) {
    let t = Object.keys(r), s = Object.keys(e);
    return t.length == s.length && t.every((n) => r[n] == e[n]);
  }
});
Me.languageData = hy;
Me.changeFilter = py;
Me.transactionFilter = my;
Me.transactionExtender = gy;
$c.reconfigure = /* @__PURE__ */ pt.define();
function Kh(r, e, t = {}) {
  let s = {};
  for (let n of r)
    for (let o of Object.keys(n)) {
      let i = n[o], a = s[o];
      if (a === void 0)
        s[o] = i;
      else if (!(a === i || i === void 0))
        if (Object.hasOwnProperty.call(t, o))
          s[o] = t[o](a, i);
        else
          throw new Error("Config merge conflict for field " + o);
    }
  for (let n in e)
    s[n] === void 0 && (s[n] = e[n]);
  return s;
}
class go {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return bd.create(e, t, this);
  }
}
go.prototype.startSide = go.prototype.endSide = 0;
go.prototype.point = !1;
go.prototype.mapMode = zt.TrackDel;
let bd = class wy {
  constructor(e, t, s) {
    this.from = e, this.to = t, this.value = s;
  }
  /**
  @internal
  */
  static create(e, t, s) {
    return new wy(e, t, s);
  }
};
function vd(r, e) {
  return r.from - e.from || r.value.startSide - e.value.startSide;
}
class Wh {
  constructor(e, t, s, n) {
    this.from = e, this.to = t, this.value = s, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, s, n = 0) {
    let o = s ? this.to : this.from;
    for (let i = n, a = o.length; ; ) {
      if (i == a)
        return i;
      let l = i + a >> 1, c = o[l] - e || (s ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == i)
        return c >= 0 ? i : a;
      c >= 0 ? a = l : i = l + 1;
    }
  }
  between(e, t, s, n) {
    for (let o = this.findIndex(t, -1e9, !0), i = this.findIndex(s, 1e9, !1, o); o < i; o++)
      if (n(this.from[o] + e, this.to[o] + e, this.value[o]) === !1)
        return !1;
  }
  map(e, t) {
    let s = [], n = [], o = [], i = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], u = this.from[l] + e, d = this.to[l] + e, h, f;
      if (u == d) {
        let m = t.mapPos(u, c.startSide, c.mapMode);
        if (m == null || (h = f = m, c.startSide != c.endSide && (f = t.mapPos(u, c.endSide), f < h)))
          continue;
      } else if (h = t.mapPos(u, c.startSide), f = t.mapPos(d, c.endSide), h > f || h == f && c.startSide > 0 && c.endSide <= 0)
        continue;
      (f - h || c.endSide - c.startSide) < 0 || (i < 0 && (i = h), c.point && (a = Math.max(a, f - h)), s.push(c), n.push(h - i), o.push(f - i));
    }
    return { mapped: s.length ? new Wh(n, o, s, a) : null, pos: i };
  }
}
class Re {
  constructor(e, t, s, n) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = s, this.maxPoint = n;
  }
  /**
  @internal
  */
  static create(e, t, s, n) {
    return new Re(e, t, s, n);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: s = !1, filterFrom: n = 0, filterTo: o = this.length } = e, i = e.filter;
    if (t.length == 0 && !i)
      return this;
    if (s && (t = t.slice().sort(vd)), this.isEmpty)
      return t.length ? Re.of(t) : this;
    let a = new ky(this, null, -1).goto(0), l = 0, c = [], u = new yo();
    for (; a.value || l < t.length; )
      if (l < t.length && (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0) {
        let d = t[l++];
        u.addInner(d.from, d.to, d.value) || c.push(d);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) && (!i || n > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!i || n > a.to || o < a.from || i(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(bd.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? Re.empty : this.nextLayer.update({ add: c, filter: i, filterFrom: n, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], s = [], n = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let a = this.chunkPos[i], l = this.chunk[i], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        n = Math.max(n, l.maxPoint), t.push(l), s.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: u, pos: d } = l.map(a, e);
        u && (n = Math.max(n, u.maxPoint), t.push(u), s.push(d));
      }
    }
    let o = this.nextLayer.map(e);
    return t.length == 0 ? o : new Re(s, t, o || Re.empty, n);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, s) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let o = this.chunkPos[n], i = this.chunk[n];
        if (t >= o && e <= o + i.length && i.between(o, e - o, t - o, s) === !1)
          return;
      }
      this.nextLayer.between(e, t, s);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Wi.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Wi.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, s, n, o = -1) {
    let i = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= o), a = t.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= o), l = nm(i, a, s), c = new li(i, l, o), u = new li(a, l, o);
    s.iterGaps((d, h, f) => om(c, d, u, h, f, n)), s.empty && s.length == 0 && om(c, 0, u, 0, 0, n);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, s = 0, n) {
    n == null && (n = 999999999);
    let o = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0), i = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (o.length != i.length)
      return !1;
    if (!o.length)
      return !0;
    let a = nm(o, i), l = new li(o, a, 0).goto(s), c = new li(i, a, 0).goto(s);
    for (; ; ) {
      if (l.to != c.to || !wd(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > n)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, s, n, o = -1) {
    let i = new li(e, null, o).goto(t), a = t, l = i.openStart;
    for (; ; ) {
      let c = Math.min(i.to, s);
      if (i.point) {
        let u = i.activeForPoint(i.to), d = i.pointFrom < t ? u.length + 1 : i.point.startSide < 0 ? u.length : Math.min(u.length, l);
        n.point(a, c, i.point, u, d, i.pointRank), l = Math.min(i.openEnd(c), u.length);
      } else
        c > a && (n.span(a, c, i.active, l), l = i.openEnd(c));
      if (i.to > s)
        return l + (i.point && i.to > s ? 1 : 0);
      a = i.to, i.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let s = new yo();
    for (let n of e instanceof bd ? [e] : t ? g2(e) : e)
      s.add(n.from, n.to, n.value);
    return s.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Re.empty;
    let t = e[e.length - 1];
    for (let s = e.length - 2; s >= 0; s--)
      for (let n = e[s]; n != Re.empty; n = n.nextLayer)
        t = new Re(n.chunkPos, n.chunk, t, Math.max(n.maxPoint, t.maxPoint));
    return t;
  }
}
Re.empty = /* @__PURE__ */ new Re([], [], null, -1);
function g2(r) {
  if (r.length > 1)
    for (let e = r[0], t = 1; t < r.length; t++) {
      let s = r[t];
      if (vd(e, s) > 0)
        return r.slice().sort(vd);
      e = s;
    }
  return r;
}
Re.empty.nextLayer = Re.empty;
class yo {
  finishChunk(e) {
    this.chunks.push(new Wh(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, s) {
    this.addInner(e, t, s) || (this.nextLayer || (this.nextLayer = new yo())).add(e, t, s);
  }
  /**
  @internal
  */
  addInner(e, t, s) {
    let n = e - this.lastTo || s.startSide - this.last.endSide;
    if (n <= 0 && (e - this.lastFrom || s.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = s, this.lastFrom = e, this.lastTo = t, this.value.push(s), s.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let s = t.value.length - 1;
    return this.last = t.value[s], this.lastFrom = t.from[s] + e, this.lastTo = t.to[s] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Re.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Re.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function nm(r, e, t) {
  let s = /* @__PURE__ */ new Map();
  for (let o of r)
    for (let i = 0; i < o.chunk.length; i++)
      o.chunk[i].maxPoint <= 0 && s.set(o.chunk[i], o.chunkPos[i]);
  let n = /* @__PURE__ */ new Set();
  for (let o of e)
    for (let i = 0; i < o.chunk.length; i++) {
      let a = s.get(o.chunk[i]);
      a != null && (t ? t.mapPos(a) : a) == o.chunkPos[i] && !(t != null && t.touchesRange(a, a + o.chunk[i].length)) && n.add(o.chunk[i]);
    }
  return n;
}
class ky {
  constructor(e, t, s, n = 0) {
    this.layer = e, this.skip = t, this.minPoint = s, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, s) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < e || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, s = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!s || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], s = e + t.from[this.rangeIndex];
        if (this.from = s, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Wi {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, s = -1) {
    let n = [];
    for (let o = 0; o < e.length; o++)
      for (let i = e[o]; !i.isEmpty; i = i.nextLayer)
        i.maxPoint >= s && n.push(new ky(i, t, s, o));
    return n.length == 1 ? n[0] : new Wi(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let s of this.heap)
      s.goto(e, t);
    for (let s = this.heap.length >> 1; s >= 0; s--)
      mu(this.heap, s);
    return this.next(), this;
  }
  forward(e, t) {
    for (let s of this.heap)
      s.forward(e, t);
    for (let s = this.heap.length >> 1; s >= 0; s--)
      mu(this.heap, s);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), mu(this.heap, 0);
    }
  }
}
function mu(r, e) {
  for (let t = r[e]; ; ) {
    let s = (e << 1) + 1;
    if (s >= r.length)
      break;
    let n = r[s];
    if (s + 1 < r.length && n.compare(r[s + 1]) >= 0 && (n = r[s + 1], s++), t.compare(n) < 0)
      break;
    r[s] = t, r[e] = n, e = s;
  }
}
class li {
  constructor(e, t, s) {
    this.minPoint = s, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Wi.from(e, t, s);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Va(this.active, e), Va(this.activeTo, e), Va(this.activeRank, e), this.minActive = im(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: s, to: n, rank: o } = this.cursor;
    for (; t < this.activeRank.length && (o - this.activeRank[t] || n - this.activeTo[t]) > 0; )
      t++;
    Ua(this.active, t, s), Ua(this.activeTo, t, n), Ua(this.activeRank, t, o), e && Ua(e, t, this.cursor.from), this.minActive = im(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let s = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), s && Va(s, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(s), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (s) {
      this.openStart = 0;
      for (let n = s.length - 1; n >= 0 && s[n] < e; n--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let s = this.active.length - 1; s >= 0 && !(this.activeRank[s] < this.pointRank); s--)
      (this.activeTo[s] > e || this.activeTo[s] == e && this.active[s].endSide >= this.point.endSide) && t.push(this.active[s]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let s = this.activeTo.length - 1; s >= 0 && this.activeTo[s] > e; s--)
      t++;
    return t;
  }
}
function om(r, e, t, s, n, o) {
  r.goto(e), t.goto(s);
  let i = s + n, a = s, l = s - e;
  for (; ; ) {
    let c = r.to + l - t.to || r.endSide - t.endSide, u = c < 0 ? r.to + l : t.to, d = Math.min(u, i);
    if (r.point || t.point ? r.point && t.point && (r.point == t.point || r.point.eq(t.point)) && wd(r.activeForPoint(r.to), t.activeForPoint(t.to)) || o.comparePoint(a, d, r.point, t.point) : d > a && !wd(r.active, t.active) && o.compareRange(a, d, r.active, t.active), u > i)
      break;
    a = u, c <= 0 && r.next(), c >= 0 && t.next();
  }
}
function wd(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] != e[t] && !r[t].eq(e[t]))
      return !1;
  return !0;
}
function Va(r, e) {
  for (let t = e, s = r.length - 1; t < s; t++)
    r[t] = r[t + 1];
  r.pop();
}
function Ua(r, e, t) {
  for (let s = r.length - 1; s >= e; s--)
    r[s + 1] = r[s];
  r[e] = t;
}
function im(r, e) {
  let t = -1, s = 1e9;
  for (let n = 0; n < e.length; n++)
    (e[n] - s || r[n].endSide - r[t].endSide) < 0 && (t = n, s = e[n]);
  return t;
}
function Sy(r, e, t = r.length) {
  let s = 0;
  for (let n = 0; n < t; )
    r.charCodeAt(n) == 9 ? (s += e - s % e, n++) : (s++, n = Lr(r, n));
  return s;
}
function y2(r, e, t, s) {
  for (let n = 0, o = 0; ; ) {
    if (o >= e)
      return n;
    if (n == r.length)
      break;
    o += r.charCodeAt(n) == 9 ? t - o % t : 1, n = Lr(r, n);
  }
  return s === !0 ? -1 : r.length;
}
const kd = "ͼ", am = typeof Symbol > "u" ? "__" + kd : Symbol.for(kd), Sd = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), lm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Rs {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: s } = t || {};
    function n(i) {
      return /^@/.test(i) ? [i] : i.split(/,\s*/);
    }
    function o(i, a, l, c) {
      let u = [], d = /^@(\w+)\b/.exec(i[0]), h = d && d[1] == "keyframes";
      if (d && a == null)
        return l.push(i[0] + ";");
      for (let f in a) {
        let m = a[f];
        if (/&/.test(f))
          o(
            f.split(/,\s*/).map((g) => i.map((p) => g.replace(/&/, p))).reduce((g, p) => g.concat(p)),
            m,
            l
          );
        else if (m && typeof m == "object") {
          if (!d)
            throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          o(n(f), m, u, h);
        } else
          m != null && u.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + m + ";");
      }
      (u.length || h) && l.push((s && !d && !c ? i.map(s) : i).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let i in e)
      o(n(i), e[i], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = lm[am] || 1;
    return lm[am] = e + 1, kd + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, s) {
    let n = e[Sd], o = s && s.nonce;
    n ? o && n.setNonce(o) : n = new b2(e, o), n.mount(Array.isArray(t) ? t : [t]);
  }
}
let cm = /* @__PURE__ */ new Map();
class b2 {
  constructor(e, t) {
    this.root = e;
    let s = e.ownerDocument || e, n = s.defaultView;
    if (!e.head && e.adoptedStyleSheets && n.CSSStyleSheet) {
      let o = cm.get(s);
      if (o)
        return e[Sd] = o;
      this.sheet = new n.CSSStyleSheet(), cm.set(s, this);
    } else
      this.styleTag = s.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[Sd] = this;
  }
  mount(e) {
    let t = this.sheet, s = 0, n = 0;
    for (let o = 0; o < e.length; o++) {
      let i = e[o], a = this.modules.indexOf(i);
      if (a < n && a > -1 && (this.modules.splice(a, 1), n--, a = -1), a == -1) {
        if (this.modules.splice(n++, 0, i), t)
          for (let l = 0; l < i.rules.length; l++)
            t.insertRule(i.rules[l], s++);
      } else {
        for (; n < a; )
          s += this.modules[n++].rules.length;
        s += i.rules.length, n++;
      }
    }
    if (t)
      this.root.adoptedStyleSheets.indexOf(this.sheet) < 0 && (this.root.adoptedStyleSheets = [this.sheet, ...this.root.adoptedStyleSheets]);
    else {
      let o = "";
      for (let a = 0; a < this.modules.length; a++)
        o += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = o;
      let i = this.root.head || this.root;
      this.styleTag.parentNode != i && i.insertBefore(this.styleTag, i.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var js = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Gi = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, v2 = typeof navigator < "u" && /Mac/.test(navigator.platform), w2 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var yt = 0; yt < 10; yt++)
  js[48 + yt] = js[96 + yt] = String(yt);
for (var yt = 1; yt <= 24; yt++)
  js[yt + 111] = "F" + yt;
for (var yt = 65; yt <= 90; yt++)
  js[yt] = String.fromCharCode(yt + 32), Gi[yt] = String.fromCharCode(yt);
for (var gu in js)
  Gi.hasOwnProperty(gu) || (Gi[gu] = js[gu]);
function k2(r) {
  var e = v2 && r.metaKey && r.shiftKey && !r.ctrlKey && !r.altKey || w2 && r.shiftKey && r.key && r.key.length == 1 || r.key == "Unidentified", t = !e && r.key || (r.shiftKey ? Gi : js)[r.keyCode] || r.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function ql(r) {
  let e;
  return r.nodeType == 11 ? e = r.getSelection ? r : r.ownerDocument : e = r, e.getSelection();
}
function $d(r, e) {
  return e ? r == e || r.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function S2(r) {
  let e = r.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function _l(r, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return $d(r, e.anchorNode);
  } catch {
    return !1;
  }
}
function Ji(r) {
  return r.nodeType == 3 ? bn(r, 0, r.nodeValue.length).getClientRects() : r.nodeType == 1 ? r.getClientRects() : [];
}
function Mi(r, e, t, s) {
  return t ? um(r, e, t, s, -1) || um(r, e, t, s, 1) : !1;
}
function Yi(r) {
  for (var e = 0; ; e++)
    if (r = r.previousSibling, !r)
      return e;
}
function um(r, e, t, s, n) {
  for (; ; ) {
    if (r == t && e == s)
      return !0;
    if (e == (n < 0 ? 0 : is(r))) {
      if (r.nodeName == "DIV")
        return !1;
      let o = r.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      e = Yi(r) + (n < 0 ? 0 : 1), r = o;
    } else if (r.nodeType == 1) {
      if (r = r.childNodes[e + (n < 0 ? -1 : 0)], r.nodeType == 1 && r.contentEditable == "false")
        return !1;
      e = n < 0 ? is(r) : 0;
    } else
      return !1;
  }
}
function is(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
function Gh(r, e) {
  let t = e ? r.left : r.right;
  return { left: t, right: t, top: r.top, bottom: r.bottom };
}
function $2(r) {
  return {
    left: 0,
    right: r.innerWidth,
    top: 0,
    bottom: r.innerHeight
  };
}
function $y(r, e) {
  let t = e.width / r.offsetWidth, s = e.height / r.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - r.offsetWidth) < 1) && (t = 1), (s > 0.995 && s < 1.005 || !isFinite(s) || Math.abs(e.height - r.offsetHeight) < 1) && (s = 1), { scaleX: t, scaleY: s };
}
function _2(r, e, t, s, n, o, i, a) {
  let l = r.ownerDocument, c = l.defaultView || window;
  for (let u = r, d = !1; u && !d; )
    if (u.nodeType == 1) {
      let h, f = u == l.body, m = 1, g = 1;
      if (f)
        h = $2(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (d = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let b = u.getBoundingClientRect();
        ({ scaleX: m, scaleY: g } = $y(u, b)), h = {
          left: b.left,
          right: b.left + u.clientWidth * m,
          top: b.top,
          bottom: b.top + u.clientHeight * g
        };
      }
      let p = 0, y = 0;
      if (n == "nearest")
        e.top < h.top ? (y = -(h.top - e.top + i), t > 0 && e.bottom > h.bottom + y && (y = e.bottom - h.bottom + y + i)) : e.bottom > h.bottom && (y = e.bottom - h.bottom + i, t < 0 && e.top - y < h.top && (y = -(h.top + y - e.top + i)));
      else {
        let b = e.bottom - e.top, v = h.bottom - h.top;
        y = (n == "center" && b <= v ? e.top + b / 2 - v / 2 : n == "start" || n == "center" && t < 0 ? e.top - i : e.bottom - v + i) - h.top;
      }
      if (s == "nearest" ? e.left < h.left ? (p = -(h.left - e.left + o), t > 0 && e.right > h.right + p && (p = e.right - h.right + p + o)) : e.right > h.right && (p = e.right - h.right + o, t < 0 && e.left < h.left + p && (p = -(h.left + p - e.left + o))) : p = (s == "center" ? e.left + (e.right - e.left) / 2 - (h.right - h.left) / 2 : s == "start" == a ? e.left - o : e.right - (h.right - h.left) + o) - h.left, p || y)
        if (f)
          c.scrollBy(p, y);
        else {
          let b = 0, v = 0;
          if (y) {
            let k = u.scrollTop;
            u.scrollTop += y / g, v = (u.scrollTop - k) * g;
          }
          if (p) {
            let k = u.scrollLeft;
            u.scrollLeft += p / m, b = (u.scrollLeft - k) * m;
          }
          e = {
            left: e.left - b,
            top: e.top - v,
            right: e.right - b,
            bottom: e.bottom - v
          }, b && Math.abs(b - p) < 1 && (s = "nearest"), v && Math.abs(v - y) < 1 && (n = "nearest");
        }
      if (f)
        break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function x2(r) {
  let e = r.ownerDocument;
  for (let t = r.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class C2 {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: s } = e;
    this.set(t, Math.min(e.anchorOffset, t ? is(t) : 0), s, Math.min(e.focusOffset, s ? is(s) : 0));
  }
  set(e, t, s, n) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = s, this.focusOffset = n;
  }
}
let Fn = null;
function _y(r) {
  if (r.setActive)
    return r.setActive();
  if (Fn)
    return r.focus(Fn);
  let e = [];
  for (let t = r; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (r.focus(Fn == null ? {
    get preventScroll() {
      return Fn = { preventScroll: !0 }, !0;
    }
  } : void 0), !Fn) {
    Fn = !1;
    for (let t = 0; t < e.length; ) {
      let s = e[t++], n = e[t++], o = e[t++];
      s.scrollTop != n && (s.scrollTop = n), s.scrollLeft != o && (s.scrollLeft = o);
    }
  }
}
let dm;
function bn(r, e, t = e) {
  let s = dm || (dm = document.createRange());
  return s.setEnd(r, t), s.setStart(r, e), s;
}
function oo(r, e, t) {
  let s = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, n = new KeyboardEvent("keydown", s);
  n.synthetic = !0, r.dispatchEvent(n);
  let o = new KeyboardEvent("keyup", s);
  return o.synthetic = !0, r.dispatchEvent(o), n.defaultPrevented || o.defaultPrevented;
}
function A2(r) {
  for (; r; ) {
    if (r && (r.nodeType == 9 || r.nodeType == 11 && r.host))
      return r;
    r = r.assignedSlot || r.parentNode;
  }
  return null;
}
function xy(r) {
  for (; r.attributes.length; )
    r.removeAttributeNode(r.attributes[0]);
}
function E2(r, e) {
  let t = e.focusNode, s = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != s)
    return !1;
  for (s = Math.min(s, is(t)); ; )
    if (s) {
      if (t.nodeType != 1)
        return !1;
      let n = t.childNodes[s - 1];
      n.contentEditable == "false" ? s-- : (t = n, s = is(t));
    } else {
      if (t == r)
        return !0;
      s = Yi(t), t = t.parentNode;
    }
}
function Cy(r) {
  return r.scrollTop > Math.max(1, r.scrollHeight - r.clientHeight - 4);
}
class St {
  constructor(e, t, s = !0) {
    this.node = e, this.offset = t, this.precise = s;
  }
  static before(e, t) {
    return new St(e.parentNode, Yi(e), t);
  }
  static after(e, t) {
    return new St(e.parentNode, Yi(e) + 1, t);
  }
}
const Jh = [];
class Ge {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let s of this.children) {
      if (s == e)
        return t;
      t += s.length + s.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let s = this.dom, n = null, o;
      for (let i of this.children) {
        if (i.flags & 7) {
          if (!i.dom && (o = n ? n.nextSibling : s.firstChild)) {
            let a = Ge.get(o);
            (!a || !a.parent && a.canReuseDOM(i)) && i.reuseDOM(o);
          }
          i.sync(e, t), i.flags &= -8;
        }
        if (o = n ? n.nextSibling : s.firstChild, t && !t.written && t.node == s && o != i.dom && (t.written = !0), i.dom.parentNode == s)
          for (; o && o != i.dom; )
            o = hm(o);
        else
          s.insertBefore(i.dom, o);
        n = i.dom;
      }
      for (o = n ? n.nextSibling : s.firstChild, o && t && t.node == s && (t.written = !0); o; )
        o = hm(o);
    } else if (this.flags & 1)
      for (let s of this.children)
        s.flags & 7 && (s.sync(e, t), s.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let s;
    if (e == this.dom)
      s = this.dom.childNodes[t];
    else {
      let n = is(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let o = e.parentNode;
        if (o == this.dom)
          break;
        n == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? n = -1 : n = 1), e = o;
      }
      n < 0 ? s = e : s = e.nextSibling;
    }
    if (s == this.dom.firstChild)
      return 0;
    for (; s && !Ge.get(s); )
      s = s.nextSibling;
    if (!s)
      return this.length;
    for (let n = 0, o = 0; ; n++) {
      let i = this.children[n];
      if (i.dom == s)
        return o;
      o += i.length + i.breakAfter;
    }
  }
  domBoundsAround(e, t, s = 0) {
    let n = -1, o = -1, i = -1, a = -1;
    for (let l = 0, c = s, u = s; l < this.children.length; l++) {
      let d = this.children[l], h = c + d.length;
      if (c < e && h > t)
        return d.domBoundsAround(e, t, c);
      if (h >= e && n == -1 && (n = l, o = c), c > t && d.dom.parentNode == this.dom) {
        i = l, a = u;
        break;
      }
      u = h, c = h + d.breakAfter;
    }
    return {
      from: o,
      to: a < 0 ? s + this.length : a,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: i < this.children.length && i >= 0 ? this.children[i].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, s = Jh) {
    this.markDirty();
    for (let n = e; n < t; n++) {
      let o = this.children[n];
      o.parent == this && s.indexOf(o) < 0 && o.destroy();
    }
    this.children.splice(e, t - e, ...s);
    for (let n = 0; n < s.length; n++)
      s[n].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new Ay(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, s, n, o, i) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Ge.prototype.breakAfter = 0;
function hm(r) {
  let e = r.nextSibling;
  return r.parentNode.removeChild(r), e;
}
class Ay {
  constructor(e, t, s) {
    this.children = e, this.pos = t, this.i = s, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let s = this.children[--this.i];
      this.pos -= s.length + s.breakAfter;
    }
  }
}
function Ey(r, e, t, s, n, o, i, a, l) {
  let { children: c } = r, u = c.length ? c[e] : null, d = o.length ? o[o.length - 1] : null, h = d ? d.breakAfter : i;
  if (!(e == s && u && !i && !h && o.length < 2 && u.merge(t, n, o.length ? d : null, t == 0, a, l))) {
    if (s < c.length) {
      let f = c[s];
      f && (n < f.length || f.breakAfter && (d != null && d.breakAfter)) ? (e == s && (f = f.split(n), n = 0), !h && d && f.merge(0, n, d, !0, 0, l) ? o[o.length - 1] = f : ((n || f.children.length && !f.children[0].length) && f.merge(0, n, null, !1, 0, l), o.push(f))) : f != null && f.breakAfter && (d ? d.breakAfter = 1 : i = 1), s++;
    }
    for (u && (u.breakAfter = i, t > 0 && (!i && o.length && u.merge(t, u.length, o[0], !1, a, 0) ? u.breakAfter = o.shift().breakAfter : (t < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(t, u.length, null, !1, a, 0), e++)); e < s && o.length; )
      if (c[s - 1].become(o[o.length - 1]))
        s--, o.pop(), l = o.length ? 0 : a;
      else if (c[e].become(o[0]))
        e++, o.shift(), a = o.length ? 0 : l;
      else
        break;
    !o.length && e && s < c.length && !c[e - 1].breakAfter && c[s].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < s || o.length) && r.replaceChildren(e, s, o);
  }
}
function Oy(r, e, t, s, n, o) {
  let i = r.childCursor(), { i: a, off: l } = i.findPos(t, 1), { i: c, off: u } = i.findPos(e, -1), d = e - t;
  for (let h of s)
    d += h.length;
  r.length += d, Ey(r, c, u, a, l, s, 0, n, o);
}
let qt = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, _d = typeof document < "u" ? document : { documentElement: { style: {} } };
const xd = /* @__PURE__ */ /Edge\/(\d+)/.exec(qt.userAgent), Ty = /* @__PURE__ */ /MSIE \d/.test(qt.userAgent), Cd = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(qt.userAgent), _c = !!(Ty || Cd || xd), fm = !_c && /* @__PURE__ */ /gecko\/(\d+)/i.test(qt.userAgent), yu = !_c && /* @__PURE__ */ /Chrome\/(\d+)/.exec(qt.userAgent), pm = "webkitFontSmoothing" in _d.documentElement.style, Py = !_c && /* @__PURE__ */ /Apple Computer/.test(qt.vendor), mm = Py && (/* @__PURE__ */ /Mobile\/\w+/.test(qt.userAgent) || qt.maxTouchPoints > 2);
var le = {
  mac: mm || /* @__PURE__ */ /Mac/.test(qt.platform),
  windows: /* @__PURE__ */ /Win/.test(qt.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(qt.platform),
  ie: _c,
  ie_version: Ty ? _d.documentMode || 6 : Cd ? +Cd[1] : xd ? +xd[1] : 0,
  gecko: fm,
  gecko_version: fm ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(qt.userAgent) || [0, 0])[1] : 0,
  chrome: !!yu,
  chrome_version: yu ? +yu[1] : 0,
  ios: mm,
  android: /* @__PURE__ */ /Android\b/.test(qt.userAgent),
  webkit: pm,
  safari: Py,
  webkit_version: pm ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: _d.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const O2 = 256;
class as extends Ge {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, s) {
    return this.flags & 8 || s && (!(s instanceof as) || this.length - (t - e) + s.length > O2 || s.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (s ? s.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new as(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new St(this.dom, e);
  }
  domBoundsAround(e, t, s) {
    return { from: s, to: s + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return T2(this.dom, e, t);
  }
}
class ls extends Ge {
  constructor(e, t = [], s = 0) {
    super(), this.mark = e, this.children = t, this.length = s;
    for (let n of t)
      n.setParent(this);
  }
  setAttrs(e) {
    if (xy(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, s, n, o, i) {
    return s && (!(s instanceof ls && s.mark.eq(this.mark)) || e && o <= 0 || t < this.length && i <= 0) ? !1 : (Oy(this, e, t, s ? s.children.slice() : [], o - 1, i - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], s = 0, n = -1, o = 0;
    for (let a of this.children) {
      let l = s + a.length;
      l > e && t.push(s < e ? a.split(e - s) : a), n < 0 && s >= e && (n = o), s = l, o++;
    }
    let i = this.length - e;
    return this.length = e, n > -1 && (this.children.length = n, this.markDirty()), new ls(this.mark, t, i);
  }
  domAtPos(e) {
    return Iy(this, e);
  }
  coordsAt(e, t) {
    return My(this, e, t);
  }
}
function T2(r, e, t) {
  let s = r.nodeValue.length;
  e > s && (e = s);
  let n = e, o = e, i = 0;
  e == 0 && t < 0 || e == s && t >= 0 ? le.chrome || le.gecko || (e ? (n--, i = 1) : o < s && (o++, i = -1)) : t < 0 ? n-- : o < s && o++;
  let a = bn(r, n, o).getClientRects();
  if (!a.length)
    return null;
  let l = a[(i ? i < 0 : t >= 0) ? 0 : a.length - 1];
  return le.safari && !i && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), i ? Gh(l, i < 0) : l || null;
}
class ln extends Ge {
  static create(e, t, s) {
    return new ln(e, t, s);
  }
  constructor(e, t, s) {
    super(), this.widget = e, this.length = t, this.side = s, this.prevWidget = null;
  }
  split(e) {
    let t = ln.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, s, n, o, i) {
    return s && (!(s instanceof ln) || !this.widget.compare(s.widget) || e > 0 && o <= 0 || t < this.length && i <= 0) ? !1 : (this.length = e + (s ? s.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof ln && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return je.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, s = t && t.state.doc, n = this.posAtStart;
    return s ? s.slice(n, n + this.length) : je.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? St.before(this.dom) : St.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let s = this.widget.coordsAt(this.dom, e, t);
    if (s)
      return s;
    let n = this.dom.getClientRects(), o = null;
    if (!n.length)
      return null;
    let i = this.side ? this.side < 0 : e > 0;
    for (let a = i ? n.length - 1 : 0; o = n[a], !(e > 0 ? a == 0 : a == n.length - 1 || o.top < o.bottom); a += i ? -1 : 1)
      ;
    return Gh(o, !i);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class bo extends Ge {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof bo && e.side == this.side;
  }
  split() {
    return new bo(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? St.before(this.dom) : St.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return je.empty;
  }
  get isHidden() {
    return !0;
  }
}
as.prototype.children = ln.prototype.children = bo.prototype.children = Jh;
function Iy(r, e) {
  let t = r.dom, { children: s } = r, n = 0;
  for (let o = 0; n < s.length; n++) {
    let i = s[n], a = o + i.length;
    if (!(a == o && i.getSide() <= 0)) {
      if (e > o && e < a && i.dom.parentNode == t)
        return i.domAtPos(e - o);
      if (e <= o)
        break;
      o = a;
    }
  }
  for (let o = n; o > 0; o--) {
    let i = s[o - 1];
    if (i.dom.parentNode == t)
      return i.domAtPos(i.length);
  }
  for (let o = n; o < s.length; o++) {
    let i = s[o];
    if (i.dom.parentNode == t)
      return i.domAtPos(0);
  }
  return new St(t, 0);
}
function Ny(r, e, t) {
  let s, { children: n } = r;
  t > 0 && e instanceof ls && n.length && (s = n[n.length - 1]) instanceof ls && s.mark.eq(e.mark) ? Ny(s, e.children[0], t - 1) : (n.push(e), e.setParent(r)), r.length += e.length;
}
function My(r, e, t) {
  let s = null, n = -1, o = null, i = -1;
  function a(c, u) {
    for (let d = 0, h = 0; d < c.children.length && h <= u; d++) {
      let f = c.children[d], m = h + f.length;
      m >= u && (f.children.length ? a(f, u - h) : (!o || o.isHidden && t > 0) && (m > u || h == m && f.getSide() > 0) ? (o = f, i = u - h) : (h < u || h == m && f.getSide() < 0 && !f.isHidden) && (s = f, n = u - h)), h = m;
    }
  }
  a(r, e);
  let l = (t < 0 ? s : o) || s || o;
  return l ? l.coordsAt(Math.max(0, l == s ? n : i), t) : P2(r);
}
function P2(r) {
  let e = r.dom.lastChild;
  if (!e)
    return r.dom.getBoundingClientRect();
  let t = Ji(e);
  return t[t.length - 1] || null;
}
function Ad(r, e) {
  for (let t in r)
    t == "class" && e.class ? e.class += " " + r.class : t == "style" && e.style ? e.style += ";" + r.style : e[t] = r[t];
  return e;
}
const gm = /* @__PURE__ */ Object.create(null);
function Yh(r, e, t) {
  if (r == e)
    return !0;
  r || (r = gm), e || (e = gm);
  let s = Object.keys(r), n = Object.keys(e);
  if (s.length - (t && s.indexOf(t) > -1 ? 1 : 0) != n.length - (t && n.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let o of s)
    if (o != t && (n.indexOf(o) == -1 || r[o] !== e[o]))
      return !1;
  return !0;
}
function Ed(r, e, t) {
  let s = !1;
  if (e)
    for (let n in e)
      t && n in t || (s = !0, n == "style" ? r.style.cssText = "" : r.removeAttribute(n));
  if (t)
    for (let n in t)
      e && e[n] == t[n] || (s = !0, n == "style" ? r.style.cssText = t[n] : r.setAttribute(n, t[n]));
  return s;
}
function I2(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < r.attributes.length; t++) {
    let s = r.attributes[t];
    e[s.name] = s.value;
  }
  return e;
}
class lt extends Ge {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, s, n, o, i) {
    if (s) {
      if (!(s instanceof lt))
        return !1;
      this.dom || s.transferDOM(this);
    }
    return n && this.setDeco(s ? s.attrs : null), Oy(this, e, t, s ? s.children.slice() : [], o, i), !0;
  }
  split(e) {
    let t = new lt();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: s, off: n } = this.childPos(e);
    n && (t.append(this.children[s].split(n), 0), this.children[s].merge(n, this.children[s].length, null, !1, 0, 0), s++);
    for (let o = s; o < this.children.length; o++)
      t.append(this.children[o], 0);
    for (; s > 0 && this.children[s - 1].length == 0; )
      this.children[--s].destroy();
    return this.children.length = s, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Yh(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    Ny(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, s = e.spec.class;
    t && (this.attrs = Ad(t, this.attrs || {})), s && (this.attrs = Ad({ class: s }, this.attrs || {}));
  }
  domAtPos(e) {
    return Iy(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var s;
    this.dom ? this.flags & 4 && (xy(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Ed(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let n = this.dom.lastChild;
    for (; n && Ge.get(n) instanceof ls; )
      n = n.lastChild;
    if (!n || !this.length || n.nodeName != "BR" && ((s = Ge.get(n)) === null || s === void 0 ? void 0 : s.isEditable) == !1 && (!le.ios || !this.children.some((o) => o instanceof as))) {
      let o = document.createElement("BR");
      o.cmIgnore = !0, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let s of this.children) {
      if (!(s instanceof as) || /[^ -~]/.test(s.text))
        return null;
      let n = Ji(s.dom);
      if (n.length != 1)
        return null;
      e += n[0].width, t = n[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let s = My(this, e, t);
    if (!this.children.length && s && this.parent) {
      let { heightOracle: n } = this.parent.view.viewState, o = s.bottom - s.top;
      if (Math.abs(o - n.lineHeight) < 2 && n.textHeight < o) {
        let i = (o - n.textHeight) / 2;
        return { top: s.top + i, bottom: s.bottom - i, left: s.left, right: s.left };
      }
    }
    return s;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let s = 0, n = 0; s < e.children.length; s++) {
      let o = e.children[s], i = n + o.length;
      if (i >= t) {
        if (o instanceof lt)
          return o;
        if (i > t)
          break;
      }
      n = i + o.breakAfter;
    }
    return null;
  }
}
class Is extends Ge {
  constructor(e, t, s) {
    super(), this.widget = e, this.length = t, this.deco = s, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, s, n, o, i) {
    return s && (!(s instanceof Is) || !this.widget.compare(s.widget) || e > 0 && o <= 0 || t < this.length && i <= 0) ? !1 : (this.length = e + (s ? s.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? St.before(this.dom) : St.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let s = new Is(this.widget, t, this.deco);
    return s.breakAfter = this.breakAfter, s;
  }
  get children() {
    return Jh;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : je.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Is && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: s } = this.deco;
    return t == s ? !1 : e < 0 ? t < 0 : s > 0;
  }
}
class fa {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, s) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var yr = /* @__PURE__ */ function(r) {
  return r[r.Text = 0] = "Text", r[r.WidgetBefore = 1] = "WidgetBefore", r[r.WidgetAfter = 2] = "WidgetAfter", r[r.WidgetRange = 3] = "WidgetRange", r;
}(yr || (yr = {}));
class Je extends go {
  constructor(e, t, s, n) {
    super(), this.startSide = e, this.endSide = t, this.widget = s, this.spec = n;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new pa(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), s = !!e.block;
    return t += s && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Ls(e, t, t, s, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, s, n;
    if (e.isBlockGap)
      s = -5e8, n = 4e8;
    else {
      let { start: o, end: i } = Dy(e, t);
      s = (o ? t ? -3e8 : -1 : 5e8) - 1, n = (i ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Ls(e, s, n, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new ma(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Re.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Je.none = Re.empty;
class pa extends Je {
  constructor(e) {
    let { start: t, end: s } = Dy(e);
    super(t ? -1 : 5e8, s ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, s;
    return this == e || e instanceof pa && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((s = e.attrs) === null || s === void 0 ? void 0 : s.class)) && Yh(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
pa.prototype.point = !1;
class ma extends Je {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof ma && this.spec.class == e.spec.class && Yh(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
ma.prototype.mapMode = zt.TrackBefore;
ma.prototype.point = !0;
class Ls extends Je {
  constructor(e, t, s, n, o, i) {
    super(t, s, o, e), this.block = n, this.isReplace = i, this.mapMode = n ? t <= 0 ? zt.TrackBefore : zt.TrackAfter : zt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? yr.WidgetRange : this.startSide <= 0 ? yr.WidgetBefore : yr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Ls && N2(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Ls.prototype.point = !0;
function Dy(r, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: s } = r;
  return t == null && (t = r.inclusive), s == null && (s = r.inclusive), { start: t ?? e, end: s ?? e };
}
function N2(r, e) {
  return r == e || !!(r && e && r.compare(e));
}
function Od(r, e, t, s = 0) {
  let n = t.length - 1;
  n >= 0 && t[n] + s >= r ? t[n] = Math.max(t[n], e) : t.push(r, e);
}
class Di {
  constructor(e, t, s, n) {
    this.doc = e, this.pos = t, this.end = s, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Is && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new lt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(za(new bo(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Is) && this.getLine();
  }
  buildText(e, t, s) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: i, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (i) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let n = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - s)), this.getLine().append(za(new as(this.text.slice(this.textOff, this.textOff + n)), t), s), this.atCursorPos = !0, this.textOff += n, e -= n, s = 0;
    }
  }
  span(e, t, s, n) {
    this.buildText(t - e, s, n), this.pos = t, this.openStart < 0 && (this.openStart = n);
  }
  point(e, t, s, n, o, i) {
    if (this.disallowBlockEffectsFor[i] && s instanceof Ls) {
      if (s.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = t - e;
    if (s instanceof Ls)
      if (s.block)
        s.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Is(s.widget || new ym("div"), a, s));
      else {
        let l = ln.create(s.widget || new ym("span"), a, a ? 0 : s.startSide), c = this.atCursorPos && !l.isEditable && o <= n.length && (e < t || s.startSide > 0), u = !l.isEditable && (e < t || o > n.length || s.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(n), c && (d.append(za(new bo(1), n), o), o = n.length + Math.max(0, o - n.length)), d.append(za(l, n), o), this.atCursorPos = u, this.pendingBuffer = u ? e < t || o > n.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = n.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(s);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = o);
  }
  static build(e, t, s, n, o) {
    let i = new Di(e, t, s, o);
    return i.openEnd = Re.spans(n, t, s, i), i.openStart < 0 && (i.openStart = i.openEnd), i.finish(i.openEnd), i;
  }
}
function za(r, e) {
  for (let t of e)
    r = new ls(t, [r], r.length);
  return r;
}
class ym extends fa {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var ct = /* @__PURE__ */ function(r) {
  return r[r.LTR = 0] = "LTR", r[r.RTL = 1] = "RTL", r;
}(ct || (ct = {}));
const vn = ct.LTR, Xh = ct.RTL;
function Ry(r) {
  let e = [];
  for (let t = 0; t < r.length; t++)
    e.push(1 << +r[t]);
  return e;
}
const M2 = /* @__PURE__ */ Ry("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), D2 = /* @__PURE__ */ Ry("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Td = /* @__PURE__ */ Object.create(null), Tr = [];
for (let r of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ r.charCodeAt(0), t = /* @__PURE__ */ r.charCodeAt(1);
  Td[e] = t, Td[t] = -e;
}
function jy(r) {
  return r <= 247 ? M2[r] : 1424 <= r && r <= 1524 ? 2 : 1536 <= r && r <= 1785 ? D2[r - 1536] : 1774 <= r && r <= 2220 ? 4 : 8192 <= r && r <= 8204 ? 256 : 64336 <= r && r <= 65023 ? 4 : 1;
}
const R2 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ts {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? Xh : vn;
  }
  /**
  @internal
  */
  constructor(e, t, s) {
    this.from = e, this.to = t, this.level = s;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, s, n) {
    let o = -1;
    for (let i = 0; i < e.length; i++) {
      let a = e[i];
      if (a.from <= t && a.to >= t) {
        if (a.level == s)
          return i;
        (o < 0 || (n != 0 ? n < 0 ? a.from < t : a.to > t : e[o].level > a.level)) && (o = i);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
function Ly(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++) {
    let s = r[t], n = e[t];
    if (s.from != n.from || s.to != n.to || s.direction != n.direction || !Ly(s.inner, n.inner))
      return !1;
  }
  return !0;
}
const Fe = [];
function j2(r, e, t, s, n) {
  for (let o = 0; o <= s.length; o++) {
    let i = o ? s[o - 1].to : e, a = o < s.length ? s[o].from : t, l = o ? 256 : n;
    for (let c = i, u = l, d = l; c < a; c++) {
      let h = jy(r.charCodeAt(c));
      h == 512 ? h = u : h == 8 && d == 4 && (h = 16), Fe[c] = h == 4 ? 2 : h, h & 7 && (d = h), u = h;
    }
    for (let c = i, u = l, d = l; c < a; c++) {
      let h = Fe[c];
      if (h == 128)
        c < a - 1 && u == Fe[c + 1] && u & 24 ? h = Fe[c] = u : Fe[c] = 256;
      else if (h == 64) {
        let f = c + 1;
        for (; f < a && Fe[f] == 64; )
          f++;
        let m = c && u == 8 || f < t && Fe[f] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let g = c; g < f; g++)
          Fe[g] = m;
        c = f - 1;
      } else
        h == 8 && d == 1 && (Fe[c] = 1);
      u = h, h & 7 && (d = h);
    }
  }
}
function L2(r, e, t, s, n) {
  let o = n == 1 ? 2 : 1;
  for (let i = 0, a = 0, l = 0; i <= s.length; i++) {
    let c = i ? s[i - 1].to : e, u = i < s.length ? s[i].from : t;
    for (let d = c, h, f, m; d < u; d++)
      if (f = Td[h = r.charCodeAt(d)])
        if (f < 0) {
          for (let g = a - 3; g >= 0; g -= 3)
            if (Tr[g + 1] == -f) {
              let p = Tr[g + 2], y = p & 2 ? n : p & 4 ? p & 1 ? o : n : 0;
              y && (Fe[d] = Fe[Tr[g]] = y), a = g;
              break;
            }
        } else {
          if (Tr.length == 189)
            break;
          Tr[a++] = d, Tr[a++] = h, Tr[a++] = l;
        }
      else if ((m = Fe[d]) == 2 || m == 1) {
        let g = m == n;
        l = g ? 0 : 1;
        for (let p = a - 3; p >= 0; p -= 3) {
          let y = Tr[p + 2];
          if (y & 2)
            break;
          if (g)
            Tr[p + 2] |= 2;
          else {
            if (y & 4)
              break;
            Tr[p + 2] |= 4;
          }
        }
      }
  }
}
function B2(r, e, t, s) {
  for (let n = 0, o = s; n <= t.length; n++) {
    let i = n ? t[n - 1].to : r, a = n < t.length ? t[n].from : e;
    for (let l = i; l < a; ) {
      let c = Fe[l];
      if (c == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (n == t.length)
              break;
            u = t[n++].to, a = n < t.length ? t[n].from : e;
          } else if (Fe[u] == 256)
            u++;
          else
            break;
        let d = o == 1, h = (u < e ? Fe[u] : s) == 1, f = d == h ? d ? 1 : 2 : s;
        for (let m = u, g = n, p = g ? t[g - 1].to : r; m > l; )
          m == p && (m = t[--g].from, p = g ? t[g - 1].to : r), Fe[--m] = f;
        l = u;
      } else
        o = c, l++;
    }
  }
}
function Pd(r, e, t, s, n, o, i) {
  let a = s % 2 ? 2 : 1;
  if (s % 2 == n % 2)
    for (let l = e, c = 0; l < t; ) {
      let u = !0, d = !1;
      if (c == o.length || l < o[c].from) {
        let g = Fe[l];
        g != a && (u = !1, d = g == 16);
      }
      let h = !u && a == 1 ? [] : null, f = u ? s : s + 1, m = l;
      e:
        for (; ; )
          if (c < o.length && m == o[c].from) {
            if (d)
              break e;
            let g = o[c];
            if (!u)
              for (let p = g.to, y = c + 1; ; ) {
                if (p == t)
                  break e;
                if (y < o.length && o[y].from == p)
                  p = o[y++].to;
                else {
                  if (Fe[p] == a)
                    break e;
                  break;
                }
              }
            if (c++, h)
              h.push(g);
            else {
              g.from > l && i.push(new Ts(l, g.from, f));
              let p = g.direction == vn != !(f % 2);
              Id(r, p ? s + 1 : s, n, g.inner, g.from, g.to, i), l = g.to;
            }
            m = g.to;
          } else {
            if (m == t || (u ? Fe[m] != a : Fe[m] == a))
              break;
            m++;
          }
      h ? Pd(r, l, m, s + 1, n, h, i) : l < m && i.push(new Ts(l, m, f)), l = m;
    }
  else
    for (let l = t, c = o.length; l > e; ) {
      let u = !0, d = !1;
      if (!c || l > o[c - 1].to) {
        let g = Fe[l - 1];
        g != a && (u = !1, d = g == 16);
      }
      let h = !u && a == 1 ? [] : null, f = u ? s : s + 1, m = l;
      e:
        for (; ; )
          if (c && m == o[c - 1].to) {
            if (d)
              break e;
            let g = o[--c];
            if (!u)
              for (let p = g.from, y = c; ; ) {
                if (p == e)
                  break e;
                if (y && o[y - 1].to == p)
                  p = o[--y].from;
                else {
                  if (Fe[p - 1] == a)
                    break e;
                  break;
                }
              }
            if (h)
              h.push(g);
            else {
              g.to < l && i.push(new Ts(g.to, l, f));
              let p = g.direction == vn != !(f % 2);
              Id(r, p ? s + 1 : s, n, g.inner, g.from, g.to, i), l = g.from;
            }
            m = g.from;
          } else {
            if (m == e || (u ? Fe[m - 1] != a : Fe[m - 1] == a))
              break;
            m--;
          }
      h ? Pd(r, m, l, s + 1, n, h, i) : m < l && i.push(new Ts(m, l, f)), l = m;
    }
}
function Id(r, e, t, s, n, o, i) {
  let a = e % 2 ? 2 : 1;
  j2(r, n, o, s, a), L2(r, n, o, s, a), B2(n, o, s, a), Pd(r, n, o, e, t, s, i);
}
function F2(r, e, t) {
  if (!r)
    return [new Ts(0, 0, e == Xh ? 1 : 0)];
  if (e == vn && !t.length && !R2.test(r))
    return By(r.length);
  if (t.length)
    for (; r.length > Fe.length; )
      Fe[Fe.length] = 256;
  let s = [], n = e == vn ? 0 : 1;
  return Id(r, n, n, t, 0, r.length, s), s;
}
function By(r) {
  return [new Ts(0, r, 0)];
}
let Fy = "";
function V2(r, e, t, s, n) {
  var o;
  let i = s.head - r.from, a = Ts.find(e, i, (o = s.bidiLevel) !== null && o !== void 0 ? o : -1, s.assoc), l = e[a], c = l.side(n, t);
  if (i == c) {
    let h = a += n ? 1 : -1;
    if (h < 0 || h >= e.length)
      return null;
    l = e[a = h], i = l.side(!n, t), c = l.side(n, t);
  }
  let u = Lr(r.text, i, l.forward(n, t));
  (u < l.from || u > l.to) && (u = c), Fy = r.text.slice(Math.min(i, u), Math.max(i, u));
  let d = a == (n ? e.length - 1 : 0) ? null : e[a + (n ? 1 : -1)];
  return d && u == c && d.level + (n ? 0 : 1) < l.level ? de.cursor(d.side(!n, t) + r.from, d.forward(n, t) ? 1 : -1, d.level) : de.cursor(u + r.from, l.forward(n, t) ? -1 : 1, l.level);
}
function U2(r, e, t) {
  for (let s = e; s < t; s++) {
    let n = jy(r.charCodeAt(s));
    if (n == 1)
      return vn;
    if (n == 2 || n == 4)
      return Xh;
  }
  return vn;
}
const Vy = /* @__PURE__ */ pe.define(), Uy = /* @__PURE__ */ pe.define(), zy = /* @__PURE__ */ pe.define(), qy = /* @__PURE__ */ pe.define(), Nd = /* @__PURE__ */ pe.define(), Hy = /* @__PURE__ */ pe.define(), Ky = /* @__PURE__ */ pe.define(), Wy = /* @__PURE__ */ pe.define({
  combine: (r) => r.some((e) => e)
}), z2 = /* @__PURE__ */ pe.define({
  combine: (r) => r.some((e) => e)
});
class io {
  constructor(e, t = "nearest", s = "nearest", n = 5, o = 5, i = !1) {
    this.range = e, this.y = t, this.x = s, this.yMargin = n, this.xMargin = o, this.isSnapshot = i;
  }
  map(e) {
    return e.empty ? this : new io(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new io(de.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const qa = /* @__PURE__ */ pt.define({ map: (r, e) => r.map(e) });
function Ns(r, e, t) {
  let s = r.facet(qy);
  s.length ? s[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const xc = /* @__PURE__ */ pe.define({ combine: (r) => r.length ? r[0] : !0 });
let q2 = 0;
const vi = /* @__PURE__ */ pe.define();
class wr {
  constructor(e, t, s, n, o) {
    this.id = e, this.create = t, this.domEventHandlers = s, this.domEventObservers = n, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: s, eventObservers: n, provide: o, decorations: i } = t || {};
    return new wr(q2++, e, s, n, (a) => {
      let l = [vi.of(a)];
      return i && l.push(Xi.of((c) => {
        let u = c.plugin(a);
        return u ? i(u) : Je.none;
      })), o && l.push(o(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return wr.define((s) => new e(s), t);
  }
}
class bu {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (s) {
            if (Ns(t.state, s, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        Ns(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (s) {
        Ns(e.state, s, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Gy = /* @__PURE__ */ pe.define(), Qh = /* @__PURE__ */ pe.define(), Xi = /* @__PURE__ */ pe.define(), Jy = /* @__PURE__ */ pe.define(), Zh = /* @__PURE__ */ pe.define(), Yy = /* @__PURE__ */ pe.define();
function bm(r, e) {
  let t = r.state.facet(Yy);
  if (!t.length)
    return t;
  let s = t.map((o) => o instanceof Function ? o(r) : o), n = [];
  return Re.spans(s, e.from, e.to, {
    point() {
    },
    span(o, i, a, l) {
      let c = o - e.from, u = i - e.from, d = n;
      for (let h = a.length - 1; h >= 0; h--, l--) {
        let f = a[h].spec.bidiIsolate, m;
        if (f == null && (f = U2(e.text, c, u)), l > 0 && d.length && (m = d[d.length - 1]).to == c && m.direction == f)
          m.to = u, d = m.inner;
        else {
          let g = { from: c, to: u, direction: f, inner: [] };
          d.push(g), d = g.inner;
        }
      }
    }
  }), n;
}
const Xy = /* @__PURE__ */ pe.define();
function Qy(r) {
  let e = 0, t = 0, s = 0, n = 0;
  for (let o of r.state.facet(Xy)) {
    let i = o(r);
    i && (i.left != null && (e = Math.max(e, i.left)), i.right != null && (t = Math.max(t, i.right)), i.top != null && (s = Math.max(s, i.top)), i.bottom != null && (n = Math.max(n, i.bottom)));
  }
  return { left: e, right: t, top: s, bottom: n };
}
const wi = /* @__PURE__ */ pe.define();
class tr {
  constructor(e, t, s, n) {
    this.fromA = e, this.toA = t, this.fromB = s, this.toB = n;
  }
  join(e) {
    return new tr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, s = this;
    for (; t > 0; t--) {
      let n = e[t - 1];
      if (!(n.fromA > s.toA)) {
        if (n.toA < s.fromA)
          break;
        s = s.join(n), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, s), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let s = [];
    for (let n = 0, o = 0, i = 0, a = 0; ; n++) {
      let l = n == e.length ? null : e[n], c = i - a, u = l ? l.fromB : 1e9;
      for (; o < t.length && t[o] < u; ) {
        let d = t[o], h = t[o + 1], f = Math.max(a, d), m = Math.min(u, h);
        if (f <= m && new tr(f + c, m + c, f, m).addToSet(s), h > u)
          break;
        o += 2;
      }
      if (!l)
        return s;
      new tr(l.fromA, l.toA, l.fromB, l.toB).addToSet(s), i = l.toA, a = l.toB;
    }
  }
}
class Hl {
  constructor(e, t, s) {
    this.view = e, this.state = t, this.transactions = s, this.flags = 0, this.startState = e.state, this.changes = ft.empty(this.startState.doc.length);
    for (let o of s)
      this.changes = this.changes.compose(o.changes);
    let n = [];
    this.changes.iterChangedRanges((o, i, a, l) => n.push(new tr(o, i, a, l))), this.changedRanges = n;
  }
  /**
  @internal
  */
  static create(e, t, s) {
    return new Hl(e, t, s);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class vm extends Ge {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new lt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new tr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let s = e.changedRanges;
    this.minWidth > 0 && s.length && (s.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let n = -1;
    this.view.inputState.composing >= 0 && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? n = this.domChanged.newSel.head : !X2(e.changes, this.hasComposition) && !e.selectionSet && (n = e.state.selection.main.head));
    let o = n > -1 ? K2(this.view, e.changes, n) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      s = new tr(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(s.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (le.ie || le.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let i = this.decorations, a = this.updateDeco(), l = J2(i, a, e.changes);
    return s = tr.extendWithRanges(s, l), !(this.flags & 7) && s.length == 0 ? !1 : (this.updateInner(s, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, s) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, s);
    let { observer: n } = this.view;
    n.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let i = le.chrome || le.ios ? { node: n.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, i), this.flags &= -8, i && (i.written || n.selectionRange.focusNode != i.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (i) => i.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let i of this.children)
        i instanceof Is && i.widget instanceof wm && o.push(i.dom);
    n.updateGaps(o);
  }
  updateChildren(e, t, s) {
    let n = s ? s.range.addToSet(e.slice()) : e, o = this.childCursor(t);
    for (let i = n.length - 1; ; i--) {
      let a = i >= 0 ? n[i] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: u, toB: d } = a, h, f, m, g;
      if (s && s.range.fromB < d && s.range.toB > u) {
        let k = Di.build(this.view.state.doc, u, s.range.fromB, this.decorations, this.dynamicDecorationMap), _ = Di.build(this.view.state.doc, s.range.toB, d, this.decorations, this.dynamicDecorationMap);
        f = k.breakAtStart, m = k.openStart, g = _.openEnd;
        let w = this.compositionView(s);
        _.breakAtStart ? w.breakAfter = 1 : _.content.length && w.merge(w.length, w.length, _.content[0], !1, _.openStart, 0) && (w.breakAfter = _.content[0].breakAfter, _.content.shift()), k.content.length && w.merge(0, 0, k.content[k.content.length - 1], !0, 0, k.openEnd) && k.content.pop(), h = k.content.concat(w).concat(_.content);
      } else
        ({ content: h, breakAtStart: f, openStart: m, openEnd: g } = Di.build(this.view.state.doc, u, d, this.decorations, this.dynamicDecorationMap));
      let { i: p, off: y } = o.findPos(c, 1), { i: b, off: v } = o.findPos(l, -1);
      Ey(this, b, v, p, y, h, f, m, g);
    }
    s && this.fixCompositionDOM(s);
  }
  compositionView(e) {
    let t = new as(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: n } of e.marks)
      t = new ls(n, [t], t.length);
    let s = new lt();
    return s.append(t, 0), s;
  }
  fixCompositionDOM(e) {
    let t = (o, i) => {
      i.flags |= 8 | (i.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(i);
      let a = Ge.get(o);
      a && a != i && (a.dom = null), i.setDOM(o);
    }, s = this.childPos(e.range.fromB, 1), n = this.children[s.i];
    t(e.line, n);
    for (let o = e.marks.length - 1; o >= -1; o--)
      s = n.childPos(s.off, 1), n = n.children[s.i], t(o >= 0 ? e.marks[o].node : e.text, n);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let s = this.view.root.activeElement, n = s == this.dom, o = !n && _l(this.dom, this.view.observer.selectionRange) && !(s && this.dom.contains(s));
    if (!(n || t || o))
      return;
    let i = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (le.gecko && a.empty && !this.hasComposition && H2(l)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(d, l.node.childNodes[l.offset] || null)), l = c = new St(d, 0), i = !0;
    }
    let u = this.view.observer.selectionRange;
    (i || !u.focusNode || (!Mi(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Mi(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
      le.android && le.chrome && this.dom.contains(u.focusNode) && Y2(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = ql(this.view.root);
      if (d)
        if (a.empty) {
          if (le.gecko) {
            let h = W2(l.node, l.offset);
            if (h && h != 3) {
              let f = eb(l.node, l.offset, h == 1 ? 1 : -1);
              f && (l = new St(f.node, f.offset));
            }
          }
          d.collapse(l.node, l.offset), a.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = a.bidiLevel);
        } else if (d.extend) {
          d.collapse(l.node, l.offset);
          try {
            d.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let h = document.createRange();
          a.anchor > a.head && ([l, c] = [c, l]), h.setEnd(c.node, c.offset), h.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(h);
        }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), s && s.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new St(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new St(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && Mi(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, s = ql(e.root), { anchorNode: n, anchorOffset: o } = e.observer.selectionRange;
    if (!s || !t.empty || !t.assoc || !s.modify)
      return;
    let i = lt.find(this, t.head);
    if (!i)
      return;
    let a = i.posAtStart;
    if (t.head == a || t.head == a + i.length)
      return;
    let l = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let u = this.domAtPos(t.head + t.assoc);
    s.collapse(u.node, u.offset), s.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let d = e.observer.selectionRange;
    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != t.from && s.collapse(n, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, s;
    if (e.node != t)
      return e;
    for (let n = e.offset; !s && n < t.childNodes.length; n++) {
      let o = Ge.get(t.childNodes[n]);
      o instanceof lt && (s = o.domAtPos(0));
    }
    for (let n = e.offset - 1; !s && n >= 0; n--) {
      let o = Ge.get(t.childNodes[n]);
      o instanceof lt && (s = o.domAtPos(o.length));
    }
    return s ? new St(s.node, s.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let s = Ge.get(t);
      if (s && s.rootView == this)
        return s;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let s = this.nearest(e);
    if (!s)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return s.localPosFromDOM(e, t) + s.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: s } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let n = this.children[t];
      if (s < n.length || n instanceof lt)
        break;
      t++, s = 0;
    }
    return this.children[t].domAtPos(s);
  }
  coordsAt(e, t) {
    let s = null, n = 0;
    for (let o = this.length, i = this.children.length - 1; i >= 0; i--) {
      let a = this.children[i], l = o - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!s || a instanceof lt && !(s instanceof lt && t >= 0)) && (s = a, n = c), o = c;
    }
    return s ? s.coordsAt(e - n, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: s } = this.childPos(e, 1), n = this.children[t];
    if (!(n instanceof lt))
      return null;
    for (; n.children.length; ) {
      let { i: a, off: l } = n.childPos(s, 1);
      for (; ; a++) {
        if (a == n.children.length)
          return null;
        if ((n = n.children[a]).length)
          break;
      }
      s = l;
    }
    if (!(n instanceof as))
      return null;
    let o = Lr(n.text, s);
    if (o == s)
      return null;
    let i = bn(n.dom, s, o).getClientRects();
    for (let a = 0; a < i.length; a++) {
      let l = i[a];
      if (a == i.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: s, to: n } = e, o = this.view.contentDOM.clientWidth, i = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == ct.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let d = this.children[u], h = c + d.length;
      if (h > n)
        break;
      if (c >= s) {
        let f = d.dom.getBoundingClientRect();
        if (t.push(f.height), i) {
          let m = d.dom.lastChild, g = m ? Ji(m) : [];
          if (g.length) {
            let p = g[g.length - 1], y = l ? p.right - f.left : f.right - p.left;
            y > a && (a = y, this.minWidth = o, this.minWidthFrom = c, this.minWidthTo = h);
          }
        }
      }
      c = h + d.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? ct.RTL : ct.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof lt) {
        let i = o.measureTextSize();
        if (i)
          return i;
      }
    let e = document.createElement("div"), t, s, n;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let o = Ji(e.firstChild)[0];
      t = e.getBoundingClientRect().height, s = o ? o.width / 27 : 7, n = o ? o.height : t, e.remove();
    }), { lineHeight: t, charWidth: s, textHeight: n };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new Ay(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let s = 0, n = 0; ; n++) {
      let o = n == t.viewports.length ? null : t.viewports[n], i = o ? o.from - 1 : this.length;
      if (i > s) {
        let a = (t.lineBlockAt(i).bottom - t.lineBlockAt(s).top) / this.view.scaleY;
        e.push(Je.replace({
          widget: new wm(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(s, i));
      }
      if (!o)
        break;
      s = o.to + 1;
    }
    return Je.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(Xi).map((n, o) => (this.dynamicDecorationMap[o] = typeof n == "function") ? n(this.view) : n), t = !1, s = this.view.state.facet(Jy).map((n, o) => {
      let i = typeof n == "function";
      return i && (t = !0), i ? n(this.view) : n;
    });
    s.length && (this.dynamicDecorationMap[e.length] = t, e.push(Re.join(s)));
    for (let n = e.length; n < e.length + 3; n++)
      this.dynamicDecorationMap[n] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: t } = e, s = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), n;
    if (!s)
      return;
    !t.empty && (n = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (s = {
      left: Math.min(s.left, n.left),
      top: Math.min(s.top, n.top),
      right: Math.max(s.right, n.right),
      bottom: Math.max(s.bottom, n.bottom)
    });
    let o = Qy(this.view), i = {
      left: s.left - o.left,
      top: s.top - o.top,
      right: s.right + o.right,
      bottom: s.bottom + o.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    _2(this.view.scrollDOM, i, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == ct.LTR);
  }
}
function H2(r) {
  return r.node.nodeType == 1 && r.node.firstChild && (r.offset == 0 || r.node.childNodes[r.offset - 1].contentEditable == "false") && (r.offset == r.node.childNodes.length || r.node.childNodes[r.offset].contentEditable == "false");
}
class wm extends fa {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function Zy(r, e) {
  let t = r.observer.selectionRange, s = t.focusNode && eb(t.focusNode, t.focusOffset, 0);
  if (!s)
    return null;
  let n = e - s.offset;
  return { from: n, to: n + s.node.nodeValue.length, node: s.node };
}
function K2(r, e, t) {
  let s = Zy(r, t);
  if (!s)
    return null;
  let { node: n, from: o, to: i } = s, a = n.nodeValue;
  if (/[\n\r]/.test(a) || r.state.doc.sliceString(s.from, s.to) != a)
    return null;
  let l = e.invertedDesc, c = new tr(l.mapPos(o), l.mapPos(i), o, i), u = [];
  for (let d = n.parentNode; ; d = d.parentNode) {
    let h = Ge.get(d);
    if (h instanceof ls)
      u.push({ node: d, deco: h.mark });
    else {
      if (h instanceof lt || d.nodeName == "DIV" && d.parentNode == r.contentDOM)
        return { range: c, text: n, marks: u, line: d };
      if (d != r.contentDOM)
        u.push({ node: d, deco: new pa({
          inclusive: !0,
          attributes: I2(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function eb(r, e, t) {
  if (t <= 0)
    for (let s = r, n = e; ; ) {
      if (s.nodeType == 3)
        return { node: s, offset: n };
      if (s.nodeType == 1 && n > 0)
        s = s.childNodes[n - 1], n = is(s);
      else
        break;
    }
  if (t >= 0)
    for (let s = r, n = e; ; ) {
      if (s.nodeType == 3)
        return { node: s, offset: n };
      if (s.nodeType == 1 && n < s.childNodes.length && t >= 0)
        s = s.childNodes[n], n = 0;
      else
        break;
    }
  return null;
}
function W2(r, e) {
  return r.nodeType != 1 ? 0 : (e && r.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < r.childNodes.length && r.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let G2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    Od(e, t, this.changes);
  }
  comparePoint(e, t) {
    Od(e, t, this.changes);
  }
};
function J2(r, e, t) {
  let s = new G2();
  return Re.compare(r, e, t, s), s.changes;
}
function Y2(r, e) {
  for (let t = r; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function X2(r, e) {
  let t = !1;
  return e && r.iterChangedRanges((s, n) => {
    s < e.to && n > e.from && (t = !0);
  }), t;
}
function Q2(r, e, t = 1) {
  let s = r.charCategorizer(e), n = r.doc.lineAt(e), o = e - n.from;
  if (n.length == 0)
    return de.cursor(e);
  o == 0 ? t = 1 : o == n.length && (t = -1);
  let i = o, a = o;
  t < 0 ? i = Lr(n.text, o, !1) : a = Lr(n.text, o);
  let l = s(n.text.slice(i, a));
  for (; i > 0; ) {
    let c = Lr(n.text, i, !1);
    if (s(n.text.slice(c, i)) != l)
      break;
    i = c;
  }
  for (; a < n.length; ) {
    let c = Lr(n.text, a);
    if (s(n.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return de.range(i + n.from, a + n.from);
}
function Z2(r, e) {
  return e.left > r ? e.left - r : Math.max(0, r - e.right);
}
function e$(r, e) {
  return e.top > r ? e.top - r : Math.max(0, r - e.bottom);
}
function vu(r, e) {
  return r.top < e.bottom - 1 && r.bottom > e.top + 1;
}
function km(r, e) {
  return e < r.top ? { top: e, left: r.left, right: r.right, bottom: r.bottom } : r;
}
function Sm(r, e) {
  return e > r.bottom ? { top: r.top, left: r.left, right: r.right, bottom: e } : r;
}
function Md(r, e, t) {
  let s, n, o, i, a = !1, l, c, u, d;
  for (let m = r.firstChild; m; m = m.nextSibling) {
    let g = Ji(m);
    for (let p = 0; p < g.length; p++) {
      let y = g[p];
      n && vu(n, y) && (y = km(Sm(y, n.bottom), n.top));
      let b = Z2(e, y), v = e$(t, y);
      if (b == 0 && v == 0)
        return m.nodeType == 3 ? $m(m, e, t) : Md(m, e, t);
      if (!s || i > v || i == v && o > b) {
        s = m, n = y, o = b, i = v;
        let k = v ? t < y.top ? -1 : 1 : b ? e < y.left ? -1 : 1 : 0;
        a = !k || (k > 0 ? p < g.length - 1 : p > 0);
      }
      b == 0 ? t > y.bottom && (!u || u.bottom < y.bottom) ? (l = m, u = y) : t < y.top && (!d || d.top > y.top) && (c = m, d = y) : u && vu(u, y) ? u = Sm(u, y.bottom) : d && vu(d, y) && (d = km(d, y.top));
    }
  }
  if (u && u.bottom >= t ? (s = l, n = u) : d && d.top <= t && (s = c, n = d), !s)
    return { node: r, offset: 0 };
  let h = Math.max(n.left, Math.min(n.right, e));
  if (s.nodeType == 3)
    return $m(s, h, t);
  if (a && s.contentEditable != "false")
    return Md(s, h, t);
  let f = Array.prototype.indexOf.call(r.childNodes, s) + (e >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: r, offset: f };
}
function $m(r, e, t) {
  let s = r.nodeValue.length, n = -1, o = 1e9, i = 0;
  for (let a = 0; a < s; a++) {
    let l = bn(r, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom)
        continue;
      i || (i = e - u.left);
      let d = (u.top > t ? u.top - t : t - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && d < o) {
        let h = e >= (u.left + u.right) / 2, f = h;
        if ((le.chrome || le.gecko) && bn(r, a).getBoundingClientRect().left == u.right && (f = !h), d <= 0)
          return { node: r, offset: a + (f ? 1 : 0) };
        n = a + (f ? 1 : 0), o = d;
      }
    }
  }
  return { node: r, offset: n > -1 ? n : i > 0 ? r.nodeValue.length : 0 };
}
function tb(r, e, t, s = -1) {
  var n, o;
  let i = r.contentDOM.getBoundingClientRect(), a = i.top + r.viewState.paddingTop, l, { docHeight: c } = r.viewState, { x: u, y: d } = e, h = d - a;
  if (h < 0)
    return 0;
  if (h > c)
    return r.state.doc.length;
  for (let k = r.viewState.heightOracle.textHeight / 2, _ = !1; l = r.elementAtHeight(h), l.type != yr.Text; )
    for (; h = s > 0 ? l.bottom + k : l.top - k, !(h >= 0 && h <= c); ) {
      if (_)
        return t ? null : 0;
      _ = !0, s = -s;
    }
  d = a + h;
  let f = l.from;
  if (f < r.viewport.from)
    return r.viewport.from == 0 ? 0 : t ? null : _m(r, i, l, u, d);
  if (f > r.viewport.to)
    return r.viewport.to == r.state.doc.length ? r.state.doc.length : t ? null : _m(r, i, l, u, d);
  let m = r.dom.ownerDocument, g = r.root.elementFromPoint ? r.root : m, p = g.elementFromPoint(u, d);
  p && !r.contentDOM.contains(p) && (p = null), p || (u = Math.max(i.left + 1, Math.min(i.right - 1, u)), p = g.elementFromPoint(u, d), p && !r.contentDOM.contains(p) && (p = null));
  let y, b = -1;
  if (p && ((n = r.docView.nearest(p)) === null || n === void 0 ? void 0 : n.isEditable) != !1) {
    if (m.caretPositionFromPoint) {
      let k = m.caretPositionFromPoint(u, d);
      k && ({ offsetNode: y, offset: b } = k);
    } else if (m.caretRangeFromPoint) {
      let k = m.caretRangeFromPoint(u, d);
      k && ({ startContainer: y, startOffset: b } = k, (!r.contentDOM.contains(y) || le.safari && t$(y, b, u) || le.chrome && r$(y, b, u)) && (y = void 0));
    }
  }
  if (!y || !r.docView.dom.contains(y)) {
    let k = lt.find(r.docView, f);
    if (!k)
      return h > l.top + l.height / 2 ? l.to : l.from;
    ({ node: y, offset: b } = Md(k.dom, u, d));
  }
  let v = r.docView.nearest(y);
  if (!v)
    return null;
  if (v.isWidget && ((o = v.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let k = v.dom.getBoundingClientRect();
    return e.y < k.top || e.y <= k.bottom && e.x <= (k.left + k.right) / 2 ? v.posAtStart : v.posAtEnd;
  } else
    return v.localPosFromDOM(y, b) + v.posAtStart;
}
function _m(r, e, t, s, n) {
  let o = Math.round((s - e.left) * r.defaultCharacterWidth);
  if (r.lineWrapping && t.height > r.defaultLineHeight * 1.5) {
    let a = r.viewState.heightOracle.textHeight, l = Math.floor((n - t.top - (r.defaultLineHeight - a) * 0.5) / a);
    o += l * r.viewState.heightOracle.lineLength;
  }
  let i = r.state.sliceDoc(t.from, t.to);
  return t.from + y2(i, o, r.state.tabSize);
}
function t$(r, e, t) {
  let s;
  if (r.nodeType != 3 || e != (s = r.nodeValue.length))
    return !1;
  for (let n = r.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return !1;
  return bn(r, s - 1, s).getBoundingClientRect().left > t;
}
function r$(r, e, t) {
  if (e != 0)
    return !1;
  for (let n = r; ; ) {
    let o = n.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != n)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    n = o;
  }
  let s = r.nodeType == 1 ? r.getBoundingClientRect() : bn(r, 0, Math.max(r.nodeValue.length, 1)).getBoundingClientRect();
  return t - s.left > 5;
}
function s$(r, e) {
  let t = r.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let s of t.type)
      if (s.to > e || s.to == e && (s.to == t.to || s.type == yr.Text))
        return s;
  }
  return t;
}
function n$(r, e, t, s) {
  let n = s$(r, e.head), o = !s || n.type != yr.Text || !(r.lineWrapping || n.widgetLineBreaks) ? null : r.coordsAtPos(e.assoc < 0 && e.head > n.from ? e.head - 1 : e.head);
  if (o) {
    let i = r.dom.getBoundingClientRect(), a = r.textDirectionAt(n.from), l = r.posAtCoords({
      x: t == (a == ct.LTR) ? i.right - 1 : i.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (l != null)
      return de.cursor(l, t ? -1 : 1);
  }
  return de.cursor(t ? n.to : n.from, t ? -1 : 1);
}
function xm(r, e, t, s) {
  let n = r.state.doc.lineAt(e.head), o = r.bidiSpans(n), i = r.textDirectionAt(n.from);
  for (let a = e, l = null; ; ) {
    let c = V2(n, o, i, a, t), u = Fy;
    if (!c) {
      if (n.number == (t ? r.state.doc.lines : 1))
        return a;
      u = `
`, n = r.state.doc.line(n.number + (t ? 1 : -1)), o = r.bidiSpans(n), c = r.visualLineSide(n, !t);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!s)
        return c;
      l = s(u);
    }
    a = c;
  }
}
function o$(r, e, t) {
  let s = r.state.charCategorizer(e), n = s(t);
  return (o) => {
    let i = s(o);
    return n == Qr.Space && (n = i), n == i;
  };
}
function i$(r, e, t, s) {
  let n = e.head, o = t ? 1 : -1;
  if (n == (t ? r.state.doc.length : 0))
    return de.cursor(n, e.assoc);
  let i = e.goalColumn, a, l = r.contentDOM.getBoundingClientRect(), c = r.coordsAtPos(n, e.assoc || -1), u = r.documentTop;
  if (c)
    i == null && (i = c.left - l.left), a = o < 0 ? c.top : c.bottom;
  else {
    let f = r.viewState.lineBlockAt(n);
    i == null && (i = Math.min(l.right - l.left, r.defaultCharacterWidth * (n - f.from))), a = (o < 0 ? f.top : f.bottom) + u;
  }
  let d = l.left + i, h = s ?? r.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let m = a + (h + f) * o, g = tb(r, { x: d, y: m }, !1, o);
    if (m < l.top || m > l.bottom || (o < 0 ? g < n : g > n)) {
      let p = r.docView.coordsForChar(g), y = !p || m < p.top ? -1 : 1;
      return de.cursor(g, y, void 0, i);
    }
  }
}
function xl(r, e, t) {
  for (; ; ) {
    let s = 0;
    for (let n of r)
      n.between(e - 1, e + 1, (o, i, a) => {
        if (e > o && e < i) {
          let l = s || t || (e - o < i - e ? -1 : 1);
          e = l < 0 ? o : i, s = l;
        }
      });
    if (!s)
      return e;
  }
}
function wu(r, e, t) {
  let s = xl(r.state.facet(Zh).map((n) => n(r)), t.from, e.head > t.from ? -1 : 1);
  return s == t.from ? t : de.cursor(s, s < t.from ? 1 : -1);
}
class a$ {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, le.safari && e.contentDOM.addEventListener("input", () => null), le.gecko && $$(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !m$(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, t) {
    let s = this.handlers[e];
    if (s) {
      for (let n of s.observers)
        n(this.view, t);
      for (let n of s.handlers) {
        if (t.defaultPrevented)
          break;
        if (n(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = l$(e), s = this.handlers, n = this.view.contentDOM;
    for (let o in t)
      if (o != "scroll") {
        let i = !t[o].handlers.length, a = s[o];
        a && i != !a.handlers.length && (n.removeEventListener(o, this.handleEvent), a = null), a || n.addEventListener(o, this.handleEvent, { passive: i });
      }
    for (let o in s)
      o != "scroll" && !t[o] && n.removeEventListener(o, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && sb.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), le.android && le.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return le.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = rb.find((s) => s.keyCode == e.keyCode)) && !e.ctrlKey || c$.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, oo(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : le.safari && !le.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function Cm(r, e) {
  return (t, s) => {
    try {
      return e.call(r, s, t);
    } catch (n) {
      Ns(t.state, n);
    }
  };
}
function l$(r) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(s) {
    return e[s] || (e[s] = { observers: [], handlers: [] });
  }
  for (let s of r) {
    let n = s.spec;
    if (n && n.domEventHandlers)
      for (let o in n.domEventHandlers) {
        let i = n.domEventHandlers[o];
        i && t(o).handlers.push(Cm(s.value, i));
      }
    if (n && n.domEventObservers)
      for (let o in n.domEventObservers) {
        let i = n.domEventObservers[o];
        i && t(o).observers.push(Cm(s.value, i));
      }
  }
  for (let s in kr)
    t(s).handlers.push(kr[s]);
  for (let s in Sr)
    t(s).observers.push(Sr[s]);
  return e;
}
const rb = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], c$ = "dthko", sb = [16, 17, 18, 20, 91, 92, 224, 225], Ha = 6;
function Ka(r) {
  return Math.max(0, r) * 0.7 + 8;
}
function u$(r, e) {
  return Math.max(Math.abs(r.clientX - e.clientX), Math.abs(r.clientY - e.clientY));
}
class d$ {
  constructor(e, t, s, n) {
    this.view = e, this.startEvent = t, this.style = s, this.mustSelect = n, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = x2(e.contentDOM), this.atoms = e.state.facet(Zh).map((i) => i(e));
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(Me.allowMultipleSelections) && h$(e, t), this.dragging = p$(e, t) && ab(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && u$(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let s = 0, n = 0, o = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, i = Qy(this.view);
    e.clientX - i.left <= o.left + Ha ? s = -Ka(o.left - e.clientX) : e.clientX + i.right >= o.right - Ha && (s = Ka(e.clientX - o.right)), e.clientY - i.top <= o.top + Ha ? n = -Ka(o.top - e.clientY) : e.clientY + i.bottom >= o.bottom - Ha && (n = Ka(e.clientY - o.bottom)), this.setScrollSpeed(s, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let s = 0; s < e.ranges.length; s++) {
      let n = e.ranges[s], o = null;
      if (n.empty) {
        let i = xl(this.atoms, n.from, 0);
        i != n.from && (o = de.cursor(i, -1));
      } else {
        let i = xl(this.atoms, n.from, -1), a = xl(this.atoms, n.to, 1);
        (i != n.from || a != n.to) && (o = de.range(n.from == n.anchor ? i : a, n.from == n.head ? i : a));
      }
      o && (t || (t = e.ranges.slice()), t[s] = o);
    }
    return t ? de.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, s = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !s.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: s,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function h$(r, e) {
  let t = r.state.facet(Vy);
  return t.length ? t[0](e) : le.mac ? e.metaKey : e.ctrlKey;
}
function f$(r, e) {
  let t = r.state.facet(Uy);
  return t.length ? t[0](e) : le.mac ? !e.altKey : !e.ctrlKey;
}
function p$(r, e) {
  let { main: t } = r.state.selection;
  if (t.empty)
    return !1;
  let s = ql(r.root);
  if (!s || s.rangeCount == 0)
    return !0;
  let n = s.getRangeAt(0).getClientRects();
  for (let o = 0; o < n.length; o++) {
    let i = n[o];
    if (i.left <= e.clientX && i.right >= e.clientX && i.top <= e.clientY && i.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function m$(r, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, s; t != r.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (s = Ge.get(t)) && s.ignoreEvent(e))
      return !1;
  return !0;
}
const kr = /* @__PURE__ */ Object.create(null), Sr = /* @__PURE__ */ Object.create(null), nb = le.ie && le.ie_version < 15 || le.ios && le.webkit_version < 604;
function g$(r) {
  let e = r.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    r.focus(), t.remove(), ob(r, t.value);
  }, 50);
}
function ob(r, e) {
  let { state: t } = r, s, n = 1, o = t.toText(e), i = o.lines == t.selection.ranges.length;
  if (Dd != null && t.selection.ranges.every((l) => l.empty) && Dd == o.toString()) {
    let l = -1;
    s = t.changeByRange((c) => {
      let u = t.doc.lineAt(c.from);
      if (u.from == l)
        return { range: c };
      l = u.from;
      let d = t.toText((i ? o.line(n++).text : e) + t.lineBreak);
      return {
        changes: { from: u.from, insert: d },
        range: de.cursor(c.from + d.length)
      };
    });
  } else
    i ? s = t.changeByRange((l) => {
      let c = o.line(n++);
      return {
        changes: { from: l.from, to: l.to, insert: c.text },
        range: de.cursor(l.from + c.length)
      };
    }) : s = t.replaceSelection(o);
  r.dispatch(s, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Sr.scroll = (r) => {
  r.inputState.lastScrollTop = r.scrollDOM.scrollTop, r.inputState.lastScrollLeft = r.scrollDOM.scrollLeft;
};
kr.keydown = (r, e) => (r.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (r.inputState.lastEscPress = Date.now()), !1);
Sr.touchstart = (r, e) => {
  r.inputState.lastTouchTime = Date.now(), r.inputState.setSelectionOrigin("select.pointer");
};
Sr.touchmove = (r) => {
  r.inputState.setSelectionOrigin("select.pointer");
};
kr.mousedown = (r, e) => {
  if (r.observer.flush(), r.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let s of r.state.facet(zy))
    if (t = s(r, e), t)
      break;
  if (!t && e.button == 0 && (t = v$(r, e)), t) {
    let s = !r.hasFocus;
    r.inputState.startMouseSelection(new d$(r, e, t, s)), s && r.observer.ignore(() => _y(r.contentDOM));
    let n = r.inputState.mouseSelection;
    if (n)
      return n.start(e), n.dragging === !1;
  }
  return !1;
};
function Am(r, e, t, s) {
  if (s == 1)
    return de.cursor(e, t);
  if (s == 2)
    return Q2(r.state, e, t);
  {
    let n = lt.find(r.docView, e), o = r.state.doc.lineAt(n ? n.posAtEnd : e), i = n ? n.posAtStart : o.from, a = n ? n.posAtEnd : o.to;
    return a < r.state.doc.length && a == o.to && a++, de.range(i, a);
  }
}
let ib = (r, e) => r >= e.top && r <= e.bottom, Em = (r, e, t) => ib(e, t) && r >= t.left && r <= t.right;
function y$(r, e, t, s) {
  let n = lt.find(r.docView, e);
  if (!n)
    return 1;
  let o = e - n.posAtStart;
  if (o == 0)
    return 1;
  if (o == n.length)
    return -1;
  let i = n.coordsAt(o, -1);
  if (i && Em(t, s, i))
    return -1;
  let a = n.coordsAt(o, 1);
  return a && Em(t, s, a) ? 1 : i && ib(s, i) ? -1 : 1;
}
function Om(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: y$(r, t, e.clientX, e.clientY) };
}
const b$ = le.ie && le.ie_version <= 11;
let Tm = null, Pm = 0, Im = 0;
function ab(r) {
  if (!b$)
    return r.detail;
  let e = Tm, t = Im;
  return Tm = r, Im = Date.now(), Pm = !e || t > Date.now() - 400 && Math.abs(e.clientX - r.clientX) < 2 && Math.abs(e.clientY - r.clientY) < 2 ? (Pm + 1) % 3 : 1;
}
function v$(r, e) {
  let t = Om(r, e), s = ab(e), n = r.state.selection;
  return {
    update(o) {
      o.docChanged && (t.pos = o.changes.mapPos(t.pos), n = n.map(o.changes));
    },
    get(o, i, a) {
      let l = Om(r, o), c, u = Am(r, l.pos, l.bias, s);
      if (t.pos != l.pos && !i) {
        let d = Am(r, t.pos, t.bias, s), h = Math.min(d.from, u.from), f = Math.max(d.to, u.to);
        u = h < u.from ? de.range(h, f) : de.range(f, h);
      }
      return i ? n.replaceRange(n.main.extend(u.from, u.to)) : a && s == 1 && n.ranges.length > 1 && (c = w$(n, l.pos)) ? c : a ? n.addRange(u) : de.create([u]);
    }
  };
}
function w$(r, e) {
  for (let t = 0; t < r.ranges.length; t++) {
    let { from: s, to: n } = r.ranges[t];
    if (s <= e && n >= e)
      return de.create(r.ranges.slice(0, t).concat(r.ranges.slice(t + 1)), r.mainIndex == t ? 0 : r.mainIndex - (r.mainIndex > t ? 1 : 0));
  }
  return null;
}
kr.dragstart = (r, e) => {
  let { selection: { main: t } } = r.state;
  if (e.target.draggable) {
    let n = r.docView.nearest(e.target);
    if (n && n.isWidget) {
      let o = n.posAtStart, i = o + n.length;
      (o >= t.to || i <= t.from) && (t = de.range(o, i));
    }
  }
  let { inputState: s } = r;
  return s.mouseSelection && (s.mouseSelection.dragging = !0), s.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", r.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
kr.dragend = (r) => (r.inputState.draggedContent = null, !1);
function Nm(r, e, t, s) {
  if (!t)
    return;
  let n = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: o } = r.inputState, i = s && o && f$(r, e) ? { from: o.from, to: o.to } : null, a = { from: n, insert: t }, l = r.state.changes(i ? [i, a] : a);
  r.focus(), r.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(n, -1), head: l.mapPos(n, 1) },
    userEvent: i ? "move.drop" : "input.drop"
  }), r.inputState.draggedContent = null;
}
kr.drop = (r, e) => {
  if (!e.dataTransfer)
    return !1;
  if (r.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let s = Array(t.length), n = 0, o = () => {
      ++n == t.length && Nm(r, e, s.filter((i) => i != null).join(r.state.lineBreak), !1);
    };
    for (let i = 0; i < t.length; i++) {
      let a = new FileReader();
      a.onerror = o, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (s[i] = a.result), o();
      }, a.readAsText(t[i]);
    }
    return !0;
  } else {
    let s = e.dataTransfer.getData("Text");
    if (s)
      return Nm(r, e, s, !0), !0;
  }
  return !1;
};
kr.paste = (r, e) => {
  if (r.state.readOnly)
    return !0;
  r.observer.flush();
  let t = nb ? null : e.clipboardData;
  return t ? (ob(r, t.getData("text/plain") || t.getData("text/uri-text")), !0) : (g$(r), !1);
};
function k$(r, e) {
  let t = r.dom.parentNode;
  if (!t)
    return;
  let s = t.appendChild(document.createElement("textarea"));
  s.style.cssText = "position: fixed; left: -10000px; top: 10px", s.value = e, s.focus(), s.selectionEnd = e.length, s.selectionStart = 0, setTimeout(() => {
    s.remove(), r.focus();
  }, 50);
}
function S$(r) {
  let e = [], t = [], s = !1;
  for (let n of r.selection.ranges)
    n.empty || (e.push(r.sliceDoc(n.from, n.to)), t.push(n));
  if (!e.length) {
    let n = -1;
    for (let { from: o } of r.selection.ranges) {
      let i = r.doc.lineAt(o);
      i.number > n && (e.push(i.text), t.push({ from: i.from, to: Math.min(r.doc.length, i.to + 1) })), n = i.number;
    }
    s = !0;
  }
  return { text: e.join(r.lineBreak), ranges: t, linewise: s };
}
let Dd = null;
kr.copy = kr.cut = (r, e) => {
  let { text: t, ranges: s, linewise: n } = S$(r.state);
  if (!t && !n)
    return !1;
  Dd = n ? t : null, e.type == "cut" && !r.state.readOnly && r.dispatch({
    changes: s,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let o = nb ? null : e.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", t), !0) : (k$(r, t), !1);
};
const lb = /* @__PURE__ */ Io.define();
function cb(r, e) {
  let t = [];
  for (let s of r.facet(Ky)) {
    let n = s(r, e);
    n && t.push(n);
  }
  return t ? r.update({ effects: t, annotations: lb.of(!0) }) : null;
}
function ub(r) {
  setTimeout(() => {
    let e = r.hasFocus;
    if (e != r.inputState.notifiedFocused) {
      let t = cb(r.state, e);
      t ? r.dispatch(t) : r.update([]);
    }
  }, 10);
}
Sr.focus = (r) => {
  r.inputState.lastFocusTime = Date.now(), !r.scrollDOM.scrollTop && (r.inputState.lastScrollTop || r.inputState.lastScrollLeft) && (r.scrollDOM.scrollTop = r.inputState.lastScrollTop, r.scrollDOM.scrollLeft = r.inputState.lastScrollLeft), ub(r);
};
Sr.blur = (r) => {
  r.observer.clearSelectionRange(), ub(r);
};
Sr.compositionstart = Sr.compositionupdate = (r) => {
  r.inputState.compositionFirstChange == null && (r.inputState.compositionFirstChange = !0), r.inputState.composing < 0 && (r.inputState.composing = 0);
};
Sr.compositionend = (r) => {
  r.inputState.composing = -1, r.inputState.compositionEndedAt = Date.now(), r.inputState.compositionPendingKey = !0, r.inputState.compositionPendingChange = r.observer.pendingRecords().length > 0, r.inputState.compositionFirstChange = null, le.chrome && le.android ? r.observer.flushSoon() : r.inputState.compositionPendingChange ? Promise.resolve().then(() => r.observer.flush()) : setTimeout(() => {
    r.inputState.composing < 0 && r.docView.hasComposition && r.update([]);
  }, 50);
};
Sr.contextmenu = (r) => {
  r.inputState.lastContextMenu = Date.now();
};
kr.beforeinput = (r, e) => {
  var t;
  let s;
  if (le.chrome && le.android && (s = rb.find((n) => n.inputType == e.inputType)) && (r.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let n = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > n + 10 && r.hasFocus && (r.contentDOM.blur(), r.focus());
    }, 100);
  }
  return !1;
};
const Mm = /* @__PURE__ */ new Set();
function $$(r) {
  Mm.has(r) || (Mm.add(r), r.addEventListener("copy", () => {
  }), r.addEventListener("cut", () => {
  }));
}
const Dm = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class _$ {
  constructor(e) {
    this.lineWrapping = e, this.doc = je.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let s = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (s += Math.max(0, Math.ceil((t - e - s * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * s;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return Dm.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let s = 0; s < e.length; s++) {
      let n = e[s];
      n < 0 ? s++ : this.heightSamples[Math.floor(n * 10)] || (t = !0, this.heightSamples[Math.floor(n * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, s, n, o, i) {
    let a = Dm.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = t, this.charWidth = s, this.textHeight = n, this.lineLength = o, l) {
      this.heightSamples = {};
      for (let c = 0; c < i.length; c++) {
        let u = i[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}
class x$ {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Rr {
  /**
  @internal
  */
  constructor(e, t, s, n, o) {
    this.from = e, this.length = t, this.top = s, this.height = n, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? yr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Ls ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Rr(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Ke = /* @__PURE__ */ function(r) {
  return r[r.ByPos = 0] = "ByPos", r[r.ByHeight = 1] = "ByHeight", r[r.ByPosNoHeight = 2] = "ByPosNoHeight", r;
}(Ke || (Ke = {}));
const Cl = 1e-3;
class Pt {
  constructor(e, t, s = 2) {
    this.length = e, this.height = t, this.flags = s;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > Cl && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, s) {
    return Pt.of(s);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, s, n) {
    let o = this, i = s.doc;
    for (let a = n.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: d } = n[a], h = o.lineAt(l, Ke.ByPosNoHeight, s.setDoc(t), 0, 0), f = h.to >= c ? h : o.lineAt(c, Ke.ByPosNoHeight, s, 0, 0);
      for (d += f.to - c, c = f.to; a > 0 && h.from <= n[a - 1].toA; )
        l = n[a - 1].fromA, u = n[a - 1].fromB, a--, l < h.from && (h = o.lineAt(l, Ke.ByPosNoHeight, s, 0, 0));
      u += h.from - l, l = h.from;
      let m = ef.build(s.setDoc(i), e, u, d);
      o = o.replace(l, c, m);
    }
    return o.updateHeight(s, 0);
  }
  static empty() {
    return new Vt(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, s = e.length, n = 0, o = 0;
    for (; ; )
      if (t == s)
        if (n > o * 2) {
          let a = e[t - 1];
          a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right), s += 1 + a.break, n -= a.size;
        } else if (o > n * 2) {
          let a = e[s];
          a.break ? e.splice(s, 1, a.left, null, a.right) : e.splice(s, 1, a.left, a.right), s += 2 + a.break, o -= a.size;
        } else
          break;
      else if (n < o) {
        let a = e[t++];
        a && (n += a.size);
      } else {
        let a = e[--s];
        a && (o += a.size);
      }
    let i = 0;
    return e[t - 1] == null ? (i = 1, t--) : e[t] == null && (i = 1, s++), new C$(Pt.of(e.slice(0, t)), i, Pt.of(e.slice(s)));
  }
}
Pt.prototype.size = 1;
class db extends Pt {
  constructor(e, t, s) {
    super(e, t), this.deco = s;
  }
  blockAt(e, t, s, n) {
    return new Rr(n, this.length, s, this.height, this.deco || 0);
  }
  lineAt(e, t, s, n, o) {
    return this.blockAt(0, s, n, o);
  }
  forEachLine(e, t, s, n, o, i) {
    e <= o + this.length && t >= o && i(this.blockAt(0, s, n, o));
  }
  updateHeight(e, t = 0, s = !1, n) {
    return n && n.from <= t && n.more && this.setHeight(e, n.heights[n.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Vt extends db {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, s, n) {
    return new Rr(n, this.length, s, this.height, this.breaks);
  }
  replace(e, t, s) {
    let n = s[0];
    return s.length == 1 && (n instanceof Vt || n instanceof gt && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof gt ? n = new Vt(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : Pt.of(s);
  }
  updateHeight(e, t = 0, s = !1, n) {
    return n && n.from <= t && n.more ? this.setHeight(e, n.heights[n.index++]) : (s || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class gt extends Pt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let s = e.doc.lineAt(t).number, n = e.doc.lineAt(t + this.length).number, o = n - s + 1, i, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * o);
      i = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
    } else
      i = this.height / o;
    return { firstLine: s, lastLine: n, perLine: i, perChar: a };
  }
  blockAt(e, t, s, n) {
    let { firstLine: o, lastLine: i, perLine: a, perChar: l } = this.heightMetrics(t, n);
    if (t.lineWrapping) {
      let c = n + Math.round(Math.max(0, Math.min(1, (e - s) / this.height)) * this.length), u = t.doc.lineAt(c), d = a + u.length * l, h = Math.max(s, e - d / 2);
      return new Rr(u.from, u.length, h, d, 0);
    } else {
      let c = Math.max(0, Math.min(i - o, Math.floor((e - s) / a))), { from: u, length: d } = t.doc.line(o + c);
      return new Rr(u, d, s + a * c, a, 0);
    }
  }
  lineAt(e, t, s, n, o) {
    if (t == Ke.ByHeight)
      return this.blockAt(e, s, n, o);
    if (t == Ke.ByPosNoHeight) {
      let { from: f, to: m } = s.doc.lineAt(e);
      return new Rr(f, m - f, 0, 0, 0);
    }
    let { firstLine: i, perLine: a, perChar: l } = this.heightMetrics(s, o), c = s.doc.lineAt(e), u = a + c.length * l, d = c.number - i, h = n + a * d + l * (c.from - o - d);
    return new Rr(c.from, c.length, Math.max(n, Math.min(h, n + this.height - u)), u, 0);
  }
  forEachLine(e, t, s, n, o, i) {
    e = Math.max(e, o), t = Math.min(t, o + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(s, o);
    for (let u = e, d = n; u <= t; ) {
      let h = s.doc.lineAt(u);
      if (u == e) {
        let m = h.number - a;
        d += l * m + c * (e - o - m);
      }
      let f = l + c * h.length;
      i(new Rr(h.from, h.length, d, f, 0)), d += f, u = h.to + 1;
    }
  }
  replace(e, t, s) {
    let n = this.length - t;
    if (n > 0) {
      let o = s[s.length - 1];
      o instanceof gt ? s[s.length - 1] = new gt(o.length + n) : s.push(null, new gt(n - 1));
    }
    if (e > 0) {
      let o = s[0];
      o instanceof gt ? s[0] = new gt(e + o.length) : s.unshift(new gt(e - 1), null);
    }
    return Pt.of(s);
  }
  decomposeLeft(e, t) {
    t.push(new gt(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new gt(this.length - e - 1));
  }
  updateHeight(e, t = 0, s = !1, n) {
    let o = t + this.length;
    if (n && n.from <= t + this.length && n.more) {
      let i = [], a = Math.max(t, n.from), l = -1;
      for (n.from > t && i.push(new gt(n.from - t - 1).updateHeight(e, t)); a <= o && n.more; ) {
        let u = e.doc.lineAt(a).length;
        i.length && i.push(null);
        let d = n.heights[n.index++];
        l == -1 ? l = d : Math.abs(d - l) >= Cl && (l = -2);
        let h = new Vt(u, d);
        h.outdated = !1, i.push(h), a += u + 1;
      }
      a <= o && i.push(null, new gt(o - a).updateHeight(e, a));
      let c = Pt.of(i);
      return (l < 0 || Math.abs(c.height - this.height) >= Cl || Math.abs(l - this.heightMetrics(e, t).perLine) >= Cl) && (e.heightChanged = !0), c;
    } else
      (s || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class C$ extends Pt {
  constructor(e, t, s) {
    super(e.length + t + s.length, e.height + s.height, t | (e.outdated || s.outdated ? 2 : 0)), this.left = e, this.right = s, this.size = e.size + s.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, s, n) {
    let o = s + this.left.height;
    return e < o ? this.left.blockAt(e, t, s, n) : this.right.blockAt(e, t, o, n + this.left.length + this.break);
  }
  lineAt(e, t, s, n, o) {
    let i = n + this.left.height, a = o + this.left.length + this.break, l = t == Ke.ByHeight ? e < i : e < a, c = l ? this.left.lineAt(e, t, s, n, o) : this.right.lineAt(e, t, s, i, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let u = t == Ke.ByPosNoHeight ? Ke.ByPosNoHeight : Ke.ByPos;
    return l ? c.join(this.right.lineAt(a, u, s, i, a)) : this.left.lineAt(a, u, s, n, o).join(c);
  }
  forEachLine(e, t, s, n, o, i) {
    let a = n + this.left.height, l = o + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, s, n, o, i), t >= l && this.right.forEachLine(e, t, s, a, l, i);
    else {
      let c = this.lineAt(l, Ke.ByPos, s, n, o);
      e < c.from && this.left.forEachLine(e, c.from - 1, s, n, o, i), c.to >= e && c.from <= t && i(c), t > c.to && this.right.forEachLine(c.to + 1, t, s, a, l, i);
    }
  }
  replace(e, t, s) {
    let n = this.left.length + this.break;
    if (t < n)
      return this.balanced(this.left.replace(e, t, s), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - n, t - n, s));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let i = o.length;
    for (let a of s)
      o.push(a);
    if (e > 0 && Rm(o, i - 1), t < this.length) {
      let a = o.length;
      this.decomposeRight(t, o), Rm(o, a);
    }
    return Pt.of(o);
  }
  decomposeLeft(e, t) {
    let s = this.left.length;
    if (e <= s)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (s++, e >= s && t.push(null)), e > s && this.right.decomposeLeft(e - s, t);
  }
  decomposeRight(e, t) {
    let s = this.left.length, n = s + this.break;
    if (e >= n)
      return this.right.decomposeRight(e - n, t);
    e < s && this.left.decomposeRight(e, t), this.break && e < n && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Pt.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, s = !1, n) {
    let { left: o, right: i } = this, a = t + o.length + this.break, l = null;
    return n && n.from <= t + o.length && n.more ? l = o = o.updateHeight(e, t, s, n) : o.updateHeight(e, t, s), n && n.from <= a + i.length && n.more ? l = i = i.updateHeight(e, a, s, n) : i.updateHeight(e, a, s), l ? this.balanced(o, i) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function Rm(r, e) {
  let t, s;
  r[e] == null && (t = r[e - 1]) instanceof gt && (s = r[e + 1]) instanceof gt && r.splice(e - 1, 3, new gt(t.length + 1 + s.length));
}
const A$ = 5;
class ef {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let s = Math.min(t, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof Vt ? n.length += s - this.pos : (s > this.pos || !this.isCovered) && this.nodes.push(new Vt(s - this.pos, -1)), this.writtenTo = s, t > s && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, s) {
    if (e < t || s.heightRelevant) {
      let n = s.widget ? s.widget.estimatedHeight : 0, o = s.widget ? s.widget.lineBreaks : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let i = t - e;
      s.block ? this.addBlock(new db(i, n, s)) : (i || o || n >= A$) && this.addLineDeco(n, o, i);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Vt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let s = new gt(t - e);
    return this.oracle.doc.lineAt(e).to == t && (s.flags |= 4), s;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Vt)
      return e;
    let t = new Vt(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, s) {
    let n = this.ensureLine();
    n.length += s, n.collapsed += s, n.widgetHeight = Math.max(n.widgetHeight, e), n.breaks += t, this.writtenTo = this.pos = this.pos + s;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Vt) && !this.isCovered ? this.nodes.push(new Vt(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let s = e;
    for (let n of this.nodes)
      n instanceof Vt && n.updateHeight(this.oracle, s), s += n ? n.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, s, n) {
    let o = new ef(s, e);
    return Re.spans(t, s, n, o, 0), o.finish(s);
  }
}
function E$(r, e, t) {
  let s = new O$();
  return Re.compare(r, e, t, s, 0), s.changes;
}
class O$ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, s, n) {
    (e < t || s && s.heightRelevant || n && n.heightRelevant) && Od(e, t, this.changes, 5);
  }
}
function T$(r, e) {
  let t = r.getBoundingClientRect(), s = r.ownerDocument, n = s.defaultView || window, o = Math.max(0, t.left), i = Math.min(n.innerWidth, t.right), a = Math.max(0, t.top), l = Math.min(n.innerHeight, t.bottom);
  for (let c = r.parentNode; c && c != s.body; )
    if (c.nodeType == 1) {
      let u = c, d = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && d.overflow != "visible") {
        let h = u.getBoundingClientRect();
        o = Math.max(o, h.left), i = Math.min(i, h.right), a = Math.max(a, h.top), l = c == r.parentNode ? h.bottom : Math.min(l, h.bottom);
      }
      c = d.position == "absolute" || d.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: o - t.left,
    right: Math.max(o, i) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  };
}
function P$(r, e) {
  let t = r.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class ku {
  constructor(e, t, s) {
    this.from = e, this.to = t, this.size = s;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let s = 0; s < e.length; s++) {
      let n = e[s], o = t[s];
      if (n.from != o.from || n.to != o.to || n.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return Je.replace({
      widget: new I$(this.size * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class I$ extends fa {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class jm {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = Lm, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = ct.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Qh).some((s) => typeof s != "function" && s.class == "cm-lineWrapping");
    this.heightOracle = new _$(t), this.stateDeco = e.facet(Xi).filter((s) => typeof s != "function"), this.heightMap = Pt.empty().applyChanges(this.stateDeco, je.empty, this.heightOracle.setDoc(e.doc), [new tr(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Je.set(this.lineGaps.map((s) => s.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let s = 0; s <= 1; s++) {
      let n = s ? t.head : t.anchor;
      if (!e.some(({ from: o, to: i }) => n >= o && n <= i)) {
        let { from: o, to: i } = this.lineBlockAt(n);
        e.push(new Wa(o, i));
      }
    }
    this.viewports = e.sort((s, n) => s.from - n.from), this.scaler = this.heightMap.height <= 7e6 ? Lm : new D$(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : ki(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let s = this.stateDeco;
    this.stateDeco = this.state.facet(Xi).filter((u) => typeof u != "function");
    let n = e.changedRanges, o = tr.extendWithRanges(n, E$(s, this.stateDeco, e ? e.changes : ft.empty(this.state.doc.length))), i = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), this.heightMap.height != i && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let c = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(z2) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, s = window.getComputedStyle(t), n = this.heightOracle, o = s.whiteSpace;
    this.defaultTextDirection = s.direction == "rtl" ? ct.RTL : ct.LTR;
    let i = this.heightOracle.mustRefreshForWrapping(o), a = t.getBoundingClientRect(), l = i || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: k, scaleY: _ } = $y(t, a);
      (this.scaleX != k || this.scaleY != _) && (this.scaleX = k, this.scaleY = _, c |= 8, i = l = !0);
    }
    let d = (parseInt(s.paddingTop) || 0) * this.scaleY, h = (parseInt(s.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != h) && (this.paddingTop = d, this.paddingBottom = h, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (n.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let f = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f && (this.scrollAnchorHeight = -1, this.scrollTop = f), this.scrolledToBottom = Cy(e.scrollDOM);
    let m = (this.printing ? P$ : T$)(t, this.paddingTop), g = m.top - this.pixelViewport.top, p = m.bottom - this.pixelViewport.bottom;
    this.pixelViewport = m;
    let y = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (y != this.inView && (this.inView = y, y && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let b = a.width;
    if ((this.contentDOMWidth != b || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), l) {
      let k = e.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights(k) && (i = !0), i || n.lineWrapping && Math.abs(b - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: _, charWidth: w, textHeight: x } = e.docView.measureTextSize();
        i = _ > 0 && n.refresh(o, _, w, x, b / w, k), i && (e.docView.minWidth = 0, c |= 8);
      }
      g > 0 && p > 0 ? u = Math.max(g, p) : g < 0 && p < 0 && (u = Math.min(g, p)), n.heightChanged = !1;
      for (let _ of this.viewports) {
        let w = _.from == this.viewport.from ? k : e.docView.measureVisibleLineHeights(_);
        this.heightMap = (i ? Pt.empty().applyChanges(this.stateDeco, je.empty, this.heightOracle, [new tr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(n, 0, i, new x$(_.from, w));
      }
      n.heightChanged && (c |= 2);
    }
    let v = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return v && (this.viewport = this.getViewport(u, this.scrollTarget)), this.updateForViewport(), (c & 2 || v) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(i ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let s = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), n = this.heightMap, o = this.heightOracle, { visibleTop: i, visibleBottom: a } = this, l = new Wa(n.lineAt(i - s * 1e3, Ke.ByHeight, o, 0, 0).from, n.lineAt(a + (1 - s) * 1e3, Ke.ByHeight, o, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = n.lineAt(c, Ke.ByPos, o, 0, 0), h;
        t.y == "center" ? h = (d.top + d.bottom) / 2 - u / 2 : t.y == "start" || t.y == "nearest" && c < l.from ? h = d.top : h = d.bottom - u, l = new Wa(n.lineAt(h - 1e3 / 2, Ke.ByHeight, o, 0, 0).from, n.lineAt(h + u + 1e3 / 2, Ke.ByHeight, o, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let s = t.mapPos(e.from, -1), n = t.mapPos(e.to, 1);
    return new Wa(this.heightMap.lineAt(s, Ke.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(n, Ke.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, s = 0) {
    if (!this.inView)
      return !0;
    let { top: n } = this.heightMap.lineAt(e, Ke.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(t, Ke.ByPos, this.heightOracle, 0, 0), { visibleTop: i, visibleBottom: a } = this;
    return (e == 0 || n <= i - Math.max(10, Math.min(
      -s,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || o >= a + Math.max(10, Math.min(
      s,
      250
      /* VP.MaxCoverMargin */
    ))) && n > i - 2 * 1e3 && o < a + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let s = [];
    for (let n of e)
      t.touchesRange(n.from, n.to) || s.push(new ku(t.mapPos(n.from), t.mapPos(n.to), n.size));
    return s;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let s = this.heightOracle.lineWrapping, n = s ? 1e4 : 2e3, o = n >> 1, i = n << 1;
    if (this.defaultTextDirection != ct.LTR && !s)
      return [];
    let a = [], l = (c, u, d, h) => {
      if (u - c < o)
        return;
      let f = this.state.selection.main, m = [f.from];
      f.empty || m.push(f.to);
      for (let p of m)
        if (p > c && p < u) {
          l(c, p - 10, d, h), l(p + 10, u, d, h);
          return;
        }
      let g = M$(e, (p) => p.from >= d.from && p.to <= d.to && Math.abs(p.from - c) < o && Math.abs(p.to - u) < o && !m.some((y) => p.from < y && p.to > y));
      if (!g) {
        if (u < d.to && t && s && t.visibleRanges.some((p) => p.from <= u && p.to >= u)) {
          let p = t.moveToLineBoundary(de.cursor(u), !1, !0).head;
          p > c && (u = p);
        }
        g = new ku(c, u, this.gapSize(d, c, u, h));
      }
      a.push(g);
    };
    for (let c of this.viewportLines) {
      if (c.length < i)
        continue;
      let u = N$(c.from, c.to, this.stateDeco);
      if (u.total < i)
        continue;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, h, f;
      if (s) {
        let m = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, p;
        if (d != null) {
          let y = Ja(u, d), b = ((this.visibleBottom - this.visibleTop) / 2 + m) / c.height;
          g = y - b, p = y + b;
        } else
          g = (this.visibleTop - c.top - m) / c.height, p = (this.visibleBottom - c.top + m) / c.height;
        h = Ga(u, g), f = Ga(u, p);
      } else {
        let m = u.total * this.heightOracle.charWidth, g = n * this.heightOracle.charWidth, p, y;
        if (d != null) {
          let b = Ja(u, d), v = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / m;
          p = b - v, y = b + v;
        } else
          p = (this.pixelViewport.left - g) / m, y = (this.pixelViewport.right + g) / m;
        h = Ga(u, p), f = Ga(u, y);
      }
      h > c.from && l(c.from, h, c, u), f < c.to && l(f, c.to, c, u);
    }
    return a;
  }
  gapSize(e, t, s, n) {
    let o = Ja(n, s) - Ja(n, t);
    return this.heightOracle.lineWrapping ? e.height * o : n.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    ku.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Je.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    Re.spans(e, this.viewport.from, this.viewport.to, {
      span(n, o) {
        t.push({ from: n, to: o });
      },
      point() {
      }
    }, 20);
    let s = t.length != this.visibleRanges.length || this.visibleRanges.some((n, o) => n.from != t[o].from || n.to != t[o].to);
    return this.visibleRanges = t, s ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || ki(this.heightMap.lineAt(e, Ke.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return ki(this.heightMap.lineAt(this.scaler.fromDOM(e), Ke.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return ki(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Wa {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function N$(r, e, t) {
  let s = [], n = r, o = 0;
  return Re.spans(t, r, e, {
    span() {
    },
    point(i, a) {
      i > n && (s.push({ from: n, to: i }), o += i - n), n = a;
    }
  }, 20), n < e && (s.push({ from: n, to: e }), o += e - n), { total: o, ranges: s };
}
function Ga({ total: r, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let s = Math.floor(r * t);
  for (let n = 0; ; n++) {
    let { from: o, to: i } = e[n], a = i - o;
    if (s <= a)
      return o + s;
    s -= a;
  }
}
function Ja(r, e) {
  let t = 0;
  for (let { from: s, to: n } of r.ranges) {
    if (e <= n) {
      t += e - s;
      break;
    }
    t += n - s;
  }
  return t / r.total;
}
function M$(r, e) {
  for (let t of r)
    if (e(t))
      return t;
}
const Lm = {
  toDOM(r) {
    return r;
  },
  fromDOM(r) {
    return r;
  },
  scale: 1
};
class D$ {
  constructor(e, t, s) {
    let n = 0, o = 0, i = 0;
    this.viewports = s.map(({ from: a, to: l }) => {
      let c = t.lineAt(a, Ke.ByPos, e, 0, 0).top, u = t.lineAt(l, Ke.ByPos, e, 0, 0).bottom;
      return n += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (t.height - n);
    for (let a of this.viewports)
      a.domTop = i + (a.top - o) * this.scale, i = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
  }
  toDOM(e) {
    for (let t = 0, s = 0, n = 0; ; t++) {
      let o = t < this.viewports.length ? this.viewports[t] : null;
      if (!o || e < o.top)
        return n + (e - s) * this.scale;
      if (e <= o.bottom)
        return o.domTop + (e - o.top);
      s = o.bottom, n = o.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, s = 0, n = 0; ; t++) {
      let o = t < this.viewports.length ? this.viewports[t] : null;
      if (!o || e < o.domTop)
        return s + (e - n) / this.scale;
      if (e <= o.domBottom)
        return o.top + (e - o.domTop);
      s = o.bottom, n = o.domBottom;
    }
  }
}
function ki(r, e) {
  if (e.scale == 1)
    return r;
  let t = e.toDOM(r.top), s = e.toDOM(r.bottom);
  return new Rr(r.from, r.length, t, s - t, Array.isArray(r._content) ? r._content.map((n) => ki(n, e)) : r._content);
}
const Ya = /* @__PURE__ */ pe.define({ combine: (r) => r.join(" ") }), Rd = /* @__PURE__ */ pe.define({ combine: (r) => r.indexOf(!0) > -1 }), jd = /* @__PURE__ */ Rs.newName(), hb = /* @__PURE__ */ Rs.newName(), fb = /* @__PURE__ */ Rs.newName(), pb = { "&light": "." + hb, "&dark": "." + fb };
function Ld(r, e, t) {
  return new Rs(e, {
    finish(s) {
      return /&/.test(s) ? s.replace(/&\w*/, (n) => {
        if (n == "&")
          return r;
        if (!t || !t[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return t[n];
      }) : r + " " + s;
    }
  });
}
const R$ = /* @__PURE__ */ Ld("." + jd, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, pb), Si = "￿";
class j$ {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(Me.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Si;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let s = e.parentNode;
    for (let n = e; ; ) {
      this.findPointBefore(s, n);
      let o = this.text.length;
      this.readNode(n);
      let i = n.nextSibling;
      if (i == t)
        break;
      let a = Ge.get(n), l = Ge.get(i);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Bm(n)) || Bm(i) && (n.nodeName != "BR" || n.cmIgnore) && this.text.length > o) && this.lineBreak(), n = i;
    }
    return this.findPointBefore(s, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let s of this.points)
      s.node == e && (s.pos = this.text.length + Math.min(s.offset, t.length));
    for (let s = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, i = 1, a;
      if (this.lineSeparator ? (o = t.indexOf(this.lineSeparator, s), i = this.lineSeparator.length) : (a = n.exec(t)) && (o = a.index, i = a[0].length), this.append(t.slice(s, o < 0 ? t.length : o)), o < 0)
        break;
      if (this.lineBreak(), i > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= i - 1);
      s = o + i;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Ge.get(e), s = t && t.overrideDOMText;
    if (s != null) {
      this.findPointInside(e, s.length);
      for (let n = s.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let s of this.points)
      s.node == e && e.childNodes[s.offset] == t && (s.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let s of this.points)
      (e.nodeType == 3 ? s.node == e : e.contains(s.node)) && (s.pos = this.text.length + (L$(e, s.node, s.offset) ? t : 0));
  }
}
function L$(r, e, t) {
  for (; ; ) {
    if (!e || t < is(e))
      return !1;
    if (e == r)
      return !0;
    t = Yi(e) + 1, e = e.parentNode;
  }
}
function Bm(r) {
  return r.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(r.nodeName);
}
class Fm {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class B$ {
  constructor(e, t, s, n) {
    this.typeOver = n, this.bounds = null, this.text = "";
    let { impreciseHead: o, impreciseAnchor: i } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, s, 0))) {
      let a = o || i ? [] : U$(e), l = new j$(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = z$(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !$d(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = i && i.node == a.anchorNode && i.offset == a.anchorOffset || !$d(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
      if ((le.ios || le.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let d = Math.min(l, c), h = Math.max(l, c), f = u.from - d, m = u.to - h;
        (f == 0 || f == 1 || d == 0) && (m == 0 || m == -1 || h == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = de.single(c, l);
    }
  }
}
function mb(r, e) {
  let t, { newSel: s } = e, n = r.state.selection.main, o = r.inputState.lastKeyTime > Date.now() - 100 ? r.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: i, to: a } = e.bounds, l = n.from, c = null;
    (o === 8 || le.android && e.text.length < a - i) && (l = n.to, c = "end");
    let u = V$(r.state.doc.sliceString(i, a, Si), e.text, l - i, c);
    u && (le.chrome && o == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Si + Si && u.toB--, t = {
      from: i + u.from,
      to: i + u.toA,
      insert: je.of(e.text.slice(u.from, u.toB).split(Si))
    });
  } else
    s && (!r.hasFocus && r.state.facet(xc) || s.main.eq(n)) && (s = null);
  if (!t && !s)
    return !1;
  if (!t && e.typeOver && !n.empty && s && s.main.empty ? t = { from: n.from, to: n.to, insert: r.state.doc.slice(n.from, n.to) } : t && t.from >= n.from && t.to <= n.to && (t.from != n.from || t.to != n.to) && n.to - n.from - (t.to - t.from) <= 4 ? t = {
    from: n.from,
    to: n.to,
    insert: r.state.doc.slice(n.from, t.from).append(t.insert).append(r.state.doc.slice(t.to, n.to))
  } : (le.mac || le.android) && t && t.from == t.to && t.from == n.head - 1 && /^\. ?$/.test(t.insert.toString()) && r.contentDOM.getAttribute("autocorrect") == "off" ? (s && t.insert.length == 2 && (s = de.single(s.main.anchor - 1, s.main.head - 1)), t = { from: n.from, to: n.to, insert: je.of([" "]) }) : le.chrome && t && t.from == t.to && t.from == n.head && t.insert.toString() == `
 ` && r.lineWrapping && (s && (s = de.single(s.main.anchor - 1, s.main.head - 1)), t = { from: n.from, to: n.to, insert: je.of([" "]) }), t) {
    if (le.ios && r.inputState.flushIOSKey() || le.android && (t.from == n.from && t.to == n.to && t.insert.length == 1 && t.insert.lines == 2 && oo(r.contentDOM, "Enter", 13) || (t.from == n.from - 1 && t.to == n.to && t.insert.length == 0 || o == 8 && t.insert.length < t.to - t.from && t.to > n.head) && oo(r.contentDOM, "Backspace", 8) || t.from == n.from && t.to == n.to + 1 && t.insert.length == 0 && oo(r.contentDOM, "Delete", 46)))
      return !0;
    let i = t.insert.toString();
    r.inputState.composing >= 0 && r.inputState.composing++;
    let a, l = () => a || (a = F$(r, t, s));
    return r.state.facet(Hy).some((c) => c(r, t.from, t.to, i, l)) || r.dispatch(l()), !0;
  } else if (s && !s.main.eq(n)) {
    let i = !1, a = "select";
    return r.inputState.lastSelectionTime > Date.now() - 50 && (r.inputState.lastSelectionOrigin == "select" && (i = !0), a = r.inputState.lastSelectionOrigin), r.dispatch({ selection: s, scrollIntoView: i, userEvent: a }), !0;
  } else
    return !1;
}
function F$(r, e, t) {
  let s, n = r.state, o = n.selection.main;
  if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && r.inputState.composing < 0) {
    let a = o.from < e.from ? n.sliceDoc(o.from, e.from) : "", l = o.to > e.to ? n.sliceDoc(e.to, o.to) : "";
    s = n.replaceSelection(r.state.toText(a + e.insert.sliceString(0, void 0, r.state.lineBreak) + l));
  } else {
    let a = n.changes(e), l = t && t.main.to <= a.newLength ? t.main : void 0;
    if (n.selection.ranges.length > 1 && r.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
      let c = r.state.sliceDoc(e.from, e.to), u, d = t && Zy(r, t.main.head);
      if (d) {
        let m = e.insert.length - (e.to - e.from);
        u = { from: d.from, to: d.to - m };
      } else
        u = r.state.doc.lineAt(o.head);
      let h = o.to - e.to, f = o.to - o.from;
      s = n.changeByRange((m) => {
        if (m.from == o.from && m.to == o.to)
          return { changes: a, range: l || m.map(a) };
        let g = m.to - h, p = g - c.length;
        if (m.to - m.from != f || r.state.sliceDoc(p, g) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        m.to >= u.from && m.from <= u.to)
          return { range: m };
        let y = n.changes({ from: p, to: g, insert: e.insert }), b = m.to - o.to;
        return {
          changes: y,
          range: l ? de.range(Math.max(0, l.anchor + b), Math.max(0, l.head + b)) : m.map(y)
        };
      });
    } else
      s = {
        changes: a,
        selection: l && n.selection.replaceRange(l)
      };
  }
  let i = "input.type";
  return (r.composing || r.inputState.compositionPendingChange && r.inputState.compositionEndedAt > Date.now() - 50) && (r.inputState.compositionPendingChange = !1, i += ".compose", r.inputState.compositionFirstChange && (i += ".start", r.inputState.compositionFirstChange = !1)), n.update(s, { userEvent: i, scrollIntoView: !0 });
}
function V$(r, e, t, s) {
  let n = Math.min(r.length, e.length), o = 0;
  for (; o < n && r.charCodeAt(o) == e.charCodeAt(o); )
    o++;
  if (o == n && r.length == e.length)
    return null;
  let i = r.length, a = e.length;
  for (; i > 0 && a > 0 && r.charCodeAt(i - 1) == e.charCodeAt(a - 1); )
    i--, a--;
  if (s == "end") {
    let l = Math.max(0, o - Math.min(i, a));
    t -= i + l - o;
  }
  if (i < o && r.length < e.length) {
    let l = t <= o && t >= i ? o - t : 0;
    o -= l, a = o + (a - i), i = o;
  } else if (a < o) {
    let l = t <= o && t >= a ? o - t : 0;
    o -= l, i = o + (i - a), a = o;
  }
  return { from: o, toA: i, toB: a };
}
function U$(r) {
  let e = [];
  if (r.root.activeElement != r.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: s, focusNode: n, focusOffset: o } = r.observer.selectionRange;
  return t && (e.push(new Fm(t, s)), (n != t || o != s) && e.push(new Fm(n, o))), e;
}
function z$(r, e) {
  if (r.length == 0)
    return null;
  let t = r[0].pos, s = r.length == 2 ? r[1].pos : t;
  return t > -1 && s > -1 ? de.single(t + e, s + e) : null;
}
const q$ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Su = le.ie && le.ie_version <= 11;
class H$ {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new C2(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let s of t)
        this.queue.push(s);
      (le.ie && le.ie_version <= 11 || le.ios && e.composing) && t.some((s) => s.type == "childList" && s.removedNodes.length || s.type == "characterData" && s.oldValue.length > s.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Su && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, s) => t != e[s]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: s } = this, n = this.selectionRange;
    if (s.state.facet(xc) ? s.root.activeElement != this.dom : !_l(s.dom, n))
      return;
    let o = n.anchorNode && s.docView.nearest(n.anchorNode);
    if (o && o.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (le.ie && le.ie_version <= 11 || le.android && le.chrome) && !s.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    n.focusNode && Mi(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = le.safari && e.root.nodeType == 11 && S2(this.dom.ownerDocument) == this.dom && K$(this.view) || ql(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let s = _l(this.dom, t);
    return s && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && E2(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let s = this.dom; s; )
      if (s.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == s ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(s), s = s.assignedSlot || s.parentNode;
      else if (s.nodeType == 11)
        s = s.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let s of this.scrollTargets)
        s.removeEventListener("scroll", this.onScroll);
      for (let s of this.scrollTargets = t)
        s.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, q$), Su && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Su && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var s;
    if (!this.delayedAndroidKey) {
      let n = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && oo(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(n);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((s = this.delayedAndroidKey) === null || s === void 0) && s.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, s = -1, n = !1;
    for (let o of e) {
      let i = this.readMutation(o);
      i && (i.typeOver && (n = !0), t == -1 ? { from: t, to: s } = i : (t = Math.min(i.from, t), s = Math.max(i.to, s)));
    }
    return { from: t, to: s, typeOver: n };
  }
  readChange() {
    let { from: e, to: t, typeOver: s } = this.processRecords(), n = this.selectionChanged && _l(this.dom, this.selectionRange);
    if (e < 0 && !n)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = new B$(this.view, e, t, s);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let s = this.view.state, n = mb(this.view, t);
    return this.view.state == s && this.view.update([]), n;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let s = Vm(t, e.previousSibling || e.target.previousSibling, -1), n = Vm(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: s ? t.posAfter(s) : t.posAtStart,
        to: n ? t.posBefore(n) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, s;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (s = this.resizeScroll) === null || s === void 0 || s.disconnect();
    for (let n of this.scrollTargets)
      n.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function Vm(r, e, t) {
  for (; e; ) {
    let s = Ge.get(e);
    if (s && s.parent == r)
      return s;
    let n = e.parentNode;
    e = n != r.dom ? n : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function K$(r) {
  let e = null;
  function t(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (r.contentDOM.addEventListener("beforeinput", t, !0), r.dom.ownerDocument.execCommand("indent"), r.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let s = e.startContainer, n = e.startOffset, o = e.endContainer, i = e.endOffset, a = r.docView.domAtPos(r.state.selection.main.anchor);
  return Mi(a.node, a.offset, o, i) && ([s, n, o, i] = [o, i, s, n]), { anchorNode: s, anchorOffset: n, focusNode: o, focusOffset: i };
}
class Ee {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: t } = e;
    this.dispatchTransactions = e.dispatchTransactions || t && ((s) => s.forEach((n) => t(n, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = e.root || A2(e.parent) || document, this.viewState = new jm(e.state || Me.create(e)), e.scrollTo && e.scrollTo.is(qa) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(vi).map((s) => new bu(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new H$(this), this.inputState = new a$(this), this.inputState.ensureHandlers(this.plugins), this.docView = new vm(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof $t ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, s = !1, n, o = this.state;
    for (let h of e) {
      if (h.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = h.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let i = this.hasFocus, a = 0, l = null;
    e.some((h) => h.annotation(lb)) ? (this.inputState.notifiedFocused = i, a = 1) : i != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = i, l = cb(o, i), l || (a = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (u = null)) : this.observer.clear(), o.facet(Me.phrases) != this.state.facet(Me.phrases))
      return this.setState(o);
    n = Hl.create(this, o, e), n.flags |= a;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let h of e) {
        if (d && (d = d.map(h.changes)), h.scrollIntoView) {
          let { main: f } = h.state.selection;
          d = new io(f.empty ? f : de.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of h.effects)
          f.is(qa) && (d = f.value.clip(this.state));
      }
      this.viewState.update(n, d), this.bidiCache = Kl.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), t = this.docView.update(n), this.state.facet(wi) != this.styleModules && this.mountStyles(), s = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((h) => h.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(Ya) != n.state.facet(Ya) && (this.viewState.mustMeasureContent = !0), (t || s || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !n.empty)
      for (let h of this.state.facet(Nd))
        try {
          h(n);
        } catch (f) {
          Ns(this.state, f, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !mb(this, u) && c.force && oo(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let s of this.plugins)
        s.destroy(this);
      this.viewState = new jm(e), this.plugins = e.facet(vi).map((s) => new bu(s)), this.pluginMap.clear();
      for (let s of this.plugins)
        s.update(this);
      this.docView.destroy(), this.docView = new vm(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(vi), s = e.state.facet(vi);
    if (t != s) {
      let n = [];
      for (let o of s) {
        let i = t.indexOf(o);
        if (i < 0)
          n.push(new bu(o));
        else {
          let a = this.plugins[i];
          a.mustUpdate = e, n.push(a);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != e && o.destroy(this);
      this.plugins = n, this.pluginMap.clear();
    } else
      for (let n of this.plugins)
        n.mustUpdate = e;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
    t != s && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, s = this.scrollDOM, n = s.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: i } = this.viewState;
    Math.abs(n - this.viewState.scrollTop) > 1 && (i = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (i < 0)
          if (Cy(s))
            o = -1, i = this.viewState.heightMap.height;
          else {
            let f = this.viewState.scrollAnchorAt(n);
            o = f.from, i = f.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((f) => {
          try {
            return f.read(this);
          } catch (m) {
            return Ns(this.state, m), Um;
          }
        }), d = Hl.create(this, this.state, []), h = !1;
        d.flags |= l, t ? t.flags |= l : t = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), h = this.docView.update(d));
        for (let f = 0; f < c.length; f++)
          if (u[f] != Um)
            try {
              let m = c[f];
              m.write && m.write(u[f], this);
            } catch (m) {
              Ns(this.state, m);
            }
        if (h && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, i = -1;
              continue;
            } else {
              let m = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - i;
              if (m > 1 || m < -1) {
                n = n + m, s.scrollTop = n / this.scaleY, i = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let a of this.state.facet(Nd))
        a(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return jd + " " + (this.state.facet(Rd) ? fb : hb) + " " + this.state.facet(Ya);
  }
  updateAttrs() {
    let e = zm(this, Gy, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(xc) ? "true" : "false",
      class: "cm-content",
      style: `${le.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), zm(this, Qh, t);
    let s = this.observer.ignore(() => {
      let n = Ed(this.contentDOM, this.contentAttrs, t), o = Ed(this.dom, this.editorAttrs, e);
      return n || o;
    });
    return this.editorAttrs = e, this.contentAttrs = t, s;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let s of e)
      for (let n of s.effects)
        if (n.is(Ee.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(wi);
    let e = this.state.facet(Ee.cspNonce);
    Rs.mount(this.root, this.styleModules.concat(R$).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((s) => s.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, s) {
    return wu(this, e, xm(this, e, t, s));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return wu(this, e, xm(this, e, t, (s) => o$(this, e.head, s)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let s = this.bidiSpans(e), n = this.textDirectionAt(e.from), o = s[t ? s.length - 1 : 0];
    return de.cursor(o.side(t, n) + e.from, o.forward(!t, n) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, s = !0) {
    return n$(this, e, t, s);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, s) {
    return wu(this, e, i$(this, e, t, s));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), tb(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let s = this.docView.coordsAt(e, t);
    if (!s || s.left == s.right)
      return s;
    let n = this.state.doc.lineAt(e), o = this.bidiSpans(n), i = o[Ts.find(o, e - n.from, -1, t)];
    return Gh(s, i.dir == ct.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(Wy) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > W$)
      return By(e.length);
    let t = this.textDirectionAt(e.from), s;
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == t && (o.fresh || Ly(o.isolates, s = bm(this, e))))
        return o.order;
    s || (s = bm(this, e));
    let n = F2(e.text, t, s);
    return this.bidiCache.push(new Kl(e.from, e.to, t, s, !0, n)), n;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || le.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      _y(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return qa.of(new io(typeof e == "number" ? de.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, s = this.viewState.scrollAnchorAt(e);
    return qa.of(new io(de.cursor(s.from), "start", "start", s.top - e, t, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return wr.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return wr.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let s = Rs.newName(), n = [Ya.of(s), wi.of(Ld(`.${s}`, e))];
    return t && t.dark && n.push(Rd.of(!0)), n;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Hh.lowest(wi.of(Ld("." + jd, e, pb)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let s = e.querySelector(".cm-content"), n = s && Ge.get(s) || Ge.get(e);
    return ((t = n == null ? void 0 : n.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
Ee.styleModule = wi;
Ee.inputHandler = Hy;
Ee.focusChangeEffect = Ky;
Ee.perLineTextDirection = Wy;
Ee.exceptionSink = qy;
Ee.updateListener = Nd;
Ee.editable = xc;
Ee.mouseSelectionStyle = zy;
Ee.dragMovesSelection = Uy;
Ee.clickAddsSelectionRange = Vy;
Ee.decorations = Xi;
Ee.outerDecorations = Jy;
Ee.atomicRanges = Zh;
Ee.bidiIsolatedRanges = Yy;
Ee.scrollMargins = Xy;
Ee.darkTheme = Rd;
Ee.cspNonce = /* @__PURE__ */ pe.define({ combine: (r) => r.length ? r[0] : "" });
Ee.contentAttributes = Qh;
Ee.editorAttributes = Gy;
Ee.lineWrapping = /* @__PURE__ */ Ee.contentAttributes.of({ class: "cm-lineWrapping" });
Ee.announce = /* @__PURE__ */ pt.define();
const W$ = 4096, Um = {};
class Kl {
  constructor(e, t, s, n, o, i) {
    this.from = e, this.to = t, this.dir = s, this.isolates = n, this.fresh = o, this.order = i;
  }
  static update(e, t) {
    if (t.empty && !e.some((o) => o.fresh))
      return e;
    let s = [], n = e.length ? e[e.length - 1].dir : ct.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let i = e[o];
      i.dir == n && !t.touchesRange(i.from, i.to) && s.push(new Kl(t.mapPos(i.from, 1), t.mapPos(i.to, -1), i.dir, i.isolates, !1, i.order));
    }
    return s;
  }
}
function zm(r, e, t) {
  for (let s = r.state.facet(e), n = s.length - 1; n >= 0; n--) {
    let o = s[n], i = typeof o == "function" ? o(r) : o;
    i && Ad(i, t);
  }
  return t;
}
const G$ = le.mac ? "mac" : le.windows ? "win" : le.linux ? "linux" : "key";
function J$(r, e) {
  const t = r.split(/-(?!$)/);
  let s = t[t.length - 1];
  s == "Space" && (s = " ");
  let n, o, i, a;
  for (let l = 0; l < t.length - 1; ++l) {
    const c = t[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      o = !0;
    else if (/^s(hift)?$/i.test(c))
      i = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return n && (s = "Alt-" + s), o && (s = "Ctrl-" + s), a && (s = "Meta-" + s), i && (s = "Shift-" + s), s;
}
function Xa(r, e, t) {
  return e.altKey && (r = "Alt-" + r), e.ctrlKey && (r = "Ctrl-" + r), e.metaKey && (r = "Meta-" + r), t !== !1 && e.shiftKey && (r = "Shift-" + r), r;
}
const Y$ = /* @__PURE__ */ Hh.default(/* @__PURE__ */ Ee.domEventHandlers({
  keydown(r, e) {
    return t_(Q$(e.state), r, e, "editor");
  }
})), X$ = /* @__PURE__ */ pe.define({ enables: Y$ }), qm = /* @__PURE__ */ new WeakMap();
function Q$(r) {
  let e = r.facet(X$), t = qm.get(e);
  return t || qm.set(e, t = e_(e.reduce((s, n) => s.concat(n), []))), t;
}
let Cs = null;
const Z$ = 4e3;
function e_(r, e = G$) {
  let t = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null), n = (i, a) => {
    let l = s[i];
    if (l == null)
      s[i] = a;
    else if (l != a)
      throw new Error("Key binding " + i + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (i, a, l, c, u) => {
    var d, h;
    let f = t[i] || (t[i] = /* @__PURE__ */ Object.create(null)), m = a.split(/ (?!$)/).map((y) => J$(y, e));
    for (let y = 1; y < m.length; y++) {
      let b = m.slice(0, y).join(" ");
      n(b, !0), f[b] || (f[b] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(v) => {
          let k = Cs = { view: v, prefix: b, scope: i };
          return setTimeout(() => {
            Cs == k && (Cs = null);
          }, Z$), !0;
        }]
      });
    }
    let g = m.join(" ");
    n(g, !1);
    let p = f[g] || (f[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((h = (d = f._any) === null || d === void 0 ? void 0 : d.run) === null || h === void 0 ? void 0 : h.slice()) || []
    });
    l && p.run.push(l), c && (p.preventDefault = !0), u && (p.stopPropagation = !0);
  };
  for (let i of r) {
    let a = i.scope ? i.scope.split(" ") : ["editor"];
    if (i.any)
      for (let c of a) {
        let u = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let d in u)
          u[d].run.push(i.any);
      }
    let l = i[e] || i.key;
    if (l)
      for (let c of a)
        o(c, l, i.run, i.preventDefault, i.stopPropagation), i.shift && o(c, "Shift-" + l, i.shift, i.preventDefault, i.stopPropagation);
  }
  return t;
}
function t_(r, e, t, s) {
  let n = k2(e), o = Ii(n, 0), i = cd(o) == n.length && n != " ", a = "", l = !1, c = !1, u = !1;
  Cs && Cs.view == t && Cs.scope == s && (a = Cs.prefix + " ", sb.indexOf(e.keyCode) < 0 && (c = !0, Cs = null));
  let d = /* @__PURE__ */ new Set(), h = (p) => {
    if (p) {
      for (let y of p.run)
        if (!d.has(y) && (d.add(y), y(t, e)))
          return p.stopPropagation && (u = !0), !0;
      p.preventDefault && (p.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, f = r[s], m, g;
  return f && (h(f[a + Xa(n, e, !i)]) ? l = !0 : i && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(le.windows && e.ctrlKey && e.altKey) && (m = js[e.keyCode]) && m != n ? (h(f[a + Xa(m, e, !0)]) || e.shiftKey && (g = Gi[e.keyCode]) != n && g != m && h(f[a + Xa(g, e, !1)])) && (l = !0) : i && e.shiftKey && h(f[a + Xa(n, e, !0)]) && (l = !0), !l && h(f._any) && (l = !0)), c && (l = !0), l && u && e.stopPropagation(), l;
}
const r_ = !le.ios, Hm = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
r_ && (Hm[".cm-line"].caretColor = "transparent !important", Hm[".cm-content"] = { caretColor: "transparent !important" });
function Km(r, e, t, s, n) {
  e.lastIndex = 0;
  for (let o = r.iterRange(t, s), i = t, a; !o.next().done; i += o.value.length)
    if (!o.lineBreak)
      for (; a = e.exec(o.value); )
        n(i + a.index, a);
}
function s_(r, e) {
  let t = r.visibleRanges;
  if (t.length == 1 && t[0].from == r.viewport.from && t[0].to == r.viewport.to)
    return t;
  let s = [];
  for (let { from: n, to: o } of t)
    n = Math.max(r.state.doc.lineAt(n).from, n - e), o = Math.min(r.state.doc.lineAt(o).to, o + e), s.length && s[s.length - 1].to >= n ? s[s.length - 1].to = o : s.push({ from: n, to: o });
  return s;
}
class gb {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: s, decorate: n, boundary: o, maxLength: i = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, n)
      this.addMatch = (a, l, c, u) => n(u, c, c + a[0].length, a, l);
    else if (typeof s == "function")
      this.addMatch = (a, l, c, u) => {
        let d = s(a, l, c);
        d && u(c, c + a[0].length, d);
      };
    else if (s)
      this.addMatch = (a, l, c, u) => u(c, c + a[0].length, s);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = i;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new yo(), s = t.add.bind(t);
    for (let { from: n, to: o } of s_(e, this.maxLength))
      Km(e.state.doc, this.regexp, n, o, (i, a) => this.addMatch(a, e, i, s));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let s = 1e9, n = -1;
    return e.docChanged && e.changes.iterChanges((o, i, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (s = Math.min(a, s), n = Math.max(l, n));
    }), e.viewportChanged || n - s > 1e3 ? this.createDeco(e.view) : n > -1 ? this.updateRange(e.view, t.map(e.changes), s, n) : t;
  }
  updateRange(e, t, s, n) {
    for (let o of e.visibleRanges) {
      let i = Math.max(o.from, s), a = Math.min(o.to, n);
      if (a > i) {
        let l = e.state.doc.lineAt(i), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(o.from, l.from), d = Math.min(o.to, c.to);
        if (this.boundary) {
          for (; i > l.from; i--)
            if (this.boundary.test(l.text[i - 1 - l.from])) {
              u = i;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              d = a;
              break;
            }
        }
        let h = [], f, m = (g, p, y) => h.push(y.range(g, p));
        if (l == c)
          for (this.regexp.lastIndex = u - l.from; (f = this.regexp.exec(l.text)) && f.index < d - l.from; )
            this.addMatch(f, e, f.index + l.from, m);
        else
          Km(e.state.doc, this.regexp, u, d, (g, p) => this.addMatch(p, e, g, m));
        t = t.update({ filterFrom: u, filterTo: d, filter: (g, p) => g < u || p > d, add: h });
      }
    }
    return t;
  }
}
const Bd = /x/.unicode != null ? "gu" : "g", n_ = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Bd), o_ = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let $u = null;
function i_() {
  var r;
  if ($u == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    $u = ((r = e.tabSize) !== null && r !== void 0 ? r : e.MozTabSize) != null;
  }
  return $u || !1;
}
const Al = /* @__PURE__ */ pe.define({
  combine(r) {
    let e = Kh(r, {
      render: null,
      specialChars: n_,
      addSpecialChars: null
    });
    return (e.replaceTabs = !i_()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Bd)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Bd)), e;
  }
});
function bF(r = {}) {
  return [Al.of(r), a_()];
}
let Wm = null;
function a_() {
  return Wm || (Wm = wr.fromClass(class {
    constructor(r) {
      this.view = r, this.decorations = Je.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(r.state.facet(Al)), this.decorations = this.decorator.createDeco(r);
    }
    makeDecorator(r) {
      return new gb({
        regexp: r.specialChars,
        decoration: (e, t, s) => {
          let { doc: n } = t.state, o = Ii(e[0], 0);
          if (o == 9) {
            let i = n.lineAt(s), a = t.state.tabSize, l = Sy(i.text, a, s - i.from);
            return Je.replace({
              widget: new d_((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = Je.replace({ widget: new u_(r, o) }));
        },
        boundary: r.replaceTabs ? void 0 : /[^]/
      });
    }
    update(r) {
      let e = r.state.facet(Al);
      r.startState.facet(Al) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(r.view)) : this.decorations = this.decorator.updateDeco(r, this.decorations);
    }
  }, {
    decorations: (r) => r.decorations
  }));
}
const l_ = "•";
function c_(r) {
  return r >= 32 ? l_ : r == 10 ? "␤" : String.fromCharCode(9216 + r);
}
class u_ extends fa {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = c_(this.code), s = e.state.phrase("Control character") + " " + (o_[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, s, t);
    if (n)
      return n;
    let o = document.createElement("span");
    return o.textContent = t, o.title = s, o.setAttribute("aria-label", s), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return !1;
  }
}
class d_ extends fa {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
const ci = "-10000px";
class h_ {
  constructor(e, t, s, n) {
    this.facet = t, this.createTooltipView = s, this.removeTooltipView = n, this.input = e.state.facet(t), this.tooltips = this.input.filter((i) => i);
    let o = null;
    this.tooltipViews = this.tooltips.map((i) => o = s(i, o));
  }
  update(e, t) {
    var s;
    let n = e.state.facet(this.facet), o = n.filter((l) => l);
    if (n === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let i = [], a = t ? [] : null;
    for (let l = 0; l < o.length; l++) {
      let c = o[l], u = -1;
      if (c) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let h = this.tooltips[d];
          h && h.create == c.create && (u = d);
        }
        if (u < 0)
          i[l] = this.createTooltipView(c, l ? i[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let d = i[l] = this.tooltipViews[u];
          a && (a[l] = t[u]), d.update && d.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      i.indexOf(l) < 0 && (this.removeTooltipView(l), (s = l.destroy) === null || s === void 0 || s.call(l));
    return t && (a.forEach((l, c) => t[c] = l), t.length = a.length), this.input = n, this.tooltips = o, this.tooltipViews = i, !0;
  }
}
function f_(r) {
  let { win: e } = r;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const _u = /* @__PURE__ */ pe.define({
  combine: (r) => {
    var e, t, s;
    return {
      position: le.ios ? "absolute" : ((e = r.find((n) => n.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = r.find((n) => n.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((s = r.find((n) => n.tooltipSpace)) === null || s === void 0 ? void 0 : s.tooltipSpace) || f_
    };
  }
}), Gm = /* @__PURE__ */ new WeakMap(), yb = /* @__PURE__ */ wr.fromClass(class {
  constructor(r) {
    this.view = r, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = r.state.facet(_u);
    this.position = e.position, this.parent = e.parent, this.classes = r.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new h_(r, g_, (t, s) => this.createTooltip(t, s), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), r.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let r of this.manager.tooltipViews)
        this.intersectionObserver.observe(r.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(r) {
    r.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(r, this.above);
    e && this.observeIntersection();
    let t = e || r.geometryChanged, s = r.state.facet(_u);
    if (s.position != this.position && !this.madeAbsolute) {
      this.position = s.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      t = !0;
    }
    if (s.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = s.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(r, e) {
    let t = r.create(this.view), s = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), r.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let n = document.createElement("div");
      n.className = "cm-tooltip-arrow", t.dom.insertBefore(n, s);
    }
    return t.dom.style.position = this.position, t.dom.style.top = ci, t.dom.style.left = "0px", this.container.insertBefore(t.dom, s), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var r, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let s of this.manager.tooltipViews)
      s.dom.remove(), (r = s.destroy) === null || r === void 0 || r.call(s);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let r = this.view.dom.getBoundingClientRect(), e = 1, t = 1, s = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: n } = this.manager.tooltipViews[0];
      if (le.gecko)
        s = n.offsetParent != this.container.ownerDocument.body;
      else if (n.style.top == ci && n.style.left == "0px") {
        let o = n.getBoundingClientRect();
        s = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (s || this.position == "absolute")
      if (this.parent) {
        let n = this.parent.getBoundingClientRect();
        n.width && n.height && (e = n.width / this.parent.offsetWidth, t = n.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: t } = this.view.viewState);
    return {
      editor: r,
      parent: this.parent ? this.container.getBoundingClientRect() : r,
      pos: this.manager.tooltips.map((n, o) => {
        let i = this.manager.tooltipViews[o];
        return i.getCoords ? i.getCoords(n.pos) : this.view.coordsAtPos(n.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: n }) => n.getBoundingClientRect()),
      space: this.view.state.facet(_u).tooltipSpace(this.view),
      scaleX: e,
      scaleY: t,
      makeAbsolute: s
    };
  }
  writeMeasure(r) {
    var e;
    if (r.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: t, space: s, scaleX: n, scaleY: o } = r, i = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, d = r.pos[a], h = r.size[a];
      if (!d || d.bottom <= Math.max(t.top, s.top) || d.top >= Math.min(t.bottom, s.bottom) || d.right < Math.max(t.left, s.left) - 0.1 || d.left > Math.min(t.right, s.right) + 0.1) {
        u.style.top = ci;
        continue;
      }
      let f = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, m = f ? 7 : 0, g = h.right - h.left, p = (e = Gm.get(c)) !== null && e !== void 0 ? e : h.bottom - h.top, y = c.offset || m_, b = this.view.textDirection == ct.LTR, v = h.width > s.right - s.left ? b ? s.left : s.right - h.width : b ? Math.min(d.left - (f ? 14 : 0) + y.x, s.right - g) : Math.max(s.left, d.left - g + (f ? 14 : 0) - y.x), k = this.above[a];
      !l.strictSide && (k ? d.top - (h.bottom - h.top) - y.y < s.top : d.bottom + (h.bottom - h.top) + y.y > s.bottom) && k == s.bottom - d.bottom > d.top - s.top && (k = this.above[a] = !k);
      let _ = (k ? d.top - s.top : s.bottom - d.bottom) - m;
      if (_ < p && c.resize !== !1) {
        if (_ < this.view.defaultLineHeight) {
          u.style.top = ci;
          continue;
        }
        Gm.set(c, p), u.style.height = (p = _) / o + "px";
      } else
        u.style.height && (u.style.height = "");
      let w = k ? d.top - p - m - y.y : d.bottom + m + y.y, x = v + g;
      if (c.overlap !== !0)
        for (let T of i)
          T.left < x && T.right > v && T.top < w + p && T.bottom > w && (w = k ? T.top - p - 2 - m : T.bottom + m + 2);
      if (this.position == "absolute" ? (u.style.top = (w - r.parent.top) / o + "px", u.style.left = (v - r.parent.left) / n + "px") : (u.style.top = w / o + "px", u.style.left = v / n + "px"), f) {
        let T = d.left + (b ? y.x : -y.x) - (v + 14 - 7);
        f.style.left = T / n + "px";
      }
      c.overlap !== !0 && i.push({ left: v, top: w, right: x, bottom: w + p }), u.classList.toggle("cm-tooltip-above", k), u.classList.toggle("cm-tooltip-below", !k), c.positioned && c.positioned(r.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let r of this.manager.tooltipViews)
        r.dom.style.top = ci;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), p_ = /* @__PURE__ */ Ee.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), m_ = { x: 0, y: 0 }, g_ = /* @__PURE__ */ pe.define({
  enables: [yb, p_]
});
function vF(r, e) {
  let t = r.plugin(yb);
  if (!t)
    return null;
  let s = t.manager.tooltips.indexOf(e);
  return s < 0 ? null : t.manager.tooltipViews[s];
}
class wn extends go {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
wn.prototype.elementClass = "";
wn.prototype.toDOM = void 0;
wn.prototype.mapMode = zt.TrackBefore;
wn.prototype.startSide = wn.prototype.endSide = -1;
wn.prototype.point = !0;
const xu = /* @__PURE__ */ pe.define(), El = /* @__PURE__ */ pe.define(), Fd = /* @__PURE__ */ pe.define({
  combine: (r) => r.some((e) => e)
});
function y_(r) {
  let e = [
    b_
  ];
  return r && r.fixed === !1 && e.push(Fd.of(!0)), e;
}
const b_ = /* @__PURE__ */ wr.fromClass(class {
  constructor(r) {
    this.view = r, this.prevViewport = r.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = r.state.facet(El).map((e) => new Ym(r, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !r.state.facet(Fd), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), r.scrollDOM.insertBefore(this.dom, r.contentDOM);
  }
  update(r) {
    if (this.updateGutters(r)) {
      let e = this.prevViewport, t = r.view.viewport, s = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(s < (t.to - t.from) * 0.8);
    }
    r.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Fd) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = r.view.viewport;
  }
  syncGutters(r) {
    let e = this.dom.nextSibling;
    r && this.dom.remove();
    let t = Re.iter(this.view.state.facet(xu), this.view.viewport.from), s = [], n = this.gutters.map((o) => new v_(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks)
      if (s.length && (s = []), Array.isArray(o.type)) {
        let i = !0;
        for (let a of o.type)
          if (a.type == yr.Text && i) {
            Vd(t, s, a.from);
            for (let l of n)
              l.line(this.view, a, s);
            i = !1;
          } else if (a.widget)
            for (let l of n)
              l.widget(this.view, a);
      } else if (o.type == yr.Text) {
        Vd(t, s, o.from);
        for (let i of n)
          i.line(this.view, o, s);
      } else if (o.widget)
        for (let i of n)
          i.widget(this.view, o);
    for (let o of n)
      o.finish();
    r && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(r) {
    let e = r.startState.facet(El), t = r.state.facet(El), s = r.docChanged || r.heightChanged || r.viewportChanged || !Re.eq(r.startState.facet(xu), r.state.facet(xu), r.view.viewport.from, r.view.viewport.to);
    if (e == t)
      for (let n of this.gutters)
        n.update(r) && (s = !0);
    else {
      s = !0;
      let n = [];
      for (let o of t) {
        let i = e.indexOf(o);
        i < 0 ? n.push(new Ym(this.view, o)) : (this.gutters[i].update(r), n.push(this.gutters[i]));
      }
      for (let o of this.gutters)
        o.dom.remove(), n.indexOf(o) < 0 && o.destroy();
      for (let o of n)
        this.dom.appendChild(o.dom);
      this.gutters = n;
    }
    return s;
  }
  destroy() {
    for (let r of this.gutters)
      r.destroy();
    this.dom.remove();
  }
}, {
  provide: (r) => Ee.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == ct.LTR ? { left: t.dom.offsetWidth * e.scaleX } : { right: t.dom.offsetWidth * e.scaleX };
  })
});
function Jm(r) {
  return Array.isArray(r) ? r : [r];
}
function Vd(r, e, t) {
  for (; r.value && r.from <= t; )
    r.from == t && e.push(r.value), r.next();
}
class v_ {
  constructor(e, t, s) {
    this.gutter = e, this.height = s, this.i = 0, this.cursor = Re.iter(e.markers, t.from);
  }
  addElement(e, t, s) {
    let { gutter: n } = this, o = (t.top - this.height) / e.scaleY, i = t.height / e.scaleY;
    if (this.i == n.elements.length) {
      let a = new bb(e, i, o, s);
      n.elements.push(a), n.dom.appendChild(a.dom);
    } else
      n.elements[this.i].update(e, i, o, s);
    this.height = t.bottom, this.i++;
  }
  line(e, t, s) {
    let n = [];
    Vd(this.cursor, n, t.from), s.length && (n = n.concat(s));
    let o = this.gutter.config.lineMarker(e, t, n);
    o && n.unshift(o);
    let i = this.gutter;
    n.length == 0 && !i.config.renderEmptyElements || this.addElement(e, t, n);
  }
  widget(e, t) {
    let s = this.gutter.config.widgetMarker(e, t.widget, t);
    s && this.addElement(e, t, [s]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class Ym {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let s in t.domEventHandlers)
      this.dom.addEventListener(s, (n) => {
        let o = n.target, i;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let l = o.getBoundingClientRect();
          i = (l.top + l.bottom) / 2;
        } else
          i = n.clientY;
        let a = e.lineBlockAtHeight(i - e.documentTop);
        t.domEventHandlers[s](e, a, n) && n.preventDefault();
      });
    this.markers = Jm(t.markers(e)), t.initialSpacer && (this.spacer = new bb(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = Jm(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], e);
      n != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [n]);
    }
    let s = e.view.viewport;
    return !Re.eq(this.markers, t, s.from, s.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class bb {
  constructor(e, t, s, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, s, n);
  }
  update(e, t, s, n) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != s && (this.dom.style.marginTop = (this.above = s) ? s + "px" : ""), w_(this.markers, n) || this.setMarkers(e, n);
  }
  setMarkers(e, t) {
    let s = "cm-gutterElement", n = this.dom.firstChild;
    for (let o = 0, i = 0; ; ) {
      let a = i, l = o < t.length ? t[o++] : null, c = !1;
      if (l) {
        let u = l.elementClass;
        u && (s += " " + u);
        for (let d = i; d < this.markers.length; d++)
          if (this.markers[d].compare(l)) {
            a = d, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; i < a; ) {
        let u = this.markers[i++];
        if (u.toDOM) {
          u.destroy(n);
          let d = n.nextSibling;
          n.remove(), n = d;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? n = n.nextSibling : this.dom.insertBefore(l.toDOM(e), n)), c && i++;
    }
    this.dom.className = s, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function w_(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!r[t].compare(e[t]))
      return !1;
  return !0;
}
const k_ = /* @__PURE__ */ pe.define(), Yn = /* @__PURE__ */ pe.define({
  combine(r) {
    return Kh(r, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let s = Object.assign({}, e);
        for (let n in t) {
          let o = s[n], i = t[n];
          s[n] = o ? (a, l, c) => o(a, l, c) || i(a, l, c) : i;
        }
        return s;
      }
    });
  }
});
class Cu extends wn {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Au(r, e) {
  return r.state.facet(Yn).formatNumber(e, r.state);
}
const S_ = /* @__PURE__ */ El.compute([Yn], (r) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(k_);
  },
  lineMarker(e, t, s) {
    return s.some((n) => n.toDOM) ? null : new Cu(Au(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(Yn) != e.state.facet(Yn),
  initialSpacer(e) {
    return new Cu(Au(e, Xm(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let s = Au(t.view, Xm(t.view.state.doc.lines));
    return s == e.number ? e : new Cu(s);
  },
  domEventHandlers: r.facet(Yn).domEventHandlers
}));
function wF(r = {}) {
  return [
    Yn.of(r),
    y_(),
    S_
  ];
}
function Xm(r) {
  let e = 9;
  for (; e < r; )
    e = e * 10 + 9;
  return e;
}
const $_ = 1024;
let __ = 0;
class er {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class Te {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = __++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Bt.match(e)), (t) => {
      let s = e(t);
      return s === void 0 ? null : [this, s];
    };
  }
}
Te.closedBy = new Te({ deserialize: (r) => r.split(" ") });
Te.openedBy = new Te({ deserialize: (r) => r.split(" ") });
Te.group = new Te({ deserialize: (r) => r.split(" ") });
Te.isolate = new Te({ deserialize: (r) => {
  if (r && r != "rtl" && r != "ltr" && r != "auto")
    throw new RangeError("Invalid value for isolate: " + r);
  return r || "auto";
} });
Te.contextHash = new Te({ perNode: !0 });
Te.lookAhead = new Te({ perNode: !0 });
Te.mounted = new Te({ perNode: !0 });
class Qi {
  constructor(e, t, s) {
    this.tree = e, this.overlay = t, this.parser = s;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Te.mounted.id];
  }
}
const x_ = /* @__PURE__ */ Object.create(null);
class Bt {
  /**
  @internal
  */
  constructor(e, t, s, n = 0) {
    this.name = e, this.props = t, this.id = s, this.flags = n;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : x_, s = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), n = new Bt(e.name || "", t, e.id, s);
    if (e.props) {
      for (let o of e.props)
        if (Array.isArray(o) || (o = o(n)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[o[0].id] = o[1];
        }
    }
    return n;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(Te.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let s in e)
      for (let n of s.split(" "))
        t[n] = e[s];
    return (s) => {
      for (let n = s.prop(Te.group), o = -1; o < (n ? n.length : 0); o++) {
        let i = t[o < 0 ? s.name : n[o]];
        if (i)
          return i;
      }
    };
  }
}
Bt.none = new Bt(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class vb {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let s of this.types) {
      let n = null;
      for (let o of e) {
        let i = o(s);
        i && (n || (n = Object.assign({}, s.props)), n[i[0].id] = i[1]);
      }
      t.push(n ? new Bt(s.name, n, s.id, s.flags) : s);
    }
    return new vb(t);
  }
}
const Qa = /* @__PURE__ */ new WeakMap(), Qm = /* @__PURE__ */ new WeakMap();
var Xe;
(function(r) {
  r[r.ExcludeBuffers = 1] = "ExcludeBuffers", r[r.IncludeAnonymous = 2] = "IncludeAnonymous", r[r.IgnoreMounts = 4] = "IgnoreMounts", r[r.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Xe || (Xe = {}));
class ut {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, s, n, o) {
    if (this.type = e, this.children = t, this.positions = s, this.length = n, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [i, a] of o)
        this.props[typeof i == "number" ? i : i.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Qi.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let s of this.children) {
      let n = s.toString();
      n && (t && (t += ","), t += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Wl(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, s = 0) {
    let n = Qa.get(this) || this.topNode, o = new Wl(n);
    return o.moveTo(e, t), Qa.set(this, o._tree), o;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new _t(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let s = Zi(Qa.get(this) || this.topNode, e, t, !1);
    return Qa.set(this, s), s;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let s = Zi(Qm.get(this) || this.topNode, e, t, !0);
    return Qm.set(this, s), s;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return E_(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: s, from: n = 0, to: o = this.length } = e, i = e.mode || 0, a = (i & Xe.IncludeAnonymous) > 0;
    for (let l = this.cursor(i | Xe.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= o && l.to >= n && (!a && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && s && (a || !l.type.isAnonymous) && s(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : sf(Bt.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, s, n) => new ut(this.type, t, s, n, this.propValues), e.makeTree || ((t, s, n) => new ut(Bt.none, t, s, n)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return O_(e);
  }
}
ut.empty = new ut(Bt.none, [], [], 0);
class tf {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new tf(this.buffer, this.index);
  }
}
class Bs {
  /**
  Create a tree buffer.
  */
  constructor(e, t, s) {
    this.buffer = e, this.length = t, this.set = s;
  }
  /**
  @internal
  */
  get type() {
    return Bt.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], s = this.buffer[e + 3], n = this.set.types[t], o = n.name;
    if (/\W/.test(o) && !n.isError && (o = JSON.stringify(o)), e += 4, s == e)
      return o;
    let i = [];
    for (; e < s; )
      i.push(this.childString(e)), e = this.buffer[e + 3];
    return o + "(" + i.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, s, n, o) {
    let { buffer: i } = this, a = -1;
    for (let l = e; l != t && !(wb(o, n, i[l + 1], i[l + 2]) && (a = l, s > 0)); l = i[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, t, s) {
    let n = this.buffer, o = new Uint16Array(t - e), i = 0;
    for (let a = e, l = 0; a < t; ) {
      o[l++] = n[a++], o[l++] = n[a++] - s;
      let c = o[l++] = n[a++] - s;
      o[l++] = n[a++] - e, i = Math.max(i, c);
    }
    return new Bs(o, i, this.set);
  }
}
function wb(r, e, t, s) {
  switch (r) {
    case -2:
      return t < e;
    case -1:
      return s >= e && t < e;
    case 0:
      return t < e && s > e;
    case 1:
      return t <= e && s > e;
    case 2:
      return s > e;
    case 4:
      return !0;
  }
}
function Zi(r, e, t, s) {
  for (var n; r.from == r.to || (t < 1 ? r.from >= e : r.from > e) || (t > -1 ? r.to <= e : r.to < e); ) {
    let i = !s && r instanceof _t && r.index < 0 ? null : r.parent;
    if (!i)
      return r;
    r = i;
  }
  let o = s ? 0 : Xe.IgnoreOverlays;
  if (s)
    for (let i = r, a = i.parent; a; i = a, a = i.parent)
      i instanceof _t && i.index < 0 && ((n = a.enter(e, t, o)) === null || n === void 0 ? void 0 : n.from) != i.from && (r = a);
  for (; ; ) {
    let i = r.enter(e, t, o);
    if (!i)
      return r;
    r = i;
  }
}
class kb {
  cursor(e = 0) {
    return new Wl(this, e);
  }
  getChild(e, t = null, s = null) {
    let n = Zm(this, e, t, s);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, s = null) {
    return Zm(this, e, t, s);
  }
  resolve(e, t = 0) {
    return Zi(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Zi(this, e, t, !0);
  }
  matchContext(e) {
    return Ud(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), s = this;
    for (; t; ) {
      let n = t.lastChild;
      if (!n || n.to != t.to)
        break;
      n.type.isError && n.from == n.to ? (s = t, t = n.prevSibling) : t = n;
    }
    return s;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class _t extends kb {
  constructor(e, t, s, n) {
    super(), this._tree = e, this.from = t, this.index = s, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, s, n, o = 0) {
    for (let i = this; ; ) {
      for (let { children: a, positions: l } = i._tree, c = t > 0 ? a.length : -1; e != c; e += t) {
        let u = a[e], d = l[e] + i.from;
        if (wb(n, s, d, d + u.length)) {
          if (u instanceof Bs) {
            if (o & Xe.ExcludeBuffers)
              continue;
            let h = u.findChild(0, u.buffer.length, t, s - d, n);
            if (h > -1)
              return new Br(new C_(i, u, e, d), null, h);
          } else if (o & Xe.IncludeAnonymous || !u.type.isAnonymous || rf(u)) {
            let h;
            if (!(o & Xe.IgnoreMounts) && (h = Qi.get(u)) && !h.overlay)
              return new _t(h.tree, d, e, i);
            let f = new _t(u, d, e, i);
            return o & Xe.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(t < 0 ? u.children.length - 1 : 0, t, s, n);
          }
        }
      }
      if (o & Xe.IncludeAnonymous || !i.type.isAnonymous || (i.index >= 0 ? e = i.index + t : e = t < 0 ? -1 : i._parent._tree.children.length, i = i._parent, !i))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, s = 0) {
    let n;
    if (!(s & Xe.IgnoreOverlays) && (n = Qi.get(this._tree)) && n.overlay) {
      let o = e - this.from;
      for (let { from: i, to: a } of n.overlay)
        if ((t > 0 ? i <= o : i < o) && (t < 0 ? a >= o : a > o))
          return new _t(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, s);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function Zm(r, e, t, s) {
  let n = r.cursor(), o = [];
  if (!n.firstChild())
    return o;
  if (t != null) {
    for (let i = !1; !i; )
      if (i = n.type.is(t), !n.nextSibling())
        return o;
  }
  for (; ; ) {
    if (s != null && n.type.is(s))
      return o;
    if (n.type.is(e) && o.push(n.node), !n.nextSibling())
      return s == null ? o : [];
  }
}
function Ud(r, e, t = e.length - 1) {
  for (let s = r.parent; t >= 0; s = s.parent) {
    if (!s)
      return !1;
    if (!s.type.isAnonymous) {
      if (e[t] && e[t] != s.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class C_ {
  constructor(e, t, s, n) {
    this.parent = e, this.buffer = t, this.index = s, this.start = n;
  }
}
class Br extends kb {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, s) {
    super(), this.context = e, this._parent = t, this.index = s, this.type = e.buffer.set.types[e.buffer.buffer[s]];
  }
  child(e, t, s) {
    let { buffer: n } = this.context, o = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.context.start, s);
    return o < 0 ? null : new Br(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, s = 0) {
    if (s & Xe.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, o = n.findChild(this.index + 4, n.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return o < 0 ? null : new Br(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Br(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Br(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: s } = this.context, n = this.index + 4, o = s.buffer[this.index + 3];
    if (o > n) {
      let i = s.buffer[this.index + 1];
      e.push(s.slice(n, o, i)), t.push(0);
    }
    return new ut(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function Sb(r) {
  if (!r.length)
    return null;
  let e = 0, t = r[0];
  for (let o = 1; o < r.length; o++) {
    let i = r[o];
    (i.from > t.from || i.to < t.to) && (t = i, e = o);
  }
  let s = t instanceof _t && t.index < 0 ? null : t.parent, n = r.slice();
  return s ? n[e] = s : n.splice(e, 1), new A_(n, t);
}
class A_ {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return Sb(this.heads);
  }
}
function E_(r, e, t) {
  let s = r.resolveInner(e, t), n = null;
  for (let o = s instanceof _t ? s : s.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let i = o.parent;
      (n || (n = [s])).push(i.resolve(e, t)), o = i;
    } else {
      let i = Qi.get(o.tree);
      if (i && i.overlay && i.overlay[0].from <= e && i.overlay[i.overlay.length - 1].to >= e) {
        let a = new _t(i.tree, i.overlay[0].from + o.from, -1, o);
        (n || (n = [s])).push(Zi(a, e, t, !1));
      }
    }
  return n ? Sb(n) : s;
}
class Wl {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof _t)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let s = e._parent; s; s = s._parent)
        this.stack.unshift(s.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: s, buffer: n } = this.buffer;
    return this.type = t || n.set.types[n.buffer[e]], this.from = s + n.buffer[e + 1], this.to = s + n.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof _t ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, s) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, s, this.mode));
    let { buffer: n } = this.buffer, o = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.buffer.start, s);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, s = this.mode) {
    return this.buffer ? s & Xe.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, s));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Xe.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Xe.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, s = this.stack.length - 1;
    if (e < 0) {
      let n = s < 0 ? 0 : this.stack[s] + 4;
      if (this.index != n)
        return this.yieldBuf(t.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = t.buffer[this.index + 3];
      if (n < (s < 0 ? t.buffer.length : t.buffer[this.stack[s] + 3]))
        return this.yieldBuf(n);
    }
    return s < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, s, { buffer: n } = this;
    if (n) {
      if (e > 0) {
        if (this.index < n.buffer.buffer.length)
          return !1;
      } else
        for (let o = 0; o < this.index; o++)
          if (n.buffer.buffer[o + 3] < this.index)
            return !1;
      ({ index: t, parent: s } = n);
    } else
      ({ index: t, _parent: s } = this._tree);
    for (; s; { index: t, _parent: s } = s)
      if (t > -1)
        for (let o = t + e, i = e < 0 ? -1 : s._tree.children.length; o != i; o += e) {
          let a = s._tree.children[o];
          if (this.mode & Xe.IncludeAnonymous || a instanceof Bs || !a.type.isAnonymous || rf(a))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, s = 0;
    if (e && e.context == this.buffer)
      e:
        for (let n = this.index, o = this.stack.length; o >= 0; ) {
          for (let i = e; i; i = i._parent)
            if (i.index == n) {
              if (n == this.index)
                return i;
              t = i, s = o + 1;
              break e;
            }
          n = this.stack[--o];
        }
    for (let n = s; n < this.stack.length; n++)
      t = new Br(this.buffer, t, this.stack[n]);
    return this.bufferNode = new Br(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let s = 0; ; ) {
      let n = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          s++;
          continue;
        }
        this.type.isAnonymous || (n = !0);
      }
      for (; n && t && t(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!s)
          return;
        this.parent(), s--, n = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Ud(this.node, e);
    let { buffer: t } = this.buffer, { types: s } = t.set;
    for (let n = e.length - 1, o = this.stack.length - 1; n >= 0; o--) {
      if (o < 0)
        return Ud(this.node, e, n);
      let i = s[t.buffer[this.stack[o]]];
      if (!i.isAnonymous) {
        if (e[n] && e[n] != i.name)
          return !1;
        n--;
      }
    }
    return !0;
  }
}
function rf(r) {
  return r.children.some((e) => e instanceof Bs || !e.type.isAnonymous || rf(e));
}
function O_(r) {
  var e;
  let { buffer: t, nodeSet: s, maxBufferLength: n = $_, reused: o = [], minRepeatType: i = s.types.length } = r, a = Array.isArray(t) ? new tf(t, t.length) : t, l = s.types, c = 0, u = 0;
  function d(_, w, x, T, j, B) {
    let { id: W, start: L, end: ue, size: ae } = a, me = u;
    for (; ae < 0; )
      if (a.next(), ae == -1) {
        let Y = o[W];
        x.push(Y), T.push(L - _);
        return;
      } else if (ae == -3) {
        c = W;
        return;
      } else if (ae == -4) {
        u = W;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${ae}`);
    let Pe = l[W], De, Be, ve = L - _;
    if (ue - L <= n && (Be = p(a.pos - w, j))) {
      let Y = new Uint16Array(Be.size - Be.skip), M = a.pos - Be.size, q = Y.length;
      for (; a.pos > M; )
        q = y(Be.start, Y, q);
      De = new Bs(Y, ue - Be.start, s), ve = Be.start - _;
    } else {
      let Y = a.pos - ae;
      a.next();
      let M = [], q = [], F = W >= i ? W : -1, C = 0, I = ue;
      for (; a.pos > Y; )
        F >= 0 && a.id == F && a.size >= 0 ? (a.end <= I - n && (m(M, q, L, C, a.end, I, F, me), C = M.length, I = a.end), a.next()) : B > 2500 ? h(L, Y, M, q) : d(L, Y, M, q, F, B + 1);
      if (F >= 0 && C > 0 && C < M.length && m(M, q, L, C, L, I, F, me), M.reverse(), q.reverse(), F > -1 && C > 0) {
        let D = f(Pe);
        De = sf(Pe, M, q, 0, M.length, 0, ue - L, D, D);
      } else
        De = g(Pe, M, q, ue - L, me - ue);
    }
    x.push(De), T.push(ve);
  }
  function h(_, w, x, T) {
    let j = [], B = 0, W = -1;
    for (; a.pos > w; ) {
      let { id: L, start: ue, end: ae, size: me } = a;
      if (me > 4)
        a.next();
      else {
        if (W > -1 && ue < W)
          break;
        W < 0 && (W = ae - n), j.push(L, ue, ae), B++, a.next();
      }
    }
    if (B) {
      let L = new Uint16Array(B * 4), ue = j[j.length - 2];
      for (let ae = j.length - 3, me = 0; ae >= 0; ae -= 3)
        L[me++] = j[ae], L[me++] = j[ae + 1] - ue, L[me++] = j[ae + 2] - ue, L[me++] = me;
      x.push(new Bs(L, j[2] - ue, s)), T.push(ue - _);
    }
  }
  function f(_) {
    return (w, x, T) => {
      let j = 0, B = w.length - 1, W, L;
      if (B >= 0 && (W = w[B]) instanceof ut) {
        if (!B && W.type == _ && W.length == T)
          return W;
        (L = W.prop(Te.lookAhead)) && (j = x[B] + W.length + L);
      }
      return g(_, w, x, T, j);
    };
  }
  function m(_, w, x, T, j, B, W, L) {
    let ue = [], ae = [];
    for (; _.length > T; )
      ue.push(_.pop()), ae.push(w.pop() + x - j);
    _.push(g(s.types[W], ue, ae, B - j, L - B)), w.push(j - x);
  }
  function g(_, w, x, T, j = 0, B) {
    if (c) {
      let W = [Te.contextHash, c];
      B = B ? [W].concat(B) : [W];
    }
    if (j > 25) {
      let W = [Te.lookAhead, j];
      B = B ? [W].concat(B) : [W];
    }
    return new ut(_, w, x, T, B);
  }
  function p(_, w) {
    let x = a.fork(), T = 0, j = 0, B = 0, W = x.end - n, L = { size: 0, start: 0, skip: 0 };
    e:
      for (let ue = x.pos - _; x.pos > ue; ) {
        let ae = x.size;
        if (x.id == w && ae >= 0) {
          L.size = T, L.start = j, L.skip = B, B += 4, T += 4, x.next();
          continue;
        }
        let me = x.pos - ae;
        if (ae < 0 || me < ue || x.start < W)
          break;
        let Pe = x.id >= i ? 4 : 0, De = x.start;
        for (x.next(); x.pos > me; ) {
          if (x.size < 0)
            if (x.size == -3)
              Pe += 4;
            else
              break e;
          else
            x.id >= i && (Pe += 4);
          x.next();
        }
        j = De, T += ae, B += Pe;
      }
    return (w < 0 || T == _) && (L.size = T, L.start = j, L.skip = B), L.size > 4 ? L : void 0;
  }
  function y(_, w, x) {
    let { id: T, start: j, end: B, size: W } = a;
    if (a.next(), W >= 0 && T < i) {
      let L = x;
      if (W > 4) {
        let ue = a.pos - (W - 4);
        for (; a.pos > ue; )
          x = y(_, w, x);
      }
      w[--x] = L, w[--x] = B - _, w[--x] = j - _, w[--x] = T;
    } else
      W == -3 ? c = T : W == -4 && (u = T);
    return x;
  }
  let b = [], v = [];
  for (; a.pos > 0; )
    d(r.start || 0, r.bufferStart || 0, b, v, -1, 0);
  let k = (e = r.length) !== null && e !== void 0 ? e : b.length ? v[0] + b[0].length : 0;
  return new ut(l[r.topID], b.reverse(), v.reverse(), k);
}
const eg = /* @__PURE__ */ new WeakMap();
function Ol(r, e) {
  if (!r.isAnonymous || e instanceof Bs || e.type != r)
    return 1;
  let t = eg.get(e);
  if (t == null) {
    t = 1;
    for (let s of e.children) {
      if (s.type != r || !(s instanceof ut)) {
        t = 1;
        break;
      }
      t += Ol(r, s);
    }
    eg.set(e, t);
  }
  return t;
}
function sf(r, e, t, s, n, o, i, a, l) {
  let c = 0;
  for (let m = s; m < n; m++)
    c += Ol(r, e[m]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], h = [];
  function f(m, g, p, y, b) {
    for (let v = p; v < y; ) {
      let k = v, _ = g[v], w = Ol(r, m[v]);
      for (v++; v < y; v++) {
        let x = Ol(r, m[v]);
        if (w + x >= u)
          break;
        w += x;
      }
      if (v == k + 1) {
        if (w > u) {
          let x = m[k];
          f(x.children, x.positions, 0, x.children.length, g[k] + b);
          continue;
        }
        d.push(m[k]);
      } else {
        let x = g[v - 1] + m[v - 1].length - _;
        d.push(sf(r, m, g, k, v, _, x, null, l));
      }
      h.push(_ + b - o);
    }
  }
  return f(e, t, s, n, 0), (a || l)(d, h, i);
}
class kF {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, s) {
    let n = this.map.get(e);
    n || this.map.set(e, n = /* @__PURE__ */ new Map()), n.set(t, s);
  }
  getBuffer(e, t) {
    let s = this.map.get(e);
    return s && s.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof Br ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof _t && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Br ? this.getBuffer(e.context.buffer, e.index) : e instanceof _t ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class rs {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, s, n, o = !1, i = !1) {
    this.from = e, this.to = t, this.tree = s, this.offset = n, this.open = (o ? 1 : 0) | (i ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], s = !1) {
    let n = [new rs(0, e.length, e, 0, !1, s)];
    for (let o of t)
      o.to > e.length && n.push(o);
    return n;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, s = 128) {
    if (!t.length)
      return e;
    let n = [], o = 1, i = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < t.length ? t[a] : null, d = u ? u.fromA : 1e9;
      if (d - l >= s)
        for (; i && i.from < d; ) {
          let h = i;
          if (l >= h.from || d <= h.to || c) {
            let f = Math.max(h.from, l) - c, m = Math.min(h.to, d) - c;
            h = f >= m ? null : new rs(f, m, h.tree, h.offset + c, a > 0, !!u);
          }
          if (h && n.push(h), i.to > d)
            break;
          i = o < e.length ? e[o++] : null;
        }
      if (!u)
        break;
      l = u.toA, c = u.toA - u.toB;
    }
    return n;
  }
}
class T_ {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, s) {
    return typeof e == "string" && (e = new P_(e)), s = s ? s.length ? s.map((n) => new er(n.from, n.to)) : [new er(0, 0)] : [new er(0, e.length)], this.createParse(e, t || [], s);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, s) {
    let n = this.startParse(e, t, s);
    for (; ; ) {
      let o = n.advance();
      if (o)
        return o;
    }
  }
}
class P_ {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function SF(r) {
  return (e, t, s, n) => new N_(e, r, t, s, n);
}
class tg {
  constructor(e, t, s, n, o) {
    this.parser = e, this.parse = t, this.overlay = s, this.target = n, this.from = o;
  }
}
function rg(r) {
  if (!r.length || r.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(r));
}
class I_ {
  constructor(e, t, s, n, o, i, a) {
    this.parser = e, this.predicate = t, this.mounts = s, this.index = n, this.start = o, this.target = i, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const zd = new Te({ perNode: !0 });
class N_ {
  constructor(e, t, s, n, o) {
    this.nest = t, this.input = s, this.fragments = n, this.ranges = o, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let s = this.baseParse.advance();
      if (!s)
        return null;
      if (this.baseParse = null, this.baseTree = s, this.startInner(), this.stoppedAt != null)
        for (let n of this.inner)
          n.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let s = this.baseTree;
      return this.stoppedAt != null && (s = new ut(s.type, s.children, s.positions, s.length, s.propValues.concat([[zd, this.stoppedAt]]))), s;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let s = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      s[Te.mounted.id] = new Qi(t, e.overlay, e.parser), e.target.props = s;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new R_(this.fragments), t = null, s = null, n = new Wl(new _t(this.baseTree, this.ranges[0].from, 0, null), Xe.IncludeAnonymous | Xe.IgnoreMounts);
    e:
      for (let o, i; ; ) {
        let a = !0, l;
        if (this.stoppedAt != null && n.from >= this.stoppedAt)
          a = !1;
        else if (e.hasNode(n)) {
          if (t) {
            let c = t.mounts.find((u) => u.frag.from <= n.from && u.frag.to >= n.to && u.mount.overlay);
            if (c)
              for (let u of c.mount.overlay) {
                let d = u.from + c.pos, h = u.to + c.pos;
                d >= n.from && h <= n.to && !t.ranges.some((f) => f.from < h && f.to > d) && t.ranges.push({ from: d, to: h });
              }
          }
          a = !1;
        } else if (s && (i = M_(s.ranges, n.from, n.to)))
          a = i != 2;
        else if (!n.type.isAnonymous && (o = this.nest(n, this.input)) && (n.from < n.to || !o.overlay)) {
          n.tree || D_(n);
          let c = e.findMounts(n.from, o.parser);
          if (typeof o.overlay == "function")
            t = new I_(o.parser, o.overlay, c, this.inner.length, n.from, n.tree, t);
          else {
            let u = og(this.ranges, o.overlay || (n.from < n.to ? [new er(n.from, n.to)] : []));
            u.length && rg(u), (u.length || !o.overlay) && this.inner.push(new tg(o.parser, u.length ? o.parser.startParse(this.input, ig(c, u), u) : o.parser.startParse(""), o.overlay ? o.overlay.map((d) => new er(d.from - n.from, d.to - n.from)) : null, n.tree, u.length ? u[0].from : n.from)), o.overlay ? u.length && (s = { ranges: u, depth: 0, prev: s }) : a = !1;
          }
        } else
          t && (l = t.predicate(n)) && (l === !0 && (l = new er(n.from, n.to)), l.from < l.to && t.ranges.push(l));
        if (a && n.firstChild())
          t && t.depth++, s && s.depth++;
        else
          for (; !n.nextSibling(); ) {
            if (!n.parent())
              break e;
            if (t && !--t.depth) {
              let c = og(this.ranges, t.ranges);
              c.length && (rg(c), this.inner.splice(t.index, 0, new tg(t.parser, t.parser.startParse(this.input, ig(t.mounts, c), c), t.ranges.map((u) => new er(u.from - t.start, u.to - t.start)), t.target, c[0].from))), t = t.prev;
            }
            s && !--s.depth && (s = s.prev);
          }
      }
  }
}
function M_(r, e, t) {
  for (let s of r) {
    if (s.from >= t)
      break;
    if (s.to > e)
      return s.from <= e && s.to >= t ? 2 : 1;
  }
  return 0;
}
function sg(r, e, t, s, n, o) {
  if (e < t) {
    let i = r.buffer[e + 1];
    s.push(r.slice(e, t, i)), n.push(i - o);
  }
}
function D_(r) {
  let { node: e } = r, t = [], s = e.context.buffer;
  do
    t.push(r.index), r.parent();
  while (!r.tree);
  let n = r.tree, o = n.children.indexOf(s), i = n.children[o], a = i.buffer, l = [o];
  function c(u, d, h, f, m, g) {
    let p = t[g], y = [], b = [];
    sg(i, u, p, y, b, f);
    let v = a[p + 1], k = a[p + 2];
    l.push(y.length);
    let _ = g ? c(p + 4, a[p + 3], i.set.types[a[p]], v, k - v, g - 1) : e.toTree();
    return y.push(_), b.push(v - f), sg(i, a[p + 3], d, y, b, f), new ut(h, y, b, m);
  }
  n.children[o] = c(0, a.length, Bt.none, 0, i.length, t.length - 1);
  for (let u of l) {
    let d = r.tree.children[u], h = r.tree.positions[u];
    r.yield(new _t(d, h + r.from, u, r._tree));
  }
}
class ng {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Xe.IncludeAnonymous | Xe.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, s = e - this.offset;
    for (; !this.done && t.from < s; )
      t.to >= e && t.enter(s, 1, Xe.IgnoreOverlays | Xe.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof ut)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
class R_ {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let s = this.curFrag = e[0];
      this.curTo = (t = s.tree.prop(zd)) !== null && t !== void 0 ? t : s.to, this.inner = new ng(s.tree, -s.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(zd)) !== null && e !== void 0 ? e : t.to, this.inner = new ng(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var s;
    let n = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let o = this.inner.cursor.node; o; o = o.parent) {
        let i = (s = o.tree) === null || s === void 0 ? void 0 : s.prop(Te.mounted);
        if (i && i.parser == t)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= o.to)
              break;
            l.tree == this.curFrag.tree && n.push({
              frag: l,
              pos: o.from - l.offset,
              mount: i
            });
          }
      }
    }
    return n;
  }
}
function og(r, e) {
  let t = null, s = e;
  for (let n = 1, o = 0; n < r.length; n++) {
    let i = r[n - 1].to, a = r[n].from;
    for (; o < s.length; o++) {
      let l = s[o];
      if (l.from >= a)
        break;
      l.to <= i || (t || (s = t = e.slice()), l.from < i ? (t[o] = new er(l.from, i), l.to > a && t.splice(o + 1, 0, new er(a, l.to))) : l.to > a ? t[o--] = new er(a, l.to) : t.splice(o--, 1));
    }
  }
  return s;
}
function j_(r, e, t, s) {
  let n = 0, o = 0, i = !1, a = !1, l = -1e9, c = [];
  for (; ; ) {
    let u = n == r.length ? 1e9 : i ? r[n].to : r[n].from, d = o == e.length ? 1e9 : a ? e[o].to : e[o].from;
    if (i != a) {
      let h = Math.max(l, t), f = Math.min(u, d, s);
      h < f && c.push(new er(h, f));
    }
    if (l = Math.min(u, d), l == 1e9)
      break;
    u == l && (i ? (i = !1, n++) : i = !0), d == l && (a ? (a = !1, o++) : a = !0);
  }
  return c;
}
function ig(r, e) {
  let t = [];
  for (let { pos: s, mount: n, frag: o } of r) {
    let i = s + (n.overlay ? n.overlay[0].from : 0), a = i + n.tree.length, l = Math.max(o.from, i), c = Math.min(o.to, a);
    if (n.overlay) {
      let u = n.overlay.map((h) => new er(h.from + s, h.to + s)), d = j_(e, u, l, c);
      for (let h = 0, f = l; ; h++) {
        let m = h == d.length, g = m ? c : d[h].from;
        if (g > f && t.push(new rs(f, g, n.tree, -i, o.from >= f || o.openStart, o.to <= g || o.openEnd)), m)
          break;
        f = d[h].to;
      }
    } else
      t.push(new rs(l, c, n.tree, -i, o.from >= i || o.openStart, o.to <= a || o.openEnd));
  }
  return t;
}
let L_ = 0, Ss = class $b {
  /**
  @internal
  */
  constructor(e, t, s) {
    this.set = e, this.base = t, this.modified = s, this.id = L_++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new $b([], null, []);
    if (t.set.push(t), e)
      for (let s of e.set)
        t.set.push(s);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new Gl();
    return (t) => t.modified.indexOf(e) > -1 ? t : Gl.get(t.base || t, t.modified.concat(e).sort((s, n) => s.id - n.id));
  }
}, B_ = 0;
class Gl {
  constructor() {
    this.instances = [], this.id = B_++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let s = t[0].instances.find((a) => a.base == e && F_(t, a.modified));
    if (s)
      return s;
    let n = [], o = new Ss(n, e, t);
    for (let a of t)
      a.instances.push(o);
    let i = V_(t);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of i)
          n.push(Gl.get(a, l));
    return o;
  }
}
function F_(r, e) {
  return r.length == e.length && r.every((t, s) => t == e[s]);
}
function V_(r) {
  let e = [[]];
  for (let t = 0; t < r.length; t++)
    for (let s = 0, n = e.length; s < n; s++)
      e.push(e[s].concat(r[t]));
  return e.sort((t, s) => s.length - t.length);
}
function U_(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in r) {
    let s = r[t];
    Array.isArray(s) || (s = [s]);
    for (let n of t.split(" "))
      if (n) {
        let o = [], i = 2, a = n;
        for (let d = 0; ; ) {
          if (a == "..." && d > 0 && d + 3 == n.length) {
            i = 1;
            break;
          }
          let h = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!h)
            throw new RangeError("Invalid path: " + n);
          if (o.push(h[0] == "*" ? "" : h[0][0] == '"' ? JSON.parse(h[0]) : h[0]), d += h[0].length, d == n.length)
            break;
          let f = n[d++];
          if (d == n.length && f == "!") {
            i = 0;
            break;
          }
          if (f != "/")
            throw new RangeError("Invalid path: " + n);
          a = n.slice(d);
        }
        let l = o.length - 1, c = o[l];
        if (!c)
          throw new RangeError("Invalid path: " + n);
        let u = new Jl(s, i, l > 0 ? o.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return _b.add(e);
}
const _b = new Te();
class Jl {
  constructor(e, t, s, n) {
    this.tags = e, this.mode = t, this.context = s, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Jl.empty = new Jl([], 2, null);
function xb(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let o of r)
    if (!Array.isArray(o.tag))
      t[o.tag.id] = o.class;
    else
      for (let i of o.tag)
        t[i.id] = o.class;
  let { scope: s, all: n = null } = e || {};
  return {
    style: (o) => {
      let i = n;
      for (let a of o)
        for (let l of a.set) {
          let c = t[l.id];
          if (c) {
            i = i ? i + " " + c : c;
            break;
          }
        }
      return i;
    },
    scope: s
  };
}
function z_(r, e) {
  let t = null;
  for (let s of r) {
    let n = s.style(e);
    n && (t = t ? t + " " + n : n);
  }
  return t;
}
function q_(r, e, t, s = 0, n = r.length) {
  let o = new H_(s, Array.isArray(e) ? e : [e], t);
  o.highlightRange(r.cursor(), s, n, "", o.highlighters), o.flush(n);
}
class H_ {
  constructor(e, t, s) {
    this.at = e, this.highlighters = t, this.span = s, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, s, n, o) {
    let { type: i, from: a, to: l } = e;
    if (a >= s || l <= t)
      return;
    i.isTop && (o = this.highlighters.filter((f) => !f.scope || f.scope(i)));
    let c = n, u = K_(e) || Jl.empty, d = z_(o, u.tags);
    if (d && (c && (c += " "), c += d, u.mode == 1 && (n += (n ? " " : "") + d)), this.startSpan(Math.max(t, a), c), u.opaque)
      return;
    let h = e.tree && e.tree.prop(Te.mounted);
    if (h && h.overlay) {
      let f = e.node.enter(h.overlay[0].from + a, 1), m = this.highlighters.filter((p) => !p.scope || p.scope(h.tree.type)), g = e.firstChild();
      for (let p = 0, y = a; ; p++) {
        let b = p < h.overlay.length ? h.overlay[p] : null, v = b ? b.from + a : l, k = Math.max(t, y), _ = Math.min(s, v);
        if (k < _ && g)
          for (; e.from < _ && (this.highlightRange(e, k, _, n, o), this.startSpan(Math.min(_, e.to), c), !(e.to >= v || !e.nextSibling())); )
            ;
        if (!b || v > s)
          break;
        y = b.to + a, y > t && (this.highlightRange(f.cursor(), Math.max(t, b.from + a), Math.min(s, y), "", m), this.startSpan(Math.min(s, y), c));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      h && (n = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= s)
            break;
          this.highlightRange(e, t, s, n, o), this.startSpan(Math.min(s, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function K_(r) {
  let e = r.type.prop(_b);
  for (; e && e.context && !r.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const se = Ss.define, Za = se(), $s = se(), ag = se($s), lg = se($s), _s = se(), el = se(_s), Eu = se(_s), Nr = se(), Xs = se(Nr), Pr = se(), Ir = se(), qd = se(), ui = se(qd), tl = se(), G = {
  /**
  A comment.
  */
  comment: Za,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: se(Za),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: se(Za),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: se(Za),
  /**
  Any kind of identifier.
  */
  name: $s,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: se($s),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: ag,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: se(ag),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: lg,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: se(lg),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: se($s),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: se($s),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: se($s),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: se($s),
  /**
  A literal value.
  */
  literal: _s,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: el,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: se(el),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: se(el),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: se(el),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Eu,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: se(Eu),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: se(Eu),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: se(_s),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: se(_s),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: se(_s),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: se(_s),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: se(_s),
  /**
  A language keyword.
  */
  keyword: Pr,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: se(Pr),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: se(Pr),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: se(Pr),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: se(Pr),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: se(Pr),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: se(Pr),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: se(Pr),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: se(Pr),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: se(Pr),
  /**
  An operator.
  */
  operator: Ir,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: se(Ir),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: se(Ir),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: se(Ir),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: se(Ir),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: se(Ir),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: se(Ir),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: se(Ir),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: se(Ir),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: se(Ir),
  /**
  Program or markup punctuation.
  */
  punctuation: qd,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: se(qd),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: ui,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: se(ui),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: se(ui),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: se(ui),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: se(ui),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Nr,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Xs,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: se(Xs),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: se(Xs),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: se(Xs),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: se(Xs),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: se(Xs),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: se(Xs),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: se(Nr),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: se(Nr),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: se(Nr),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: se(Nr),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: se(Nr),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: se(Nr),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: se(Nr),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: se(Nr),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: se(),
  /**
  Deleted text.
  */
  deleted: se(),
  /**
  Changed text.
  */
  changed: se(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: se(),
  /**
  Metadata or meta-instruction.
  */
  meta: tl,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: se(tl),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: se(tl),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: se(tl),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Ss.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Ss.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Ss.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Ss.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Ss.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Ss.defineModifier()
};
xb([
  { tag: G.link, class: "tok-link" },
  { tag: G.heading, class: "tok-heading" },
  { tag: G.emphasis, class: "tok-emphasis" },
  { tag: G.strong, class: "tok-strong" },
  { tag: G.keyword, class: "tok-keyword" },
  { tag: G.atom, class: "tok-atom" },
  { tag: G.bool, class: "tok-bool" },
  { tag: G.url, class: "tok-url" },
  { tag: G.labelName, class: "tok-labelName" },
  { tag: G.inserted, class: "tok-inserted" },
  { tag: G.deleted, class: "tok-deleted" },
  { tag: G.literal, class: "tok-literal" },
  { tag: G.string, class: "tok-string" },
  { tag: G.number, class: "tok-number" },
  { tag: [G.regexp, G.escape, G.special(G.string)], class: "tok-string2" },
  { tag: G.variableName, class: "tok-variableName" },
  { tag: G.local(G.variableName), class: "tok-variableName tok-local" },
  { tag: G.definition(G.variableName), class: "tok-variableName tok-definition" },
  { tag: G.special(G.variableName), class: "tok-variableName2" },
  { tag: G.definition(G.propertyName), class: "tok-propertyName tok-definition" },
  { tag: G.typeName, class: "tok-typeName" },
  { tag: G.namespace, class: "tok-namespace" },
  { tag: G.className, class: "tok-className" },
  { tag: G.macroName, class: "tok-macroName" },
  { tag: G.propertyName, class: "tok-propertyName" },
  { tag: G.operator, class: "tok-operator" },
  { tag: G.comment, class: "tok-comment" },
  { tag: G.meta, class: "tok-meta" },
  { tag: G.invalid, class: "tok-invalid" },
  { tag: G.punctuation, class: "tok-punctuation" }
]);
var Ou;
const Xn = /* @__PURE__ */ new Te();
function W_(r) {
  return pe.define({
    combine: r ? (e) => e.concat(r) : void 0
  });
}
const G_ = /* @__PURE__ */ new Te();
class mr {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, s = [], n = "") {
    this.data = e, this.name = n, Me.prototype.hasOwnProperty("tree") || Object.defineProperty(Me.prototype, "tree", { get() {
      return kn(this);
    } }), this.parser = t, this.extension = [
      wo.of(this),
      Me.languageData.of((o, i, a) => {
        let l = cg(o, i, a), c = l.type.prop(Xn);
        if (!c)
          return [];
        let u = o.facet(c), d = l.type.prop(G_);
        if (d) {
          let h = l.resolve(i - l.from, a);
          for (let f of d)
            if (f.test(h, o)) {
              let m = o.facet(f.facet);
              return f.type == "replace" ? m : m.concat(u);
            }
        }
        return u;
      })
    ].concat(s);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, s = -1) {
    return cg(e, t, s).type.prop(Xn) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(wo);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let s = [], n = (o, i) => {
      if (o.prop(Xn) == this.data) {
        s.push({ from: i, to: i + o.length });
        return;
      }
      let a = o.prop(Te.mounted);
      if (a) {
        if (a.tree.prop(Xn) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              s.push({ from: l.from + i, to: l.to + i });
          else
            s.push({ from: i, to: i + o.length });
          return;
        } else if (a.overlay) {
          let l = s.length;
          if (n(a.tree, a.overlay[0].from + i), s.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let c = o.children[l];
        c instanceof ut && n(c, o.positions[l] + i);
      }
    };
    return n(kn(e), 0), s;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
mr.setState = /* @__PURE__ */ pt.define();
function cg(r, e, t) {
  let s = r.facet(wo), n = kn(r).topNode;
  if (!s || s.allowsNesting)
    for (let o = n; o; o = o.enter(e, t, Xe.ExcludeBuffers))
      o.type.isTop && (n = o);
  return n;
}
class Hd extends mr {
  constructor(e, t, s) {
    super(e, t, [], s), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = W_(e.languageData);
    return new Hd(t, e.parser.configure({
      props: [Xn.add((s) => s.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new Hd(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function kn(r) {
  let e = r.field(mr.state, !1);
  return e ? e.tree : ut.empty;
}
class J_ {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let s = this.cursorPos - this.string.length;
    return e < s || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - s, t - s);
  }
}
let di = null;
class Yl {
  constructor(e, t, s = [], n, o, i, a, l) {
    this.parser = e, this.state = t, this.fragments = s, this.tree = n, this.treeLen = o, this.viewport = i, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, s) {
    return new Yl(e, t, [], ut.empty, 0, s, [], null);
  }
  startParse() {
    return this.parser.startParse(new J_(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != ut.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var s;
      if (typeof e == "number") {
        let n = Date.now() + e;
        e = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(rs.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (s = this.parse.stoppedAt) !== null && s !== void 0 ? s : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(rs.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = di;
    di = this;
    try {
      return e();
    } finally {
      di = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = ug(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: s, tree: n, treeLen: o, viewport: i, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, u, d, h) => l.push({ fromA: c, toA: u, fromB: d, toB: h })), s = rs.applyChanges(s, l), n = ut.empty, o = 0, i = { from: e.mapPos(i.from, -1), to: e.mapPos(i.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), d = e.mapPos(c.to, -1);
          u < d && a.push({ from: u, to: d });
        }
      }
    }
    return new Yl(this.parser, t, s, n, o, i, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let s = 0; s < this.skipped.length; s++) {
      let { from: n, to: o } = this.skipped[s];
      n < e.to && o > e.from && (this.fragments = ug(this.fragments, n, o), this.skipped.splice(s--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends T_ {
      createParse(t, s, n) {
        let o = n[0].from, i = n[n.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let l = di;
            if (l) {
              for (let c of n)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = i, new ut(Bt.none, [], [], i - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return di;
  }
}
function ug(r, e, t) {
  return rs.applyChanges(r, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class vo {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), s = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, s) || t.takeTree(), new vo(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), s = Yl.create(e.facet(wo).parser, e, { from: 0, to: t });
    return s.work(20, t) || s.takeTree(), new vo(s);
  }
}
mr.state = /* @__PURE__ */ zs.define({
  create: vo.init,
  update(r, e) {
    for (let t of e.effects)
      if (t.is(mr.setState))
        return t.value;
    return e.startState.facet(wo) != e.state.facet(wo) ? vo.init(e.state) : r.apply(e);
  }
});
let Cb = (r) => {
  let e = setTimeout(
    () => r(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (Cb = (r) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(r, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const Tu = typeof navigator < "u" && (!((Ou = navigator.scheduling) === null || Ou === void 0) && Ou.isInputPending) ? () => navigator.scheduling.isInputPending() : null, Y_ = /* @__PURE__ */ wr.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(mr.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(mr.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = Cb(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: s, viewport: { to: n } } = this.view, o = s.field(mr.state);
    if (o.tree == o.context.tree && o.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let i = Date.now() + Math.min(this.chunkBudget, 100, e && !Tu ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < n && s.doc.length > n + 1e3, l = o.context.work(() => Tu && Tu() || Date.now() > i, n + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: mr.setState.of(new vo(o.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Ns(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), wo = /* @__PURE__ */ pe.define({
  combine(r) {
    return r.length ? r[0] : null;
  },
  enables: (r) => [
    mr.state,
    Y_,
    Ee.contentAttributes.compute([r], (e) => {
      let t = e.facet(r);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class _F {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const X_ = /* @__PURE__ */ pe.define(), Ab = /* @__PURE__ */ pe.define({
  combine: (r) => {
    if (!r.length)
      return "  ";
    let e = r[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(r[0]));
    return e;
  }
});
function Q_(r) {
  let e = r.facet(Ab);
  return e.charCodeAt(0) == 9 ? r.tabSize * e.length : e.length;
}
function Z_(r, e) {
  let t = "", s = r.tabSize, n = r.facet(Ab)[0];
  if (n == "	") {
    for (; e >= s; )
      t += "	", e -= s;
    n = " ";
  }
  for (let o = 0; o < e; o++)
    t += n;
  return t;
}
function ex(r, e) {
  r instanceof Me && (r = new Eb(r));
  for (let s of r.state.facet(X_)) {
    let n = s(r, e);
    if (n !== void 0)
      return n;
  }
  let t = kn(r.state);
  return t.length >= e ? rx(r, t, e) : null;
}
class Eb {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Q_(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let s = this.state.doc.lineAt(e), { simulateBreak: n, simulateDoubleBreak: o } = this.options;
    return n != null && n >= s.from && n <= s.to ? o && n == e ? { text: "", from: e } : (t < 0 ? n < e : n <= e) ? { text: s.text.slice(n - s.from), from: n } : { text: s.text.slice(0, n - s.from), from: s.from } : s;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: s, from: n } = this.lineAt(e, t);
    return s.slice(e - n, Math.min(s.length, e + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: s, from: n } = this.lineAt(e, t), o = this.countColumn(s, e - n), i = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return i > -1 && (o += i - this.countColumn(s, s.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Sy(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: s, from: n } = this.lineAt(e, t), o = this.options.overrideIndentation;
    if (o) {
      let i = o(n);
      if (i > -1)
        return i;
    }
    return this.countColumn(s, s.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const tx = /* @__PURE__ */ new Te();
function rx(r, e, t) {
  let s = e.resolveStack(t), n = s.node.enterUnfinishedNodesBefore(t);
  if (n != s.node) {
    let o = [];
    for (let i = n; i != s.node; i = i.parent)
      o.push(i);
    for (let i = o.length - 1; i >= 0; i--)
      s = { node: o[i], next: s };
  }
  return Ob(s, r, t);
}
function Ob(r, e, t) {
  for (let s = r; s; s = s.next) {
    let n = nx(s.node);
    if (n)
      return n(nf.create(e, t, s));
  }
  return 0;
}
function sx(r) {
  return r.pos == r.options.simulateBreak && r.options.simulateDoubleBreak;
}
function nx(r) {
  let e = r.type.prop(tx);
  if (e)
    return e;
  let t = r.firstChild, s;
  if (t && (s = t.type.prop(Te.closedBy))) {
    let n = r.lastChild, o = n && s.indexOf(n.name) > -1;
    return (i) => Tb(i, !0, 1, void 0, o && !sx(i) ? n.from : void 0);
  }
  return r.parent == null ? ox : null;
}
function ox() {
  return 0;
}
class nf extends Eb {
  constructor(e, t, s) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = s;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, s) {
    return new nf(e, t, s);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let s = e.resolve(t.from);
      for (; s.parent && s.parent.from == s.from; )
        s = s.parent;
      if (ix(s, e))
        break;
      t = this.state.doc.lineAt(s.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return Ob(this.context.next, this.base, this.pos);
  }
}
function ix(r, e) {
  for (let t = e; t; t = t.parent)
    if (r == t)
      return !0;
  return !1;
}
function ax(r) {
  let e = r.node, t = e.childAfter(e.from), s = e.lastChild;
  if (!t)
    return null;
  let n = r.options.simulateBreak, o = r.state.doc.lineAt(t.from), i = n == null || n <= o.from ? o.to : Math.min(o.to, n);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == s)
      return null;
    if (!l.type.isSkipped)
      return l.from < i ? t : null;
    a = l.to;
  }
}
function xF({ closing: r, align: e = !0, units: t = 1 }) {
  return (s) => Tb(s, e, t, r);
}
function Tb(r, e, t, s, n) {
  let o = r.textAfter, i = o.match(/^\s*/)[0].length, a = s && o.slice(i, i + s.length) == s || n == r.pos + i, l = e ? ax(r) : null;
  return l ? a ? r.column(l.from) : r.column(l.to) : r.baseIndent + (a ? 0 : r.unit * t);
}
const CF = (r) => r.baseIndent;
function AF({ except: r, units: e = 1 } = {}) {
  return (t) => {
    let s = r && r.test(t.textAfter);
    return t.baseIndent + (s ? 0 : e * t.unit);
  };
}
const lx = 200;
function EF() {
  return Me.transactionFilter.of((r) => {
    if (!r.docChanged || !r.isUserEvent("input.type") && !r.isUserEvent("input.complete"))
      return r;
    let e = r.startState.languageDataAt("indentOnInput", r.startState.selection.main.head);
    if (!e.length)
      return r;
    let t = r.newDoc, { head: s } = r.newSelection.main, n = t.lineAt(s);
    if (s > n.from + lx)
      return r;
    let o = t.sliceString(n.from, s);
    if (!e.some((c) => c.test(o)))
      return r;
    let { state: i } = r, a = -1, l = [];
    for (let { head: c } of i.selection.ranges) {
      let u = i.doc.lineAt(c);
      if (u.from == a)
        continue;
      a = u.from;
      let d = ex(i, u.from);
      if (d == null)
        continue;
      let h = /^\s*/.exec(u.text)[0], f = Z_(i, d);
      h != f && l.push({ from: u.from, to: u.from + h.length, insert: f });
    }
    return l.length ? [r, { changes: l, sequential: !0 }] : r;
  });
}
const OF = /* @__PURE__ */ new Te();
function TF(r) {
  let e = r.firstChild, t = r.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? r.to : t.from } : null;
}
class ga {
  constructor(e, t) {
    this.specs = e;
    let s;
    function n(a) {
      let l = Rs.newName();
      return (s || (s = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const o = typeof t.all == "string" ? t.all : t.all ? n(t.all) : void 0, i = t.scope;
    this.scope = i instanceof mr ? (a) => a.prop(Xn) == i.data : i ? (a) => a == i : void 0, this.style = xb(e.map((a) => ({
      tag: a.tag,
      class: a.class || n(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = s ? new Rs(s) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new ga(e, t || {});
  }
}
const Kd = /* @__PURE__ */ pe.define(), Pb = /* @__PURE__ */ pe.define({
  combine(r) {
    return r.length ? [r[0]] : null;
  }
});
function Pu(r) {
  let e = r.facet(Kd);
  return e.length ? e : r.facet(Pb);
}
function cx(r, e) {
  let t = [dx], s;
  return r instanceof ga && (r.module && t.push(Ee.styleModule.of(r.module)), s = r.themeType), e != null && e.fallback ? t.push(Pb.of(r)) : s ? t.push(Kd.computeN([Ee.darkTheme], (n) => n.facet(Ee.darkTheme) == (s == "dark") ? [r] : [])) : t.push(Kd.of(r)), t;
}
class ux {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = kn(e.state), this.decorations = this.buildDeco(e, Pu(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = kn(e.state), s = Pu(e.state), n = s != Pu(e.startState), { viewport: o } = e.view, i = e.changes.mapPos(this.decoratedTo, 1);
    t.length < o.to && !n && t.type == this.tree.type && i >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = i) : (t != this.tree || e.viewportChanged || n) && (this.tree = t, this.decorations = this.buildDeco(e.view, s), this.decoratedTo = o.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return Je.none;
    let s = new yo();
    for (let { from: n, to: o } of e.visibleRanges)
      q_(this.tree, t, (i, a, l) => {
        s.add(i, a, this.markCache[l] || (this.markCache[l] = Je.mark({ class: l })));
      }, n, o);
    return s.finish();
  }
}
const dx = /* @__PURE__ */ Hh.high(/* @__PURE__ */ wr.fromClass(ux, {
  decorations: (r) => r.decorations
})), PF = /* @__PURE__ */ ga.define([
  {
    tag: G.meta,
    color: "#404740"
  },
  {
    tag: G.link,
    textDecoration: "underline"
  },
  {
    tag: G.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: G.emphasis,
    fontStyle: "italic"
  },
  {
    tag: G.strong,
    fontWeight: "bold"
  },
  {
    tag: G.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: G.keyword,
    color: "#708"
  },
  {
    tag: [G.atom, G.bool, G.url, G.contentSeparator, G.labelName],
    color: "#219"
  },
  {
    tag: [G.literal, G.inserted],
    color: "#164"
  },
  {
    tag: [G.string, G.deleted],
    color: "#a11"
  },
  {
    tag: [G.regexp, G.escape, /* @__PURE__ */ G.special(G.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ G.definition(G.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ G.local(G.variableName),
    color: "#30a"
  },
  {
    tag: [G.typeName, G.namespace],
    color: "#085"
  },
  {
    tag: G.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ G.special(G.variableName), G.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ G.definition(G.propertyName),
    color: "#00c"
  },
  {
    tag: G.comment,
    color: "#940"
  },
  {
    tag: G.invalid,
    color: "#f00"
  }
]), hx = /* @__PURE__ */ Ee.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), Ib = 1e4, Nb = "()[]{}", Mb = /* @__PURE__ */ pe.define({
  combine(r) {
    return Kh(r, {
      afterCursor: !0,
      brackets: Nb,
      maxScanDistance: Ib,
      renderMatch: mx
    });
  }
}), fx = /* @__PURE__ */ Je.mark({ class: "cm-matchingBracket" }), px = /* @__PURE__ */ Je.mark({ class: "cm-nonmatchingBracket" });
function mx(r) {
  let e = [], t = r.matched ? fx : px;
  return e.push(t.range(r.start.from, r.start.to)), r.end && e.push(t.range(r.end.from, r.end.to)), e;
}
const gx = /* @__PURE__ */ zs.define({
  create() {
    return Je.none;
  },
  update(r, e) {
    if (!e.docChanged && !e.selection)
      return r;
    let t = [], s = e.state.facet(Mb);
    for (let n of e.state.selection.ranges) {
      if (!n.empty)
        continue;
      let o = rl(e.state, n.head, -1, s) || n.head > 0 && rl(e.state, n.head - 1, 1, s) || s.afterCursor && (rl(e.state, n.head, 1, s) || n.head < e.state.doc.length && rl(e.state, n.head + 1, -1, s));
      o && (t = t.concat(s.renderMatch(o, e.state)));
    }
    return Je.set(t, !0);
  },
  provide: (r) => Ee.decorations.from(r)
}), yx = [
  gx,
  hx
];
function IF(r = {}) {
  return [Mb.of(r), yx];
}
const bx = /* @__PURE__ */ new Te();
function Wd(r, e, t) {
  let s = r.prop(e < 0 ? Te.openedBy : Te.closedBy);
  if (s)
    return s;
  if (r.name.length == 1) {
    let n = t.indexOf(r.name);
    if (n > -1 && n % 2 == (e < 0 ? 1 : 0))
      return [t[n + e]];
  }
  return null;
}
function Gd(r) {
  let e = r.type.prop(bx);
  return e ? e(r.node) : r;
}
function rl(r, e, t, s = {}) {
  let n = s.maxScanDistance || Ib, o = s.brackets || Nb, i = kn(r), a = i.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let c = Wd(l.type, t, o);
    if (c && l.from < l.to) {
      let u = Gd(l);
      if (u && (t > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return vx(r, e, t, l, u, c, o);
    }
  }
  return wx(r, e, t, i, a.type, n, o);
}
function vx(r, e, t, s, n, o, i) {
  let a = s.parent, l = { from: n.from, to: n.to }, c = 0, u = a == null ? void 0 : a.cursor();
  if (u && (t < 0 ? u.childBefore(s.from) : u.childAfter(s.to)))
    do
      if (t < 0 ? u.to <= s.from : u.from >= s.to) {
        if (c == 0 && o.indexOf(u.type.name) > -1 && u.from < u.to) {
          let d = Gd(u);
          return { start: l, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (Wd(u.type, t, i))
          c++;
        else if (Wd(u.type, -t, i)) {
          if (c == 0) {
            let d = Gd(u);
            return {
              start: l,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function wx(r, e, t, s, n, o, i) {
  let a = t < 0 ? r.sliceDoc(e - 1, e) : r.sliceDoc(e, e + 1), l = i.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, u = r.doc.iterRange(e, t > 0 ? r.doc.length : 0), d = 0;
  for (let h = 0; !u.next().done && h <= o; ) {
    let f = u.value;
    t < 0 && (h += f.length);
    let m = e + h * t;
    for (let g = t > 0 ? 0 : f.length - 1, p = t > 0 ? f.length : -1; g != p; g += t) {
      let y = i.indexOf(f[g]);
      if (!(y < 0 || s.resolveInner(m + g, 1).type != n))
        if (y % 2 == 0 == t > 0)
          d++;
        else {
          if (d == 1)
            return { start: c, end: { from: m + g, to: m + g + 1 }, matched: y >> 1 == l >> 1 };
          d--;
        }
    }
    t > 0 && (h += f.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
const kx = /* @__PURE__ */ Object.create(null), dg = [Bt.none], hg = [], fg = /* @__PURE__ */ Object.create(null), Sx = /* @__PURE__ */ Object.create(null);
for (let [r, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  Sx[r] = /* @__PURE__ */ $x(kx, e);
function Iu(r, e) {
  hg.indexOf(r) > -1 || (hg.push(r), console.warn(e));
}
function $x(r, e) {
  let t = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = r[c] || G[c];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : Iu(c, `Modifier ${c} used at start of tag`) : l.length ? Iu(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : Iu(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let s = e.replace(/ /g, "_"), n = s + " " + t.map((a) => a.id), o = fg[n];
  if (o)
    return o.id;
  let i = fg[n] = Bt.define({
    id: dg.length,
    name: s,
    props: [U_({ [s]: t })]
  });
  return dg.push(i), i.id;
}
ct.RTL, ct.LTR;
var _x = (r) => {
  var {
    theme: e,
    settings: t = {},
    styles: s = []
  } = r, n = {
    ".cm-gutters": {}
  }, o = {};
  t.background && (o.backgroundColor = t.background), t.backgroundImage && (o.backgroundImage = t.backgroundImage), t.foreground && (o.color = t.foreground), (t.background || t.foreground) && (n["&"] = o), t.fontFamily && (n["&.cm-editor .cm-scroller"] = {
    fontFamily: t.fontFamily
  }), t.gutterBackground && (n[".cm-gutters"].backgroundColor = t.gutterBackground), t.gutterForeground && (n[".cm-gutters"].color = t.gutterForeground), t.gutterBorder && (n[".cm-gutters"].borderRightColor = t.gutterBorder), t.caret && (n[".cm-content"] = {
    caretColor: t.caret
  }, n[".cm-cursor, .cm-dropCursor"] = {
    borderLeftColor: t.caret
  });
  var i = {};
  t.gutterActiveForeground && (i.color = t.gutterActiveForeground), t.lineHighlight && (n[".cm-activeLine"] = {
    backgroundColor: t.lineHighlight
  }, i.backgroundColor = t.lineHighlight), n[".cm-activeLineGutter"] = i, t.selection && (n["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
    background: t.selection + " !important"
  }), t.selectionMatch && (n["& .cm-selectionMatch"] = {
    backgroundColor: t.selectionMatch
  });
  var a = Ee.theme(n, {
    dark: e === "dark"
  }), l = ga.define(s), c = [a, cx(l)];
  return c;
};
const NF = _x({
  theme: "light",
  settings: {
    background: "var(--scalar-background-2)",
    foreground: "var(--scalar-color-1)",
    caret: "var(--scalar-color-1)",
    // Selection likely needs a hardcoded color due to it not accepting variables
    selection: "rgba(151, 183, 205, 0.2)",
    selectionMatch: "#e3dcce",
    gutterBackground: "var(--scalar-background-2)",
    gutterForeground: "var(--scalar-color-3)",
    gutterBorder: "transparent",
    lineHighlight: "var(--scalar-background-3)",
    fontFamily: "var(--scalar-font-code)"
  },
  styles: [
    {
      tag: [G.standard(G.tagName), G.tagName],
      color: "var(--scalar-color-purple)"
    },
    {
      tag: [G.comment],
      color: "var(--scalar-color-3)"
    },
    {
      tag: [G.className],
      color: "var(--scalar-color-orange)"
    },
    {
      tag: [G.variableName, G.propertyName, G.attributeName],
      color: "var(--scalar-color-1)"
    },
    {
      tag: [G.operator],
      color: "var(--scalar-color-2)"
    },
    {
      tag: [G.keyword, G.typeName, G.typeOperator],
      color: "var(--scalar-color-green)"
    },
    {
      tag: [G.string],
      color: "var(--scalar-color-blue)"
    },
    {
      tag: [G.bracket, G.regexp, G.meta],
      color: "var(--scalar-color-3)"
    },
    {
      tag: [G.number],
      color: "var(--scalar-color-blue)"
    },
    {
      tag: [G.name, G.quote],
      color: "var(--scalar-color-3)"
    },
    {
      tag: [G.heading],
      color: "var(--scalar-color-3)",
      fontWeight: "bold"
    },
    {
      tag: [G.emphasis],
      color: "var(--scalar-color-3)",
      fontStyle: "italic"
    },
    {
      tag: [G.deleted],
      color: "var(--scalar-color-3)",
      backgroundColor: "transparent"
    },
    {
      tag: [G.atom, G.bool, G.special(G.variableName)],
      color: "var(--scalar-color-3)"
    },
    {
      tag: [G.url, G.escape, G.regexp, G.link],
      color: "var(--scalar-color-1)"
    },
    { tag: G.link, textDecoration: "underline" },
    { tag: G.strikethrough, textDecoration: "line-through" },
    {
      tag: G.invalid,
      color: "var(--scalar-color-3)"
    }
  ]
}), pg = new gb({
  regexp: /(\{[^}]+\})/g,
  decoration: () => Je.mark({
    attributes: {
      class: "api-client-url-variable"
    }
  })
}), MF = () => wr.fromClass(
  class {
    constructor(r) {
      qp(this, "variables");
      this.variables = pg.createDeco(r);
    }
    update(r) {
      this.variables = pg.updateDeco(
        r,
        this.variables
      );
    }
  },
  {
    decorations: (r) => r.variables,
    provide: (r) => Ee.atomicRanges.of(
      (e) => {
        var t;
        return ((t = e.plugin(r)) == null ? void 0 : t.variables) || Je.none;
      }
    )
  }
), xx = { class: "scalar-modal-layout modal-layout" }, Cx = /* @__PURE__ */ Q({
  __name: "FlowModal",
  props: {
    state: {},
    title: {},
    bodyClass: {},
    maxWidth: {},
    variant: { default: "normal" }
  },
  setup(r) {
    return (e, t) => (S(), U($(Jw), {
      open: e.state.open,
      onClose: t[0] || (t[0] = (s) => e.state.hide())
    }, {
      default: P(() => [
        V("div", xx, [
          R($(Yw), {
            class: xe(["modal", {
              "modal-content-large": e.variant === "large",
              "modal-content-normal": e.variant === "normal",
              "modal-content-small": e.variant === "small",
              "modal-content-search": e.variant === "search",
              "modal-content-history": e.variant === "history"
            }]),
            style: os({ maxWidth: e.maxWidth })
          }, {
            default: P(() => [
              e.title ? (S(), U($(Xw), {
                key: 0,
                class: "modal-header"
              }, {
                default: P(() => [
                  J(ee(e.title), 1)
                ]),
                _: 1
              })) : z("", !0),
              R($(Qw), {
                class: xe(["modal-body custom-scroll", [e.bodyClass]])
              }, {
                default: P(() => [
                  te(e.$slots, "default", {}, void 0, !0)
                ]),
                _: 3
              }, 8, ["class"])
            ]),
            _: 3
          }, 8, ["class", "style"])
        ])
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), Ax = /* @__PURE__ */ ne(Cx, [["__scopeId", "data-v-4aafbf68"]]), Ex = () => $r({
  open: !1,
  show() {
    this.open = !0;
  },
  hide() {
    this.open = !1;
  }
});
function Nu() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
const Ox = (r, e) => {
  if (typeof e != "string" || !e.length)
    return r;
  const t = r.trim(), s = e.trim(), n = t.endsWith("/") ? t : `${t}/`, o = s.startsWith("/") ? s.slice(1) : s;
  return [n, o].join("");
};
function Tx(r) {
  return typeof window > "u" ? Buffer.from(r).toString("base64") : btoa(r);
}
const Px = (r) => {
  const e = /(?:\{+)\s*(\w+)\s*(?:\}+)/g;
  return [...r.matchAll(e)].map((t) => t[1].trim()) || [];
};
function Ix(r) {
  return !(!r || Array.isArray(r) && !r.length || (r ?? []).some(
    (e) => !Object.keys(e).length
  ));
}
function Db(r, e) {
  var l, c;
  const t = [], s = [], n = [];
  if (!r.customSecurity && (!r.preferredSecurityScheme || !Ix(e)))
    return { headers: t, queryString: s, cookies: n };
  const i = (e == null ? void 0 : e.some(
    (u) => r.preferredSecurityScheme && Object.keys(u).includes(
      r.preferredSecurityScheme
    )
  )) || r.customSecurity ? r.preferredSecurityScheme : Object.keys((e == null ? void 0 : e[0]) ?? {}).pop(), a = (l = r.securitySchemes) == null ? void 0 : l[i ?? ""];
  if (a) {
    if ("type" in a && a.type === "apiKey") {
      if ("in" in a && a.in === "header") {
        const u = (c = r.apiKey.token) != null && c.length ? r.apiKey.token : "YOUR_TOKEN";
        t.push({
          name: "name" in a ? a.name : "",
          value: u
        });
      } else if ("in" in a && a.in === "cookie") {
        const u = r.apiKey.token.length ? r.apiKey.token : "YOUR_TOKEN";
        n.push({
          name: a.name,
          value: u
        });
      } else if ("in" in a && a.in === "query") {
        const u = r.apiKey.token.length ? r.apiKey.token : "YOUR_TOKEN";
        s.push({
          name: a.name,
          value: u
        });
      }
    } else if ("type" in a && // @ts-ignore
    (a.type === "http" || a.type === "basic")) {
      if ("type" in a && // @ts-ignore
      (a.type === "basic" || a.type === "http" && a.scheme === "basic")) {
        const { username: u, password: d } = r.http.basic, h = Rb(u, d);
        t.push({
          name: "Authorization",
          value: `Basic ${h}`.trim()
        });
      } else if ("type" in a && a.type === "http" && a.scheme === "bearer") {
        const u = r.http.bearer.token.length ? r.http.bearer.token : "YOUR_SECRET_TOKEN";
        t.push({
          name: "Authorization",
          value: `Bearer ${u}`
        });
      }
    } else if ("type" in a && a.type.toLowerCase() === "oauth2") {
      const u = r.oAuth2.accessToken || "YOUR_SECRET_TOKEN";
      t.push({
        name: "Authorization",
        value: `Bearer ${u}`
      });
    }
  }
  return { headers: t, queryString: s, cookies: n };
}
function Rb(r, e) {
  return r != null && r.length || e != null && e.length ? Tx(`${r}:${e}`) : "";
}
function Nx(r) {
  return [
    r.apiKey.token,
    r.http.bearer.token,
    r.oAuth2.accessToken,
    // The basic auth token is the base64 encoded username and password
    Rb(
      r.http.basic.username,
      r.http.basic.password
    ),
    // The plain text password shouldn’t appear anyway, but just in case
    r.http.basic.password
  ].filter(Boolean);
}
function jb(r, e) {
  const t = /{{\s*([\w.-]+)\s*}}/g, s = /{\s*([\w.-]+)\s*}/g, n = (o, i) => {
    var a;
    return typeof e == "function" ? e(i) : (a = e[i]) == null ? void 0 : a.toString();
  };
  return r.replace(t, n).replace(s, n);
}
function Xl(r) {
  var n;
  const e = (n = r == null ? void 0 : r.servers) == null ? void 0 : n[r.selectedServer ?? 0], t = r.variables.reduce(
    (o, i) => (o[i.name] = i.value, o),
    {}
  );
  return typeof (e == null ? void 0 : e.url) == "string" ? jb(e == null ? void 0 : e.url, t) : e == null ? void 0 : e.url;
}
function Mx(r, e) {
  const t = new URL(e);
  return t.href = r, t.searchParams.append("scalar_url", e), t.toString();
}
const DF = Oh(Symbol());
var Dx = Object.defineProperty, Rx = (r, e, t) => e in r ? Dx(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, At = (r, e, t) => (Rx(r, typeof e != "symbol" ? e + "" : e, t), t);
function jx(r) {
  if (!r || typeof document > "u")
    return;
  let e = document.head || document.getElementsByTagName("head")[0], t = document.createElement("style");
  t.type = "text/css", e.appendChild(t), t.styleSheet ? t.styleSheet.cssText = r : t.appendChild(document.createTextNode(r));
}
jx("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999}[data-sonner-toaster][data-x-position=right]{right:max(var(--offset),env(safe-area-inset-right))}[data-sonner-toaster][data-x-position=left]{left:max(var(--offset),env(safe-area-inset-left))}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:max(var(--offset),env(safe-area-inset-top))}[data-sonner-toaster][data-y-position=bottom]{bottom:max(var(--offset),env(safe-area-inset-bottom))}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;will-change:transform,opacity,height;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast] [data-description]{font-weight:400;line-height:1.4;color:inherit}[data-sonner-toast] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast] [data-icon]{display:flex;height:20px;width:20px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast] [data-icon]>*{flex-shrink:0}[data-sonner-toast] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:0;transition:opacity .4s,box-shadow .2s;z-index:100}[data-sonner-toast] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toast][data-theme=dark] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;opacity:0;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast]:hover [data-close-button]{opacity:1}[data-sonner-toast]:focus [data-close-button]{opacity:1}[data-sonner-toast]:focus-within [data-close-button]{opacity:1}[data-sonner-toast]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]:before{content:'';position:absolute;left:0;right:0;height:100%}[data-sonner-toast][data-y-position=top][data-swiping=true]:before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]:before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]:before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast]:after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]:before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount,0));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{from{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;--mobile-offset:16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - 32px)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 91%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 91%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 91%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 100%, 12%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 12%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-rich-colors=true] [data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{display:none;transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}");
let Jd = 1;
class Lx {
  constructor() {
    At(this, "subscribers"), At(this, "toasts"), At(this, "subscribe", (e) => (this.subscribers.push(e), () => {
      const t = this.subscribers.indexOf(e);
      this.subscribers.splice(t, 1);
    })), At(this, "publish", (e) => {
      this.subscribers.forEach((t) => t(e));
    }), At(this, "addToast", (e) => {
      this.publish(e), this.toasts = [...this.toasts, e];
    }), At(this, "create", (e) => {
      var t;
      const { message: s, ...n } = e, o = typeof (e == null ? void 0 : e.id) == "number" || ((t = e.id) == null ? void 0 : t.length) > 0 ? e.id : Jd++, i = this.toasts.findIndex((l) => l.id === o), a = e.dismissible === void 0 ? !0 : e.dismissible;
      return i !== -1 ? this.toasts = this.toasts.map((l) => l.id === o ? (this.publish({ ...l, ...e, id: o, title: s }), {
        ...l,
        ...e,
        id: o,
        dismissible: a,
        title: s
      }) : l) : this.addToast({ title: s, ...n, dismissible: a, id: o }), o;
    }), At(this, "dismiss", (e) => (e || this.toasts.forEach((t) => {
      this.subscribers.forEach(
        (s) => s({ id: t.id, dismiss: !0 })
      );
    }), this.subscribers.forEach((t) => t({ id: e, dismiss: !0 })), e)), At(this, "message", (e, t) => this.create({ ...t, message: e })), At(this, "error", (e, t) => this.create({ ...t, type: "error", message: e })), At(this, "success", (e, t) => this.create({ ...t, type: "success", message: e })), At(this, "info", (e, t) => this.create({ ...t, type: "info", message: e })), At(this, "warning", (e, t) => this.create({ ...t, type: "warning", message: e })), At(this, "loading", (e, t) => this.create({ ...t, type: "loading", message: e })), At(this, "promise", (e, t) => {
      if (!t)
        return;
      let s;
      t.loading !== void 0 && (s = this.create({
        ...t,
        promise: e,
        type: "loading",
        message: t.loading
      }));
      const n = e instanceof Promise ? e : e();
      let o = s !== void 0;
      return n.then((i) => {
        if (t.success !== void 0) {
          o = !1;
          const a = typeof t.success == "function" ? t.success(i) : t.success;
          this.create({ id: s, type: "success", message: a });
        }
      }).catch((i) => {
        if (t.error !== void 0) {
          o = !1;
          const a = typeof t.error == "function" ? t.error(i) : t.error;
          this.create({ id: s, type: "error", message: a });
        }
      }).finally(() => {
        var i;
        o && (this.dismiss(s), s = void 0), (i = t.finally) == null || i.call(t);
      }), s;
    }), At(this, "custom", (e, t) => {
      const s = (t == null ? void 0 : t.id) || Jd++;
      return this.publish({ ...t, id: s, title: e }), s;
    }), this.subscribers = [], this.toasts = [];
  }
}
const dr = new Lx(), Bx = (r, e) => {
  const t = (e == null ? void 0 : e.id) || Jd++;
  return dr.publish({
    title: r,
    ...e,
    id: t
  }), t;
}, Fx = Bx, sl = Object.assign(Fx, {
  success: dr.success,
  info: dr.info,
  warning: dr.warning,
  error: dr.error,
  custom: dr.custom,
  message: dr.message,
  promise: dr.promise,
  dismiss: dr.dismiss,
  loading: dr.loading
}), Vx = ["data-visible"], Ux = { className: "sonner-spinner" }, zx = /* @__PURE__ */ Q({
  __name: "Loader",
  props: {
    visible: Boolean
  },
  setup(r) {
    const e = Array(12).fill(0);
    return (t, s) => (S(), E("div", {
      className: "sonner-loading-wrapper",
      "data-visible": r.visible
    }, [
      V("div", Ux, [
        (S(!0), E(Z, null, we($(e), (n) => (S(), E("div", {
          key: `spinner-bar-${n}`,
          className: "sonner-loading-bar"
        }))), 128))
      ])
    ], 8, Vx));
  }
}), ya = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [s, n] of e)
    t[s] = n;
  return t;
}, qx = {}, Hx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, Kx = /* @__PURE__ */ V("path", {
  "fill-rule": "evenodd",
  d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
  "clip-rule": "evenodd"
}, null, -1), Wx = [
  Kx
];
function Gx(r, e) {
  return S(), E("svg", Hx, Wx);
}
const Jx = /* @__PURE__ */ ya(qx, [["render", Gx]]), Yx = {}, Xx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, Qx = /* @__PURE__ */ V("path", {
  "fill-rule": "evenodd",
  d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
  "clip-rule": "evenodd"
}, null, -1), Zx = [
  Qx
];
function eC(r, e) {
  return S(), E("svg", Xx, Zx);
}
const tC = /* @__PURE__ */ ya(Yx, [["render", eC]]), rC = {}, sC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
}, nC = /* @__PURE__ */ V("path", {
  "fill-rule": "evenodd",
  d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
  "clip-rule": "evenodd"
}, null, -1), oC = [
  nC
];
function iC(r, e) {
  return S(), E("svg", sC, oC);
}
const aC = /* @__PURE__ */ ya(rC, [["render", iC]]), lC = {}, cC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
}, uC = /* @__PURE__ */ V("path", {
  "fill-rule": "evenodd",
  d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
  "clip-rule": "evenodd"
}, null, -1), dC = [
  uC
];
function hC(r, e) {
  return S(), E("svg", cC, dC);
}
const fC = /* @__PURE__ */ ya(lC, [["render", hC]]), pC = {}, mC = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, gC = /* @__PURE__ */ V("line", {
  x1: "18",
  y1: "6",
  x2: "6",
  y2: "18"
}, null, -1), yC = /* @__PURE__ */ V("line", {
  x1: "6",
  y1: "6",
  x2: "18",
  y2: "18"
}, null, -1), bC = [
  gC,
  yC
];
function vC(r, e) {
  return S(), E("svg", mC, bC);
}
const wC = /* @__PURE__ */ ya(pC, [["render", vC]]), kC = ["aria-live", "data-styled", "data-mounted", "data-promise", "data-removed", "data-visible", "data-y-position", "data-x-position", "data-index", "data-front", "data-swiping", "data-type", "data-invert", "data-swipe-out", "data-expanded"], SC = ["data-disabled"], $C = {
  key: 1,
  "data-icon": ""
}, _C = { "data-content": "" }, xC = { "data-title": "" }, CC = 4e3, AC = 14, EC = 20, OC = 200, TC = /* @__PURE__ */ Q({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    position: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    duration: {},
    descriptionClass: {}
  },
  emits: ["update:heights", "removeToast"],
  setup(r, { emit: e }) {
    const t = (D) => !!D.promise, s = e, n = r, o = ie(!1), i = ie(!1), a = ie(!1), l = ie(!1), c = ie(null), u = ie(0), d = ie(0), h = ie(null), f = ie(null), m = oe(() => n.index === 0), g = oe(() => n.index + 1 <= n.visibleToasts), p = oe(() => n.toast.type), y = oe(() => n.toast.dismissible), b = n.toast.className || "", v = n.toast.descriptionClassName || "", k = n.toast.style || {}, _ = oe(
      () => n.heights.findIndex((D) => D.toastId === n.toast.id) || 0
    ), w = oe(
      () => n.toast.duration || n.duration || CC
    ), x = ie(0), T = ie(0), j = ie(w.value), B = ie(0), W = ie(null), L = oe(() => n.position.split("-")), ue = oe(() => L.value[0]), ae = oe(() => L.value[1]), me = oe(() => n.heights.reduce((D, X, re) => re >= _.value ? D : D + X.height, 0)), Pe = oe(() => n.toast.invert || n.invert), De = oe(() => c.value === "loading"), Be = oe(
      () => c.value ?? (n.toast.type || null)
    ), ve = oe(() => !t(n.toast) && typeof n.toast.title == "object"), Y = oe(() => {
      if (!t(n.toast))
        return null;
      switch (c.value) {
        case "loading":
          return n.toast.loading;
        case "success":
          return typeof n.toast.success == "function" ? h.value : n.toast.success;
        case "error":
          return typeof n.toast.error == "function" ? h.value : n.toast.error;
        default:
          return null;
      }
    });
    vr(() => o.value = !0), Ei(() => {
      T.value = _.value * AC + me.value;
    });
    function M() {
      var D, X;
      (!De.value || y.value) && (q(), (X = (D = n.toast).onDismiss) == null || X.call(D, n.toast));
    }
    function q() {
      i.value = !0, u.value = T.value;
      const D = n.heights.filter(
        (X) => X.toastId !== n.toast.id
      );
      s("update:heights", D), setTimeout(() => {
        s("removeToast", n.toast);
      }, OC);
    }
    const F = (D) => {
      De || (u.value = T.value, D.target.setPointerCapture(D.pointerId), D.target.tagName !== "BUTTON" && (a.value = !0, W.value = { x: D.clientX, y: D.clientY }));
    }, C = (D) => {
      var X, re, ke, be;
      if (l.value)
        return;
      W.value = null;
      const Ne = Number(
        ((X = f.value) == null ? void 0 : X.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0
      );
      if (Math.abs(Ne) >= EC) {
        u.value = T.value, (ke = (re = n.toast).onDismiss) == null || ke.call(re, n.toast), q(), l.value = !0;
        return;
      }
      (be = f.value) == null || be.style.setProperty("--swipe-amount", "0px"), a.value = !0;
    }, I = (D) => {
      var X;
      if (!W.value)
        return;
      const re = D.clientY - W.value.y, ke = D.clientX - W.value.x, be = (L.value[0] === "top" ? Math.min : Math.max)(0, re), Ne = D.pointerType === "touch" ? 10 : 2;
      Math.abs(be) > Ne ? (X = f.value) == null || X.style.setProperty("--swipe-amount", `${re}px`) : Math.abs(ke) > Ne && (W.value = null);
    };
    return Ei((D) => {
      if (n.toast.promise && c.value === "loading" || n.toast.duration === 1 / 0)
        return;
      let X;
      const re = () => {
        if (B.value < x.value) {
          const be = (/* @__PURE__ */ new Date()).getTime() - x.value;
          j.value = j.value - be;
        }
        B.value = (/* @__PURE__ */ new Date()).getTime();
      }, ke = () => {
        x.value = (/* @__PURE__ */ new Date()).getTime(), X = setTimeout(() => {
          var be, Ne;
          (Ne = (be = n.toast).onAutoClose) == null || Ne.call(be, n.toast), q();
        }, j.value);
      };
      n.expanded || n.interacting ? re() : ke(), D(() => {
        clearTimeout(X);
      });
    }), vr(() => {
      if (f.value) {
        const D = f.value.getBoundingClientRect().height;
        d.value = D;
        const X = [{ toastId: n.toast.id, height: D }, ...n.heights];
        s("update:heights", X);
      }
    }), N0(() => {
      if (f.value) {
        const D = n.heights.filter(
          (X) => X.toastId !== n.toast.id
        );
        s("update:heights", D);
      }
    }), Ei(() => {
      n.toast.delete && q();
    }), (D, X) => (S(), E("li", {
      "aria-live": D.toast.important ? "assertive" : "polite",
      "aria-atomic": "",
      role: "status",
      tabindex: "0",
      ref_key: "toastRef",
      ref: f,
      "data-sonner-toast": "",
      class: xe($(b)),
      "data-styled": !ve.value,
      "data-mounted": o.value,
      "data-promise": !!D.toast.promise,
      "data-removed": i.value,
      "data-visible": g.value,
      "data-y-position": ue.value,
      "data-x-position": ae.value,
      "data-index": n.index,
      "data-front": m.value,
      "data-swiping": a.value,
      "data-type": c.value !== "loading" && c.value ? c.value : p.value,
      "data-invert": Pe.value,
      "data-swipe-out": l.value,
      "data-expanded": !!(n.expanded || n.expandByDefault && o.value),
      style: os({
        "--index": n.index,
        "--toasts-before": n.index,
        "--z-index": D.toasts.length - n.index,
        "--offset": `${i.value ? u.value : T.value}px`,
        "--initial-height": n.expandByDefault ? "auto" : `${d.value}px`,
        ...$(k)
      }),
      onPointerdown: F,
      onPointerup: C,
      onPointermove: I
    }, [
      n.closeButton && !ve.value ? (S(), E("button", {
        key: 0,
        "aria-label": "Close toast",
        "data-close-button": "",
        "data-disabled": De.value,
        onClick: M
      }, [
        R(wC)
      ], 8, SC)) : z("", !0),
      p.value || D.toast.icon || D.toast.promise ? (S(), E("div", $C, [
        typeof D.toast.promise == "function" || p.value === "loading" ? (S(), U(zx, {
          key: 0,
          visible: c.value === "loading" || p.value === "loading"
        }, null, 8, ["visible"])) : z("", !0),
        Be.value === "success" ? (S(), U(Jx, { key: 1 })) : Be.value === "info" ? (S(), U(tC, { key: 2 })) : Be.value === "warning" ? (S(), U(aC, { key: 3 })) : Be.value === "error" ? (S(), U(fC, { key: 4 })) : z("", !0)
      ])) : z("", !0),
      V("div", _C, [
        V("div", xC, [
          typeof D.toast.title == "string" ? (S(), E(Z, { key: 0 }, [
            J(ee(D.toast.title), 1)
          ], 64)) : D.toast.title === void 0 || D.toast.title === null ? (S(), E(Z, { key: 1 }, [
            J(ee(Y.value), 1)
          ], 64)) : ve.value ? (S(), U(br(D.toast.title), {
            key: 2,
            onCloseToast: X[0] || (X[0] = () => {
              var re;
              q(), (re = D.toast.cancel) != null && re.onClick && D.toast.cancel.onClick();
            })
          }, null, 32)) : z("", !0)
        ]),
        D.toast.description ? (S(), E("div", {
          key: 0,
          "data-description": "",
          class: xe(D.descriptionClass + $(v))
        }, ee(D.toast.description), 3)) : z("", !0)
      ]),
      D.toast.cancel ? (S(), E("button", {
        key: 2,
        "data-button": "",
        "data-cancel": "",
        onClick: X[1] || (X[1] = () => {
          var re;
          q(), (re = D.toast.cancel) != null && re.onClick && D.toast.cancel.onClick();
        })
      }, ee(D.toast.cancel.label), 1)) : z("", !0),
      D.toast.action ? (S(), E("button", {
        key: 3,
        "data-button": "",
        onClick: X[2] || (X[2] = () => {
          var re;
          q(), (re = D.toast.action) == null || re.onClick();
        })
      }, ee(D.toast.action.label), 1)) : z("", !0)
    ], 46, kC));
  }
}), PC = ["aria-label"], IC = ["dir", "data-theme", "data-rich-colors", "data-y-position", "data-x-position"], NC = 3, mg = "32px", MC = 4e3, DC = 356, gg = 14, RC = typeof window < "u" && typeof document < "u", jC = /* @__PURE__ */ Q({
  name: "Toaster",
  inheritAttrs: !1,
  __name: "Toaster",
  props: {
    invert: { type: Boolean, default: !1 },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: { type: Boolean, default: !1 },
    expand: { type: Boolean, default: !1 },
    duration: { default: MC },
    gap: { default: gg },
    visibleToasts: { default: NC },
    closeButton: { type: Boolean, default: !1 },
    toastOptions: { default: () => ({}) },
    className: { default: "" },
    style: { default: () => ({}) },
    offset: { default: mg },
    dir: { default: "auto" }
  },
  setup(r) {
    const e = r, t = Co(), s = ie([]), n = ie([]), o = ie(!1), i = ie(!1), a = ie(
      e.theme !== "system" ? e.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
    ), l = oe(() => e.position.split("-")), c = ie(null), u = e.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function d(f) {
      s.value = s.value.filter(({ id: m }) => m !== f.id);
    }
    function h() {
      if (typeof window > "u")
        return "ltr";
      const f = document.documentElement.getAttribute("dir");
      return f === "auto" || !f ? window.getComputedStyle(document.documentElement).direction : f;
    }
    return vr(() => {
      const f = dr.subscribe((m) => {
        if (m.dismiss) {
          s.value = s.value.map(
            (g) => g.id === m.id ? { ...g, delete: !0 } : g
          );
          return;
        }
        Ai(() => {
          const g = s.value.findIndex((p) => p.id === m.id);
          g !== -1 ? s.value.splice(g, 1, m) : s.value = [m, ...s.value];
        });
      });
      N0(() => {
        f();
      });
    }), Le(
      () => e.theme,
      (f) => {
        if (f !== "system") {
          a.value = f;
          return;
        }
        f === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? a.value = "dark" : a.value = "light"), !(typeof window > "u") && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches: m }) => {
          m ? a.value = "dark" : a.value = "light";
        });
      }
    ), Ei(() => {
      s.value.length <= 1 && (o.value = !1);
    }), Ei((f) => {
      function m(g) {
        var p, y;
        e.hotkey.every(
          (b) => g[b] || g.code === b
        ) && (o.value = !0, (p = c.value) == null || p.focus()), g.code === "Escape" && (document.activeElement === c.value || (y = c.value) != null && y.contains(document.activeElement)) && (o.value = !1);
      }
      RC && (document.addEventListener("keydown", m), f(() => {
        document.removeEventListener("keydown", m);
      }));
    }), (f, m) => {
      var g;
      return S(), E("section", {
        "aria-label": `Notifications ${$(u)}`,
        tabIndex: -1
      }, [
        V("ol", {
          ref_key: "listRef",
          ref: c,
          "data-sonner-toaster": "",
          dir: f.dir === "auto" ? h() : f.dir,
          tabIndex: -1,
          "data-theme": f.theme,
          "data-rich-colors": f.richColors,
          "data-y-position": l.value[0],
          "data-x-position": l.value[1],
          style: os(
            {
              "--front-toast-height": `${(g = n.value[0]) == null ? void 0 : g.height}px`,
              "--offset": typeof f.offset == "number" ? `${f.offset}px` : f.offset || mg,
              "--width": `${DC}px`,
              "--gap": `${gg}px`,
              ...$(t).style
            }
          ),
          onMouseenter: m[1] || (m[1] = (p) => o.value = !0),
          onMousemove: m[2] || (m[2] = (p) => o.value = !0),
          onMouseleave: m[3] || (m[3] = () => {
            i.value || (o.value = !1);
          }),
          onPointerdown: m[4] || (m[4] = (p) => i.value = !1),
          onPointerup: m[5] || (m[5] = (p) => i.value = !1)
        }, [
          (S(!0), E(Z, null, we(s.value, (p, y) => {
            var b, v, k, _;
            return S(), U(TC, {
              key: p.id,
              index: y,
              toast: p,
              duration: ((b = f.toastOptions) == null ? void 0 : b.duration) ?? f.duration,
              className: (v = f.toastOptions) == null ? void 0 : v.className,
              descriptionClassName: (k = f.toastOptions) == null ? void 0 : k.descriptionClassName,
              invert: f.invert,
              visibleToasts: f.visibleToasts,
              closeButton: f.closeButton,
              interacting: i.value,
              position: f.position,
              style: os((_ = f.toastOptions) == null ? void 0 : _.style),
              toasts: s.value,
              expandByDefault: f.expand,
              gap: f.gap,
              expanded: o.value,
              heights: n.value,
              "onUpdate:heights": m[0] || (m[0] = (w) => n.value = w),
              onRemoveToast: d
            }, null, 8, ["index", "toast", "duration", "className", "descriptionClassName", "invert", "visibleToasts", "closeButton", "interacting", "position", "style", "toasts", "expandByDefault", "gap", "expanded", "heights"]);
          }), 128))
        ], 44, IC)
      ], 8, PC);
    };
  }
}), Lb = {
  toast: () => null
};
function LC(r) {
  Lb.toast = r;
}
function of() {
  return {
    initializeToasts: LC,
    toast: (r, e = "info", t = { timeout: 3e3 }) => {
      Lb.toast(r, e, t);
    }
  };
}
const BC = /* @__PURE__ */ Q({
  __name: "ScalarToasts",
  setup(r) {
    const e = ie(!1);
    vr(() => e.value = !0);
    const t = {
      success: sl.success,
      error: sl.error,
      warn: sl.warning,
      info: sl
    }, { initializeToasts: s } = of();
    return s((n, o = "info", i = {}) => {
      (t[o] || t.info)(n, {
        duration: i.timeout || 3e3,
        description: i.description
      });
    }), (n, o) => e.value ? (S(), U($(jC), {
      key: 0,
      toastOptions: { className: "toaster" }
    })) : z("", !0);
  }
}), FC = {}, VC = { class: "card-form" };
function UC(r, e) {
  return S(), E("form", VC, [
    te(r.$slots, "default", {}, void 0, !0)
  ]);
}
const zC = /* @__PURE__ */ ne(FC, [["render", UC], ["__scopeId", "data-v-983db964"]]), qC = /* @__PURE__ */ Q({
  __name: "CardFormButton",
  setup(r, { expose: e }) {
    const t = ie();
    return e({ el: t }), (s, n) => (S(), E("button", {
      ref_key: "el",
      ref: t,
      class: "card-form-button",
      type: "button"
    }, [
      te(s.$slots, "default", {}, void 0, !0)
    ], 512));
  }
}), Bb = /* @__PURE__ */ ne(qC, [["__scopeId", "data-v-d19add49"]]), HC = {}, KC = { class: "card-form-group" };
function WC(r, e) {
  return S(), E("div", KC, [
    te(r.$slots, "default", {}, void 0, !0)
  ]);
}
const hi = /* @__PURE__ */ ne(HC, [["render", WC], ["__scopeId", "data-v-c2b3e8ed"]]), GC = {}, JC = { class: "card-form-rows" };
function YC(r, e) {
  return S(), E("div", JC, [
    te(r.$slots, "default", {}, void 0, !0)
  ]);
}
const yg = /* @__PURE__ */ ne(GC, [["render", YC], ["__scopeId", "data-v-31dc20e9"]]);
function Fb(r) {
  var e, t, s = "";
  if (typeof r == "string" || typeof r == "number")
    s += r;
  else if (typeof r == "object")
    if (Array.isArray(r))
      for (e = 0; e < r.length; e++)
        r[e] && (t = Fb(r[e])) && (s && (s += " "), s += t);
    else
      for (e in r)
        r[e] && (s && (s += " "), s += e);
  return s;
}
function Mu() {
  for (var r, e, t = 0, s = ""; t < arguments.length; )
    (r = arguments[t++]) && (e = Fb(r)) && (s && (s += " "), s += e);
  return s;
}
const bg = (r) => typeof r == "boolean" ? "".concat(r) : r === 0 ? "0" : r, XC = (r) => {
  const e = function() {
    for (var n = arguments.length, o = new Array(n), i = 0; i < n; i++)
      o[i] = arguments[i];
    var a, l;
    return typeof (r == null || (a = r.hooks) === null || a === void 0 ? void 0 : a["cx:done"]) < "u" ? r == null ? void 0 : r.hooks["cx:done"](Mu(o)) : typeof (r == null || (l = r.hooks) === null || l === void 0 ? void 0 : l.onComplete) < "u" ? r == null ? void 0 : r.hooks.onComplete(Mu(o)) : Mu(o);
  };
  return { compose: function() {
    for (var n = arguments.length, o = new Array(n), i = 0; i < n; i++)
      o[i] = arguments[i];
    return (a) => {
      const l = Object.fromEntries(Object.entries(a || {}).filter((c) => {
        let [u] = c;
        return !["class", "className"].includes(u);
      }));
      return e(o.map((c) => c(l)), a == null ? void 0 : a.class, a == null ? void 0 : a.className);
    };
  }, cva: (n) => (o) => {
    var i;
    if ((n == null ? void 0 : n.variants) == null)
      return e(n == null ? void 0 : n.base, o == null ? void 0 : o.class, o == null ? void 0 : o.className);
    const { variants: a, defaultVariants: l } = n, c = Object.keys(a).map((h) => {
      const f = o == null ? void 0 : o[h], m = l == null ? void 0 : l[h], g = bg(f) || bg(m);
      return a[h][g];
    }), u = { ...l, ...o && Object.entries(o).reduce((h, f) => {
      let [m, g] = f;
      return typeof g > "u" ? h : { ...h, [m]: g };
    }, {}) }, d = n == null || (i = n.compoundVariants) === null || i === void 0 ? void 0 : i.reduce((h, f) => {
      let { class: m, className: g, ...p } = f;
      return Object.entries(p).every((y) => {
        let [b, v] = y;
        const k = u[b];
        return Array.isArray(v) ? v.includes(k) : k === v;
      }) ? [...h, m, g] : h;
    }, []);
    return e(n == null ? void 0 : n.base, c, d, o == null ? void 0 : o.class, o == null ? void 0 : o.className);
  }, cx: e };
}, af = "-";
function QC(r) {
  const e = eA(r), {
    conflictingClassGroups: t,
    conflictingClassGroupModifiers: s
  } = r;
  function n(i) {
    const a = i.split(af);
    return a[0] === "" && a.length !== 1 && a.shift(), Vb(a, e) || ZC(i);
  }
  function o(i, a) {
    const l = t[i] || [];
    return a && s[i] ? [...l, ...s[i]] : l;
  }
  return {
    getClassGroupId: n,
    getConflictingClassGroupIds: o
  };
}
function Vb(r, e) {
  var i;
  if (r.length === 0)
    return e.classGroupId;
  const t = r[0], s = e.nextPart.get(t), n = s ? Vb(r.slice(1), s) : void 0;
  if (n)
    return n;
  if (e.validators.length === 0)
    return;
  const o = r.join(af);
  return (i = e.validators.find(({
    validator: a
  }) => a(o))) == null ? void 0 : i.classGroupId;
}
const vg = /^\[(.+)\]$/;
function ZC(r) {
  if (vg.test(r)) {
    const e = vg.exec(r)[1], t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (t)
      return "arbitrary.." + t;
  }
}
function eA(r) {
  const {
    theme: e,
    prefix: t
  } = r, s = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return rA(Object.entries(r.classGroups), t).forEach(([o, i]) => {
    Yd(i, s, o, e);
  }), s;
}
function Yd(r, e, t, s) {
  r.forEach((n) => {
    if (typeof n == "string") {
      const o = n === "" ? e : wg(e, n);
      o.classGroupId = t;
      return;
    }
    if (typeof n == "function") {
      if (tA(n)) {
        Yd(n(s), e, t, s);
        return;
      }
      e.validators.push({
        validator: n,
        classGroupId: t
      });
      return;
    }
    Object.entries(n).forEach(([o, i]) => {
      Yd(i, wg(e, o), t, s);
    });
  });
}
function wg(r, e) {
  let t = r;
  return e.split(af).forEach((s) => {
    t.nextPart.has(s) || t.nextPart.set(s, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), t = t.nextPart.get(s);
  }), t;
}
function tA(r) {
  return r.isThemeGetter;
}
function rA(r, e) {
  return e ? r.map(([t, s]) => {
    const n = s.map((o) => typeof o == "string" ? e + o : typeof o == "object" ? Object.fromEntries(Object.entries(o).map(([i, a]) => [e + i, a])) : o);
    return [t, n];
  }) : r;
}
function sA(r) {
  if (r < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, t = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  function n(o, i) {
    t.set(o, i), e++, e > r && (e = 0, s = t, t = /* @__PURE__ */ new Map());
  }
  return {
    get(o) {
      let i = t.get(o);
      if (i !== void 0)
        return i;
      if ((i = s.get(o)) !== void 0)
        return n(o, i), i;
    },
    set(o, i) {
      t.has(o) ? t.set(o, i) : n(o, i);
    }
  };
}
const Ub = "!";
function nA(r) {
  const e = r.separator, t = e.length === 1, s = e[0], n = e.length;
  return function(i) {
    const a = [];
    let l = 0, c = 0, u;
    for (let g = 0; g < i.length; g++) {
      let p = i[g];
      if (l === 0) {
        if (p === s && (t || i.slice(g, g + n) === e)) {
          a.push(i.slice(c, g)), c = g + n;
          continue;
        }
        if (p === "/") {
          u = g;
          continue;
        }
      }
      p === "[" ? l++ : p === "]" && l--;
    }
    const d = a.length === 0 ? i : i.substring(c), h = d.startsWith(Ub), f = h ? d.substring(1) : d, m = u && u > c ? u - c : void 0;
    return {
      modifiers: a,
      hasImportantModifier: h,
      baseClassName: f,
      maybePostfixModifierPosition: m
    };
  };
}
function oA(r) {
  if (r.length <= 1)
    return r;
  const e = [];
  let t = [];
  return r.forEach((s) => {
    s[0] === "[" ? (e.push(...t.sort(), s), t = []) : t.push(s);
  }), e.push(...t.sort()), e;
}
function iA(r) {
  return {
    cache: sA(r.cacheSize),
    splitModifiers: nA(r),
    ...QC(r)
  };
}
const aA = /\s+/;
function lA(r, e) {
  const {
    splitModifiers: t,
    getClassGroupId: s,
    getConflictingClassGroupIds: n
  } = e, o = /* @__PURE__ */ new Set();
  return r.trim().split(aA).map((i) => {
    const {
      modifiers: a,
      hasImportantModifier: l,
      baseClassName: c,
      maybePostfixModifierPosition: u
    } = t(i);
    let d = s(u ? c.substring(0, u) : c), h = !!u;
    if (!d) {
      if (!u)
        return {
          isTailwindClass: !1,
          originalClassName: i
        };
      if (d = s(c), !d)
        return {
          isTailwindClass: !1,
          originalClassName: i
        };
      h = !1;
    }
    const f = oA(a).join(":");
    return {
      isTailwindClass: !0,
      modifierId: l ? f + Ub : f,
      classGroupId: d,
      originalClassName: i,
      hasPostfixModifier: h
    };
  }).reverse().filter((i) => {
    if (!i.isTailwindClass)
      return !0;
    const {
      modifierId: a,
      classGroupId: l,
      hasPostfixModifier: c
    } = i, u = a + l;
    return o.has(u) ? !1 : (o.add(u), n(l, c).forEach((d) => o.add(a + d)), !0);
  }).reverse().map((i) => i.originalClassName).join(" ");
}
function cA() {
  let r = 0, e, t, s = "";
  for (; r < arguments.length; )
    (e = arguments[r++]) && (t = zb(e)) && (s && (s += " "), s += t);
  return s;
}
function zb(r) {
  if (typeof r == "string")
    return r;
  let e, t = "";
  for (let s = 0; s < r.length; s++)
    r[s] && (e = zb(r[s])) && (t && (t += " "), t += e);
  return t;
}
function kg(r, ...e) {
  let t, s, n, o = i;
  function i(l) {
    const c = e.reduce((u, d) => d(u), r());
    return t = iA(c), s = t.cache.get, n = t.cache.set, o = a, a(l);
  }
  function a(l) {
    const c = s(l);
    if (c)
      return c;
    const u = lA(l, t);
    return n(l, u), u;
  }
  return function() {
    return o(cA.apply(null, arguments));
  };
}
function He(r) {
  const e = (t) => t[r] || [];
  return e.isThemeGetter = !0, e;
}
const qb = /^\[(?:([a-z-]+):)?(.+)\]$/i, uA = /^\d+\/\d+$/, dA = /* @__PURE__ */ new Set(["px", "full", "screen"]), hA = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, fA = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, pA = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, mA = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, gA = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function Jr(r) {
  return cn(r) || dA.has(r) || uA.test(r);
}
function ps(r) {
  return No(r, "length", _A);
}
function cn(r) {
  return !!r && !Number.isNaN(Number(r));
}
function nl(r) {
  return No(r, "number", cn);
}
function fi(r) {
  return !!r && Number.isInteger(Number(r));
}
function yA(r) {
  return r.endsWith("%") && cn(r.slice(0, -1));
}
function _e(r) {
  return qb.test(r);
}
function ms(r) {
  return hA.test(r);
}
const bA = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function vA(r) {
  return No(r, bA, Hb);
}
function wA(r) {
  return No(r, "position", Hb);
}
const kA = /* @__PURE__ */ new Set(["image", "url"]);
function SA(r) {
  return No(r, kA, CA);
}
function $A(r) {
  return No(r, "", xA);
}
function pi() {
  return !0;
}
function No(r, e, t) {
  const s = qb.exec(r);
  return s ? s[1] ? typeof e == "string" ? s[1] === e : e.has(s[1]) : t(s[2]) : !1;
}
function _A(r) {
  return fA.test(r) && !pA.test(r);
}
function Hb() {
  return !1;
}
function xA(r) {
  return mA.test(r);
}
function CA(r) {
  return gA.test(r);
}
function Sg() {
  const r = He("colors"), e = He("spacing"), t = He("blur"), s = He("brightness"), n = He("borderColor"), o = He("borderRadius"), i = He("borderSpacing"), a = He("borderWidth"), l = He("contrast"), c = He("grayscale"), u = He("hueRotate"), d = He("invert"), h = He("gap"), f = He("gradientColorStops"), m = He("gradientColorStopPositions"), g = He("inset"), p = He("margin"), y = He("opacity"), b = He("padding"), v = He("saturate"), k = He("scale"), _ = He("sepia"), w = He("skew"), x = He("space"), T = He("translate"), j = () => ["auto", "contain", "none"], B = () => ["auto", "hidden", "clip", "visible", "scroll"], W = () => ["auto", _e, e], L = () => [_e, e], ue = () => ["", Jr, ps], ae = () => ["auto", cn, _e], me = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], Pe = () => ["solid", "dashed", "dotted", "double", "none"], De = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], Be = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], ve = () => ["", "0", _e], Y = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], M = () => [cn, nl], q = () => [cn, _e];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [pi],
      spacing: [Jr, ps],
      blur: ["none", "", ms, _e],
      brightness: M(),
      borderColor: [r],
      borderRadius: ["none", "", "full", ms, _e],
      borderSpacing: L(),
      borderWidth: ue(),
      contrast: M(),
      grayscale: ve(),
      hueRotate: q(),
      invert: ve(),
      gap: L(),
      gradientColorStops: [r],
      gradientColorStopPositions: [yA, ps],
      inset: W(),
      margin: W(),
      opacity: M(),
      padding: L(),
      saturate: M(),
      scale: M(),
      sepia: ve(),
      skew: q(),
      space: L(),
      translate: L()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", _e]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [ms]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": Y()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": Y()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...me(), _e]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: B()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": B()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": B()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: j()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": j()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": j()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", fi, _e]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: W()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", _e]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ve()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ve()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", fi, _e]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [pi]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", fi, _e]
        }, _e]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": ae()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": ae()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [pi]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [fi, _e]
        }, _e]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": ae()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": ae()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", _e]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", _e]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [h]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [h]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [h]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...Be()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...Be(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...Be(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [b]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [b]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [b]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [b]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [b]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [b]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [b]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [b]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [b]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [p]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [p]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [p]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [p]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [p]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [p]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [p]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [p]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [p]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [x]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [x]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", _e, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [_e, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [_e, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [ms]
        }, ms]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [_e, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [_e, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [_e, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [_e, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", ms, ps]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", nl]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [pi]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", _e]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", cn, nl]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Jr, _e]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", _e]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", _e]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [r]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [y]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [r]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [y]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Pe(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Jr, ps]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Jr, _e]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [r]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: L()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", _e]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", _e]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [y]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...me(), wA]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", vA]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, SA]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [r]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [m]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [m]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [m]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [f]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [f]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [f]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [o]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [o]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [o]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [o]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [o]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [o]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [o]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [o]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [o]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [o]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [o]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [o]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [o]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [o]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [o]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [y]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Pe(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [y]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: Pe()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [n]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [n]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [n]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [n]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [n]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [n]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [n]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [n]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...Pe()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Jr, _e]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Jr, ps]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [r]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: ue()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [r]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [y]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Jr, ps]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [r]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", ms, $A]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [pi]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [y]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...De(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": De()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [t]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [s]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", ms, _e]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [v]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [_]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [t]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [s]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [y]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [v]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [_]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [i]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [i]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [i]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", _e]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: q()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", _e]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: q()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", _e]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [k]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [k]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [k]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [fi, _e]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [T]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [T]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [w]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [w]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", _e]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", r]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", _e]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [r]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": L()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": L()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": L()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": L()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": L()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": L()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": L()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": L()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": L()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": L()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": L()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": L()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": L()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": L()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": L()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": L()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": L()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": L()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", _e]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [r, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Jr, ps, nl]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [r, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
function AA(r, {
  cacheSize: e,
  prefix: t,
  separator: s,
  extend: n = {},
  override: o = {}
}) {
  Tl(r, "cacheSize", e), Tl(r, "prefix", t), Tl(r, "separator", s);
  for (const i in o)
    EA(r[i], o[i]);
  for (const i in n)
    OA(r[i], n[i]);
  return r;
}
function Tl(r, e, t) {
  t !== void 0 && (r[e] = t);
}
function EA(r, e) {
  if (e)
    for (const t in e)
      Tl(r, t, e[t]);
}
function OA(r, e) {
  if (e)
    for (const t in e) {
      const s = e[t];
      s !== void 0 && (r[t] = (r[t] || []).concat(s));
    }
}
function TA(r, ...e) {
  return typeof r == "function" ? kg(Sg, r, ...e) : kg(() => AA(Sg(), r), ...e);
}
const Ql = Math.min, gn = Math.max, Zl = Math.round, ol = Math.floor, Fs = (r) => ({
  x: r,
  y: r
}), PA = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, IA = {
  start: "end",
  end: "start"
};
function $g(r, e, t) {
  return gn(r, Ql(e, t));
}
function Cc(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function Sn(r) {
  return r.split("-")[0];
}
function Ac(r) {
  return r.split("-")[1];
}
function Kb(r) {
  return r === "x" ? "y" : "x";
}
function Wb(r) {
  return r === "y" ? "height" : "width";
}
function Ec(r) {
  return ["top", "bottom"].includes(Sn(r)) ? "y" : "x";
}
function Gb(r) {
  return Kb(Ec(r));
}
function NA(r, e, t) {
  t === void 0 && (t = !1);
  const s = Ac(r), n = Gb(r), o = Wb(n);
  let i = n === "x" ? s === (t ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (i = ec(i)), [i, ec(i)];
}
function MA(r) {
  const e = ec(r);
  return [Xd(r), e, Xd(e)];
}
function Xd(r) {
  return r.replace(/start|end/g, (e) => IA[e]);
}
function DA(r, e, t) {
  const s = ["left", "right"], n = ["right", "left"], o = ["top", "bottom"], i = ["bottom", "top"];
  switch (r) {
    case "top":
    case "bottom":
      return t ? e ? n : s : e ? s : n;
    case "left":
    case "right":
      return e ? o : i;
    default:
      return [];
  }
}
function RA(r, e, t, s) {
  const n = Ac(r);
  let o = DA(Sn(r), t === "start", s);
  return n && (o = o.map((i) => i + "-" + n), e && (o = o.concat(o.map(Xd)))), o;
}
function ec(r) {
  return r.replace(/left|right|bottom|top/g, (e) => PA[e]);
}
function jA(r) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...r
  };
}
function LA(r) {
  return typeof r != "number" ? jA(r) : {
    top: r,
    right: r,
    bottom: r,
    left: r
  };
}
function tc(r) {
  const {
    x: e,
    y: t,
    width: s,
    height: n
  } = r;
  return {
    width: s,
    height: n,
    top: t,
    left: e,
    right: e + s,
    bottom: t + n,
    x: e,
    y: t
  };
}
function _g(r, e, t) {
  let {
    reference: s,
    floating: n
  } = r;
  const o = Ec(e), i = Gb(e), a = Wb(i), l = Sn(e), c = o === "y", u = s.x + s.width / 2 - n.width / 2, d = s.y + s.height / 2 - n.height / 2, h = s[a] / 2 - n[a] / 2;
  let f;
  switch (l) {
    case "top":
      f = {
        x: u,
        y: s.y - n.height
      };
      break;
    case "bottom":
      f = {
        x: u,
        y: s.y + s.height
      };
      break;
    case "right":
      f = {
        x: s.x + s.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: s.x - n.width,
        y: d
      };
      break;
    default:
      f = {
        x: s.x,
        y: s.y
      };
  }
  switch (Ac(e)) {
    case "start":
      f[i] -= h * (t && c ? -1 : 1);
      break;
    case "end":
      f[i] += h * (t && c ? -1 : 1);
      break;
  }
  return f;
}
const BA = async (r, e, t) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: i
  } = t, a = o.filter(Boolean), l = await (i.isRTL == null ? void 0 : i.isRTL(e));
  let c = await i.getElementRects({
    reference: r,
    floating: e,
    strategy: n
  }), {
    x: u,
    y: d
  } = _g(c, s, l), h = s, f = {}, m = 0;
  for (let g = 0; g < a.length; g++) {
    const {
      name: p,
      fn: y
    } = a[g], {
      x: b,
      y: v,
      data: k,
      reset: _
    } = await y({
      x: u,
      y: d,
      initialPlacement: s,
      placement: h,
      strategy: n,
      middlewareData: f,
      rects: c,
      platform: i,
      elements: {
        reference: r,
        floating: e
      }
    });
    u = b ?? u, d = v ?? d, f = {
      ...f,
      [p]: {
        ...f[p],
        ...k
      }
    }, _ && m <= 50 && (m++, typeof _ == "object" && (_.placement && (h = _.placement), _.rects && (c = _.rects === !0 ? await i.getElementRects({
      reference: r,
      floating: e,
      strategy: n
    }) : _.rects), {
      x: u,
      y: d
    } = _g(c, h, l)), g = -1);
  }
  return {
    x: u,
    y: d,
    placement: h,
    strategy: n,
    middlewareData: f
  };
};
async function Jb(r, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: s,
    y: n,
    platform: o,
    rects: i,
    elements: a,
    strategy: l
  } = r, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: h = !1,
    padding: f = 0
  } = Cc(e, r), m = LA(f), p = a[h ? d === "floating" ? "reference" : "floating" : d], y = tc(await o.getClippingRect({
    element: (t = await (o.isElement == null ? void 0 : o.isElement(p))) == null || t ? p : p.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), b = d === "floating" ? {
    ...i.floating,
    x: s,
    y: n
  } : i.reference, v = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), k = await (o.isElement == null ? void 0 : o.isElement(v)) ? await (o.getScale == null ? void 0 : o.getScale(v)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, _ = tc(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: b,
    offsetParent: v,
    strategy: l
  }) : b);
  return {
    top: (y.top - _.top + m.top) / k.y,
    bottom: (_.bottom - y.bottom + m.bottom) / k.y,
    left: (y.left - _.left + m.left) / k.x,
    right: (_.right - y.right + m.right) / k.x
  };
}
const FA = function(r) {
  return r === void 0 && (r = {}), {
    name: "flip",
    options: r,
    async fn(e) {
      var t, s;
      const {
        placement: n,
        middlewareData: o,
        rects: i,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: h,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: g = !0,
        ...p
      } = Cc(r, e);
      if ((t = o.arrow) != null && t.alignmentOffset)
        return {};
      const y = Sn(n), b = Sn(a) === a, v = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), k = h || (b || !g ? [ec(a)] : MA(a));
      !h && m !== "none" && k.push(...RA(a, g, m, v));
      const _ = [a, ...k], w = await Jb(e, p), x = [];
      let T = ((s = o.flip) == null ? void 0 : s.overflows) || [];
      if (u && x.push(w[y]), d) {
        const L = NA(n, i, v);
        x.push(w[L[0]], w[L[1]]);
      }
      if (T = [...T, {
        placement: n,
        overflows: x
      }], !x.every((L) => L <= 0)) {
        var j, B;
        const L = (((j = o.flip) == null ? void 0 : j.index) || 0) + 1, ue = _[L];
        if (ue)
          return {
            data: {
              index: L,
              overflows: T
            },
            reset: {
              placement: ue
            }
          };
        let ae = (B = T.filter((me) => me.overflows[0] <= 0).sort((me, Pe) => me.overflows[1] - Pe.overflows[1])[0]) == null ? void 0 : B.placement;
        if (!ae)
          switch (f) {
            case "bestFit": {
              var W;
              const me = (W = T.map((Pe) => [Pe.placement, Pe.overflows.filter((De) => De > 0).reduce((De, Be) => De + Be, 0)]).sort((Pe, De) => Pe[1] - De[1])[0]) == null ? void 0 : W[0];
              me && (ae = me);
              break;
            }
            case "initialPlacement":
              ae = a;
              break;
          }
        if (n !== ae)
          return {
            reset: {
              placement: ae
            }
          };
      }
      return {};
    }
  };
};
async function VA(r, e) {
  const {
    placement: t,
    platform: s,
    elements: n
  } = r, o = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), i = Sn(t), a = Ac(t), l = Ec(t) === "y", c = ["left", "top"].includes(i) ? -1 : 1, u = o && l ? -1 : 1, d = Cc(e, r);
  let {
    mainAxis: h,
    crossAxis: f,
    alignmentAxis: m
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return a && typeof m == "number" && (f = a === "end" ? m * -1 : m), l ? {
    x: f * u,
    y: h * c
  } : {
    x: h * c,
    y: f * u
  };
}
const UA = function(r) {
  return r === void 0 && (r = 0), {
    name: "offset",
    options: r,
    async fn(e) {
      var t, s;
      const {
        x: n,
        y: o,
        placement: i,
        middlewareData: a
      } = e, l = await VA(e, r);
      return i === ((t = a.offset) == null ? void 0 : t.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: n + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: i
        }
      };
    }
  };
}, zA = function(r) {
  return r === void 0 && (r = {}), {
    name: "shift",
    options: r,
    async fn(e) {
      const {
        x: t,
        y: s,
        placement: n
      } = e, {
        mainAxis: o = !0,
        crossAxis: i = !1,
        limiter: a = {
          fn: (p) => {
            let {
              x: y,
              y: b
            } = p;
            return {
              x: y,
              y: b
            };
          }
        },
        ...l
      } = Cc(r, e), c = {
        x: t,
        y: s
      }, u = await Jb(e, l), d = Ec(Sn(n)), h = Kb(d);
      let f = c[h], m = c[d];
      if (o) {
        const p = h === "y" ? "top" : "left", y = h === "y" ? "bottom" : "right", b = f + u[p], v = f - u[y];
        f = $g(b, f, v);
      }
      if (i) {
        const p = d === "y" ? "top" : "left", y = d === "y" ? "bottom" : "right", b = m + u[p], v = m - u[y];
        m = $g(b, m, v);
      }
      const g = a.fn({
        ...e,
        [h]: f,
        [d]: m
      });
      return {
        ...g,
        data: {
          x: g.x - t,
          y: g.y - s
        }
      };
    }
  };
};
function cs(r) {
  return lf(r) ? (r.nodeName || "").toLowerCase() : "#document";
}
function Kt(r) {
  var e;
  return (r == null || (e = r.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function fs(r) {
  var e;
  return (e = (lf(r) ? r.ownerDocument : r.document) || window.document) == null ? void 0 : e.documentElement;
}
function lf(r) {
  return r instanceof Node || r instanceof Kt(r).Node;
}
function us(r) {
  return r instanceof Element || r instanceof Kt(r).Element;
}
function zr(r) {
  return r instanceof HTMLElement || r instanceof Kt(r).HTMLElement;
}
function xg(r) {
  return typeof ShadowRoot > "u" ? !1 : r instanceof ShadowRoot || r instanceof Kt(r).ShadowRoot;
}
function ba(r) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: s,
    display: n
  } = nr(r);
  return /auto|scroll|overlay|hidden|clip/.test(e + s + t) && !["inline", "contents"].includes(n);
}
function qA(r) {
  return ["table", "td", "th"].includes(cs(r));
}
function cf(r) {
  const e = uf(), t = nr(r);
  return t.transform !== "none" || t.perspective !== "none" || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((s) => (t.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (t.contain || "").includes(s));
}
function HA(r) {
  let e = ko(r);
  for (; zr(e) && !Oc(e); ) {
    if (cf(e))
      return e;
    e = ko(e);
  }
  return null;
}
function uf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Oc(r) {
  return ["html", "body", "#document"].includes(cs(r));
}
function nr(r) {
  return Kt(r).getComputedStyle(r);
}
function Tc(r) {
  return us(r) ? {
    scrollLeft: r.scrollLeft,
    scrollTop: r.scrollTop
  } : {
    scrollLeft: r.pageXOffset,
    scrollTop: r.pageYOffset
  };
}
function ko(r) {
  if (cs(r) === "html")
    return r;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    r.assignedSlot || // DOM Element detected.
    r.parentNode || // ShadowRoot detected.
    xg(r) && r.host || // Fallback.
    fs(r)
  );
  return xg(e) ? e.host : e;
}
function Yb(r) {
  const e = ko(r);
  return Oc(e) ? r.ownerDocument ? r.ownerDocument.body : r.body : zr(e) && ba(e) ? e : Yb(e);
}
function ea(r, e, t) {
  var s;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const n = Yb(r), o = n === ((s = r.ownerDocument) == null ? void 0 : s.body), i = Kt(n);
  return o ? e.concat(i, i.visualViewport || [], ba(n) ? n : [], i.frameElement && t ? ea(i.frameElement) : []) : e.concat(n, ea(n, [], t));
}
function Xb(r) {
  const e = nr(r);
  let t = parseFloat(e.width) || 0, s = parseFloat(e.height) || 0;
  const n = zr(r), o = n ? r.offsetWidth : t, i = n ? r.offsetHeight : s, a = Zl(t) !== o || Zl(s) !== i;
  return a && (t = o, s = i), {
    width: t,
    height: s,
    $: a
  };
}
function df(r) {
  return us(r) ? r : r.contextElement;
}
function ao(r) {
  const e = df(r);
  if (!zr(e))
    return Fs(1);
  const t = e.getBoundingClientRect(), {
    width: s,
    height: n,
    $: o
  } = Xb(e);
  let i = (o ? Zl(t.width) : t.width) / s, a = (o ? Zl(t.height) : t.height) / n;
  return (!i || !Number.isFinite(i)) && (i = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: i,
    y: a
  };
}
const KA = /* @__PURE__ */ Fs(0);
function Qb(r) {
  const e = Kt(r);
  return !uf() || !e.visualViewport ? KA : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function WA(r, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Kt(r) ? !1 : e;
}
function $n(r, e, t, s) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const n = r.getBoundingClientRect(), o = df(r);
  let i = Fs(1);
  e && (s ? us(s) && (i = ao(s)) : i = ao(r));
  const a = WA(o, t, s) ? Qb(o) : Fs(0);
  let l = (n.left + a.x) / i.x, c = (n.top + a.y) / i.y, u = n.width / i.x, d = n.height / i.y;
  if (o) {
    const h = Kt(o), f = s && us(s) ? Kt(s) : s;
    let m = h, g = m.frameElement;
    for (; g && s && f !== m; ) {
      const p = ao(g), y = g.getBoundingClientRect(), b = nr(g), v = y.left + (g.clientLeft + parseFloat(b.paddingLeft)) * p.x, k = y.top + (g.clientTop + parseFloat(b.paddingTop)) * p.y;
      l *= p.x, c *= p.y, u *= p.x, d *= p.y, l += v, c += k, m = Kt(g), g = m.frameElement;
    }
  }
  return tc({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
const GA = [":popover-open", ":modal"];
function Zb(r) {
  return GA.some((e) => {
    try {
      return r.matches(e);
    } catch {
      return !1;
    }
  });
}
function JA(r) {
  let {
    elements: e,
    rect: t,
    offsetParent: s,
    strategy: n
  } = r;
  const o = n === "fixed", i = fs(s), a = e ? Zb(e.floating) : !1;
  if (s === i || a && o)
    return t;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = Fs(1);
  const u = Fs(0), d = zr(s);
  if ((d || !d && !o) && ((cs(s) !== "body" || ba(i)) && (l = Tc(s)), zr(s))) {
    const h = $n(s);
    c = ao(s), u.x = h.x + s.clientLeft, u.y = h.y + s.clientTop;
  }
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - l.scrollLeft * c.x + u.x,
    y: t.y * c.y - l.scrollTop * c.y + u.y
  };
}
function YA(r) {
  return Array.from(r.getClientRects());
}
function ev(r) {
  return $n(fs(r)).left + Tc(r).scrollLeft;
}
function XA(r) {
  const e = fs(r), t = Tc(r), s = r.ownerDocument.body, n = gn(e.scrollWidth, e.clientWidth, s.scrollWidth, s.clientWidth), o = gn(e.scrollHeight, e.clientHeight, s.scrollHeight, s.clientHeight);
  let i = -t.scrollLeft + ev(r);
  const a = -t.scrollTop;
  return nr(s).direction === "rtl" && (i += gn(e.clientWidth, s.clientWidth) - n), {
    width: n,
    height: o,
    x: i,
    y: a
  };
}
function QA(r, e) {
  const t = Kt(r), s = fs(r), n = t.visualViewport;
  let o = s.clientWidth, i = s.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, i = n.height;
    const c = uf();
    (!c || c && e === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: i,
    x: a,
    y: l
  };
}
function ZA(r, e) {
  const t = $n(r, !0, e === "fixed"), s = t.top + r.clientTop, n = t.left + r.clientLeft, o = zr(r) ? ao(r) : Fs(1), i = r.clientWidth * o.x, a = r.clientHeight * o.y, l = n * o.x, c = s * o.y;
  return {
    width: i,
    height: a,
    x: l,
    y: c
  };
}
function Cg(r, e, t) {
  let s;
  if (e === "viewport")
    s = QA(r, t);
  else if (e === "document")
    s = XA(fs(r));
  else if (us(e))
    s = ZA(e, t);
  else {
    const n = Qb(r);
    s = {
      ...e,
      x: e.x - n.x,
      y: e.y - n.y
    };
  }
  return tc(s);
}
function tv(r, e) {
  const t = ko(r);
  return t === e || !us(t) || Oc(t) ? !1 : nr(t).position === "fixed" || tv(t, e);
}
function eE(r, e) {
  const t = e.get(r);
  if (t)
    return t;
  let s = ea(r, [], !1).filter((a) => us(a) && cs(a) !== "body"), n = null;
  const o = nr(r).position === "fixed";
  let i = o ? ko(r) : r;
  for (; us(i) && !Oc(i); ) {
    const a = nr(i), l = cf(i);
    !l && a.position === "fixed" && (n = null), (o ? !l && !n : !l && a.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || ba(i) && !l && tv(r, i)) ? s = s.filter((u) => u !== i) : n = a, i = ko(i);
  }
  return e.set(r, s), s;
}
function tE(r) {
  let {
    element: e,
    boundary: t,
    rootBoundary: s,
    strategy: n
  } = r;
  const i = [...t === "clippingAncestors" ? eE(e, this._c) : [].concat(t), s], a = i[0], l = i.reduce((c, u) => {
    const d = Cg(e, u, n);
    return c.top = gn(d.top, c.top), c.right = Ql(d.right, c.right), c.bottom = Ql(d.bottom, c.bottom), c.left = gn(d.left, c.left), c;
  }, Cg(e, a, n));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function rE(r) {
  const {
    width: e,
    height: t
  } = Xb(r);
  return {
    width: e,
    height: t
  };
}
function sE(r, e, t) {
  const s = zr(e), n = fs(e), o = t === "fixed", i = $n(r, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Fs(0);
  if (s || !s && !o)
    if ((cs(e) !== "body" || ba(n)) && (a = Tc(e)), s) {
      const d = $n(e, !0, o, e);
      l.x = d.x + e.clientLeft, l.y = d.y + e.clientTop;
    } else
      n && (l.x = ev(n));
  const c = i.left + a.scrollLeft - l.x, u = i.top + a.scrollTop - l.y;
  return {
    x: c,
    y: u,
    width: i.width,
    height: i.height
  };
}
function Ag(r, e) {
  return !zr(r) || nr(r).position === "fixed" ? null : e ? e(r) : r.offsetParent;
}
function rv(r, e) {
  const t = Kt(r);
  if (!zr(r) || Zb(r))
    return t;
  let s = Ag(r, e);
  for (; s && qA(s) && nr(s).position === "static"; )
    s = Ag(s, e);
  return s && (cs(s) === "html" || cs(s) === "body" && nr(s).position === "static" && !cf(s)) ? t : s || HA(r) || t;
}
const nE = async function(r) {
  const e = this.getOffsetParent || rv, t = this.getDimensions;
  return {
    reference: sE(r.reference, await e(r.floating), r.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await t(r.floating)
    }
  };
};
function oE(r) {
  return nr(r).direction === "rtl";
}
const iE = {
  convertOffsetParentRelativeRectToViewportRelativeRect: JA,
  getDocumentElement: fs,
  getClippingRect: tE,
  getOffsetParent: rv,
  getElementRects: nE,
  getClientRects: YA,
  getDimensions: rE,
  getScale: ao,
  isElement: us,
  isRTL: oE
};
function aE(r, e) {
  let t = null, s;
  const n = fs(r);
  function o() {
    var a;
    clearTimeout(s), (a = t) == null || a.disconnect(), t = null;
  }
  function i(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const {
      left: c,
      top: u,
      width: d,
      height: h
    } = r.getBoundingClientRect();
    if (a || e(), !d || !h)
      return;
    const f = ol(u), m = ol(n.clientWidth - (c + d)), g = ol(n.clientHeight - (u + h)), p = ol(c), b = {
      rootMargin: -f + "px " + -m + "px " + -g + "px " + -p + "px",
      threshold: gn(0, Ql(1, l)) || 1
    };
    let v = !0;
    function k(_) {
      const w = _[0].intersectionRatio;
      if (w !== l) {
        if (!v)
          return i();
        w ? i(!1, w) : s = setTimeout(() => {
          i(!1, 1e-7);
        }, 100);
      }
      v = !1;
    }
    try {
      t = new IntersectionObserver(k, {
        ...b,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      t = new IntersectionObserver(k, b);
    }
    t.observe(r);
  }
  return i(!0), o;
}
function lE(r, e, t, s) {
  s === void 0 && (s = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: o = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = s, c = df(r), u = n || o ? [...c ? ea(c) : [], ...ea(e)] : [];
  u.forEach((y) => {
    n && y.addEventListener("scroll", t, {
      passive: !0
    }), o && y.addEventListener("resize", t);
  });
  const d = c && a ? aE(c, t) : null;
  let h = -1, f = null;
  i && (f = new ResizeObserver((y) => {
    let [b] = y;
    b && b.target === c && f && (f.unobserve(e), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      var v;
      (v = f) == null || v.observe(e);
    })), t();
  }), c && !l && f.observe(c), f.observe(e));
  let m, g = l ? $n(r) : null;
  l && p();
  function p() {
    const y = $n(r);
    g && (y.x !== g.x || y.y !== g.y || y.width !== g.width || y.height !== g.height) && t(), g = y, m = requestAnimationFrame(p);
  }
  return t(), () => {
    var y;
    u.forEach((b) => {
      n && b.removeEventListener("scroll", t), o && b.removeEventListener("resize", t);
    }), d == null || d(), (y = f) == null || y.disconnect(), f = null, l && cancelAnimationFrame(m);
  };
}
const cE = zA, uE = FA, dE = (r, e, t) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: iE,
    ...t
  }, o = {
    ...n.platform,
    _c: s
  };
  return BA(r, e, {
    ...n,
    platform: o
  });
};
function hE(r) {
  return r != null && typeof r == "object" && "$el" in r;
}
function Eg(r) {
  if (hE(r)) {
    const e = r.$el;
    return lf(e) && cs(e) === "#comment" ? null : e;
  }
  return r;
}
function sv(r) {
  return typeof window > "u" ? 1 : (r.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Og(r, e) {
  const t = sv(r);
  return Math.round(e * t) / t;
}
function fE(r, e, t) {
  t === void 0 && (t = {});
  const s = t.whileElementsMounted, n = oe(() => {
    var x;
    return (x = $(t.open)) != null ? x : !0;
  }), o = oe(() => $(t.middleware)), i = oe(() => {
    var x;
    return (x = $(t.placement)) != null ? x : "bottom";
  }), a = oe(() => {
    var x;
    return (x = $(t.strategy)) != null ? x : "absolute";
  }), l = oe(() => {
    var x;
    return (x = $(t.transform)) != null ? x : !0;
  }), c = oe(() => Eg(r.value)), u = oe(() => Eg(e.value)), d = ie(0), h = ie(0), f = ie(a.value), m = ie(i.value), g = Lw({}), p = ie(!1), y = oe(() => {
    const x = {
      position: f.value,
      left: "0",
      top: "0"
    };
    if (!u.value)
      return x;
    const T = Og(u.value, d.value), j = Og(u.value, h.value);
    return l.value ? {
      ...x,
      transform: "translate(" + T + "px, " + j + "px)",
      ...sv(u.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: f.value,
      left: T + "px",
      top: j + "px"
    };
  });
  let b;
  function v() {
    c.value == null || u.value == null || dE(c.value, u.value, {
      middleware: o.value,
      placement: i.value,
      strategy: a.value
    }).then((x) => {
      d.value = x.x, h.value = x.y, f.value = x.strategy, m.value = x.placement, g.value = x.middlewareData, p.value = !0;
    });
  }
  function k() {
    typeof b == "function" && (b(), b = void 0);
  }
  function _() {
    if (k(), s === void 0) {
      v();
      return;
    }
    if (c.value != null && u.value != null) {
      b = s(c.value, u.value, v);
      return;
    }
  }
  function w() {
    n.value || (p.value = !1);
  }
  return Le([o, i, a], v, {
    flush: "sync"
  }), Le([c, u], _, {
    flush: "sync"
  }), Le(n, w, {
    flush: "sync"
  }), Bw() && Fw(k), {
    x: Bn(d),
    y: Bn(h),
    strategy: Bn(f),
    placement: Bn(m),
    middlewareData: Bn(g),
    isPositioned: Bn(p),
    floatingStyles: y,
    update: v
  };
}
const pE = TA({
  extend: {
    classGroups: {
      "font-size": ["text-xxs"]
    }
  }
}), { cva: hf, cx: Tn, compose: RF } = XC({
  hooks: {
    onComplete: (r) => pE(r)
  }
}), mE = /* @__PURE__ */ la('<path class="svg-path svg-check-mark" d="m 0 60 l 30 30 l 70 -80" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 -40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 -40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 40" data-v-47faceda></path>', 5), gE = {
  key: 0,
  class: "circular-loader"
}, yE = /* @__PURE__ */ Q({
  __name: "ScalarLoading",
  props: {
    loadingState: {},
    size: { default: "24px" }
  },
  setup(r) {
    return Vw((e) => ({
      d6cae758: e.size
    })), (e, t) => e.loadingState ? (S(), E("div", {
      key: 0,
      class: xe($(Tn)("loader-wrapper"))
    }, [
      (S(), E("svg", {
        class: xe(["svg-loader", {
          "icon-is-valid": e.loadingState.isValid,
          "icon-is-invalid": e.loadingState.isInvalid
        }]),
        viewBox: "0 0 100 100",
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      }, [
        mE,
        e.loadingState.isLoading ? (S(), E("g", gE, [
          V("circle", {
            class: xe(["loader-path", {
              "loader-path-off": e.loadingState.isValid || e.loadingState.isInvalid
            }]),
            cx: "50",
            cy: "50",
            fill: "none",
            r: "20",
            "stroke-width": "2"
          }, null, 2)
        ])) : z("", !0)
      ], 2))
    ], 2)) : z("", !0);
  }
}), bE = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [s, n] of e)
    t[s] = n;
  return t;
}, nv = /* @__PURE__ */ bE(yE, [["__scopeId", "data-v-47faceda"]]), ov = {
  solid: [
    "scalar-button-solid",
    "bg-b-btn text-c-btn shadow-sm active:bg-b-btn active:shadow-none hocus:bg-h-btn"
  ],
  outlined: [
    "scalar-button-outlined",
    "active:bg-btn-1 border border-solid border-border bg-transparent text-c-1 hocus:bg-border"
  ],
  ghost: [
    "scalar-button-ghost",
    "bg-transparent text-c-3 transition-colors active:text-c-1 hocus:text-c-1"
  ],
  danger: [
    "scalar-button-danger",
    "bg-error text-white active:brightness-90 hocus:brightness-90"
  ]
}, vE = hf({
  base: "scalar-button row cursor-pointer items-center justify-center rounded font-medium",
  variants: {
    disabled: {
      true: "bg-background-2 text-color-3 cursor-not-allowed shadow-none"
    },
    fullWidth: { true: "w-full" },
    size: { sm: "px-2 py-1 text-xs", md: "h-10 px-6 text-sm" },
    variant: ov
  },
  compoundVariants: [
    {
      disabled: !0,
      variant: "ghost",
      class: "text-ghost bg-transparent"
    }
  ]
}), wE = ["ariaDisabled", "type"], kE = {
  key: 0,
  class: "mr-2 h-4 w-4"
}, SE = {
  key: 1,
  class: "ml-2"
}, Tg = /* @__PURE__ */ Q({
  inheritAttrs: !1,
  __name: "ScalarButton",
  props: {
    disabled: { type: Boolean },
    fullWidth: { type: Boolean, default: !1 },
    loading: {},
    size: { default: "md" },
    variant: { default: "solid" },
    type: { default: "button" }
  },
  setup(r) {
    const e = oe(() => {
      const { class: t, ...s } = Co();
      return { class: t || "", rest: s };
    });
    return (t, s) => (S(), E("button", En(e.value.rest, {
      ariaDisabled: t.disabled || void 0,
      class: $(Tn)(
        $(vE)({ fullWidth: t.fullWidth, disabled: t.disabled, size: t.size, variant: t.variant }),
        { "pl-9 pr-3": t.loading },
        `${e.value.class}`
      ),
      type: t.type
    }), [
      t.$slots.icon ? (S(), E("div", kE, [
        te(t.$slots, "icon")
      ])) : z("", !0),
      te(t.$slots, "default"),
      t.loading ? (S(), E("div", SE, [
        R($(nv), {
          loadingState: t.loading,
          size: "20px"
        }, null, 8, ["loadingState"])
      ])) : z("", !0)
    ], 16, wE));
  }
});
(function(r) {
  var e = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", t = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: !0,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  }, s = {
    bash: t,
    environment: {
      pattern: RegExp("\\$" + e),
      alias: "constant"
    },
    variable: [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: !0,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          variable: [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: !0
            },
            /^\$\(\(/
          ],
          number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          punctuation: /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: !0,
        inside: {
          variable: /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: !0,
        inside: {
          operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          punctuation: /[\[\]]/,
          environment: {
            pattern: RegExp("(\\{)" + e),
            lookbehind: !0,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  r.languages.bash = {
    shebang: {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    comment: {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: !0
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: !0,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: !0
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        environment: {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + e),
          lookbehind: !0,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: !0
    },
    // Highlight parameter names as variables
    parameter: {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: !0
    },
    string: [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: !0,
        greedy: !0,
        inside: s
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          bash: t
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: !0,
        greedy: !0,
        inside: s
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: !0,
        greedy: !0
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: !0,
        inside: {
          entity: s.entity
        }
      }
    ],
    environment: {
      pattern: RegExp("\\$?" + e),
      alias: "constant"
    },
    variable: s.variable,
    function: {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    keyword: {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    builtin: {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: !0,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    boolean: {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    operator: {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    number: {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: !0
    }
  }, t.inside = r.languages.bash;
  for (var n = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "parameter",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ], o = s.variable[1].inside, i = 0; i < n.length; i++)
    o[n[i]] = r.languages.bash[n[i]];
  r.languages.sh = r.languages.bash, r.languages.shell = r.languages.bash;
})(Prism);
Prism.languages.json = {
  property: {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: !0,
    greedy: !0
  },
  string: {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: !0,
    greedy: !0
  },
  comment: {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: !0
  },
  number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  punctuation: /[{}[\],]/,
  operator: /:/,
  boolean: /\b(?:false|true)\b/,
  null: {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function() {
  if (typeof Prism > "u" || typeof document > "u")
    return;
  var r = "line-numbers", e = /\n(?!$)/g, t = Prism.plugins.lineNumbers = {
    /**
     * Get node for provided line number
     *
     * @param {Element} element pre element
     * @param {number} number line number
     * @returns {Element|undefined}
     */
    getLine: function(i, a) {
      if (!(i.tagName !== "PRE" || !i.classList.contains(r))) {
        var l = i.querySelector(".line-numbers-rows");
        if (l) {
          var c = parseInt(i.getAttribute("data-start"), 10) || 1, u = c + (l.children.length - 1);
          a < c && (a = c), a > u && (a = u);
          var d = a - c;
          return l.children[d];
        }
      }
    },
    /**
     * Resizes the line numbers of the given element.
     *
     * This function will not add line numbers. It will only resize existing ones.
     *
     * @param {HTMLElement} element A `<pre>` element with line numbers.
     * @returns {void}
     */
    resize: function(i) {
      s([i]);
    },
    /**
     * Whether the plugin can assume that the units font sizes and margins are not depended on the size of
     * the current viewport.
     *
     * Setting this to `true` will allow the plugin to do certain optimizations for better performance.
     *
     * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.
     *
     * @type {boolean}
     */
    assumeViewportIndependence: !0
  };
  function s(i) {
    if (i = i.filter(function(l) {
      var c = n(l), u = c["white-space"];
      return u === "pre-wrap" || u === "pre-line";
    }), i.length != 0) {
      var a = i.map(function(l) {
        var c = l.querySelector("code"), u = l.querySelector(".line-numbers-rows");
        if (!(!c || !u)) {
          var d = l.querySelector(".line-numbers-sizer"), h = c.textContent.split(e);
          d || (d = document.createElement("span"), d.className = "line-numbers-sizer", c.appendChild(d)), d.innerHTML = "0", d.style.display = "block";
          var f = d.getBoundingClientRect().height;
          return d.innerHTML = "", {
            element: l,
            lines: h,
            lineHeights: [],
            oneLinerHeight: f,
            sizer: d
          };
        }
      }).filter(Boolean);
      a.forEach(function(l) {
        var c = l.sizer, u = l.lines, d = l.lineHeights, h = l.oneLinerHeight;
        d[u.length - 1] = void 0, u.forEach(function(f, m) {
          if (f && f.length > 1) {
            var g = c.appendChild(document.createElement("span"));
            g.style.display = "block", g.textContent = f;
          } else
            d[m] = h;
        });
      }), a.forEach(function(l) {
        for (var c = l.sizer, u = l.lineHeights, d = 0, h = 0; h < u.length; h++)
          u[h] === void 0 && (u[h] = c.children[d++].getBoundingClientRect().height);
      }), a.forEach(function(l) {
        var c = l.sizer, u = l.element.querySelector(".line-numbers-rows");
        c.style.display = "none", c.innerHTML = "", l.lineHeights.forEach(function(d, h) {
          u.children[h].style.height = d + "px";
        });
      });
    }
  }
  function n(i) {
    return i ? window.getComputedStyle ? getComputedStyle(i) : i.currentStyle || null : null;
  }
  var o = void 0;
  window.addEventListener("resize", function() {
    t.assumeViewportIndependence && o === window.innerWidth || (o = window.innerWidth, s(Array.prototype.slice.call(document.querySelectorAll("pre." + r))));
  }), Prism.hooks.add("complete", function(i) {
    if (i.code) {
      var a = (
        /** @type {Element} */
        i.element
      ), l = (
        /** @type {HTMLElement} */
        a.parentNode
      );
      if (!(!l || !/pre/i.test(l.nodeName)) && !a.querySelector(".line-numbers-rows") && Prism.util.isActive(a, r)) {
        a.classList.remove(r), l.classList.add(r);
        var c = i.code.match(e), u = c ? c.length + 1 : 1, d, h = new Array(u + 1).join("<span></span>");
        d = document.createElement("span"), d.setAttribute("aria-hidden", "true"), d.className = "line-numbers-rows", d.innerHTML = h, l.hasAttribute("data-start") && (l.style.counterReset = "linenumber " + (parseInt(l.getAttribute("data-start"), 10) - 1)), i.element.appendChild(d), s([l]), Prism.hooks.run("line-numbers", i);
      }
    }
  }), Prism.hooks.add("line-numbers", function(i) {
    i.plugins = i.plugins || {}, i.plugins.lineNumbers = !0;
  });
})();
function $E(r) {
  const e = /* @__PURE__ */ new Set();
  return JSON.stringify(
    r,
    (t, s) => {
      if (typeof s == "object" && s !== null) {
        if (e.has(s))
          return "[Circular]";
        e.add(s);
      }
      return s;
    },
    2
  );
}
function il(r) {
  if (typeof r == "string")
    return r;
  if (typeof r == "object")
    try {
      return JSON.stringify(r, null, 2);
    } catch {
      return $E(r);
    }
  return r;
}
const _E = ["innerHTML"], As = /* @__PURE__ */ Q({
  __name: "ScalarCodeBlock",
  props: {
    content: {},
    lang: { default: "js" },
    lineNumbers: { type: Boolean, default: !1 },
    hideCredentials: {}
  },
  setup(r) {
    const e = r, t = Nh(il(e.content)), s = `components-scalar-code-block${t}`, { plugins: n, highlightElement: o } = ii;
    e.hideCredentials && ii.hooks.add("wrap", function(d) {
      if (!e.hideCredentials)
        return;
      let h = !1;
      typeof e.hideCredentials == "string" ? d.content.includes(e.hideCredentials) && (h = !0) : Array.isArray(e.hideCredentials) && (h = e.hideCredentials.some(
        (f) => d.content.includes(f)
      )), h && (d.content = d.content.replace(
        /<span class="credentials">.*?<\/span>/g,
        (f) => f.replace(/<span class="credentials">|<\/span>/g, "")
      ), d.content = d.content.replace(
        new RegExp(
          typeof e.hideCredentials == "string" ? e.hideCredentials : e.hideCredentials.join("|"),
          "g"
        ),
        (f) => `<span class="credentials">${f}</span>`
      ));
    });
    const i = ie(null), a = ie(Eo[s] ?? ""), l = oe(() => e.lang === "node" ? "js" : e.lang), c = e.lang;
    Le(
      [() => e.lang, () => e.content, i],
      () => {
        i.value && e.content && (!a.value || e.lang !== c) && (a.value = "", Ai(() => o(i.value)));
      },
      { immediate: !0 }
    );
    const u = /\n(?!$)/g;
    return On(async () => {
      let d = "";
      e.lineNumbers && ii.hooks.add("after-tokenize", (f) => {
        const m = f.code.match(u), g = m ? m.length + 1 : 1;
        d = `<span aria-hidden="true" class="line-numbers-rows">${new Array(g + 1).join("<span></span>")}</span>`;
      });
      const h = ii.highlight(
        il(e.content),
        ii.languages[l.value],
        l.value
      );
      if (a.value = h + d, t !== 0) {
        const f = aa();
        f.payload.data[s] = h + d;
      }
    }), vr(async () => {
      await import("./prism-autoloader-Dlh8Vzlw-C7VXQ4L8.js"), n.autoloader.languages_path = "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/";
    }), (d, h) => (S(), E("pre", {
      class: xe([
        `scalar-component scalar-codeblock-pre language-${l.value}`,
        {
          "line-numbers": d.lineNumbers
        }
      ])
    }, [
      a.value ? (S(), E("code", {
        key: 0,
        class: xe(`scalar-codeblock-code language-${l.value}`),
        innerHTML: $(il)(a.value)
      }, null, 10, _E)) : (S(), E("code", {
        key: 1,
        ref_key: "el",
        ref: i,
        class: xe(`scalar-codeblock-code language-${l.value}`)
      }, ee($(il)(d.content)), 3))
    ], 2));
  }
}), Pg = /* @__PURE__ */ Object.assign({ "./Add.svg": () => import("./Add-yNxGpRcH-i9lEuw9B.js"), "./ArrowLeft.svg": () => import("./ArrowLeft-D7tW1xQo-BjB3hnI2.js"), "./ArrowRight.svg": () => import("./ArrowRight-DmO-sdb2-H1bq-qXL.js"), "./Background.svg": () => import("./Background-CU9VIbfN-xKhyTRz6.js"), "./Brackets.svg": () => import("./Brackets-CI207-BL-BbcUG0IL.js"), "./Branch.svg": () => import("./Branch-CXwj8YuG-CvPS_xP0.js"), "./CallToAction.svg": () => import("./CallToAction-XLYRSI1h-Dk1vrnxq.js"), "./Checkmark.svg": () => import("./Checkmark-DhbrPM0P-CFDz_1Nm.js"), "./ChevronDown.svg": () => import("./ChevronDown-Co7EAKAv-Dw2u19C4.js"), "./ChevronLeft.svg": () => import("./ChevronLeft-DYt0idAu-4ItgPaSH.js"), "./ChevronRight.svg": () => import("./ChevronRight-ylxToVWl-DMyZ2Rmi.js"), "./ChevronUp.svg": () => import("./ChevronUp-xAnukIfj-DYWzMh-o.js"), "./Clipboard.svg": () => import("./Clipboard-CU_KxGEv-DuOPrhqK.js"), "./Close.svg": () => import("./Close-xHiYwS8Q-DaTuBpAM.js"), "./CodeFolder.svg": () => import("./CodeFolder-Cv_igzJE-POyxhw77.js"), "./Cookie.svg": () => import("./Cookie-CEHvXpqB-Bu1-nQ4L.js"), "./DarkMode.svg": () => import("./DarkMode-BMR457PH-CsW2G1Ro.js"), "./Delete.svg": () => import("./Delete-BCZmxrDD-RGj_5vHb.js"), "./Discord.svg": () => import("./Discord-BHYOFBB2-BKiLx0Gp.js"), "./DocsPage.svg": () => import("./DocsPage-Dwx7ZMU9-DKxfVlkW.js"), "./Duplicate.svg": () => import("./Duplicate-DRWEv4R_-_bYPzpGJ.js"), "./Edit.svg": () => import("./Edit-Br04RNYb-DB3yOiz_.js"), "./Ellipses.svg": () => import("./Ellipses-Bo_X36Hx-D4ayuQAy.js"), "./Error.svg": () => import("./Error-C5LiISnw-IKDSjs2b.js"), "./ExternalLink.svg": () => import("./ExternalLink-DK8L-EH7-CnaH9txm.js"), "./FilterList.svg": () => import("./FilterList-CS8Il7NE-DP4JzPbN.js"), "./Folder.svg": () => import("./Folder-CTvnVSEo-tyPfoogp.js"), "./GitHub.svg": () => import("./GitHub-NdE6Zs9k-CxmMd7Ky.js"), "./Hide.svg": () => import("./Hide-BgcCtErz-YdhS0s7w.js"), "./History.svg": () => import("./History-D9nmhNIn-Bg9VGGKO.js"), "./JsonObject.svg": () => import("./JsonObject-hGdHUQ4M-JVzShx7P.js"), "./Key.svg": () => import("./Key-CWXJqX28-CVsMvoNb.js"), "./Leave.svg": () => import("./Leave-K1J3uwoG-6WpXSkaE.js"), "./LightDarkModeToggle.svg": () => import("./LightDarkModeToggle-De3vO47x-D8h5xBww.js"), "./LightMode.svg": () => import("./LightMode-BeoMphBY-Bbi5XCzQ.js"), "./Link.svg": () => import("./Link-Bzuc__Nc-Bopu3OCd.js"), "./Lock.svg": () => import("./Lock-xhiH1mKz-j1VwEotb.js"), "./Logo.svg": () => import("./Logo-DwEDtgj--CRDrhASr.js"), "./LogoAPI.svg": () => import("./LogoAPI-CohCfL3L-DgS67ep-.js"), "./LogoClient.svg": () => import("./LogoClient-Bq5O2QL2-BqHqCFAv.js"), "./LogoMarket.svg": () => import("./LogoMarket-DwlApcab-BpTQzqp5.js"), "./LogoSwagger.svg": () => import("./LogoSwagger-CH60H5qW--whYwExv.js"), "./Magic.svg": () => import("./Magic-Dsi9_bEc-BSsgSxL9.js"), "./Menu.svg": () => import("./Menu-CFK5cOsm-Bt89Z42K.js"), "./Page.svg": () => import("./Page-DA7CO5gc-D_LbSKiY.js"), "./PaperAirplane.svg": () => import("./PaperAirplane-BC-4mGEB-CC_xr_GF.js"), "./Payment.svg": () => import("./Payment-hzcXP1Xb-DwRM2zOI.js"), "./Play.svg": () => import("./Play-Cd4-o7Ji-W8fYdYxD.js"), "./Refresh.svg": () => import("./Refresh-BHRzzQ8P-CAKdmF9h.js"), "./Response.svg": () => import("./Response-DsTlT4S--CiyBwPLY.js"), "./Search.svg": () => import("./Search-DqtlswRG-C2Pti_ld.js"), "./Show.svg": () => import("./Show-CbiiMLUa-BCfT7JXE.js"), "./SideBarClosed.svg": () => import("./SideBarClosed-K53-CtXh-D5UXDtJk.js"), "./SideBarOpen.svg": () => import("./SideBarOpen-C7UgT82P-jT5NeYXy.js"), "./Sort.svg": () => import("./Sort-CaVMT7jM-KsvCed7U.js"), "./Terminal.svg": () => import("./Terminal-DJ7x2McL-BTmQzliq.js"), "./ThumbsDown.svg": () => import("./ThumbsDown-BMgnsASL-B1FsmbXx.js"), "./ThumbsUp.svg": () => import("./ThumbsUp-C1j6zY2j-Ca8-bvgl.js"), "./Trash.svg": () => import("./Trash-BpA3zWPD-RGj_5vHb.js"), "./Unlock.svg": () => import("./Unlock-HVYHMLxl-CsSSru63.js"), "./Upload.svg": () => import("./Upload-D_pwqBDY-DlTMOwHN.js"), "./User.svg": () => import("./User-BLGkPc5I-D-da3lPk.js"), "./programming-framework-angular.svg": () => import("./programming-framework-angular-DD4Vjgbk-CUF3ZYYB.js"), "./programming-framework-astro.svg": () => import("./programming-framework-astro-CLfrRt19-CH6OCtd8.js"), "./programming-framework-laravel.svg": () => import("./programming-framework-laravel-kAy2wVLy-kXRM5aCd.js"), "./programming-framework-nextdotjs.svg": () => import("./programming-framework-nextdotjs-BKdd_DY_-DF9m888v.js"), "./programming-framework-react.svg": () => import("./programming-framework-react-PDgmtZuN-DZjob66N.js"), "./programming-framework-vuedotjs.svg": () => import("./programming-framework-vuedotjs-Cim7D5tw-CxkKqgPk.js"), "./programming-language-c.svg": () => import("./programming-language-c-hPGu2Zvg-BesPZa4K.js"), "./programming-language-clojure.svg": () => import("./programming-language-clojure-uqYXn7U6-BhlaJXXC.js"), "./programming-language-csharp.svg": () => import("./programming-language-csharp-CGxYkVA6-BJwUA9TV.js"), "./programming-language-css3.svg": () => import("./programming-language-css3-Dpp4Cr6b-Dpx1zlAe.js"), "./programming-language-go.svg": () => import("./programming-language-go-CuKo8iD9-BpDx-Uk5.js"), "./programming-language-html5.svg": () => import("./programming-language-html5-DlqJK4EL-DfQp7LQz.js"), "./programming-language-http.svg": () => import("./programming-language-http-f3NXC-Ae-CBKA8Rw2.js"), "./programming-language-java.svg": () => import("./programming-language-java-BBodetdf-Do7Uo0sg.js"), "./programming-language-javascript.svg": () => import("./programming-language-javascript-VxLvi1QG-qbgoUfZ8.js"), "./programming-language-json.svg": () => import("./programming-language-json-Dq_K-q5f-CD7uIR91.js"), "./programming-language-kotlin.svg": () => import("./programming-language-kotlin-eTASnmL3-OG0Z7YBS.js"), "./programming-language-node.svg": () => import("./programming-language-node-oucaVOgY-BvGMDoeB.js"), "./programming-language-objc.svg": () => import("./programming-language-objc-CPgQxmNi-D44rlWUI.js"), "./programming-language-ocaml.svg": () => import("./programming-language-ocaml-Q1-Jv5Q5-QKB_Bc7i.js"), "./programming-language-php.svg": () => import("./programming-language-php-GY38f8r4-jRMN5AZX.js"), "./programming-language-powershell.svg": () => import("./programming-language-powershell-xLOxAYP_-Ck82ebOe.js"), "./programming-language-python.svg": () => import("./programming-language-python-Ct-_kNjo-DsKRdoNg.js"), "./programming-language-r.svg": () => import("./programming-language-r-Ch3T1qiC-BO-CjZZM.js"), "./programming-language-ruby.svg": () => import("./programming-language-ruby-DhdM4d7g-BuT1i5is.js"), "./programming-language-scala.svg": () => import("./programming-language-scala-BVg0dToJ-p_n-G2sI.js"), "./programming-language-shell.svg": () => import("./programming-language-shell-uj1zoCVW-BZSmYs-C.js"), "./programming-language-swift.svg": () => import("./programming-language-swift-Dn72xPjg-D-JnfNts.js"), "./programming-language-typescript.svg": () => import("./programming-language-typescript-CdF-HuRi-ocSQSwHb.js"), "./programming-script-code.svg": () => import("./programming-script-code-CUHv6qR8-DMwI7fYl.js"), "./programming-tool-git.svg": () => import("./programming-tool-git-C-BMJCAo-DUuF7AA-.js"), "./programming-tool-tailwindcss.svg": () => import("./programming-tool-tailwindcss-xjXi0E6g-r5YhtCAf.js") }), Ig = (r) => {
  const e = `./${r}.svg`;
  return Pg[e] ? M0(Pg[e]) : (console.warn(`Could not find icon: ${r}`), null);
}, xE = ["src"], Ze = /* @__PURE__ */ Q({
  __name: "ScalarIcon",
  props: {
    icon: {},
    size: {}
  },
  setup(r) {
    const e = r, t = hf({
      variants: {
        size: {
          xs: "size-3 stroke-[1.4]",
          sm: "size-3.5 stroke-[1.2]",
          md: "size-4 stroke-[1.1]",
          lg: "size-5",
          xl: "size-6 stroke-[0.96]",
          "2xl": "size-8 stroke-[0.92]",
          "3xl": "size-10 stroke-[0.9]",
          full: "size-full"
        }
      },
      defaultVariants: {
        size: "full"
      }
    }), s = Ig(e.icon);
    return (n, o) => $(s) ? (S(), U(br($(Ig)(n.icon)), {
      key: 0,
      class: xe($(Tn)("scalar-icon", $(t)({ size: n.size })))
    }, null, 8, ["class"])) : (S(), E("img", {
      key: 1,
      src: n.icon
    }, null, 8, xE));
  }
}), CE = ["ariaDisabled"], AE = { class: "sr-only" }, va = /* @__PURE__ */ Q({
  __name: "ScalarIconButton",
  props: {
    label: {},
    icon: {},
    disabled: { type: Boolean },
    variant: { default: "ghost" },
    size: { default: "md" }
  },
  setup(r) {
    const e = hf({
      base: "scalar-icon-button grid aspect-square cursor-pointer rounded",
      variants: {
        size: {
          xxs: "size-3.5 p-0.5",
          xs: "size-5 p-1",
          sm: "size-6 p-1",
          md: "size-10 p-3",
          full: "h-full w-full"
        },
        disabled: {
          true: "cursor-not-allowed shadow-none"
        },
        variant: ov
      }
    }), t = oe(() => {
      const { class: s, ...n } = Co();
      return { class: s || "", rest: n };
    });
    return (s, n) => (S(), E("button", En(t.value.rest, {
      ariaDisabled: s.disabled || void 0,
      class: $(Tn)($(e)({ size: s.size, variant: s.variant, disabled: s.disabled }), t.value.class),
      type: "button"
    }), [
      R($(Ze), { icon: s.icon }, null, 8, ["icon"]),
      V("span", AE, ee(s.label), 1)
    ], 16, CE));
  }
}), EE = { class: "sr-only" }, OE = ["value"], TE = /* @__PURE__ */ Q({
  inheritAttrs: !1,
  __name: "ScalarSearchInput",
  props: {
    loading: {},
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const t = e;
    function s(o) {
      t("update:modelValue", o.target.value);
    }
    const n = oe(() => {
      const { class: o, ...i } = Co();
      return { className: o || "", rest: i };
    });
    return (o, i) => (S(), E("label", En(n.value.rest, {
      class: $(Tn)(
        "flex rounded border bg-b-1 text-sm font-medium focus-within:border-c-1",
        n.value.className
      )
    }), [
      V("span", EE, [
        te(o.$slots, "label", {}, () => [
          J("Enter search")
        ])
      ]),
      V("input", {
        autocapitalize: "off",
        autocomplete: "off",
        autocorrect: "off",
        class: "flex-1 rounded bg-transparent p-3 outline-none",
        placeholder: "Search...",
        spellcheck: "false",
        type: "text",
        value: o.modelValue,
        onInput: s
      }, null, 40, OE),
      o.loading && o.loading.isLoading ? (S(), U($(nv), {
        key: 0,
        class: "mr-3 self-center",
        loadingState: o.loading,
        size: "20px"
      }, null, 8, ["loadingState"])) : o.modelValue ? (S(), U($(va), {
        key: 1,
        class: "self-center",
        icon: "Close",
        label: "Clear Search",
        size: "md",
        onClick: i[0] || (i[0] = (a) => t("update:modelValue", ""))
      })) : z("", !0)
    ], 16));
  }
}), PE = /* @__PURE__ */ V("div", { class: "flex flex-col items-center gap-2 px-3 py-4" }, [
  /* @__PURE__ */ V("div", { class: "rotate-90 text-lg font-bold" }, ":("),
  /* @__PURE__ */ V("div", { class: "text-sm font-medium text-c-2" }, "No results found")
], -1), IE = /* @__PURE__ */ Q({
  inheritAttrs: !1,
  __name: "ScalarSearchResultList",
  props: {
    noResults: { type: Boolean }
  },
  setup(r) {
    const e = oe(() => {
      const { class: t, ...s } = Co();
      return { className: t || "", rest: s };
    });
    return (t, s) => (S(), E("ul", En(e.value.rest, {
      class: $(Tn)("flex flex-col", e.value.className)
    }), [
      t.noResults ? te(t.$slots, "noResults", { key: 0 }, () => [
        PE
      ]) : z("", !0),
      te(t.$slots, "default")
    ], 16));
  }
}), NE = { class: "contents" }, ME = { class: "text-c-3 group-hover:text-c-1" }, DE = { class: "flex min-w-0 flex-1 flex-col gap-0.75" }, RE = { class: "flex items-center gap-1" }, jE = { class: "flex-1 truncate text-sm font-medium" }, LE = {
  key: 0,
  class: "text-xs text-c-2"
}, BE = { class: "truncate text-xs text-c-2" }, FE = /* @__PURE__ */ Q({
  inheritAttrs: !1,
  __name: "ScalarSearchResultItem",
  props: {
    icon: {},
    active: { type: Boolean }
  },
  setup(r) {
    const e = oe(() => {
      const { class: t, ...s } = Co();
      return { className: t || "", rest: s };
    });
    return (t, s) => (S(), E("li", NE, [
      V("a", En(e.value.rest, {
        class: $(Tn)(
          "group flex cursor-pointer gap-3 rounded px-3 py-1.5 no-underline hover:bg-b-2",
          {
            "bg-b-2": t.active
          },
          e.value.className
        )
      }), [
        V("div", ME, [
          te(t.$slots, "icon", {}, () => [
            t.icon ? (S(), U($(Ze), {
              key: 0,
              icon: t.icon,
              size: "sm"
            }, null, 8, ["icon"])) : z("", !0)
          ])
        ]),
        V("div", DE, [
          V("div", RE, [
            V("div", jE, [
              te(t.$slots, "default")
            ]),
            t.$slots.addon ? (S(), E("div", LE, [
              te(t.$slots, "addon")
            ])) : z("", !0)
          ]),
          V("div", BE, [
            te(t.$slots, "description")
          ])
        ])
      ], 16)
    ]));
  }
}), VE = { class: "card-form-input" }, UE = ["for"], zE = ["id", "type"], qE = /* @__PURE__ */ Q({
  inheritAttrs: !1,
  __name: "CardFormTextInput",
  props: {
    id: {},
    type: {}
  },
  setup(r) {
    const e = r, t = ie(!0), s = oe(
      () => e.type === "password" ? t.value ? "password" : "text" : e.type ?? "text"
    );
    return (n, o) => (S(), E("div", VE, [
      V("label", { for: n.id }, [
        te(n.$slots, "default", {}, void 0, !0)
      ], 8, UE),
      V("input", En(n.$attrs, {
        id: n.id,
        autocomplete: "off",
        "data-1p-ignore": "",
        spellcheck: "false",
        type: s.value
      }), null, 16, zE),
      n.type === "password" ? (S(), U($(va), {
        key: 0,
        class: "password-mask",
        icon: t.value ? "Show" : "Hide",
        label: t.value ? "Show Password" : "Hide Password",
        onClick: o[0] || (o[0] = (i) => t.value = !t.value)
      }, null, 8, ["icon", "label"])) : z("", !0)
    ]));
  }
}), Yr = /* @__PURE__ */ ne(qE, [["__scopeId", "data-v-76a13854"]]), HE = (r) => (It("data-v-a4bf8cfc"), r = r(), Nt(), r), KE = { class: "scopes-label" }, WE = /* @__PURE__ */ HE(() => /* @__PURE__ */ V("em", null, "/", -1)), GE = ["checked"], JE = { class: "dropdown-item-title" }, YE = { class: "dropdown-item-description" }, XE = /* @__PURE__ */ Q({
  __name: "SecuritySchemeScopes",
  props: {
    scopes: {},
    selected: {}
  },
  emits: ["update:selected"],
  setup(r, { emit: e }) {
    const t = r, s = e, n = ie(), o = ie(), { floatingStyles: i } = fE(n, o, {
      placement: "bottom-end",
      whileElementsMounted: lE,
      middleware: [UA(5), uE(), cE()]
    }), a = oe({
      get: () => t.selected,
      set: (l) => s("update:selected", l)
    });
    return (l, c) => (S(), U($(Zw), {
      modelValue: a.value,
      "onUpdate:modelValue": c[0] || (c[0] = (u) => a.value = u),
      multiple: ""
    }, {
      default: P(({ open: u }) => [
        V("div", {
          ref_key: "trigger",
          ref: n,
          class: xe(["wrapper", { "wrapper-open": u }])
        }, [
          R($(ek), { as: Bb }, {
            default: P(() => [
              V("div", KE, [
                J(" Scopes " + ee(a.value.length), 1),
                WE,
                J(ee(Object.entries(l.scopes).length) + " ", 1),
                R($(Ze), {
                  icon: u ? "ChevronUp" : "ChevronDown",
                  size: "sm"
                }, null, 8, ["icon"])
              ])
            ]),
            _: 2
          }, 1024)
        ], 2),
        (S(), U(Uw, { to: "body" }, [
          R($(V0), null, {
            default: P(({ styles: d }) => [
              V("div", {
                ref_key: "dropdown",
                ref: o,
                class: xe(["floating", d]),
                style: os($(i))
              }, [
                R($(tk), {
                  as: "dl",
                  class: "dropdown"
                }, {
                  default: P(() => [
                    (S(!0), E(Z, null, we(Object.entries(l.scopes), ([h, f]) => (S(), U($(rk), {
                      key: h,
                      as: "div",
                      class: "dropdown-item",
                      value: h
                    }, {
                      default: P(({ selected: m }) => [
                        V("input", {
                          checked: m,
                          class: "dropdown-item-check",
                          tabindex: "-1",
                          type: "checkbox"
                        }, null, 8, GE),
                        V("dt", JE, ee(h), 1),
                        V("dd", YE, ee(f), 1)
                      ]),
                      _: 2
                    }, 1032, ["value"]))), 128))
                  ]),
                  _: 1
                })
              ], 6)
            ]),
            _: 1
          })
        ]))
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
}), Ng = /* @__PURE__ */ ne(XE, [["__scopeId", "data-v-a4bf8cfc"]]), QE = /* @__PURE__ */ Q({
  __name: "SecurityScheme",
  props: {
    value: {},
    proxy: {}
  },
  setup(r) {
    const { toast: e } = of(), { server: t } = To(), { authentication: s, setAuthentication: n } = ha(), o = (p) => {
      n({
        apiKey: {
          ...s.apiKey,
          token: p.target.value
        }
      });
    }, i = (p) => {
      n({
        http: {
          ...s.http,
          basic: {
            ...s.http.basic,
            username: p.target.value
          }
        }
      });
    }, a = (p) => {
      n({
        http: {
          ...s.http,
          basic: {
            ...s.http.basic,
            password: p.target.value
          }
        }
      });
    }, l = (p) => {
      n({
        http: {
          ...s.http,
          bearer: {
            ...s.http.bearer,
            token: p.target.value
          }
        }
      });
    }, c = (p) => {
      n({
        oAuth2: {
          ...s.oAuth2,
          clientId: p.target.value
        }
      });
    }, u = (p) => {
      n({
        oAuth2: {
          ...s.oAuth2,
          username: p.target.value
        }
      });
    }, d = (p) => {
      n({
        oAuth2: {
          ...s.oAuth2,
          password: p.target.value
        }
      });
    };
    function h(p) {
      const y = s.oAuth2.scopes.join(" "), b = (Math.random() + 1).toString(36).substring(7), v = new URL(p.authorizationUrl);
      return n({
        oAuth2: { ...s.oAuth2, state: b }
      }), v.searchParams.set("response_type", "token"), v.searchParams.set("client_id", s.oAuth2.clientId), v.searchParams.set("redirect_uri", window.location.href), v.searchParams.set("scope", y), v.searchParams.set("state", b), v.toString();
    }
    function f(p, y) {
      if (typeof p != "string") {
        console.log("tokenUrl is not a string");
        return;
      }
      const b = y != null && y.baseUrl && !p.startsWith("http") ? Ox(y == null ? void 0 : y.baseUrl, p) : p, v = new URL(b);
      v.searchParams.set("grant_type", "password"), v.searchParams.set("username", s.oAuth2.username), v.searchParams.set("password", s.oAuth2.password), v.searchParams.set("client_id", s.oAuth2.clientId), v.searchParams.set("scope", s.oAuth2.scopes.join(" ")), fetch(
        y != null && y.proxy ? Mx(y == null ? void 0 : y.proxy, v.toString()) : v.toString(),
        {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          }
        }
      ).then((k) => {
        if (!k.ok)
          throw new Error(
            "Failed to get an access token. Please check your credentials."
          );
        return k.json();
      }).then((k) => {
        n({
          oAuth2: { ...s.oAuth2, accessToken: k.access_token }
        });
      }).catch((k) => {
        e("Couldn’t retrieve the password grant token", "warn", {
          description: "Open your browser console to get more information."
        }), console.error("[authorizeWithPassword]", k);
      });
    }
    const m = oe({
      get: () => s.oAuth2.scopes,
      set: (p) => n({ oAuth2: { ...s.oAuth2, scopes: p } })
    }), g = (p) => {
      const b = window.open(p, "openAuth2Window", "left=100,top=100,width=800,height=600");
      if (b) {
        const v = setInterval(function() {
          var k;
          try {
            const w = new URLSearchParams(b.location.href).get("access_token");
            if (b.closed || w) {
              clearInterval(v);
              const x = (k = b.location.href.match(/state=([^&]*)/)) == null ? void 0 : k[1];
              w && s.oAuth2.state === x && n({
                oAuth2: { ...s.oAuth2, accessToken: w }
              }), b.close();
            }
          } catch {
          }
        }, 200);
      }
    };
    return (p, y) => {
      var b;
      return p.value && ((b = p.value) != null && b.type) ? (S(), U(zC, { key: 0 }, {
        default: P(() => [
          p.value.type === "apiKey" ? (S(), U(Yr, {
            key: 0,
            id: `security-scheme-${p.value.name}`,
            placeholder: "Token",
            type: "password",
            value: $(s).apiKey.token,
            onInput: o
          }, {
            default: P(() => [
              J(ee(p.value.in.charAt(0).toUpperCase() + p.value.in.slice(1)) + " API ", 1)
            ]),
            _: 1
          }, 8, ["id", "value"])) : p.value.type === "http" || p.value.type === "basic" ? (S(), E(Z, { key: 1 }, [
            p.value.type === "basic" || p.value.scheme === "basic" ? (S(), U(hi, { key: 0 }, {
              default: P(() => [
                R(Yr, {
                  id: "http.basic.username",
                  placeholder: "Username",
                  value: $(s).http.basic.username,
                  onInput: i
                }, {
                  default: P(() => [
                    J(" Username ")
                  ]),
                  _: 1
                }, 8, ["value"]),
                R(Yr, {
                  id: "http.basic.password",
                  placeholder: "Password",
                  type: "password",
                  value: $(s).http.basic.password,
                  onInput: a
                }, {
                  default: P(() => [
                    J(" Password ")
                  ]),
                  _: 1
                }, 8, ["value"])
              ]),
              _: 1
            })) : p.value.type === "http" && p.value.scheme === "bearer" ? (S(), U(Yr, {
              key: 1,
              id: "http.bearer.token",
              placeholder: "Token",
              type: "password",
              value: $(s).http.bearer.token,
              onInput: l
            }, {
              default: P(() => [
                J(" Bearer Token ")
              ]),
              _: 1
            }, 8, ["value"])) : z("", !0)
          ], 64)) : p.value.type.toLowerCase() === "oauth2" && p.value.flows ? (S(), U(hi, { key: 2 }, {
            default: P(() => [
              p.value.flows.implicit ? (S(), E(Z, { key: 0 }, [
                $(s).oAuth2.accessToken ? (S(), E(Z, { key: 0 }, [
                  R(Yr, {
                    id: "oAuth2.accessToken",
                    placeholder: "xxxxx",
                    type: "password",
                    value: $(s).oAuth2.accessToken
                  }, {
                    default: P(() => [
                      J(" Access Token ")
                    ]),
                    _: 1
                  }, 8, ["value"]),
                  R(Bb, {
                    onClick: y[0] || (y[0] = () => $(n)({
                      oAuth2: {
                        ...$(s).oAuth2,
                        accessToken: "",
                        state: ""
                      }
                    }))
                  }, {
                    default: P(() => [
                      J(" Reset ")
                    ]),
                    _: 1
                  })
                ], 64)) : z("", !0)
              ], 64)) : z("", !0),
              p.value.flows.password ? (S(), U(yg, { key: 1 }, {
                default: P(() => [
                  R(hi, null, {
                    default: P(() => [
                      R(Yr, {
                        id: "oAuth2.username",
                        placeholder: "Username",
                        value: $(s).oAuth2.username,
                        onInput: u
                      }, {
                        default: P(() => [
                          J(" Username ")
                        ]),
                        _: 1
                      }, 8, ["value"]),
                      R(Yr, {
                        id: "oAuth2.password",
                        placeholder: "Password",
                        type: "password",
                        value: $(s).oAuth2.password,
                        onInput: d
                      }, {
                        default: P(() => [
                          J(" Password ")
                        ]),
                        _: 1
                      }, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  R(hi, null, {
                    default: P(() => {
                      var v, k;
                      return [
                        R(Yr, {
                          id: "oAuth2.clientId",
                          placeholder: "12345",
                          type: "text",
                          value: $(s).oAuth2.clientId,
                          onInput: c
                        }, {
                          default: P(() => [
                            J(" Client ID ")
                          ]),
                          _: 1
                        }, 8, ["value"]),
                        p.value !== void 0 && Object.entries(
                          ((v = p.value.flows.implicit) == null ? void 0 : v.scopes) ?? p.value.flows.password.scopes
                        ).length > 0 ? (S(), U(Ng, {
                          key: 0,
                          selected: m.value,
                          "onUpdate:selected": y[1] || (y[1] = (_) => m.value = _),
                          scopes: ((k = p.value.flows.implicit) == null ? void 0 : k.scopes) ?? p.value.flows.password.scopes
                        }, null, 8, ["selected", "scopes"])) : z("", !0),
                        V("button", {
                          class: "cardform-auth-button",
                          type: "button",
                          onClick: y[2] || (y[2] = () => {
                            var _, w;
                            return f(
                              (w = (_ = p.value.flows) == null ? void 0 : _.password) == null ? void 0 : w.tokenUrl,
                              {
                                baseUrl: $(Xl)($(t)),
                                proxy: p.proxy
                              }
                            );
                          })
                        }, " Authorize ")
                      ];
                    }),
                    _: 1
                  })
                ]),
                _: 1
              })) : (S(), U(yg, { key: 2 }, {
                default: P(() => [
                  R(hi, null, {
                    default: P(() => {
                      var v, k;
                      return [
                        R(Yr, {
                          id: "oAuth2.clientId",
                          placeholder: "12345",
                          type: "text",
                          value: $(s).oAuth2.clientId,
                          onInput: c
                        }, {
                          default: P(() => [
                            J(" Client ID ")
                          ]),
                          _: 1
                        }, 8, ["value"]),
                        p.value !== void 0 && Object.entries(
                          ((v = p.value.flows.implicit) == null ? void 0 : v.scopes) ?? p.value.flows.password.scopes
                        ).length > 0 ? (S(), U(Ng, {
                          key: 0,
                          selected: m.value,
                          "onUpdate:selected": y[3] || (y[3] = (_) => m.value = _),
                          scopes: ((k = p.value.flows.implicit) == null ? void 0 : k.scopes) ?? p.value.flows.password.scopes
                        }, null, 8, ["selected", "scopes"])) : z("", !0),
                        V("button", {
                          class: "cardform-auth-button",
                          type: "button",
                          onClick: y[4] || (y[4] = () => {
                            var _, w;
                            return g(
                              h(
                                //@ts-ignore
                                ((_ = p.value) == null ? void 0 : _.flows.implicit) ?? ((w = p.value) == null ? void 0 : w.flows.password)
                              )
                            );
                          })
                        }, " Authorize ")
                      ];
                    }),
                    _: 1
                  })
                ]),
                _: 1
              }))
            ]),
            _: 1
          })) : z("", !0)
        ]),
        _: 1
      })) : z("", !0);
    };
  }
}), ZE = /* @__PURE__ */ ne(QE, [["__scopeId", "data-v-9f6c0d8d"]]), eO = (r) => (It("data-v-7f0d31fc"), r = r(), Nt(), r), tO = {
  key: 0,
  class: "security-scheme-label"
}, rO = {
  key: 1,
  class: "security-scheme-selector"
}, sO = { class: "security-scheme-label" }, nO = ["value"], oO = /* @__PURE__ */ eO(() => /* @__PURE__ */ V("option", { value: "" }, "None", -1)), iO = ["value"], aO = /* @__PURE__ */ Q({
  __name: "SecuritySchemeSelector",
  props: {
    value: {}
  },
  emits: ["input"],
  setup(r, { emit: e }) {
    const t = r, s = e, { authentication: n, setAuthentication: o } = ha(), i = (p) => {
      a(p.target.value);
    };
    vr(() => {
      n.preferredSecurityScheme || a(Object.keys(t.value ?? {})[0] ?? null);
    });
    const a = (p) => {
      o({
        preferredSecurityScheme: p
      }), s("input", p);
    };
    On(
      () => a(Object.keys(t.value ?? {})[0] ?? null)
    );
    const l = (p) => !(p != null && p.type), c = (p) => p.type.toLowerCase() === "apikey", u = (p) => p.type === "http" && p.scheme.toLowerCase() === "basic" || p.type.toLowerCase() === "basic", d = (p) => p.type === "http" && p.scheme.toLowerCase() === "bearer", h = (p) => p.type.toLowerCase() === "oauth2", f = (p, y) => `${m(p)} (${y})`, m = (p) => {
      var y, b;
      return l(p) ? "No Authentication" : c(p) ? "API Key" : u(p) ? "Basic Authentication" : d(p) ? "Bearer Authentication" : h(p) ? (y = p.flows) != null && y.implicit ? "OAuth 2.0 Implicit" : (b = p.flows) != null && b.password ? "OAuth 2.0 Password" : "OAuth 2.0" : `${p.type} (not yet supported)`;
    }, g = oe(() => Object.keys(t.value ?? {}));
    return (p, y) => {
      var b, v;
      return g.value.length === 1 ? (S(), E("div", tO, ee(f((b = p.value) == null ? void 0 : b[g.value[0]], g.value[0])), 1)) : g.value.length > 1 ? (S(), E("div", rO, [
        V("span", sO, ee($(n).preferredSecurityScheme ? f(
          (v = p.value) == null ? void 0 : v[$(n).preferredSecurityScheme],
          $(n).preferredSecurityScheme
        ) : "None"), 1),
        R($(Ze), { icon: "ChevronDown" }),
        V("select", {
          value: $(n).preferredSecurityScheme,
          onClick: y[0] || (y[0] = ca(() => {
          }, ["prevent"])),
          onInput: i
        }, [
          oO,
          (S(!0), E(Z, null, we(g.value, (k) => {
            var _;
            return S(), E("option", {
              key: k,
              value: k ?? null
            }, ee(f((_ = p.value) == null ? void 0 : _[k], k)), 9, iO);
          }), 128))
        ], 40, nO)
      ])) : z("", !0);
    };
  }
}), lO = /* @__PURE__ */ ne(aO, [["__scopeId", "data-v-7f0d31fc"]]);
function lo() {
  return {
    info: {
      title: "",
      description: "",
      termsOfService: "",
      version: "",
      license: {
        name: "",
        url: ""
      },
      contact: {
        email: ""
      }
    },
    externalDocs: {
      description: "",
      url: ""
    },
    servers: [],
    tags: []
  };
}
function cO(r, e) {
  for (const [t, s] of Object.entries(r))
    s !== null && typeof s == "object" ? (e[t] ?? (e[t] = new s.__proto__.constructor()), cO(s, e[t])) : typeof s < "u" && (e[t] = s);
  return e;
}
function iv({
  serverState: r,
  authenticationState: e,
  operation: t,
  globalSecurity: s
}) {
  var a, l;
  const n = Q0(
    {
      url: Xl(r)
    },
    ad(t, { requiredOnly: !1 }),
    // Only generate authentication parameters if an authentication state is passed.
    e ? Db(
      e,
      ((a = t.information) == null ? void 0 : a.security) ?? s ?? []
    ) : {}
  ), o = ad(t, {
    requiredOnly: !1
  }), i = ro(t, "path", !1);
  return {
    id: t.operationId,
    name: t.name,
    type: n.method,
    path: o.path ?? "",
    variables: i,
    cookies: Mg(n.cookies),
    query: n.queryString.map((c) => ({ ...c, enabled: c.required ?? !0 })),
    headers: Mg(n.headers),
    url: Xl(r) ?? "",
    body: (l = n.postData) == null ? void 0 : l.text
  };
}
function Mg(r) {
  return (r ?? []).map((e) => ({ ...e, enabled: !0 }));
}
const uO = L0().use(j0).use(mk).use(pk), rc = async (r) => {
  const e = new R0(), { headings: t } = (await uO.process(r)).data;
  return dO(t, e);
}, dO = (r, e) => r.map((t) => ({
  ...t,
  slug: e.slug(t.value)
})), ff = (r) => {
  const e = Math.min(...r.map((t) => t.depth));
  return e >= 1 && e <= 6 ? e : 1;
};
function Fr(r) {
  var e, t;
  return r ? (
    // OpenAPI 3.x
    Object.keys(((e = r == null ? void 0 : r.components) == null ? void 0 : e.schemas) ?? {}).length ? (t = r == null ? void 0 : r.components) == null ? void 0 : t.schemas : (
      // Swagger 2.0
      Object.keys((r == null ? void 0 : r.definitions) ?? {}).length ? r == null ? void 0 : r.definitions : (
        // Fallback
        {}
      )
    )
  ) : {};
}
function jF(r) {
  const e = /{{?\s*([\w.-]+)\s*}}?/g, t = r == null ? void 0 : r.matchAll(e);
  return Array.from(t ?? [], (s) => s[1]);
}
const av = (r) => r ? !!Object.keys(Fr(r) ?? {}).length : !1, hO = (r) => {
  var e;
  return !!Object.keys(((e = r == null ? void 0 : r.components) == null ? void 0 : e.securitySchemes) ?? {}).length;
}, fO = (r) => r ? !!Object.keys((r == null ? void 0 : r.webhooks) ?? {}).length : !1;
function pO(r) {
  try {
    return !!new URL(r);
  } catch {
    return !1;
  }
}
const LF = (r, e) => Object.keys(r).map((t) => ({
  [e ?? t]: t,
  value: r[t]
})), BF = (r) => r.reduce((e, t) => ({
  ...e,
  ...t
}), {});
function pf(r, e) {
  return Object.keys(r).forEach((t) => {
    Object.hasOwn(e, t) || delete r[t];
  }), Object.assign(r, e), r;
}
const { server: mO } = To(), { setOperation: gO, setGlobalSecurity: yO } = ty(), { toggleApiClient: bO } = Ih(), { setActiveRequest: vO, resetActiveResponse: wO } = YS();
function Qd(r, e) {
  const t = iv({
    serverState: mO,
    operation: r,
    // Let the API client handle the authentication.
    authenticationState: null,
    globalSecurity: null
  });
  wO(), vO(t), gO(r), yO(e), bO(t, !0);
}
var kO = Object.defineProperty, SO = (r, e, t) => e in r ? kO(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, ws = (r, e, t) => (SO(r, typeof e != "symbol" ? e + "" : e, t), t);
const $O = (r, e) => {
  const t = r[e];
  return t ? typeof t == "function" ? t() : Promise.resolve(t) : new Promise((s, n) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(n.bind(null, new Error("Unknown variable dynamic import: " + e)));
  });
};
var _O = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function mf(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Zd = { exports: {} }, lv = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.formatNames = r.fastFormats = r.fullFormats = void 0;
  function e(j, B) {
    return { validate: j, compare: B };
  }
  r.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: e(o, i),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: e(l, c),
    "date-time": e(d, h),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: g,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: T,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: y,
    // signed 32 bit integer
    int32: { type: "number", validate: k },
    // signed 64 bit integer
    int64: { type: "number", validate: _ },
    // C-type float
    float: { type: "number", validate: w },
    // C-type double
    double: { type: "number", validate: w },
    // hint to the UI to hide input strings
    password: !0,
    // unchecked string payload
    binary: !0
  }, r.fastFormats = {
    ...r.fullFormats,
    date: e(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, i),
    time: e(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, c),
    "date-time": e(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, h),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, r.formatNames = Object.keys(r.fullFormats);
  function t(j) {
    return j % 4 === 0 && (j % 100 !== 0 || j % 400 === 0);
  }
  const s = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, n = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function o(j) {
    const B = s.exec(j);
    if (!B)
      return !1;
    const W = +B[1], L = +B[2], ue = +B[3];
    return L >= 1 && L <= 12 && ue >= 1 && ue <= (L === 2 && t(W) ? 29 : n[L]);
  }
  function i(j, B) {
    if (j && B)
      return j > B ? 1 : j < B ? -1 : 0;
  }
  const a = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function l(j, B) {
    const W = a.exec(j);
    if (!W)
      return !1;
    const L = +W[1], ue = +W[2], ae = +W[3], me = W[5];
    return (L <= 23 && ue <= 59 && ae <= 59 || L === 23 && ue === 59 && ae === 60) && (!B || me !== "");
  }
  function c(j, B) {
    if (!(j && B))
      return;
    const W = a.exec(j), L = a.exec(B);
    if (W && L)
      return j = W[1] + W[2] + W[3] + (W[4] || ""), B = L[1] + L[2] + L[3] + (L[4] || ""), j > B ? 1 : j < B ? -1 : 0;
  }
  const u = /t|\s/i;
  function d(j) {
    const B = j.split(u);
    return B.length === 2 && o(B[0]) && l(B[1], !0);
  }
  function h(j, B) {
    if (!(j && B))
      return;
    const [W, L] = j.split(u), [ue, ae] = B.split(u), me = i(W, ue);
    if (me !== void 0)
      return me || c(L, ae);
  }
  const f = /\/|:/, m = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function g(j) {
    return f.test(j) && m.test(j);
  }
  const p = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function y(j) {
    return p.lastIndex = 0, p.test(j);
  }
  const b = -(2 ** 31), v = 2 ** 31 - 1;
  function k(j) {
    return Number.isInteger(j) && j <= v && j >= b;
  }
  function _(j) {
    return Number.isInteger(j);
  }
  function w() {
    return !0;
  }
  const x = /[^\\]\\Z/;
  function T(j) {
    if (x.test(j))
      return !1;
    try {
      return new RegExp(j), !0;
    } catch {
      return !1;
    }
  }
})(lv);
var cv = {}, eh = { exports: {} }, yn = {}, rr = {}, So = {}, wa = {}, ye = {}, ta = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.regexpCode = r.getEsmExportName = r.getProperty = r.safeStringify = r.stringify = r.strConcat = r.addCodeArg = r.str = r._ = r.nil = r._Code = r.Name = r.IDENTIFIER = r._CodeOrName = void 0;
  class e {
  }
  r._CodeOrName = e, r.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class t extends e {
    constructor(b) {
      if (super(), !r.IDENTIFIER.test(b))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = b;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  r.Name = t;
  class s extends e {
    constructor(b) {
      super(), this._items = typeof b == "string" ? [b] : b;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const b = this._items[0];
      return b === "" || b === '""';
    }
    get str() {
      var b;
      return (b = this._str) !== null && b !== void 0 ? b : this._str = this._items.reduce((v, k) => `${v}${k}`, "");
    }
    get names() {
      var b;
      return (b = this._names) !== null && b !== void 0 ? b : this._names = this._items.reduce((v, k) => (k instanceof t && (v[k.str] = (v[k.str] || 0) + 1), v), {});
    }
  }
  r._Code = s, r.nil = new s("");
  function n(y, ...b) {
    const v = [y[0]];
    let k = 0;
    for (; k < b.length; )
      a(v, b[k]), v.push(y[++k]);
    return new s(v);
  }
  r._ = n;
  const o = new s("+");
  function i(y, ...b) {
    const v = [f(y[0])];
    let k = 0;
    for (; k < b.length; )
      v.push(o), a(v, b[k]), v.push(o, f(y[++k]));
    return l(v), new s(v);
  }
  r.str = i;
  function a(y, b) {
    b instanceof s ? y.push(...b._items) : b instanceof t ? y.push(b) : y.push(d(b));
  }
  r.addCodeArg = a;
  function l(y) {
    let b = 1;
    for (; b < y.length - 1; ) {
      if (y[b] === o) {
        const v = c(y[b - 1], y[b + 1]);
        if (v !== void 0) {
          y.splice(b - 1, 3, v);
          continue;
        }
        y[b++] = "+";
      }
      b++;
    }
  }
  function c(y, b) {
    if (b === '""')
      return y;
    if (y === '""')
      return b;
    if (typeof y == "string")
      return b instanceof t || y[y.length - 1] !== '"' ? void 0 : typeof b != "string" ? `${y.slice(0, -1)}${b}"` : b[0] === '"' ? y.slice(0, -1) + b.slice(1) : void 0;
    if (typeof b == "string" && b[0] === '"' && !(y instanceof t))
      return `"${y}${b.slice(1)}`;
  }
  function u(y, b) {
    return b.emptyStr() ? y : y.emptyStr() ? b : i`${y}${b}`;
  }
  r.strConcat = u;
  function d(y) {
    return typeof y == "number" || typeof y == "boolean" || y === null ? y : f(Array.isArray(y) ? y.join(",") : y);
  }
  function h(y) {
    return new s(f(y));
  }
  r.stringify = h;
  function f(y) {
    return JSON.stringify(y).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  r.safeStringify = f;
  function m(y) {
    return typeof y == "string" && r.IDENTIFIER.test(y) ? new s(`.${y}`) : n`[${y}]`;
  }
  r.getProperty = m;
  function g(y) {
    if (typeof y == "string" && r.IDENTIFIER.test(y))
      return new s(`${y}`);
    throw new Error(`CodeGen: invalid export name: ${y}, use explicit $id name mapping`);
  }
  r.getEsmExportName = g;
  function p(y) {
    return new s(y.toString());
  }
  r.regexpCode = p;
})(ta);
var th = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.ValueScope = r.ValueScopeName = r.Scope = r.varKinds = r.UsedValueState = void 0;
  const e = ta;
  class t extends Error {
    constructor(c) {
      super(`CodeGen: "code" for ${c} not defined`), this.value = c.value;
    }
  }
  var s;
  (function(l) {
    l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
  })(s = r.UsedValueState || (r.UsedValueState = {})), r.varKinds = {
    const: new e.Name("const"),
    let: new e.Name("let"),
    var: new e.Name("var")
  };
  class n {
    constructor({ prefixes: c, parent: u } = {}) {
      this._names = {}, this._prefixes = c, this._parent = u;
    }
    toName(c) {
      return c instanceof e.Name ? c : this.name(c);
    }
    name(c) {
      return new e.Name(this._newName(c));
    }
    _newName(c) {
      const u = this._names[c] || this._nameGroup(c);
      return `${c}${u.index++}`;
    }
    _nameGroup(c) {
      var u, d;
      if (!((d = (u = this._parent) === null || u === void 0 ? void 0 : u._prefixes) === null || d === void 0) && d.has(c) || this._prefixes && !this._prefixes.has(c))
        throw new Error(`CodeGen: prefix "${c}" is not allowed in this scope`);
      return this._names[c] = { prefix: c, index: 0 };
    }
  }
  r.Scope = n;
  class o extends e.Name {
    constructor(c, u) {
      super(u), this.prefix = c;
    }
    setValue(c, { property: u, itemIndex: d }) {
      this.value = c, this.scopePath = (0, e._)`.${new e.Name(u)}[${d}]`;
    }
  }
  r.ValueScopeName = o;
  const i = (0, e._)`\n`;
  class a extends n {
    constructor(c) {
      super(c), this._values = {}, this._scope = c.scope, this.opts = { ...c, _n: c.lines ? i : e.nil };
    }
    get() {
      return this._scope;
    }
    name(c) {
      return new o(c, this._newName(c));
    }
    value(c, u) {
      var d;
      if (u.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const h = this.toName(c), { prefix: f } = h, m = (d = u.key) !== null && d !== void 0 ? d : u.ref;
      let g = this._values[f];
      if (g) {
        const b = g.get(m);
        if (b)
          return b;
      } else
        g = this._values[f] = /* @__PURE__ */ new Map();
      g.set(m, h);
      const p = this._scope[f] || (this._scope[f] = []), y = p.length;
      return p[y] = u.ref, h.setValue(u, { property: f, itemIndex: y }), h;
    }
    getValue(c, u) {
      const d = this._values[c];
      if (d)
        return d.get(u);
    }
    scopeRefs(c, u = this._values) {
      return this._reduceValues(u, (d) => {
        if (d.scopePath === void 0)
          throw new Error(`CodeGen: name "${d}" has no value`);
        return (0, e._)`${c}${d.scopePath}`;
      });
    }
    scopeCode(c = this._values, u, d) {
      return this._reduceValues(c, (h) => {
        if (h.value === void 0)
          throw new Error(`CodeGen: name "${h}" has no value`);
        return h.value.code;
      }, u, d);
    }
    _reduceValues(c, u, d = {}, h) {
      let f = e.nil;
      for (const m in c) {
        const g = c[m];
        if (!g)
          continue;
        const p = d[m] = d[m] || /* @__PURE__ */ new Map();
        g.forEach((y) => {
          if (p.has(y))
            return;
          p.set(y, s.Started);
          let b = u(y);
          if (b) {
            const v = this.opts.es5 ? r.varKinds.var : r.varKinds.const;
            f = (0, e._)`${f}${v} ${y} = ${b};${this.opts._n}`;
          } else if (b = h == null ? void 0 : h(y))
            f = (0, e._)`${f}${b}${this.opts._n}`;
          else
            throw new t(y);
          p.set(y, s.Completed);
        });
      }
      return f;
    }
  }
  r.ValueScope = a;
})(th);
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.or = r.and = r.not = r.CodeGen = r.operators = r.varKinds = r.ValueScopeName = r.ValueScope = r.Scope = r.Name = r.regexpCode = r.stringify = r.getProperty = r.nil = r.strConcat = r.str = r._ = void 0;
  const e = ta, t = th;
  var s = ta;
  Object.defineProperty(r, "_", { enumerable: !0, get: function() {
    return s._;
  } }), Object.defineProperty(r, "str", { enumerable: !0, get: function() {
    return s.str;
  } }), Object.defineProperty(r, "strConcat", { enumerable: !0, get: function() {
    return s.strConcat;
  } }), Object.defineProperty(r, "nil", { enumerable: !0, get: function() {
    return s.nil;
  } }), Object.defineProperty(r, "getProperty", { enumerable: !0, get: function() {
    return s.getProperty;
  } }), Object.defineProperty(r, "stringify", { enumerable: !0, get: function() {
    return s.stringify;
  } }), Object.defineProperty(r, "regexpCode", { enumerable: !0, get: function() {
    return s.regexpCode;
  } }), Object.defineProperty(r, "Name", { enumerable: !0, get: function() {
    return s.Name;
  } });
  var n = th;
  Object.defineProperty(r, "Scope", { enumerable: !0, get: function() {
    return n.Scope;
  } }), Object.defineProperty(r, "ValueScope", { enumerable: !0, get: function() {
    return n.ValueScope;
  } }), Object.defineProperty(r, "ValueScopeName", { enumerable: !0, get: function() {
    return n.ValueScopeName;
  } }), Object.defineProperty(r, "varKinds", { enumerable: !0, get: function() {
    return n.varKinds;
  } }), r.operators = {
    GT: new e._Code(">"),
    GTE: new e._Code(">="),
    LT: new e._Code("<"),
    LTE: new e._Code("<="),
    EQ: new e._Code("==="),
    NEQ: new e._Code("!=="),
    NOT: new e._Code("!"),
    OR: new e._Code("||"),
    AND: new e._Code("&&"),
    ADD: new e._Code("+")
  };
  class o {
    optimizeNodes() {
      return this;
    }
    optimizeNames(C, I) {
      return this;
    }
  }
  class i extends o {
    constructor(C, I, D) {
      super(), this.varKind = C, this.name = I, this.rhs = D;
    }
    render({ es5: C, _n: I }) {
      const D = C ? t.varKinds.var : this.varKind, X = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${D} ${this.name}${X};` + I;
    }
    optimizeNames(C, I) {
      if (C[this.name.str])
        return this.rhs && (this.rhs = ae(this.rhs, C, I)), this;
    }
    get names() {
      return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
    }
  }
  class a extends o {
    constructor(C, I, D) {
      super(), this.lhs = C, this.rhs = I, this.sideEffects = D;
    }
    render({ _n: C }) {
      return `${this.lhs} = ${this.rhs};` + C;
    }
    optimizeNames(C, I) {
      if (!(this.lhs instanceof e.Name && !C[this.lhs.str] && !this.sideEffects))
        return this.rhs = ae(this.rhs, C, I), this;
    }
    get names() {
      const C = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
      return ue(C, this.rhs);
    }
  }
  class l extends a {
    constructor(C, I, D, X) {
      super(C, D, X), this.op = I;
    }
    render({ _n: C }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + C;
    }
  }
  class c extends o {
    constructor(C) {
      super(), this.label = C, this.names = {};
    }
    render({ _n: C }) {
      return `${this.label}:` + C;
    }
  }
  class u extends o {
    constructor(C) {
      super(), this.label = C, this.names = {};
    }
    render({ _n: C }) {
      return `break${this.label ? ` ${this.label}` : ""};` + C;
    }
  }
  class d extends o {
    constructor(C) {
      super(), this.error = C;
    }
    render({ _n: C }) {
      return `throw ${this.error};` + C;
    }
    get names() {
      return this.error.names;
    }
  }
  class h extends o {
    constructor(C) {
      super(), this.code = C;
    }
    render({ _n: C }) {
      return `${this.code};` + C;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(C, I) {
      return this.code = ae(this.code, C, I), this;
    }
    get names() {
      return this.code instanceof e._CodeOrName ? this.code.names : {};
    }
  }
  class f extends o {
    constructor(C = []) {
      super(), this.nodes = C;
    }
    render(C) {
      return this.nodes.reduce((I, D) => I + D.render(C), "");
    }
    optimizeNodes() {
      const { nodes: C } = this;
      let I = C.length;
      for (; I--; ) {
        const D = C[I].optimizeNodes();
        Array.isArray(D) ? C.splice(I, 1, ...D) : D ? C[I] = D : C.splice(I, 1);
      }
      return C.length > 0 ? this : void 0;
    }
    optimizeNames(C, I) {
      const { nodes: D } = this;
      let X = D.length;
      for (; X--; ) {
        const re = D[X];
        re.optimizeNames(C, I) || (me(C, re.names), D.splice(X, 1));
      }
      return D.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((C, I) => L(C, I.names), {});
    }
  }
  class m extends f {
    render(C) {
      return "{" + C._n + super.render(C) + "}" + C._n;
    }
  }
  class g extends f {
  }
  class p extends m {
  }
  p.kind = "else";
  class y extends m {
    constructor(C, I) {
      super(I), this.condition = C;
    }
    render(C) {
      let I = `if(${this.condition})` + super.render(C);
      return this.else && (I += "else " + this.else.render(C)), I;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const C = this.condition;
      if (C === !0)
        return this.nodes;
      let I = this.else;
      if (I) {
        const D = I.optimizeNodes();
        I = this.else = Array.isArray(D) ? new p(D) : D;
      }
      if (I)
        return C === !1 ? I instanceof y ? I : I.nodes : this.nodes.length ? this : new y(Pe(C), I instanceof y ? [I] : I.nodes);
      if (!(C === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(C, I) {
      var D;
      if (this.else = (D = this.else) === null || D === void 0 ? void 0 : D.optimizeNames(C, I), !!(super.optimizeNames(C, I) || this.else))
        return this.condition = ae(this.condition, C, I), this;
    }
    get names() {
      const C = super.names;
      return ue(C, this.condition), this.else && L(C, this.else.names), C;
    }
  }
  y.kind = "if";
  class b extends m {
  }
  b.kind = "for";
  class v extends b {
    constructor(C) {
      super(), this.iteration = C;
    }
    render(C) {
      return `for(${this.iteration})` + super.render(C);
    }
    optimizeNames(C, I) {
      if (super.optimizeNames(C, I))
        return this.iteration = ae(this.iteration, C, I), this;
    }
    get names() {
      return L(super.names, this.iteration.names);
    }
  }
  class k extends b {
    constructor(C, I, D, X) {
      super(), this.varKind = C, this.name = I, this.from = D, this.to = X;
    }
    render(C) {
      const I = C.es5 ? t.varKinds.var : this.varKind, { name: D, from: X, to: re } = this;
      return `for(${I} ${D}=${X}; ${D}<${re}; ${D}++)` + super.render(C);
    }
    get names() {
      const C = ue(super.names, this.from);
      return ue(C, this.to);
    }
  }
  class _ extends b {
    constructor(C, I, D, X) {
      super(), this.loop = C, this.varKind = I, this.name = D, this.iterable = X;
    }
    render(C) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(C);
    }
    optimizeNames(C, I) {
      if (super.optimizeNames(C, I))
        return this.iterable = ae(this.iterable, C, I), this;
    }
    get names() {
      return L(super.names, this.iterable.names);
    }
  }
  class w extends m {
    constructor(C, I, D) {
      super(), this.name = C, this.args = I, this.async = D;
    }
    render(C) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(C);
    }
  }
  w.kind = "func";
  class x extends f {
    render(C) {
      return "return " + super.render(C);
    }
  }
  x.kind = "return";
  class T extends m {
    render(C) {
      let I = "try" + super.render(C);
      return this.catch && (I += this.catch.render(C)), this.finally && (I += this.finally.render(C)), I;
    }
    optimizeNodes() {
      var C, I;
      return super.optimizeNodes(), (C = this.catch) === null || C === void 0 || C.optimizeNodes(), (I = this.finally) === null || I === void 0 || I.optimizeNodes(), this;
    }
    optimizeNames(C, I) {
      var D, X;
      return super.optimizeNames(C, I), (D = this.catch) === null || D === void 0 || D.optimizeNames(C, I), (X = this.finally) === null || X === void 0 || X.optimizeNames(C, I), this;
    }
    get names() {
      const C = super.names;
      return this.catch && L(C, this.catch.names), this.finally && L(C, this.finally.names), C;
    }
  }
  class j extends m {
    constructor(C) {
      super(), this.error = C;
    }
    render(C) {
      return `catch(${this.error})` + super.render(C);
    }
  }
  j.kind = "catch";
  class B extends m {
    render(C) {
      return "finally" + super.render(C);
    }
  }
  B.kind = "finally";
  class W {
    constructor(C, I = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...I, _n: I.lines ? `
` : "" }, this._extScope = C, this._scope = new t.Scope({ parent: C }), this._nodes = [new g()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(C) {
      return this._scope.name(C);
    }
    // reserves unique name in the external scope
    scopeName(C) {
      return this._extScope.name(C);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(C, I) {
      const D = this._extScope.value(C, I);
      return (this._values[D.prefix] || (this._values[D.prefix] = /* @__PURE__ */ new Set())).add(D), D;
    }
    getScopeValue(C, I) {
      return this._extScope.getValue(C, I);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(C) {
      return this._extScope.scopeRefs(C, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(C, I, D, X) {
      const re = this._scope.toName(I);
      return D !== void 0 && X && (this._constants[re.str] = D), this._leafNode(new i(C, re, D)), re;
    }
    // `const` declaration (`var` in es5 mode)
    const(C, I, D) {
      return this._def(t.varKinds.const, C, I, D);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(C, I, D) {
      return this._def(t.varKinds.let, C, I, D);
    }
    // `var` declaration with optional assignment
    var(C, I, D) {
      return this._def(t.varKinds.var, C, I, D);
    }
    // assignment code
    assign(C, I, D) {
      return this._leafNode(new a(C, I, D));
    }
    // `+=` code
    add(C, I) {
      return this._leafNode(new l(C, r.operators.ADD, I));
    }
    // appends passed SafeExpr to code or executes Block
    code(C) {
      return typeof C == "function" ? C() : C !== e.nil && this._leafNode(new h(C)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...C) {
      const I = ["{"];
      for (const [D, X] of C)
        I.length > 1 && I.push(","), I.push(D), (D !== X || this.opts.es5) && (I.push(":"), (0, e.addCodeArg)(I, X));
      return I.push("}"), new e._Code(I);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(C, I, D) {
      if (this._blockNode(new y(C)), I && D)
        this.code(I).else().code(D).endIf();
      else if (I)
        this.code(I).endIf();
      else if (D)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(C) {
      return this._elseNode(new y(C));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new p());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(y, p);
    }
    _for(C, I) {
      return this._blockNode(C), I && this.code(I).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(C, I) {
      return this._for(new v(C), I);
    }
    // `for` statement for a range of values
    forRange(C, I, D, X, re = this.opts.es5 ? t.varKinds.var : t.varKinds.let) {
      const ke = this._scope.toName(C);
      return this._for(new k(re, ke, I, D), () => X(ke));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(C, I, D, X = t.varKinds.const) {
      const re = this._scope.toName(C);
      if (this.opts.es5) {
        const ke = I instanceof e.Name ? I : this.var("_arr", I);
        return this.forRange("_i", 0, (0, e._)`${ke}.length`, (be) => {
          this.var(re, (0, e._)`${ke}[${be}]`), D(re);
        });
      }
      return this._for(new _("of", X, re, I), () => D(re));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(C, I, D, X = this.opts.es5 ? t.varKinds.var : t.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(C, (0, e._)`Object.keys(${I})`, D);
      const re = this._scope.toName(C);
      return this._for(new _("in", X, re, I), () => D(re));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(b);
    }
    // `label` statement
    label(C) {
      return this._leafNode(new c(C));
    }
    // `break` statement
    break(C) {
      return this._leafNode(new u(C));
    }
    // `return` statement
    return(C) {
      const I = new x();
      if (this._blockNode(I), this.code(C), I.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(x);
    }
    // `try` statement
    try(C, I, D) {
      if (!I && !D)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const X = new T();
      if (this._blockNode(X), this.code(C), I) {
        const re = this.name("e");
        this._currNode = X.catch = new j(re), I(re);
      }
      return D && (this._currNode = X.finally = new B(), this.code(D)), this._endBlockNode(j, B);
    }
    // `throw` statement
    throw(C) {
      return this._leafNode(new d(C));
    }
    // start self-balancing block
    block(C, I) {
      return this._blockStarts.push(this._nodes.length), C && this.code(C).endBlock(I), this;
    }
    // end the current self-balancing block
    endBlock(C) {
      const I = this._blockStarts.pop();
      if (I === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const D = this._nodes.length - I;
      if (D < 0 || C !== void 0 && D !== C)
        throw new Error(`CodeGen: wrong number of nodes: ${D} vs ${C} expected`);
      return this._nodes.length = I, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(C, I = e.nil, D, X) {
      return this._blockNode(new w(C, I, D)), X && this.code(X).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(w);
    }
    optimize(C = 1) {
      for (; C-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(C) {
      return this._currNode.nodes.push(C), this;
    }
    _blockNode(C) {
      this._currNode.nodes.push(C), this._nodes.push(C);
    }
    _endBlockNode(C, I) {
      const D = this._currNode;
      if (D instanceof C || I && D instanceof I)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${I ? `${C.kind}/${I.kind}` : C.kind}"`);
    }
    _elseNode(C) {
      const I = this._currNode;
      if (!(I instanceof y))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = I.else = C, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const C = this._nodes;
      return C[C.length - 1];
    }
    set _currNode(C) {
      const I = this._nodes;
      I[I.length - 1] = C;
    }
  }
  r.CodeGen = W;
  function L(F, C) {
    for (const I in C)
      F[I] = (F[I] || 0) + (C[I] || 0);
    return F;
  }
  function ue(F, C) {
    return C instanceof e._CodeOrName ? L(F, C.names) : F;
  }
  function ae(F, C, I) {
    if (F instanceof e.Name)
      return D(F);
    if (!X(F))
      return F;
    return new e._Code(F._items.reduce((re, ke) => (ke instanceof e.Name && (ke = D(ke)), ke instanceof e._Code ? re.push(...ke._items) : re.push(ke), re), []));
    function D(re) {
      const ke = I[re.str];
      return ke === void 0 || C[re.str] !== 1 ? re : (delete C[re.str], ke);
    }
    function X(re) {
      return re instanceof e._Code && re._items.some((ke) => ke instanceof e.Name && C[ke.str] === 1 && I[ke.str] !== void 0);
    }
  }
  function me(F, C) {
    for (const I in C)
      F[I] = (F[I] || 0) - (C[I] || 0);
  }
  function Pe(F) {
    return typeof F == "boolean" || typeof F == "number" || F === null ? !F : (0, e._)`!${q(F)}`;
  }
  r.not = Pe;
  const De = M(r.operators.AND);
  function Be(...F) {
    return F.reduce(De);
  }
  r.and = Be;
  const ve = M(r.operators.OR);
  function Y(...F) {
    return F.reduce(ve);
  }
  r.or = Y;
  function M(F) {
    return (C, I) => C === e.nil ? I : I === e.nil ? C : (0, e._)`${q(C)} ${F} ${q(I)}`;
  }
  function q(F) {
    return F instanceof e.Name ? F : (0, e._)`(${F})`;
  }
})(ye);
var Ae = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.checkStrictMode = r.getErrorPath = r.Type = r.useFunc = r.setEvaluated = r.evaluatedPropsToName = r.mergeEvaluated = r.eachItem = r.unescapeJsonPointer = r.escapeJsonPointer = r.escapeFragment = r.unescapeFragment = r.schemaRefOrVal = r.schemaHasRulesButRef = r.schemaHasRules = r.checkUnknownRules = r.alwaysValidSchema = r.toHash = void 0;
  const e = ye, t = ta;
  function s(w) {
    const x = {};
    for (const T of w)
      x[T] = !0;
    return x;
  }
  r.toHash = s;
  function n(w, x) {
    return typeof x == "boolean" ? x : Object.keys(x).length === 0 ? !0 : (o(w, x), !i(x, w.self.RULES.all));
  }
  r.alwaysValidSchema = n;
  function o(w, x = w.schema) {
    const { opts: T, self: j } = w;
    if (!T.strictSchema || typeof x == "boolean")
      return;
    const B = j.RULES.keywords;
    for (const W in x)
      B[W] || _(w, `unknown keyword: "${W}"`);
  }
  r.checkUnknownRules = o;
  function i(w, x) {
    if (typeof w == "boolean")
      return !w;
    for (const T in w)
      if (x[T])
        return !0;
    return !1;
  }
  r.schemaHasRules = i;
  function a(w, x) {
    if (typeof w == "boolean")
      return !w;
    for (const T in w)
      if (T !== "$ref" && x.all[T])
        return !0;
    return !1;
  }
  r.schemaHasRulesButRef = a;
  function l({ topSchemaRef: w, schemaPath: x }, T, j, B) {
    if (!B) {
      if (typeof T == "number" || typeof T == "boolean")
        return T;
      if (typeof T == "string")
        return (0, e._)`${T}`;
    }
    return (0, e._)`${w}${x}${(0, e.getProperty)(j)}`;
  }
  r.schemaRefOrVal = l;
  function c(w) {
    return h(decodeURIComponent(w));
  }
  r.unescapeFragment = c;
  function u(w) {
    return encodeURIComponent(d(w));
  }
  r.escapeFragment = u;
  function d(w) {
    return typeof w == "number" ? `${w}` : w.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  r.escapeJsonPointer = d;
  function h(w) {
    return w.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  r.unescapeJsonPointer = h;
  function f(w, x) {
    if (Array.isArray(w))
      for (const T of w)
        x(T);
    else
      x(w);
  }
  r.eachItem = f;
  function m({ mergeNames: w, mergeToName: x, mergeValues: T, resultToName: j }) {
    return (B, W, L, ue) => {
      const ae = L === void 0 ? W : L instanceof e.Name ? (W instanceof e.Name ? w(B, W, L) : x(B, W, L), L) : W instanceof e.Name ? (x(B, L, W), W) : T(W, L);
      return ue === e.Name && !(ae instanceof e.Name) ? j(B, ae) : ae;
    };
  }
  r.mergeEvaluated = {
    props: m({
      mergeNames: (w, x, T) => w.if((0, e._)`${T} !== true && ${x} !== undefined`, () => {
        w.if((0, e._)`${x} === true`, () => w.assign(T, !0), () => w.assign(T, (0, e._)`${T} || {}`).code((0, e._)`Object.assign(${T}, ${x})`));
      }),
      mergeToName: (w, x, T) => w.if((0, e._)`${T} !== true`, () => {
        x === !0 ? w.assign(T, !0) : (w.assign(T, (0, e._)`${T} || {}`), p(w, T, x));
      }),
      mergeValues: (w, x) => w === !0 ? !0 : { ...w, ...x },
      resultToName: g
    }),
    items: m({
      mergeNames: (w, x, T) => w.if((0, e._)`${T} !== true && ${x} !== undefined`, () => w.assign(T, (0, e._)`${x} === true ? true : ${T} > ${x} ? ${T} : ${x}`)),
      mergeToName: (w, x, T) => w.if((0, e._)`${T} !== true`, () => w.assign(T, x === !0 ? !0 : (0, e._)`${T} > ${x} ? ${T} : ${x}`)),
      mergeValues: (w, x) => w === !0 ? !0 : Math.max(w, x),
      resultToName: (w, x) => w.var("items", x)
    })
  };
  function g(w, x) {
    if (x === !0)
      return w.var("props", !0);
    const T = w.var("props", (0, e._)`{}`);
    return x !== void 0 && p(w, T, x), T;
  }
  r.evaluatedPropsToName = g;
  function p(w, x, T) {
    Object.keys(T).forEach((j) => w.assign((0, e._)`${x}${(0, e.getProperty)(j)}`, !0));
  }
  r.setEvaluated = p;
  const y = {};
  function b(w, x) {
    return w.scopeValue("func", {
      ref: x,
      code: y[x.code] || (y[x.code] = new t._Code(x.code))
    });
  }
  r.useFunc = b;
  var v;
  (function(w) {
    w[w.Num = 0] = "Num", w[w.Str = 1] = "Str";
  })(v = r.Type || (r.Type = {}));
  function k(w, x, T) {
    if (w instanceof e.Name) {
      const j = x === v.Num;
      return T ? j ? (0, e._)`"[" + ${w} + "]"` : (0, e._)`"['" + ${w} + "']"` : j ? (0, e._)`"/" + ${w}` : (0, e._)`"/" + ${w}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return T ? (0, e.getProperty)(w).toString() : "/" + d(w);
  }
  r.getErrorPath = k;
  function _(w, x, T = w.opts.strictSchema) {
    if (T) {
      if (x = `strict mode: ${x}`, T === !0)
        throw new Error(x);
      w.self.logger.warn(x);
    }
  }
  r.checkStrictMode = _;
})(Ae);
var Wt = {};
Object.defineProperty(Wt, "__esModule", { value: !0 });
const wt = ye, xO = {
  // validation function arguments
  data: new wt.Name("data"),
  // args passed from referencing schema
  valCxt: new wt.Name("valCxt"),
  instancePath: new wt.Name("instancePath"),
  parentData: new wt.Name("parentData"),
  parentDataProperty: new wt.Name("parentDataProperty"),
  rootData: new wt.Name("rootData"),
  dynamicAnchors: new wt.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new wt.Name("vErrors"),
  errors: new wt.Name("errors"),
  this: new wt.Name("this"),
  // "globals"
  self: new wt.Name("self"),
  scope: new wt.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new wt.Name("json"),
  jsonPos: new wt.Name("jsonPos"),
  jsonLen: new wt.Name("jsonLen"),
  jsonPart: new wt.Name("jsonPart")
};
Wt.default = xO;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.extendErrors = r.resetErrorsCount = r.reportExtraError = r.reportError = r.keyword$DataError = r.keywordError = void 0;
  const e = ye, t = Ae, s = Wt;
  r.keywordError = {
    message: ({ keyword: p }) => (0, e.str)`must pass "${p}" keyword validation`
  }, r.keyword$DataError = {
    message: ({ keyword: p, schemaType: y }) => y ? (0, e.str)`"${p}" keyword must be ${y} ($data)` : (0, e.str)`"${p}" keyword is invalid ($data)`
  };
  function n(p, y = r.keywordError, b, v) {
    const { it: k } = p, { gen: _, compositeRule: w, allErrors: x } = k, T = d(p, y, b);
    v ?? (w || x) ? l(_, T) : c(k, (0, e._)`[${T}]`);
  }
  r.reportError = n;
  function o(p, y = r.keywordError, b) {
    const { it: v } = p, { gen: k, compositeRule: _, allErrors: w } = v, x = d(p, y, b);
    l(k, x), _ || w || c(v, s.default.vErrors);
  }
  r.reportExtraError = o;
  function i(p, y) {
    p.assign(s.default.errors, y), p.if((0, e._)`${s.default.vErrors} !== null`, () => p.if(y, () => p.assign((0, e._)`${s.default.vErrors}.length`, y), () => p.assign(s.default.vErrors, null)));
  }
  r.resetErrorsCount = i;
  function a({ gen: p, keyword: y, schemaValue: b, data: v, errsCount: k, it: _ }) {
    if (k === void 0)
      throw new Error("ajv implementation error");
    const w = p.name("err");
    p.forRange("i", k, s.default.errors, (x) => {
      p.const(w, (0, e._)`${s.default.vErrors}[${x}]`), p.if((0, e._)`${w}.instancePath === undefined`, () => p.assign((0, e._)`${w}.instancePath`, (0, e.strConcat)(s.default.instancePath, _.errorPath))), p.assign((0, e._)`${w}.schemaPath`, (0, e.str)`${_.errSchemaPath}/${y}`), _.opts.verbose && (p.assign((0, e._)`${w}.schema`, b), p.assign((0, e._)`${w}.data`, v));
    });
  }
  r.extendErrors = a;
  function l(p, y) {
    const b = p.const("err", y);
    p.if((0, e._)`${s.default.vErrors} === null`, () => p.assign(s.default.vErrors, (0, e._)`[${b}]`), (0, e._)`${s.default.vErrors}.push(${b})`), p.code((0, e._)`${s.default.errors}++`);
  }
  function c(p, y) {
    const { gen: b, validateName: v, schemaEnv: k } = p;
    k.$async ? b.throw((0, e._)`new ${p.ValidationError}(${y})`) : (b.assign((0, e._)`${v}.errors`, y), b.return(!1));
  }
  const u = {
    keyword: new e.Name("keyword"),
    schemaPath: new e.Name("schemaPath"),
    params: new e.Name("params"),
    propertyName: new e.Name("propertyName"),
    message: new e.Name("message"),
    schema: new e.Name("schema"),
    parentSchema: new e.Name("parentSchema")
  };
  function d(p, y, b) {
    const { createErrors: v } = p.it;
    return v === !1 ? (0, e._)`{}` : h(p, y, b);
  }
  function h(p, y, b = {}) {
    const { gen: v, it: k } = p, _ = [
      f(k, b),
      m(p, b)
    ];
    return g(p, y, _), v.object(..._);
  }
  function f({ errorPath: p }, { instancePath: y }) {
    const b = y ? (0, e.str)`${p}${(0, t.getErrorPath)(y, t.Type.Str)}` : p;
    return [s.default.instancePath, (0, e.strConcat)(s.default.instancePath, b)];
  }
  function m({ keyword: p, it: { errSchemaPath: y } }, { schemaPath: b, parentSchema: v }) {
    let k = v ? y : (0, e.str)`${y}/${p}`;
    return b && (k = (0, e.str)`${k}${(0, t.getErrorPath)(b, t.Type.Str)}`), [u.schemaPath, k];
  }
  function g(p, { params: y, message: b }, v) {
    const { keyword: k, data: _, schemaValue: w, it: x } = p, { opts: T, propertyName: j, topSchemaRef: B, schemaPath: W } = x;
    v.push([u.keyword, k], [u.params, typeof y == "function" ? y(p) : y || (0, e._)`{}`]), T.messages && v.push([u.message, typeof b == "function" ? b(p) : b]), T.verbose && v.push([u.schema, w], [u.parentSchema, (0, e._)`${B}${W}`], [s.default.data, _]), j && v.push([u.propertyName, j]);
  }
})(wa);
Object.defineProperty(So, "__esModule", { value: !0 });
So.boolOrEmptySchema = So.topBoolOrEmptySchema = void 0;
const CO = wa, AO = ye, EO = Wt, OO = {
  message: "boolean schema is false"
};
function TO(r) {
  const { gen: e, schema: t, validateName: s } = r;
  t === !1 ? uv(r, !1) : typeof t == "object" && t.$async === !0 ? e.return(EO.default.data) : (e.assign((0, AO._)`${s}.errors`, null), e.return(!0));
}
So.topBoolOrEmptySchema = TO;
function PO(r, e) {
  const { gen: t, schema: s } = r;
  s === !1 ? (t.var(e, !1), uv(r)) : t.var(e, !0);
}
So.boolOrEmptySchema = PO;
function uv(r, e) {
  const { gen: t, data: s } = r, n = {
    gen: t,
    keyword: "false schema",
    data: s,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: r
  };
  (0, CO.reportError)(n, OO, void 0, e);
}
var ka = {}, _n = {};
Object.defineProperty(_n, "__esModule", { value: !0 });
_n.getRules = _n.isJSONType = void 0;
const IO = ["string", "number", "integer", "boolean", "null", "object", "array"], NO = new Set(IO);
function MO(r) {
  return typeof r == "string" && NO.has(r);
}
_n.isJSONType = MO;
function DO() {
  const r = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...r, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, r.number, r.string, r.array, r.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
_n.getRules = DO;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.shouldUseRule = ss.shouldUseGroup = ss.schemaHasRulesForType = void 0;
function RO({ schema: r, self: e }, t) {
  const s = e.RULES.types[t];
  return s && s !== !0 && dv(r, s);
}
ss.schemaHasRulesForType = RO;
function dv(r, e) {
  return e.rules.some((t) => hv(r, t));
}
ss.shouldUseGroup = dv;
function hv(r, e) {
  var t;
  return r[e.keyword] !== void 0 || ((t = e.definition.implements) === null || t === void 0 ? void 0 : t.some((s) => r[s] !== void 0));
}
ss.shouldUseRule = hv;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.reportTypeError = r.checkDataTypes = r.checkDataType = r.coerceAndCheckDataType = r.getJSONTypes = r.getSchemaTypes = r.DataType = void 0;
  const e = _n, t = ss, s = wa, n = ye, o = Ae;
  var i;
  (function(v) {
    v[v.Correct = 0] = "Correct", v[v.Wrong = 1] = "Wrong";
  })(i = r.DataType || (r.DataType = {}));
  function a(v) {
    const k = l(v.type);
    if (k.includes("null")) {
      if (v.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!k.length && v.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      v.nullable === !0 && k.push("null");
    }
    return k;
  }
  r.getSchemaTypes = a;
  function l(v) {
    const k = Array.isArray(v) ? v : v ? [v] : [];
    if (k.every(e.isJSONType))
      return k;
    throw new Error("type must be JSONType or JSONType[]: " + k.join(","));
  }
  r.getJSONTypes = l;
  function c(v, k) {
    const { gen: _, data: w, opts: x } = v, T = d(k, x.coerceTypes), j = k.length > 0 && !(T.length === 0 && k.length === 1 && (0, t.schemaHasRulesForType)(v, k[0]));
    if (j) {
      const B = g(k, w, x.strictNumbers, i.Wrong);
      _.if(B, () => {
        T.length ? h(v, k, T) : y(v);
      });
    }
    return j;
  }
  r.coerceAndCheckDataType = c;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function d(v, k) {
    return k ? v.filter((_) => u.has(_) || k === "array" && _ === "array") : [];
  }
  function h(v, k, _) {
    const { gen: w, data: x, opts: T } = v, j = w.let("dataType", (0, n._)`typeof ${x}`), B = w.let("coerced", (0, n._)`undefined`);
    T.coerceTypes === "array" && w.if((0, n._)`${j} == 'object' && Array.isArray(${x}) && ${x}.length == 1`, () => w.assign(x, (0, n._)`${x}[0]`).assign(j, (0, n._)`typeof ${x}`).if(g(k, x, T.strictNumbers), () => w.assign(B, x))), w.if((0, n._)`${B} !== undefined`);
    for (const L of _)
      (u.has(L) || L === "array" && T.coerceTypes === "array") && W(L);
    w.else(), y(v), w.endIf(), w.if((0, n._)`${B} !== undefined`, () => {
      w.assign(x, B), f(v, B);
    });
    function W(L) {
      switch (L) {
        case "string":
          w.elseIf((0, n._)`${j} == "number" || ${j} == "boolean"`).assign(B, (0, n._)`"" + ${x}`).elseIf((0, n._)`${x} === null`).assign(B, (0, n._)`""`);
          return;
        case "number":
          w.elseIf((0, n._)`${j} == "boolean" || ${x} === null
              || (${j} == "string" && ${x} && ${x} == +${x})`).assign(B, (0, n._)`+${x}`);
          return;
        case "integer":
          w.elseIf((0, n._)`${j} === "boolean" || ${x} === null
              || (${j} === "string" && ${x} && ${x} == +${x} && !(${x} % 1))`).assign(B, (0, n._)`+${x}`);
          return;
        case "boolean":
          w.elseIf((0, n._)`${x} === "false" || ${x} === 0 || ${x} === null`).assign(B, !1).elseIf((0, n._)`${x} === "true" || ${x} === 1`).assign(B, !0);
          return;
        case "null":
          w.elseIf((0, n._)`${x} === "" || ${x} === 0 || ${x} === false`), w.assign(B, null);
          return;
        case "array":
          w.elseIf((0, n._)`${j} === "string" || ${j} === "number"
              || ${j} === "boolean" || ${x} === null`).assign(B, (0, n._)`[${x}]`);
      }
    }
  }
  function f({ gen: v, parentData: k, parentDataProperty: _ }, w) {
    v.if((0, n._)`${k} !== undefined`, () => v.assign((0, n._)`${k}[${_}]`, w));
  }
  function m(v, k, _, w = i.Correct) {
    const x = w === i.Correct ? n.operators.EQ : n.operators.NEQ;
    let T;
    switch (v) {
      case "null":
        return (0, n._)`${k} ${x} null`;
      case "array":
        T = (0, n._)`Array.isArray(${k})`;
        break;
      case "object":
        T = (0, n._)`${k} && typeof ${k} == "object" && !Array.isArray(${k})`;
        break;
      case "integer":
        T = j((0, n._)`!(${k} % 1) && !isNaN(${k})`);
        break;
      case "number":
        T = j();
        break;
      default:
        return (0, n._)`typeof ${k} ${x} ${v}`;
    }
    return w === i.Correct ? T : (0, n.not)(T);
    function j(B = n.nil) {
      return (0, n.and)((0, n._)`typeof ${k} == "number"`, B, _ ? (0, n._)`isFinite(${k})` : n.nil);
    }
  }
  r.checkDataType = m;
  function g(v, k, _, w) {
    if (v.length === 1)
      return m(v[0], k, _, w);
    let x;
    const T = (0, o.toHash)(v);
    if (T.array && T.object) {
      const j = (0, n._)`typeof ${k} != "object"`;
      x = T.null ? j : (0, n._)`!${k} || ${j}`, delete T.null, delete T.array, delete T.object;
    } else
      x = n.nil;
    T.number && delete T.integer;
    for (const j in T)
      x = (0, n.and)(x, m(j, k, _, w));
    return x;
  }
  r.checkDataTypes = g;
  const p = {
    message: ({ schema: v }) => `must be ${v}`,
    params: ({ schema: v, schemaValue: k }) => typeof v == "string" ? (0, n._)`{type: ${v}}` : (0, n._)`{type: ${k}}`
  };
  function y(v) {
    const k = b(v);
    (0, s.reportError)(k, p);
  }
  r.reportTypeError = y;
  function b(v) {
    const { gen: k, data: _, schema: w } = v, x = (0, o.schemaRefOrVal)(v, w, "type");
    return {
      gen: k,
      keyword: "type",
      data: _,
      schema: w.type,
      schemaCode: x,
      schemaValue: x,
      parentSchema: w,
      params: {},
      it: v
    };
  }
})(ka);
var Pc = {};
Object.defineProperty(Pc, "__esModule", { value: !0 });
Pc.assignDefaults = void 0;
const Vn = ye, jO = Ae;
function LO(r, e) {
  const { properties: t, items: s } = r.schema;
  if (e === "object" && t)
    for (const n in t)
      Dg(r, n, t[n].default);
  else
    e === "array" && Array.isArray(s) && s.forEach((n, o) => Dg(r, o, n.default));
}
Pc.assignDefaults = LO;
function Dg(r, e, t) {
  const { gen: s, compositeRule: n, data: o, opts: i } = r;
  if (t === void 0)
    return;
  const a = (0, Vn._)`${o}${(0, Vn.getProperty)(e)}`;
  if (n) {
    (0, jO.checkStrictMode)(r, `default is ignored for: ${a}`);
    return;
  }
  let l = (0, Vn._)`${a} === undefined`;
  i.useDefaults === "empty" && (l = (0, Vn._)`${l} || ${a} === null || ${a} === ""`), s.if(l, (0, Vn._)`${a} = ${(0, Vn.stringify)(t)}`);
}
var Vr = {}, Ce = {};
Object.defineProperty(Ce, "__esModule", { value: !0 });
Ce.validateUnion = Ce.validateArray = Ce.usePattern = Ce.callValidateCode = Ce.schemaProperties = Ce.allSchemaProperties = Ce.noPropertyInData = Ce.propertyInData = Ce.isOwnProperty = Ce.hasPropFunc = Ce.reportMissingProp = Ce.checkMissingProp = Ce.checkReportMissingProp = void 0;
const We = ye, gf = Ae, gs = Wt, BO = Ae;
function FO(r, e) {
  const { gen: t, data: s, it: n } = r;
  t.if(bf(t, s, e, n.opts.ownProperties), () => {
    r.setParams({ missingProperty: (0, We._)`${e}` }, !0), r.error();
  });
}
Ce.checkReportMissingProp = FO;
function VO({ gen: r, data: e, it: { opts: t } }, s, n) {
  return (0, We.or)(...s.map((o) => (0, We.and)(bf(r, e, o, t.ownProperties), (0, We._)`${n} = ${o}`)));
}
Ce.checkMissingProp = VO;
function UO(r, e) {
  r.setParams({ missingProperty: e }, !0), r.error();
}
Ce.reportMissingProp = UO;
function fv(r) {
  return r.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, We._)`Object.prototype.hasOwnProperty`
  });
}
Ce.hasPropFunc = fv;
function yf(r, e, t) {
  return (0, We._)`${fv(r)}.call(${e}, ${t})`;
}
Ce.isOwnProperty = yf;
function zO(r, e, t, s) {
  const n = (0, We._)`${e}${(0, We.getProperty)(t)} !== undefined`;
  return s ? (0, We._)`${n} && ${yf(r, e, t)}` : n;
}
Ce.propertyInData = zO;
function bf(r, e, t, s) {
  const n = (0, We._)`${e}${(0, We.getProperty)(t)} === undefined`;
  return s ? (0, We.or)(n, (0, We.not)(yf(r, e, t))) : n;
}
Ce.noPropertyInData = bf;
function pv(r) {
  return r ? Object.keys(r).filter((e) => e !== "__proto__") : [];
}
Ce.allSchemaProperties = pv;
function qO(r, e) {
  return pv(e).filter((t) => !(0, gf.alwaysValidSchema)(r, e[t]));
}
Ce.schemaProperties = qO;
function HO({ schemaCode: r, data: e, it: { gen: t, topSchemaRef: s, schemaPath: n, errorPath: o }, it: i }, a, l, c) {
  const u = c ? (0, We._)`${r}, ${e}, ${s}${n}` : e, d = [
    [gs.default.instancePath, (0, We.strConcat)(gs.default.instancePath, o)],
    [gs.default.parentData, i.parentData],
    [gs.default.parentDataProperty, i.parentDataProperty],
    [gs.default.rootData, gs.default.rootData]
  ];
  i.opts.dynamicRef && d.push([gs.default.dynamicAnchors, gs.default.dynamicAnchors]);
  const h = (0, We._)`${u}, ${t.object(...d)}`;
  return l !== We.nil ? (0, We._)`${a}.call(${l}, ${h})` : (0, We._)`${a}(${h})`;
}
Ce.callValidateCode = HO;
const KO = (0, We._)`new RegExp`;
function WO({ gen: r, it: { opts: e } }, t) {
  const s = e.unicodeRegExp ? "u" : "", { regExp: n } = e.code, o = n(t, s);
  return r.scopeValue("pattern", {
    key: o.toString(),
    ref: o,
    code: (0, We._)`${n.code === "new RegExp" ? KO : (0, BO.useFunc)(r, n)}(${t}, ${s})`
  });
}
Ce.usePattern = WO;
function GO(r) {
  const { gen: e, data: t, keyword: s, it: n } = r, o = e.name("valid");
  if (n.allErrors) {
    const a = e.let("valid", !0);
    return i(() => e.assign(a, !1)), a;
  }
  return e.var(o, !0), i(() => e.break()), o;
  function i(a) {
    const l = e.const("len", (0, We._)`${t}.length`);
    e.forRange("i", 0, l, (c) => {
      r.subschema({
        keyword: s,
        dataProp: c,
        dataPropType: gf.Type.Num
      }, o), e.if((0, We.not)(o), a);
    });
  }
}
Ce.validateArray = GO;
function JO(r) {
  const { gen: e, schema: t, keyword: s, it: n } = r;
  if (!Array.isArray(t))
    throw new Error("ajv implementation error");
  if (t.some((a) => (0, gf.alwaysValidSchema)(n, a)) && !n.opts.unevaluated)
    return;
  const o = e.let("valid", !1), i = e.name("_valid");
  e.block(() => t.forEach((a, l) => {
    const c = r.subschema({
      keyword: s,
      schemaProp: l,
      compositeRule: !0
    }, i);
    e.assign(o, (0, We._)`${o} || ${i}`), r.mergeValidEvaluated(c, i) || e.if((0, We.not)(o));
  })), r.result(o, () => r.reset(), () => r.error(!0));
}
Ce.validateUnion = JO;
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.validateKeywordUsage = Vr.validSchemaType = Vr.funcKeywordCode = Vr.macroKeywordCode = void 0;
const Et = ye, tn = Wt, YO = Ce, XO = wa;
function QO(r, e) {
  const { gen: t, keyword: s, schema: n, parentSchema: o, it: i } = r, a = e.macro.call(i.self, n, o, i), l = mv(t, s, a);
  i.opts.validateSchema !== !1 && i.self.validateSchema(a, !0);
  const c = t.name("valid");
  r.subschema({
    schema: a,
    schemaPath: Et.nil,
    errSchemaPath: `${i.errSchemaPath}/${s}`,
    topSchemaRef: l,
    compositeRule: !0
  }, c), r.pass(c, () => r.error(!0));
}
Vr.macroKeywordCode = QO;
function ZO(r, e) {
  var t;
  const { gen: s, keyword: n, schema: o, parentSchema: i, $data: a, it: l } = r;
  tT(l, e);
  const c = !a && e.compile ? e.compile.call(l.self, o, i, l) : e.validate, u = mv(s, n, c), d = s.let("valid");
  r.block$data(d, h), r.ok((t = e.valid) !== null && t !== void 0 ? t : d);
  function h() {
    if (e.errors === !1)
      g(), e.modifying && Rg(r), p(() => r.error());
    else {
      const y = e.async ? f() : m();
      e.modifying && Rg(r), p(() => eT(r, y));
    }
  }
  function f() {
    const y = s.let("ruleErrs", null);
    return s.try(() => g((0, Et._)`await `), (b) => s.assign(d, !1).if((0, Et._)`${b} instanceof ${l.ValidationError}`, () => s.assign(y, (0, Et._)`${b}.errors`), () => s.throw(b))), y;
  }
  function m() {
    const y = (0, Et._)`${u}.errors`;
    return s.assign(y, null), g(Et.nil), y;
  }
  function g(y = e.async ? (0, Et._)`await ` : Et.nil) {
    const b = l.opts.passContext ? tn.default.this : tn.default.self, v = !("compile" in e && !a || e.schema === !1);
    s.assign(d, (0, Et._)`${y}${(0, YO.callValidateCode)(r, u, b, v)}`, e.modifying);
  }
  function p(y) {
    var b;
    s.if((0, Et.not)((b = e.valid) !== null && b !== void 0 ? b : d), y);
  }
}
Vr.funcKeywordCode = ZO;
function Rg(r) {
  const { gen: e, data: t, it: s } = r;
  e.if(s.parentData, () => e.assign(t, (0, Et._)`${s.parentData}[${s.parentDataProperty}]`));
}
function eT(r, e) {
  const { gen: t } = r;
  t.if((0, Et._)`Array.isArray(${e})`, () => {
    t.assign(tn.default.vErrors, (0, Et._)`${tn.default.vErrors} === null ? ${e} : ${tn.default.vErrors}.concat(${e})`).assign(tn.default.errors, (0, Et._)`${tn.default.vErrors}.length`), (0, XO.extendErrors)(r);
  }, () => r.error());
}
function tT({ schemaEnv: r }, e) {
  if (e.async && !r.$async)
    throw new Error("async keyword in sync schema");
}
function mv(r, e, t) {
  if (t === void 0)
    throw new Error(`keyword "${e}" failed to compile`);
  return r.scopeValue("keyword", typeof t == "function" ? { ref: t } : { ref: t, code: (0, Et.stringify)(t) });
}
function rT(r, e, t = !1) {
  return !e.length || e.some((s) => s === "array" ? Array.isArray(r) : s === "object" ? r && typeof r == "object" && !Array.isArray(r) : typeof r == s || t && typeof r > "u");
}
Vr.validSchemaType = rT;
function sT({ schema: r, opts: e, self: t, errSchemaPath: s }, n, o) {
  if (Array.isArray(n.keyword) ? !n.keyword.includes(o) : n.keyword !== o)
    throw new Error("ajv implementation error");
  const i = n.dependencies;
  if (i != null && i.some((a) => !Object.prototype.hasOwnProperty.call(r, a)))
    throw new Error(`parent schema must have dependencies of ${o}: ${i.join(",")}`);
  if (n.validateSchema && !n.validateSchema(r[o])) {
    const a = `keyword "${o}" value is invalid at path "${s}": ` + t.errorsText(n.validateSchema.errors);
    if (e.validateSchema === "log")
      t.logger.error(a);
    else
      throw new Error(a);
  }
}
Vr.validateKeywordUsage = sT;
var Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.extendSubschemaMode = Ms.extendSubschemaData = Ms.getSubschema = void 0;
const jr = ye, gv = Ae;
function nT(r, { keyword: e, schemaProp: t, schema: s, schemaPath: n, errSchemaPath: o, topSchemaRef: i }) {
  if (e !== void 0 && s !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (e !== void 0) {
    const a = r.schema[e];
    return t === void 0 ? {
      schema: a,
      schemaPath: (0, jr._)`${r.schemaPath}${(0, jr.getProperty)(e)}`,
      errSchemaPath: `${r.errSchemaPath}/${e}`
    } : {
      schema: a[t],
      schemaPath: (0, jr._)`${r.schemaPath}${(0, jr.getProperty)(e)}${(0, jr.getProperty)(t)}`,
      errSchemaPath: `${r.errSchemaPath}/${e}/${(0, gv.escapeFragment)(t)}`
    };
  }
  if (s !== void 0) {
    if (n === void 0 || o === void 0 || i === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: s,
      schemaPath: n,
      topSchemaRef: i,
      errSchemaPath: o
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Ms.getSubschema = nT;
function oT(r, e, { dataProp: t, dataPropType: s, data: n, dataTypes: o, propertyName: i }) {
  if (n !== void 0 && t !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: a } = e;
  if (t !== void 0) {
    const { errorPath: c, dataPathArr: u, opts: d } = e, h = a.let("data", (0, jr._)`${e.data}${(0, jr.getProperty)(t)}`, !0);
    l(h), r.errorPath = (0, jr.str)`${c}${(0, gv.getErrorPath)(t, s, d.jsPropertySyntax)}`, r.parentDataProperty = (0, jr._)`${t}`, r.dataPathArr = [...u, r.parentDataProperty];
  }
  if (n !== void 0) {
    const c = n instanceof jr.Name ? n : a.let("data", n, !0);
    l(c), i !== void 0 && (r.propertyName = i);
  }
  o && (r.dataTypes = o);
  function l(c) {
    r.data = c, r.dataLevel = e.dataLevel + 1, r.dataTypes = [], e.definedProperties = /* @__PURE__ */ new Set(), r.parentData = e.data, r.dataNames = [...e.dataNames, c];
  }
}
Ms.extendSubschemaData = oT;
function iT(r, { jtdDiscriminator: e, jtdMetadata: t, compositeRule: s, createErrors: n, allErrors: o }) {
  s !== void 0 && (r.compositeRule = s), n !== void 0 && (r.createErrors = n), o !== void 0 && (r.allErrors = o), r.jtdDiscriminator = e, r.jtdMetadata = t;
}
Ms.extendSubschemaMode = iT;
var bt = {}, yv = function r(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var s, n, o;
    if (Array.isArray(e)) {
      if (s = e.length, s != t.length)
        return !1;
      for (n = s; n-- !== 0; )
        if (!r(e[n], t[n]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (o = Object.keys(e), s = o.length, s !== Object.keys(t).length)
      return !1;
    for (n = s; n-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, o[n]))
        return !1;
    for (n = s; n-- !== 0; ) {
      var i = o[n];
      if (!r(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}, bv = { exports: {} }, Ps = bv.exports = function(r, e, t) {
  typeof e == "function" && (t = e, e = {}), t = e.cb || t;
  var s = typeof t == "function" ? t : t.pre || function() {
  }, n = t.post || function() {
  };
  Pl(e, s, n, r, "", r);
};
Ps.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
Ps.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
Ps.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
Ps.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function Pl(r, e, t, s, n, o, i, a, l, c) {
  if (s && typeof s == "object" && !Array.isArray(s)) {
    e(s, n, o, i, a, l, c);
    for (var u in s) {
      var d = s[u];
      if (Array.isArray(d)) {
        if (u in Ps.arrayKeywords)
          for (var h = 0; h < d.length; h++)
            Pl(r, e, t, d[h], n + "/" + u + "/" + h, o, n, u, s, h);
      } else if (u in Ps.propsKeywords) {
        if (d && typeof d == "object")
          for (var f in d)
            Pl(r, e, t, d[f], n + "/" + u + "/" + aT(f), o, n, u, s, f);
      } else
        (u in Ps.keywords || r.allKeys && !(u in Ps.skipKeywords)) && Pl(r, e, t, d, n + "/" + u, o, n, u, s);
    }
    t(s, n, o, i, a, l, c);
  }
}
function aT(r) {
  return r.replace(/~/g, "~0").replace(/\//g, "~1");
}
var lT = bv.exports;
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.getSchemaRefs = bt.resolveUrl = bt.normalizeId = bt._getFullPath = bt.getFullPath = bt.inlineRef = void 0;
const cT = Ae, uT = yv, dT = lT, hT = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function fT(r, e = !0) {
  return typeof r == "boolean" ? !0 : e === !0 ? !rh(r) : e ? vv(r) <= e : !1;
}
bt.inlineRef = fT;
const pT = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function rh(r) {
  for (const e in r) {
    if (pT.has(e))
      return !0;
    const t = r[e];
    if (Array.isArray(t) && t.some(rh) || typeof t == "object" && rh(t))
      return !0;
  }
  return !1;
}
function vv(r) {
  let e = 0;
  for (const t in r)
    if (t === "$ref" || (e++, !hT.has(t) && (typeof r[t] == "object" && (0, cT.eachItem)(r[t], (s) => e += vv(s)), e === 1 / 0)))
      return 1 / 0;
  return e;
}
function wv(r, e = "", t) {
  t !== !1 && (e = co(e));
  const s = r.parse(e);
  return kv(r, s);
}
bt.getFullPath = wv;
function kv(r, e) {
  return r.serialize(e).split("#")[0] + "#";
}
bt._getFullPath = kv;
const mT = /#\/?$/;
function co(r) {
  return r ? r.replace(mT, "") : "";
}
bt.normalizeId = co;
function gT(r, e, t) {
  return t = co(t), r.resolve(e, t);
}
bt.resolveUrl = gT;
const yT = /^[a-z_][-a-z0-9._]*$/i;
function bT(r, e) {
  if (typeof r == "boolean")
    return {};
  const { schemaId: t, uriResolver: s } = this.opts, n = co(r[t] || e), o = { "": n }, i = wv(s, n, !1), a = {}, l = /* @__PURE__ */ new Set();
  return dT(r, { allKeys: !0 }, (d, h, f, m) => {
    if (m === void 0)
      return;
    const g = i + h;
    let p = o[m];
    typeof d[t] == "string" && (p = y.call(this, d[t])), b.call(this, d.$anchor), b.call(this, d.$dynamicAnchor), o[h] = p;
    function y(v) {
      const k = this.opts.uriResolver.resolve;
      if (v = co(p ? k(p, v) : v), l.has(v))
        throw u(v);
      l.add(v);
      let _ = this.refs[v];
      return typeof _ == "string" && (_ = this.refs[_]), typeof _ == "object" ? c(d, _.schema, v) : v !== co(g) && (v[0] === "#" ? (c(d, a[v], v), a[v] = d) : this.refs[v] = g), v;
    }
    function b(v) {
      if (typeof v == "string") {
        if (!yT.test(v))
          throw new Error(`invalid anchor "${v}"`);
        y.call(this, `#${v}`);
      }
    }
  }), a;
  function c(d, h, f) {
    if (h !== void 0 && !uT(d, h))
      throw u(f);
  }
  function u(d) {
    return new Error(`reference "${d}" resolves to more than one schema`);
  }
}
bt.getSchemaRefs = bT;
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.getData = rr.KeywordCxt = rr.validateFunctionCode = void 0;
const Sv = So, jg = ka, vf = ss, sc = ka, vT = Pc, Ri = Vr, Du = Ms, ce = ye, ge = Wt, wT = bt, ns = Ae, mi = wa;
function kT(r) {
  if (xv(r) && (Cv(r), _v(r))) {
    _T(r);
    return;
  }
  $v(r, () => (0, Sv.topBoolOrEmptySchema)(r));
}
rr.validateFunctionCode = kT;
function $v({ gen: r, validateName: e, schema: t, schemaEnv: s, opts: n }, o) {
  n.code.es5 ? r.func(e, (0, ce._)`${ge.default.data}, ${ge.default.valCxt}`, s.$async, () => {
    r.code((0, ce._)`"use strict"; ${Lg(t, n)}`), $T(r, n), r.code(o);
  }) : r.func(e, (0, ce._)`${ge.default.data}, ${ST(n)}`, s.$async, () => r.code(Lg(t, n)).code(o));
}
function ST(r) {
  return (0, ce._)`{${ge.default.instancePath}="", ${ge.default.parentData}, ${ge.default.parentDataProperty}, ${ge.default.rootData}=${ge.default.data}${r.dynamicRef ? (0, ce._)`, ${ge.default.dynamicAnchors}={}` : ce.nil}}={}`;
}
function $T(r, e) {
  r.if(ge.default.valCxt, () => {
    r.var(ge.default.instancePath, (0, ce._)`${ge.default.valCxt}.${ge.default.instancePath}`), r.var(ge.default.parentData, (0, ce._)`${ge.default.valCxt}.${ge.default.parentData}`), r.var(ge.default.parentDataProperty, (0, ce._)`${ge.default.valCxt}.${ge.default.parentDataProperty}`), r.var(ge.default.rootData, (0, ce._)`${ge.default.valCxt}.${ge.default.rootData}`), e.dynamicRef && r.var(ge.default.dynamicAnchors, (0, ce._)`${ge.default.valCxt}.${ge.default.dynamicAnchors}`);
  }, () => {
    r.var(ge.default.instancePath, (0, ce._)`""`), r.var(ge.default.parentData, (0, ce._)`undefined`), r.var(ge.default.parentDataProperty, (0, ce._)`undefined`), r.var(ge.default.rootData, ge.default.data), e.dynamicRef && r.var(ge.default.dynamicAnchors, (0, ce._)`{}`);
  });
}
function _T(r) {
  const { schema: e, opts: t, gen: s } = r;
  $v(r, () => {
    t.$comment && e.$comment && Ev(r), OT(r), s.let(ge.default.vErrors, null), s.let(ge.default.errors, 0), t.unevaluated && xT(r), Av(r), IT(r);
  });
}
function xT(r) {
  const { gen: e, validateName: t } = r;
  r.evaluated = e.const("evaluated", (0, ce._)`${t}.evaluated`), e.if((0, ce._)`${r.evaluated}.dynamicProps`, () => e.assign((0, ce._)`${r.evaluated}.props`, (0, ce._)`undefined`)), e.if((0, ce._)`${r.evaluated}.dynamicItems`, () => e.assign((0, ce._)`${r.evaluated}.items`, (0, ce._)`undefined`));
}
function Lg(r, e) {
  const t = typeof r == "object" && r[e.schemaId];
  return t && (e.code.source || e.code.process) ? (0, ce._)`/*# sourceURL=${t} */` : ce.nil;
}
function CT(r, e) {
  if (xv(r) && (Cv(r), _v(r))) {
    AT(r, e);
    return;
  }
  (0, Sv.boolOrEmptySchema)(r, e);
}
function _v({ schema: r, self: e }) {
  if (typeof r == "boolean")
    return !r;
  for (const t in r)
    if (e.RULES.all[t])
      return !0;
  return !1;
}
function xv(r) {
  return typeof r.schema != "boolean";
}
function AT(r, e) {
  const { schema: t, gen: s, opts: n } = r;
  n.$comment && t.$comment && Ev(r), TT(r), PT(r);
  const o = s.const("_errs", ge.default.errors);
  Av(r, o), s.var(e, (0, ce._)`${o} === ${ge.default.errors}`);
}
function Cv(r) {
  (0, ns.checkUnknownRules)(r), ET(r);
}
function Av(r, e) {
  if (r.opts.jtd)
    return Bg(r, [], !1, e);
  const t = (0, jg.getSchemaTypes)(r.schema), s = (0, jg.coerceAndCheckDataType)(r, t);
  Bg(r, t, !s, e);
}
function ET(r) {
  const { schema: e, errSchemaPath: t, opts: s, self: n } = r;
  e.$ref && s.ignoreKeywordsWithRef && (0, ns.schemaHasRulesButRef)(e, n.RULES) && n.logger.warn(`$ref: keywords ignored in schema at path "${t}"`);
}
function OT(r) {
  const { schema: e, opts: t } = r;
  e.default !== void 0 && t.useDefaults && t.strictSchema && (0, ns.checkStrictMode)(r, "default is ignored in the schema root");
}
function TT(r) {
  const e = r.schema[r.opts.schemaId];
  e && (r.baseId = (0, wT.resolveUrl)(r.opts.uriResolver, r.baseId, e));
}
function PT(r) {
  if (r.schema.$async && !r.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function Ev({ gen: r, schemaEnv: e, schema: t, errSchemaPath: s, opts: n }) {
  const o = t.$comment;
  if (n.$comment === !0)
    r.code((0, ce._)`${ge.default.self}.logger.log(${o})`);
  else if (typeof n.$comment == "function") {
    const i = (0, ce.str)`${s}/$comment`, a = r.scopeValue("root", { ref: e.root });
    r.code((0, ce._)`${ge.default.self}.opts.$comment(${o}, ${i}, ${a}.schema)`);
  }
}
function IT(r) {
  const { gen: e, schemaEnv: t, validateName: s, ValidationError: n, opts: o } = r;
  t.$async ? e.if((0, ce._)`${ge.default.errors} === 0`, () => e.return(ge.default.data), () => e.throw((0, ce._)`new ${n}(${ge.default.vErrors})`)) : (e.assign((0, ce._)`${s}.errors`, ge.default.vErrors), o.unevaluated && NT(r), e.return((0, ce._)`${ge.default.errors} === 0`));
}
function NT({ gen: r, evaluated: e, props: t, items: s }) {
  t instanceof ce.Name && r.assign((0, ce._)`${e}.props`, t), s instanceof ce.Name && r.assign((0, ce._)`${e}.items`, s);
}
function Bg(r, e, t, s) {
  const { gen: n, schema: o, data: i, allErrors: a, opts: l, self: c } = r, { RULES: u } = c;
  if (o.$ref && (l.ignoreKeywordsWithRef || !(0, ns.schemaHasRulesButRef)(o, u))) {
    n.block(() => Pv(r, "$ref", u.all.$ref.definition));
    return;
  }
  l.jtd || MT(r, e), n.block(() => {
    for (const h of u.rules)
      d(h);
    d(u.post);
  });
  function d(h) {
    (0, vf.shouldUseGroup)(o, h) && (h.type ? (n.if((0, sc.checkDataType)(h.type, i, l.strictNumbers)), Fg(r, h), e.length === 1 && e[0] === h.type && t && (n.else(), (0, sc.reportTypeError)(r)), n.endIf()) : Fg(r, h), a || n.if((0, ce._)`${ge.default.errors} === ${s || 0}`));
  }
}
function Fg(r, e) {
  const { gen: t, schema: s, opts: { useDefaults: n } } = r;
  n && (0, vT.assignDefaults)(r, e.type), t.block(() => {
    for (const o of e.rules)
      (0, vf.shouldUseRule)(s, o) && Pv(r, o.keyword, o.definition, e.type);
  });
}
function MT(r, e) {
  r.schemaEnv.meta || !r.opts.strictTypes || (DT(r, e), r.opts.allowUnionTypes || RT(r, e), jT(r, r.dataTypes));
}
function DT(r, e) {
  if (e.length) {
    if (!r.dataTypes.length) {
      r.dataTypes = e;
      return;
    }
    e.forEach((t) => {
      Ov(r.dataTypes, t) || wf(r, `type "${t}" not allowed by context "${r.dataTypes.join(",")}"`);
    }), BT(r, e);
  }
}
function RT(r, e) {
  e.length > 1 && !(e.length === 2 && e.includes("null")) && wf(r, "use allowUnionTypes to allow union type keyword");
}
function jT(r, e) {
  const t = r.self.RULES.all;
  for (const s in t) {
    const n = t[s];
    if (typeof n == "object" && (0, vf.shouldUseRule)(r.schema, n)) {
      const { type: o } = n.definition;
      o.length && !o.some((i) => LT(e, i)) && wf(r, `missing type "${o.join(",")}" for keyword "${s}"`);
    }
  }
}
function LT(r, e) {
  return r.includes(e) || e === "number" && r.includes("integer");
}
function Ov(r, e) {
  return r.includes(e) || e === "integer" && r.includes("number");
}
function BT(r, e) {
  const t = [];
  for (const s of r.dataTypes)
    Ov(e, s) ? t.push(s) : e.includes("integer") && s === "number" && t.push("integer");
  r.dataTypes = t;
}
function wf(r, e) {
  const t = r.schemaEnv.baseId + r.errSchemaPath;
  e += ` at "${t}" (strictTypes)`, (0, ns.checkStrictMode)(r, e, r.opts.strictTypes);
}
class Tv {
  constructor(e, t, s) {
    if ((0, Ri.validateKeywordUsage)(e, t, s), this.gen = e.gen, this.allErrors = e.allErrors, this.keyword = s, this.data = e.data, this.schema = e.schema[s], this.$data = t.$data && e.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, ns.schemaRefOrVal)(e, this.schema, s, this.$data), this.schemaType = t.schemaType, this.parentSchema = e.schema, this.params = {}, this.it = e, this.def = t, this.$data)
      this.schemaCode = e.gen.const("vSchema", Iv(this.$data, e));
    else if (this.schemaCode = this.schemaValue, !(0, Ri.validSchemaType)(this.schema, t.schemaType, t.allowUndefined))
      throw new Error(`${s} value must be ${JSON.stringify(t.schemaType)}`);
    ("code" in t ? t.trackErrors : t.errors !== !1) && (this.errsCount = e.gen.const("_errs", ge.default.errors));
  }
  result(e, t, s) {
    this.failResult((0, ce.not)(e), t, s);
  }
  failResult(e, t, s) {
    this.gen.if(e), s ? s() : this.error(), t ? (this.gen.else(), t(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(e, t) {
    this.failResult((0, ce.not)(e), void 0, t);
  }
  fail(e) {
    if (e === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(e), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(e) {
    if (!this.$data)
      return this.fail(e);
    const { schemaCode: t } = this;
    this.fail((0, ce._)`${t} !== undefined && (${(0, ce.or)(this.invalid$data(), e)})`);
  }
  error(e, t, s) {
    if (t) {
      this.setParams(t), this._error(e, s), this.setParams({});
      return;
    }
    this._error(e, s);
  }
  _error(e, t) {
    (e ? mi.reportExtraError : mi.reportError)(this, this.def.error, t);
  }
  $dataError() {
    (0, mi.reportError)(this, this.def.$dataError || mi.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, mi.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(e) {
    this.allErrors || this.gen.if(e);
  }
  setParams(e, t) {
    t ? Object.assign(this.params, e) : this.params = e;
  }
  block$data(e, t, s = ce.nil) {
    this.gen.block(() => {
      this.check$data(e, s), t();
    });
  }
  check$data(e = ce.nil, t = ce.nil) {
    if (!this.$data)
      return;
    const { gen: s, schemaCode: n, schemaType: o, def: i } = this;
    s.if((0, ce.or)((0, ce._)`${n} === undefined`, t)), e !== ce.nil && s.assign(e, !0), (o.length || i.validateSchema) && (s.elseIf(this.invalid$data()), this.$dataError(), e !== ce.nil && s.assign(e, !1)), s.else();
  }
  invalid$data() {
    const { gen: e, schemaCode: t, schemaType: s, def: n, it: o } = this;
    return (0, ce.or)(i(), a());
    function i() {
      if (s.length) {
        if (!(t instanceof ce.Name))
          throw new Error("ajv implementation error");
        const l = Array.isArray(s) ? s : [s];
        return (0, ce._)`${(0, sc.checkDataTypes)(l, t, o.opts.strictNumbers, sc.DataType.Wrong)}`;
      }
      return ce.nil;
    }
    function a() {
      if (n.validateSchema) {
        const l = e.scopeValue("validate$data", { ref: n.validateSchema });
        return (0, ce._)`!${l}(${t})`;
      }
      return ce.nil;
    }
  }
  subschema(e, t) {
    const s = (0, Du.getSubschema)(this.it, e);
    (0, Du.extendSubschemaData)(s, this.it, e), (0, Du.extendSubschemaMode)(s, e);
    const n = { ...this.it, ...s, items: void 0, props: void 0 };
    return CT(n, t), n;
  }
  mergeEvaluated(e, t) {
    const { it: s, gen: n } = this;
    s.opts.unevaluated && (s.props !== !0 && e.props !== void 0 && (s.props = ns.mergeEvaluated.props(n, e.props, s.props, t)), s.items !== !0 && e.items !== void 0 && (s.items = ns.mergeEvaluated.items(n, e.items, s.items, t)));
  }
  mergeValidEvaluated(e, t) {
    const { it: s, gen: n } = this;
    if (s.opts.unevaluated && (s.props !== !0 || s.items !== !0))
      return n.if(t, () => this.mergeEvaluated(e, ce.Name)), !0;
  }
}
rr.KeywordCxt = Tv;
function Pv(r, e, t, s) {
  const n = new Tv(r, t, e);
  "code" in t ? t.code(n, s) : n.$data && t.validate ? (0, Ri.funcKeywordCode)(n, t) : "macro" in t ? (0, Ri.macroKeywordCode)(n, t) : (t.compile || t.validate) && (0, Ri.funcKeywordCode)(n, t);
}
const FT = /^\/(?:[^~]|~0|~1)*$/, VT = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function Iv(r, { dataLevel: e, dataNames: t, dataPathArr: s }) {
  let n, o;
  if (r === "")
    return ge.default.rootData;
  if (r[0] === "/") {
    if (!FT.test(r))
      throw new Error(`Invalid JSON-pointer: ${r}`);
    n = r, o = ge.default.rootData;
  } else {
    const c = VT.exec(r);
    if (!c)
      throw new Error(`Invalid JSON-pointer: ${r}`);
    const u = +c[1];
    if (n = c[2], n === "#") {
      if (u >= e)
        throw new Error(l("property/index", u));
      return s[e - u];
    }
    if (u > e)
      throw new Error(l("data", u));
    if (o = t[e - u], !n)
      return o;
  }
  let i = o;
  const a = n.split("/");
  for (const c of a)
    c && (o = (0, ce._)`${o}${(0, ce.getProperty)((0, ns.unescapeJsonPointer)(c))}`, i = (0, ce._)`${i} && ${o}`);
  return i;
  function l(c, u) {
    return `Cannot access ${c} ${u} levels up, current level is ${e}`;
  }
}
rr.getData = Iv;
var Mo = {};
Object.defineProperty(Mo, "__esModule", { value: !0 });
class UT extends Error {
  constructor(e) {
    super("validation failed"), this.errors = e, this.ajv = this.validation = !0;
  }
}
Mo.default = UT;
var Do = {};
Object.defineProperty(Do, "__esModule", { value: !0 });
const Ru = bt;
class zT extends Error {
  constructor(e, t, s, n) {
    super(n || `can't resolve reference ${s} from id ${t}`), this.missingRef = (0, Ru.resolveUrl)(e, t, s), this.missingSchema = (0, Ru.normalizeId)((0, Ru.getFullPath)(e, this.missingRef));
  }
}
Do.default = zT;
var Tt = {};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.resolveSchema = Tt.getCompilingSchema = Tt.resolveRef = Tt.compileSchema = Tt.SchemaEnv = void 0;
const ar = ye, qT = Mo, Qs = Wt, pr = bt, Vg = Ae, HT = rr;
class Ic {
  constructor(e) {
    var t;
    this.refs = {}, this.dynamicAnchors = {};
    let s;
    typeof e.schema == "object" && (s = e.schema), this.schema = e.schema, this.schemaId = e.schemaId, this.root = e.root || this, this.baseId = (t = e.baseId) !== null && t !== void 0 ? t : (0, pr.normalizeId)(s == null ? void 0 : s[e.schemaId || "$id"]), this.schemaPath = e.schemaPath, this.localRefs = e.localRefs, this.meta = e.meta, this.$async = s == null ? void 0 : s.$async, this.refs = {};
  }
}
Tt.SchemaEnv = Ic;
function kf(r) {
  const e = Nv.call(this, r);
  if (e)
    return e;
  const t = (0, pr.getFullPath)(this.opts.uriResolver, r.root.baseId), { es5: s, lines: n } = this.opts.code, { ownProperties: o } = this.opts, i = new ar.CodeGen(this.scope, { es5: s, lines: n, ownProperties: o });
  let a;
  r.$async && (a = i.scopeValue("Error", {
    ref: qT.default,
    code: (0, ar._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const l = i.scopeName("validate");
  r.validateName = l;
  const c = {
    gen: i,
    allErrors: this.opts.allErrors,
    data: Qs.default.data,
    parentData: Qs.default.parentData,
    parentDataProperty: Qs.default.parentDataProperty,
    dataNames: [Qs.default.data],
    dataPathArr: [ar.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: i.scopeValue("schema", this.opts.code.source === !0 ? { ref: r.schema, code: (0, ar.stringify)(r.schema) } : { ref: r.schema }),
    validateName: l,
    ValidationError: a,
    schema: r.schema,
    schemaEnv: r,
    rootId: t,
    baseId: r.baseId || t,
    schemaPath: ar.nil,
    errSchemaPath: r.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, ar._)`""`,
    opts: this.opts,
    self: this
  };
  let u;
  try {
    this._compilations.add(r), (0, HT.validateFunctionCode)(c), i.optimize(this.opts.code.optimize);
    const d = i.toString();
    u = `${i.scopeRefs(Qs.default.scope)}return ${d}`, this.opts.code.process && (u = this.opts.code.process(u, r));
    const h = new Function(`${Qs.default.self}`, `${Qs.default.scope}`, u)(this, this.scope.get());
    if (this.scope.value(l, { ref: h }), h.errors = null, h.schema = r.schema, h.schemaEnv = r, r.$async && (h.$async = !0), this.opts.code.source === !0 && (h.source = { validateName: l, validateCode: d, scopeValues: i._values }), this.opts.unevaluated) {
      const { props: f, items: m } = c;
      h.evaluated = {
        props: f instanceof ar.Name ? void 0 : f,
        items: m instanceof ar.Name ? void 0 : m,
        dynamicProps: f instanceof ar.Name,
        dynamicItems: m instanceof ar.Name
      }, h.source && (h.source.evaluated = (0, ar.stringify)(h.evaluated));
    }
    return r.validate = h, r;
  } catch (d) {
    throw delete r.validate, delete r.validateName, u && this.logger.error("Error compiling schema, function code:", u), d;
  } finally {
    this._compilations.delete(r);
  }
}
Tt.compileSchema = kf;
function KT(r, e, t) {
  var s;
  t = (0, pr.resolveUrl)(this.opts.uriResolver, e, t);
  const n = r.refs[t];
  if (n)
    return n;
  let o = JT.call(this, r, t);
  if (o === void 0) {
    const i = (s = r.localRefs) === null || s === void 0 ? void 0 : s[t], { schemaId: a } = this.opts;
    i && (o = new Ic({ schema: i, schemaId: a, root: r, baseId: e }));
  }
  if (o !== void 0)
    return r.refs[t] = WT.call(this, o);
}
Tt.resolveRef = KT;
function WT(r) {
  return (0, pr.inlineRef)(r.schema, this.opts.inlineRefs) ? r.schema : r.validate ? r : kf.call(this, r);
}
function Nv(r) {
  for (const e of this._compilations)
    if (GT(e, r))
      return e;
}
Tt.getCompilingSchema = Nv;
function GT(r, e) {
  return r.schema === e.schema && r.root === e.root && r.baseId === e.baseId;
}
function JT(r, e) {
  let t;
  for (; typeof (t = this.refs[e]) == "string"; )
    e = t;
  return t || this.schemas[e] || Nc.call(this, r, e);
}
function Nc(r, e) {
  const t = this.opts.uriResolver.parse(e), s = (0, pr._getFullPath)(this.opts.uriResolver, t);
  let n = (0, pr.getFullPath)(this.opts.uriResolver, r.baseId, void 0);
  if (Object.keys(r.schema).length > 0 && s === n)
    return ju.call(this, t, r);
  const o = (0, pr.normalizeId)(s), i = this.refs[o] || this.schemas[o];
  if (typeof i == "string") {
    const a = Nc.call(this, r, i);
    return typeof (a == null ? void 0 : a.schema) != "object" ? void 0 : ju.call(this, t, a);
  }
  if (typeof (i == null ? void 0 : i.schema) == "object") {
    if (i.validate || kf.call(this, i), o === (0, pr.normalizeId)(e)) {
      const { schema: a } = i, { schemaId: l } = this.opts, c = a[l];
      return c && (n = (0, pr.resolveUrl)(this.opts.uriResolver, n, c)), new Ic({ schema: a, schemaId: l, root: r, baseId: n });
    }
    return ju.call(this, t, i);
  }
}
Tt.resolveSchema = Nc;
const YT = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function ju(r, { baseId: e, schema: t, root: s }) {
  var n;
  if (((n = r.fragment) === null || n === void 0 ? void 0 : n[0]) !== "/")
    return;
  for (const a of r.fragment.slice(1).split("/")) {
    if (typeof t == "boolean")
      return;
    const l = t[(0, Vg.unescapeFragment)(a)];
    if (l === void 0)
      return;
    t = l;
    const c = typeof t == "object" && t[this.opts.schemaId];
    !YT.has(a) && c && (e = (0, pr.resolveUrl)(this.opts.uriResolver, e, c));
  }
  let o;
  if (typeof t != "boolean" && t.$ref && !(0, Vg.schemaHasRulesButRef)(t, this.RULES)) {
    const a = (0, pr.resolveUrl)(this.opts.uriResolver, e, t.$ref);
    o = Nc.call(this, s, a);
  }
  const { schemaId: i } = this.opts;
  if (o = o || new Ic({ schema: t, schemaId: i, root: s, baseId: e }), o.schema !== o.root.schema)
    return o;
}
const XT = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", QT = "Meta-schema for $data reference (JSON AnySchema extension proposal)", ZT = "object", eP = [
  "$data"
], tP = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, rP = !1, sP = {
  $id: XT,
  description: QT,
  type: ZT,
  required: eP,
  properties: tP,
  additionalProperties: rP
};
var Sf = {}, sh = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(r, e) {
  (function(t, s) {
    s(e);
  })(_O, function(t) {
    function s() {
      for (var A = arguments.length, O = Array(A), N = 0; N < A; N++)
        O[N] = arguments[N];
      if (O.length > 1) {
        O[0] = O[0].slice(0, -1);
        for (var H = O.length - 1, K = 1; K < H; ++K)
          O[K] = O[K].slice(1, -1);
        return O[H] = O[H].slice(1), O.join("");
      } else
        return O[0];
    }
    function n(A) {
      return "(?:" + A + ")";
    }
    function o(A) {
      return A === void 0 ? "undefined" : A === null ? "null" : Object.prototype.toString.call(A).split(" ").pop().split("]").shift().toLowerCase();
    }
    function i(A) {
      return A.toUpperCase();
    }
    function a(A) {
      return A != null ? A instanceof Array ? A : typeof A.length != "number" || A.split || A.setInterval || A.call ? [A] : Array.prototype.slice.call(A) : [];
    }
    function l(A, O) {
      var N = A;
      if (O)
        for (var H in O)
          N[H] = O[H];
      return N;
    }
    function c(A) {
      var O = "[A-Za-z]", N = "[0-9]", H = s(N, "[A-Fa-f]"), K = n(n("%[EFef]" + H + "%" + H + H + "%" + H + H) + "|" + n("%[89A-Fa-f]" + H + "%" + H + H) + "|" + n("%" + H + H)), fe = "[\\:\\/\\?\\#\\[\\]\\@]", he = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", Ie = s(fe, he), nt = A ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Ve = A ? "[\\uE000-\\uF8FF]" : "[]", Oe = s(O, N, "[\\-\\.\\_\\~]", nt);
      n(O + s(O, N, "[\\+\\-\\.]") + "*"), n(n(K + "|" + s(Oe, he, "[\\:]")) + "*");
      var qe = n(n("25[0-5]") + "|" + n("2[0-4]" + N) + "|" + n("1" + N + N) + "|" + n("0?[1-9]" + N) + "|0?0?" + N), et = n(qe + "\\." + qe + "\\." + qe + "\\." + qe), Se = n(H + "{1,4}"), ot = n(n(Se + "\\:" + Se) + "|" + et), Ue = n(n(Se + "\\:") + "{6}" + ot), Jt = n("\\:\\:" + n(Se + "\\:") + "{5}" + ot), Ln = n(n(Se) + "?\\:\\:" + n(Se + "\\:") + "{4}" + ot), ir = n(n(n(Se + "\\:") + "{0,1}" + Se) + "?\\:\\:" + n(Se + "\\:") + "{3}" + ot), Wr = n(n(n(Se + "\\:") + "{0,2}" + Se) + "?\\:\\:" + n(Se + "\\:") + "{2}" + ot), Gs = n(n(n(Se + "\\:") + "{0,3}" + Se) + "?\\:\\:" + Se + "\\:" + ot), Js = n(n(n(Se + "\\:") + "{0,4}" + Se) + "?\\:\\:" + ot), Yt = n(n(n(Se + "\\:") + "{0,5}" + Se) + "?\\:\\:" + Se), Gr = n(n(n(Se + "\\:") + "{0,6}" + Se) + "?\\:\\:"), Ys = n([Ue, Jt, Ln, ir, Wr, Gs, Js, Yt, Gr].join("|")), Or = n(n(Oe + "|" + K) + "+");
      n("[vV]" + H + "+\\." + s(Oe, he, "[\\:]") + "+"), n(n(K + "|" + s(Oe, he)) + "*");
      var Ra = n(K + "|" + s(Oe, he, "[\\:\\@]"));
      return n(n(K + "|" + s(Oe, he, "[\\@]")) + "+"), n(n(Ra + "|" + s("[\\/\\?]", Ve)) + "*"), {
        NOT_SCHEME: new RegExp(s("[^]", O, N, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(s("[^\\%\\:]", Oe, he), "g"),
        NOT_HOST: new RegExp(s("[^\\%\\[\\]\\:]", Oe, he), "g"),
        NOT_PATH: new RegExp(s("[^\\%\\/\\:\\@]", Oe, he), "g"),
        NOT_PATH_NOSCHEME: new RegExp(s("[^\\%\\/\\@]", Oe, he), "g"),
        NOT_QUERY: new RegExp(s("[^\\%]", Oe, he, "[\\:\\@\\/\\?]", Ve), "g"),
        NOT_FRAGMENT: new RegExp(s("[^\\%]", Oe, he, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(s("[^]", Oe, he), "g"),
        UNRESERVED: new RegExp(Oe, "g"),
        OTHER_CHARS: new RegExp(s("[^\\%]", Oe, Ie), "g"),
        PCT_ENCODED: new RegExp(K, "g"),
        IPV4ADDRESS: new RegExp("^(" + et + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + Ys + ")" + n(n("\\%25|\\%(?!" + H + "{2})") + "(" + Or + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var u = c(!1), d = c(!0), h = /* @__PURE__ */ function() {
      function A(O, N) {
        var H = [], K = !0, fe = !1, he = void 0;
        try {
          for (var Ie = O[Symbol.iterator](), nt; !(K = (nt = Ie.next()).done) && (H.push(nt.value), !(N && H.length === N)); K = !0)
            ;
        } catch (Ve) {
          fe = !0, he = Ve;
        } finally {
          try {
            !K && Ie.return && Ie.return();
          } finally {
            if (fe)
              throw he;
          }
        }
        return H;
      }
      return function(O, N) {
        if (Array.isArray(O))
          return O;
        if (Symbol.iterator in Object(O))
          return A(O, N);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), f = function(A) {
      if (Array.isArray(A)) {
        for (var O = 0, N = Array(A.length); O < A.length; O++)
          N[O] = A[O];
        return N;
      } else
        return Array.from(A);
    }, m = 2147483647, g = 36, p = 1, y = 26, b = 38, v = 700, k = 72, _ = 128, w = "-", x = /^xn--/, T = /[^\0-\x7E]/, j = /[\x2E\u3002\uFF0E\uFF61]/g, B = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, W = g - p, L = Math.floor, ue = String.fromCharCode;
    function ae(A) {
      throw new RangeError(B[A]);
    }
    function me(A, O) {
      for (var N = [], H = A.length; H--; )
        N[H] = O(A[H]);
      return N;
    }
    function Pe(A, O) {
      var N = A.split("@"), H = "";
      N.length > 1 && (H = N[0] + "@", A = N[1]), A = A.replace(j, ".");
      var K = A.split("."), fe = me(K, O).join(".");
      return H + fe;
    }
    function De(A) {
      for (var O = [], N = 0, H = A.length; N < H; ) {
        var K = A.charCodeAt(N++);
        if (K >= 55296 && K <= 56319 && N < H) {
          var fe = A.charCodeAt(N++);
          (fe & 64512) == 56320 ? O.push(((K & 1023) << 10) + (fe & 1023) + 65536) : (O.push(K), N--);
        } else
          O.push(K);
      }
      return O;
    }
    var Be = function(A) {
      return String.fromCodePoint.apply(String, f(A));
    }, ve = function(A) {
      return A - 48 < 10 ? A - 22 : A - 65 < 26 ? A - 65 : A - 97 < 26 ? A - 97 : g;
    }, Y = function(A, O) {
      return A + 22 + 75 * (A < 26) - ((O != 0) << 5);
    }, M = function(A, O, N) {
      var H = 0;
      for (
        A = N ? L(A / v) : A >> 1, A += L(A / O);
        /* no initialization */
        A > W * y >> 1;
        H += g
      )
        A = L(A / W);
      return L(H + (W + 1) * A / (A + b));
    }, q = function(A) {
      var O = [], N = A.length, H = 0, K = _, fe = k, he = A.lastIndexOf(w);
      he < 0 && (he = 0);
      for (var Ie = 0; Ie < he; ++Ie)
        A.charCodeAt(Ie) >= 128 && ae("not-basic"), O.push(A.charCodeAt(Ie));
      for (var nt = he > 0 ? he + 1 : 0; nt < N; ) {
        for (
          var Ve = H, Oe = 1, qe = g;
          ;
          /* no condition */
          qe += g
        ) {
          nt >= N && ae("invalid-input");
          var et = ve(A.charCodeAt(nt++));
          (et >= g || et > L((m - H) / Oe)) && ae("overflow"), H += et * Oe;
          var Se = qe <= fe ? p : qe >= fe + y ? y : qe - fe;
          if (et < Se)
            break;
          var ot = g - Se;
          Oe > L(m / ot) && ae("overflow"), Oe *= ot;
        }
        var Ue = O.length + 1;
        fe = M(H - Ve, Ue, Ve == 0), L(H / Ue) > m - K && ae("overflow"), K += L(H / Ue), H %= Ue, O.splice(H++, 0, K);
      }
      return String.fromCodePoint.apply(String, O);
    }, F = function(A) {
      var O = [];
      A = De(A);
      var N = A.length, H = _, K = 0, fe = k, he = !0, Ie = !1, nt = void 0;
      try {
        for (var Ve = A[Symbol.iterator](), Oe; !(he = (Oe = Ve.next()).done); he = !0) {
          var qe = Oe.value;
          qe < 128 && O.push(ue(qe));
        }
      } catch (oi) {
        Ie = !0, nt = oi;
      } finally {
        try {
          !he && Ve.return && Ve.return();
        } finally {
          if (Ie)
            throw nt;
        }
      }
      var et = O.length, Se = et;
      for (et && O.push(w); Se < N; ) {
        var ot = m, Ue = !0, Jt = !1, Ln = void 0;
        try {
          for (var ir = A[Symbol.iterator](), Wr; !(Ue = (Wr = ir.next()).done); Ue = !0) {
            var Gs = Wr.value;
            Gs >= H && Gs < ot && (ot = Gs);
          }
        } catch (oi) {
          Jt = !0, Ln = oi;
        } finally {
          try {
            !Ue && ir.return && ir.return();
          } finally {
            if (Jt)
              throw Ln;
          }
        }
        var Js = Se + 1;
        ot - H > L((m - K) / Js) && ae("overflow"), K += (ot - H) * Js, H = ot;
        var Yt = !0, Gr = !1, Ys = void 0;
        try {
          for (var Or = A[Symbol.iterator](), Ra; !(Yt = (Ra = Or.next()).done); Yt = !0) {
            var Vp = Ra.value;
            if (Vp < H && ++K > m && ae("overflow"), Vp == H) {
              for (
                var ja = K, La = g;
                ;
                /* no condition */
                La += g
              ) {
                var Ba = La <= fe ? p : La >= fe + y ? y : La - fe;
                if (ja < Ba)
                  break;
                var Up = ja - Ba, zp = g - Ba;
                O.push(ue(Y(Ba + Up % zp, 0))), ja = L(Up / zp);
              }
              O.push(ue(Y(ja, 0))), fe = M(K, Js, Se == et), K = 0, ++Se;
            }
          }
        } catch (oi) {
          Gr = !0, Ys = oi;
        } finally {
          try {
            !Yt && Or.return && Or.return();
          } finally {
            if (Gr)
              throw Ys;
          }
        }
        ++K, ++H;
      }
      return O.join("");
    }, C = function(A) {
      return Pe(A, function(O) {
        return x.test(O) ? q(O.slice(4).toLowerCase()) : O;
      });
    }, I = function(A) {
      return Pe(A, function(O) {
        return T.test(O) ? "xn--" + F(O) : O;
      });
    }, D = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: De,
        encode: Be
      },
      decode: q,
      encode: F,
      toASCII: I,
      toUnicode: C
    }, X = {};
    function re(A) {
      var O = A.charCodeAt(0), N = void 0;
      return O < 16 ? N = "%0" + O.toString(16).toUpperCase() : O < 128 ? N = "%" + O.toString(16).toUpperCase() : O < 2048 ? N = "%" + (O >> 6 | 192).toString(16).toUpperCase() + "%" + (O & 63 | 128).toString(16).toUpperCase() : N = "%" + (O >> 12 | 224).toString(16).toUpperCase() + "%" + (O >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (O & 63 | 128).toString(16).toUpperCase(), N;
    }
    function ke(A) {
      for (var O = "", N = 0, H = A.length; N < H; ) {
        var K = parseInt(A.substr(N + 1, 2), 16);
        if (K < 128)
          O += String.fromCharCode(K), N += 3;
        else if (K >= 194 && K < 224) {
          if (H - N >= 6) {
            var fe = parseInt(A.substr(N + 4, 2), 16);
            O += String.fromCharCode((K & 31) << 6 | fe & 63);
          } else
            O += A.substr(N, 6);
          N += 6;
        } else if (K >= 224) {
          if (H - N >= 9) {
            var he = parseInt(A.substr(N + 4, 2), 16), Ie = parseInt(A.substr(N + 7, 2), 16);
            O += String.fromCharCode((K & 15) << 12 | (he & 63) << 6 | Ie & 63);
          } else
            O += A.substr(N, 9);
          N += 9;
        } else
          O += A.substr(N, 3), N += 3;
      }
      return O;
    }
    function be(A, O) {
      function N(H) {
        var K = ke(H);
        return K.match(O.UNRESERVED) ? K : H;
      }
      return A.scheme && (A.scheme = String(A.scheme).replace(O.PCT_ENCODED, N).toLowerCase().replace(O.NOT_SCHEME, "")), A.userinfo !== void 0 && (A.userinfo = String(A.userinfo).replace(O.PCT_ENCODED, N).replace(O.NOT_USERINFO, re).replace(O.PCT_ENCODED, i)), A.host !== void 0 && (A.host = String(A.host).replace(O.PCT_ENCODED, N).toLowerCase().replace(O.NOT_HOST, re).replace(O.PCT_ENCODED, i)), A.path !== void 0 && (A.path = String(A.path).replace(O.PCT_ENCODED, N).replace(A.scheme ? O.NOT_PATH : O.NOT_PATH_NOSCHEME, re).replace(O.PCT_ENCODED, i)), A.query !== void 0 && (A.query = String(A.query).replace(O.PCT_ENCODED, N).replace(O.NOT_QUERY, re).replace(O.PCT_ENCODED, i)), A.fragment !== void 0 && (A.fragment = String(A.fragment).replace(O.PCT_ENCODED, N).replace(O.NOT_FRAGMENT, re).replace(O.PCT_ENCODED, i)), A;
    }
    function Ne(A) {
      return A.replace(/^0*(.*)/, "$1") || "0";
    }
    function Cr(A, O) {
      var N = A.match(O.IPV4ADDRESS) || [], H = h(N, 2), K = H[1];
      return K ? K.split(".").map(Ne).join(".") : A;
    }
    function In(A, O) {
      var N = A.match(O.IPV6ADDRESS) || [], H = h(N, 3), K = H[1], fe = H[2];
      if (K) {
        for (var he = K.toLowerCase().split("::").reverse(), Ie = h(he, 2), nt = Ie[0], Ve = Ie[1], Oe = Ve ? Ve.split(":").map(Ne) : [], qe = nt.split(":").map(Ne), et = O.IPV4ADDRESS.test(qe[qe.length - 1]), Se = et ? 7 : 8, ot = qe.length - Se, Ue = Array(Se), Jt = 0; Jt < Se; ++Jt)
          Ue[Jt] = Oe[Jt] || qe[ot + Jt] || "";
        et && (Ue[Se - 1] = Cr(Ue[Se - 1], O));
        var Ln = Ue.reduce(function(Yt, Gr, Ys) {
          if (!Gr || Gr === "0") {
            var Or = Yt[Yt.length - 1];
            Or && Or.index + Or.length === Ys ? Or.length++ : Yt.push({ index: Ys, length: 1 });
          }
          return Yt;
        }, []), ir = Ln.sort(function(Yt, Gr) {
          return Gr.length - Yt.length;
        })[0], Wr = void 0;
        if (ir && ir.length > 1) {
          var Gs = Ue.slice(0, ir.index), Js = Ue.slice(ir.index + ir.length);
          Wr = Gs.join(":") + "::" + Js.join(":");
        } else
          Wr = Ue.join(":");
        return fe && (Wr += "%" + fe), Wr;
      } else
        return A;
    }
    var Qo = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, Zo = "".match(/(){0}/)[1] === void 0;
    function Ft(A) {
      var O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, N = {}, H = O.iri !== !1 ? d : u;
      O.reference === "suffix" && (A = (O.scheme ? O.scheme + ":" : "") + "//" + A);
      var K = A.match(Qo);
      if (K) {
        Zo ? (N.scheme = K[1], N.userinfo = K[3], N.host = K[4], N.port = parseInt(K[5], 10), N.path = K[6] || "", N.query = K[7], N.fragment = K[8], isNaN(N.port) && (N.port = K[5])) : (N.scheme = K[1] || void 0, N.userinfo = A.indexOf("@") !== -1 ? K[3] : void 0, N.host = A.indexOf("//") !== -1 ? K[4] : void 0, N.port = parseInt(K[5], 10), N.path = K[6] || "", N.query = A.indexOf("?") !== -1 ? K[7] : void 0, N.fragment = A.indexOf("#") !== -1 ? K[8] : void 0, isNaN(N.port) && (N.port = A.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? K[4] : void 0)), N.host && (N.host = In(Cr(N.host, H), H)), N.scheme === void 0 && N.userinfo === void 0 && N.host === void 0 && N.port === void 0 && !N.path && N.query === void 0 ? N.reference = "same-document" : N.scheme === void 0 ? N.reference = "relative" : N.fragment === void 0 ? N.reference = "absolute" : N.reference = "uri", O.reference && O.reference !== "suffix" && O.reference !== N.reference && (N.error = N.error || "URI is not a " + O.reference + " reference.");
        var fe = X[(O.scheme || N.scheme || "").toLowerCase()];
        if (!O.unicodeSupport && (!fe || !fe.unicodeSupport)) {
          if (N.host && (O.domainHost || fe && fe.domainHost))
            try {
              N.host = D.toASCII(N.host.replace(H.PCT_ENCODED, ke).toLowerCase());
            } catch (he) {
              N.error = N.error || "Host's domain name can not be converted to ASCII via punycode: " + he;
            }
          be(N, u);
        } else
          be(N, H);
        fe && fe.parse && fe.parse(N, O);
      } else
        N.error = N.error || "URI can not be parsed.";
      return N;
    }
    function ei(A, O) {
      var N = O.iri !== !1 ? d : u, H = [];
      return A.userinfo !== void 0 && (H.push(A.userinfo), H.push("@")), A.host !== void 0 && H.push(In(Cr(String(A.host), N), N).replace(N.IPV6ADDRESS, function(K, fe, he) {
        return "[" + fe + (he ? "%25" + he : "") + "]";
      })), (typeof A.port == "number" || typeof A.port == "string") && (H.push(":"), H.push(String(A.port))), H.length ? H.join("") : void 0;
    }
    var Nn = /^\.\.?\//, Mn = /^\/\.(\/|$)/, Dn = /^\/\.\.(\/|$)/, ti = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Ar(A) {
      for (var O = []; A.length; )
        if (A.match(Nn))
          A = A.replace(Nn, "");
        else if (A.match(Mn))
          A = A.replace(Mn, "/");
        else if (A.match(Dn))
          A = A.replace(Dn, "/"), O.pop();
        else if (A === "." || A === "..")
          A = "";
        else {
          var N = A.match(ti);
          if (N) {
            var H = N[0];
            A = A.slice(H.length), O.push(H);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return O.join("");
    }
    function Mt(A) {
      var O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, N = O.iri ? d : u, H = [], K = X[(O.scheme || A.scheme || "").toLowerCase()];
      if (K && K.serialize && K.serialize(A, O), A.host && !N.IPV6ADDRESS.test(A.host) && (O.domainHost || K && K.domainHost))
        try {
          A.host = O.iri ? D.toUnicode(A.host) : D.toASCII(A.host.replace(N.PCT_ENCODED, ke).toLowerCase());
        } catch (Ie) {
          A.error = A.error || "Host's domain name can not be converted to " + (O.iri ? "Unicode" : "ASCII") + " via punycode: " + Ie;
        }
      be(A, N), O.reference !== "suffix" && A.scheme && (H.push(A.scheme), H.push(":"));
      var fe = ei(A, O);
      if (fe !== void 0 && (O.reference !== "suffix" && H.push("//"), H.push(fe), A.path && A.path.charAt(0) !== "/" && H.push("/")), A.path !== void 0) {
        var he = A.path;
        !O.absolutePath && (!K || !K.absolutePath) && (he = Ar(he)), fe === void 0 && (he = he.replace(/^\/\//, "/%2F")), H.push(he);
      }
      return A.query !== void 0 && (H.push("?"), H.push(A.query)), A.fragment !== void 0 && (H.push("#"), H.push(A.fragment)), H.join("");
    }
    function Rn(A, O) {
      var N = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, H = arguments[3], K = {};
      return H || (A = Ft(Mt(A, N), N), O = Ft(Mt(O, N), N)), N = N || {}, !N.tolerant && O.scheme ? (K.scheme = O.scheme, K.userinfo = O.userinfo, K.host = O.host, K.port = O.port, K.path = Ar(O.path || ""), K.query = O.query) : (O.userinfo !== void 0 || O.host !== void 0 || O.port !== void 0 ? (K.userinfo = O.userinfo, K.host = O.host, K.port = O.port, K.path = Ar(O.path || ""), K.query = O.query) : (O.path ? (O.path.charAt(0) === "/" ? K.path = Ar(O.path) : ((A.userinfo !== void 0 || A.host !== void 0 || A.port !== void 0) && !A.path ? K.path = "/" + O.path : A.path ? K.path = A.path.slice(0, A.path.lastIndexOf("/") + 1) + O.path : K.path = O.path, K.path = Ar(K.path)), K.query = O.query) : (K.path = A.path, O.query !== void 0 ? K.query = O.query : K.query = A.query), K.userinfo = A.userinfo, K.host = A.host, K.port = A.port), K.scheme = A.scheme), K.fragment = O.fragment, K;
    }
    function ri(A, O, N) {
      var H = l({ scheme: "null" }, N);
      return Mt(Rn(Ft(A, H), Ft(O, H), H, !0), H);
    }
    function Ks(A, O) {
      return typeof A == "string" ? A = Mt(Ft(A, O), O) : o(A) === "object" && (A = Ft(Mt(A, O), O)), A;
    }
    function si(A, O, N) {
      return typeof A == "string" ? A = Mt(Ft(A, N), N) : o(A) === "object" && (A = Mt(A, N)), typeof O == "string" ? O = Mt(Ft(O, N), N) : o(O) === "object" && (O = Mt(O, N)), A === O;
    }
    function Da(A, O) {
      return A && A.toString().replace(!O || !O.iri ? u.ESCAPE : d.ESCAPE, re);
    }
    function Gt(A, O) {
      return A && A.toString().replace(!O || !O.iri ? u.PCT_ENCODED : d.PCT_ENCODED, ke);
    }
    var Ws = {
      scheme: "http",
      domainHost: !0,
      parse: function(A, O) {
        return A.host || (A.error = A.error || "HTTP URIs must have a host."), A;
      },
      serialize: function(A, O) {
        var N = String(A.scheme).toLowerCase() === "https";
        return (A.port === (N ? 443 : 80) || A.port === "") && (A.port = void 0), A.path || (A.path = "/"), A;
      }
    }, Np = {
      scheme: "https",
      domainHost: Ws.domainHost,
      parse: Ws.parse,
      serialize: Ws.serialize
    };
    function Mp(A) {
      return typeof A.secure == "boolean" ? A.secure : String(A.scheme).toLowerCase() === "wss";
    }
    var ni = {
      scheme: "ws",
      domainHost: !0,
      parse: function(A, O) {
        var N = A;
        return N.secure = Mp(N), N.resourceName = (N.path || "/") + (N.query ? "?" + N.query : ""), N.path = void 0, N.query = void 0, N;
      },
      serialize: function(A, O) {
        if ((A.port === (Mp(A) ? 443 : 80) || A.port === "") && (A.port = void 0), typeof A.secure == "boolean" && (A.scheme = A.secure ? "wss" : "ws", A.secure = void 0), A.resourceName) {
          var N = A.resourceName.split("?"), H = h(N, 2), K = H[0], fe = H[1];
          A.path = K && K !== "/" ? K : void 0, A.query = fe, A.resourceName = void 0;
        }
        return A.fragment = void 0, A;
      }
    }, Dp = {
      scheme: "wss",
      domainHost: ni.domainHost,
      parse: ni.parse,
      serialize: ni.serialize
    }, xw = {}, Rp = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", Er = "[0-9A-Fa-f]", Cw = n(n("%[EFef]" + Er + "%" + Er + Er + "%" + Er + Er) + "|" + n("%[89A-Fa-f]" + Er + "%" + Er + Er) + "|" + n("%" + Er + Er)), Aw = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", Ew = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", Ow = s(Ew, '[\\"\\\\]'), Tw = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", Pw = new RegExp(Rp, "g"), jn = new RegExp(Cw, "g"), Iw = new RegExp(s("[^]", Aw, "[\\.]", '[\\"]', Ow), "g"), jp = new RegExp(s("[^]", Rp, Tw), "g"), Nw = jp;
    function hu(A) {
      var O = ke(A);
      return O.match(Pw) ? O : A;
    }
    var Lp = {
      scheme: "mailto",
      parse: function(A, O) {
        var N = A, H = N.to = N.path ? N.path.split(",") : [];
        if (N.path = void 0, N.query) {
          for (var K = !1, fe = {}, he = N.query.split("&"), Ie = 0, nt = he.length; Ie < nt; ++Ie) {
            var Ve = he[Ie].split("=");
            switch (Ve[0]) {
              case "to":
                for (var Oe = Ve[1].split(","), qe = 0, et = Oe.length; qe < et; ++qe)
                  H.push(Oe[qe]);
                break;
              case "subject":
                N.subject = Gt(Ve[1], O);
                break;
              case "body":
                N.body = Gt(Ve[1], O);
                break;
              default:
                K = !0, fe[Gt(Ve[0], O)] = Gt(Ve[1], O);
                break;
            }
          }
          K && (N.headers = fe);
        }
        N.query = void 0;
        for (var Se = 0, ot = H.length; Se < ot; ++Se) {
          var Ue = H[Se].split("@");
          if (Ue[0] = Gt(Ue[0]), O.unicodeSupport)
            Ue[1] = Gt(Ue[1], O).toLowerCase();
          else
            try {
              Ue[1] = D.toASCII(Gt(Ue[1], O).toLowerCase());
            } catch (Jt) {
              N.error = N.error || "Email address's domain name can not be converted to ASCII via punycode: " + Jt;
            }
          H[Se] = Ue.join("@");
        }
        return N;
      },
      serialize: function(A, O) {
        var N = A, H = a(A.to);
        if (H) {
          for (var K = 0, fe = H.length; K < fe; ++K) {
            var he = String(H[K]), Ie = he.lastIndexOf("@"), nt = he.slice(0, Ie).replace(jn, hu).replace(jn, i).replace(Iw, re), Ve = he.slice(Ie + 1);
            try {
              Ve = O.iri ? D.toUnicode(Ve) : D.toASCII(Gt(Ve, O).toLowerCase());
            } catch (Se) {
              N.error = N.error || "Email address's domain name can not be converted to " + (O.iri ? "Unicode" : "ASCII") + " via punycode: " + Se;
            }
            H[K] = nt + "@" + Ve;
          }
          N.path = H.join(",");
        }
        var Oe = A.headers = A.headers || {};
        A.subject && (Oe.subject = A.subject), A.body && (Oe.body = A.body);
        var qe = [];
        for (var et in Oe)
          Oe[et] !== xw[et] && qe.push(et.replace(jn, hu).replace(jn, i).replace(jp, re) + "=" + Oe[et].replace(jn, hu).replace(jn, i).replace(Nw, re));
        return qe.length && (N.query = qe.join("&")), N;
      }
    }, Mw = /^([^\:]+)\:(.*)/, Bp = {
      scheme: "urn",
      parse: function(A, O) {
        var N = A.path && A.path.match(Mw), H = A;
        if (N) {
          var K = O.scheme || H.scheme || "urn", fe = N[1].toLowerCase(), he = N[2], Ie = K + ":" + (O.nid || fe), nt = X[Ie];
          H.nid = fe, H.nss = he, H.path = void 0, nt && (H = nt.parse(H, O));
        } else
          H.error = H.error || "URN can not be parsed.";
        return H;
      },
      serialize: function(A, O) {
        var N = O.scheme || A.scheme || "urn", H = A.nid, K = N + ":" + (O.nid || H), fe = X[K];
        fe && (A = fe.serialize(A, O));
        var he = A, Ie = A.nss;
        return he.path = (H || O.nid) + ":" + Ie, he;
      }
    }, Dw = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, Fp = {
      scheme: "urn:uuid",
      parse: function(A, O) {
        var N = A;
        return N.uuid = N.nss, N.nss = void 0, !O.tolerant && (!N.uuid || !N.uuid.match(Dw)) && (N.error = N.error || "UUID is not valid."), N;
      },
      serialize: function(A, O) {
        var N = A;
        return N.nss = (A.uuid || "").toLowerCase(), N;
      }
    };
    X[Ws.scheme] = Ws, X[Np.scheme] = Np, X[ni.scheme] = ni, X[Dp.scheme] = Dp, X[Lp.scheme] = Lp, X[Bp.scheme] = Bp, X[Fp.scheme] = Fp, t.SCHEMES = X, t.pctEncChar = re, t.pctDecChars = ke, t.parse = Ft, t.removeDotSegments = Ar, t.serialize = Mt, t.resolveComponents = Rn, t.resolve = ri, t.normalize = Ks, t.equal = si, t.escapeComponent = Da, t.unescapeComponent = Gt, Object.defineProperty(t, "__esModule", { value: !0 });
  });
})(sh, sh.exports);
var nP = sh.exports;
Object.defineProperty(Sf, "__esModule", { value: !0 });
const Mv = nP;
Mv.code = 'require("ajv/dist/runtime/uri").default';
Sf.default = Mv;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.CodeGen = r.Name = r.nil = r.stringify = r.str = r._ = r.KeywordCxt = void 0;
  var e = rr;
  Object.defineProperty(r, "KeywordCxt", { enumerable: !0, get: function() {
    return e.KeywordCxt;
  } });
  var t = ye;
  Object.defineProperty(r, "_", { enumerable: !0, get: function() {
    return t._;
  } }), Object.defineProperty(r, "str", { enumerable: !0, get: function() {
    return t.str;
  } }), Object.defineProperty(r, "stringify", { enumerable: !0, get: function() {
    return t.stringify;
  } }), Object.defineProperty(r, "nil", { enumerable: !0, get: function() {
    return t.nil;
  } }), Object.defineProperty(r, "Name", { enumerable: !0, get: function() {
    return t.Name;
  } }), Object.defineProperty(r, "CodeGen", { enumerable: !0, get: function() {
    return t.CodeGen;
  } });
  const s = Mo, n = Do, o = _n, i = Tt, a = ye, l = bt, c = ka, u = Ae, d = sP, h = Sf, f = (Y, M) => new RegExp(Y, M);
  f.code = "new RegExp";
  const m = ["removeAdditional", "useDefaults", "coerceTypes"], g = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), p = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, y = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, b = 200;
  function v(Y) {
    var M, q, F, C, I, D, X, re, ke, be, Ne, Cr, In, Qo, Zo, Ft, ei, Nn, Mn, Dn, ti, Ar, Mt, Rn, ri;
    const Ks = Y.strict, si = (M = Y.code) === null || M === void 0 ? void 0 : M.optimize, Da = si === !0 || si === void 0 ? 1 : si || 0, Gt = (F = (q = Y.code) === null || q === void 0 ? void 0 : q.regExp) !== null && F !== void 0 ? F : f, Ws = (C = Y.uriResolver) !== null && C !== void 0 ? C : h.default;
    return {
      strictSchema: (D = (I = Y.strictSchema) !== null && I !== void 0 ? I : Ks) !== null && D !== void 0 ? D : !0,
      strictNumbers: (re = (X = Y.strictNumbers) !== null && X !== void 0 ? X : Ks) !== null && re !== void 0 ? re : !0,
      strictTypes: (be = (ke = Y.strictTypes) !== null && ke !== void 0 ? ke : Ks) !== null && be !== void 0 ? be : "log",
      strictTuples: (Cr = (Ne = Y.strictTuples) !== null && Ne !== void 0 ? Ne : Ks) !== null && Cr !== void 0 ? Cr : "log",
      strictRequired: (Qo = (In = Y.strictRequired) !== null && In !== void 0 ? In : Ks) !== null && Qo !== void 0 ? Qo : !1,
      code: Y.code ? { ...Y.code, optimize: Da, regExp: Gt } : { optimize: Da, regExp: Gt },
      loopRequired: (Zo = Y.loopRequired) !== null && Zo !== void 0 ? Zo : b,
      loopEnum: (Ft = Y.loopEnum) !== null && Ft !== void 0 ? Ft : b,
      meta: (ei = Y.meta) !== null && ei !== void 0 ? ei : !0,
      messages: (Nn = Y.messages) !== null && Nn !== void 0 ? Nn : !0,
      inlineRefs: (Mn = Y.inlineRefs) !== null && Mn !== void 0 ? Mn : !0,
      schemaId: (Dn = Y.schemaId) !== null && Dn !== void 0 ? Dn : "$id",
      addUsedSchema: (ti = Y.addUsedSchema) !== null && ti !== void 0 ? ti : !0,
      validateSchema: (Ar = Y.validateSchema) !== null && Ar !== void 0 ? Ar : !0,
      validateFormats: (Mt = Y.validateFormats) !== null && Mt !== void 0 ? Mt : !0,
      unicodeRegExp: (Rn = Y.unicodeRegExp) !== null && Rn !== void 0 ? Rn : !0,
      int32range: (ri = Y.int32range) !== null && ri !== void 0 ? ri : !0,
      uriResolver: Ws
    };
  }
  class k {
    constructor(M = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), M = this.opts = { ...M, ...v(M) };
      const { es5: q, lines: F } = this.opts.code;
      this.scope = new a.ValueScope({ scope: {}, prefixes: g, es5: q, lines: F }), this.logger = L(M.logger);
      const C = M.validateFormats;
      M.validateFormats = !1, this.RULES = (0, o.getRules)(), _.call(this, p, M, "NOT SUPPORTED"), _.call(this, y, M, "DEPRECATED", "warn"), this._metaOpts = B.call(this), M.formats && T.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), M.keywords && j.call(this, M.keywords), typeof M.meta == "object" && this.addMetaSchema(M.meta), x.call(this), M.validateFormats = C;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: M, meta: q, schemaId: F } = this.opts;
      let C = d;
      F === "id" && (C = { ...d }, C.id = C.$id, delete C.$id), q && M && this.addMetaSchema(C, C[F], !1);
    }
    defaultMeta() {
      const { meta: M, schemaId: q } = this.opts;
      return this.opts.defaultMeta = typeof M == "object" ? M[q] || M : void 0;
    }
    validate(M, q) {
      let F;
      if (typeof M == "string") {
        if (F = this.getSchema(M), !F)
          throw new Error(`no schema with key or ref "${M}"`);
      } else
        F = this.compile(M);
      const C = F(q);
      return "$async" in F || (this.errors = F.errors), C;
    }
    compile(M, q) {
      const F = this._addSchema(M, q);
      return F.validate || this._compileSchemaEnv(F);
    }
    compileAsync(M, q) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: F } = this.opts;
      return C.call(this, M, q);
      async function C(be, Ne) {
        await I.call(this, be.$schema);
        const Cr = this._addSchema(be, Ne);
        return Cr.validate || D.call(this, Cr);
      }
      async function I(be) {
        be && !this.getSchema(be) && await C.call(this, { $ref: be }, !0);
      }
      async function D(be) {
        try {
          return this._compileSchemaEnv(be);
        } catch (Ne) {
          if (!(Ne instanceof n.default))
            throw Ne;
          return X.call(this, Ne), await re.call(this, Ne.missingSchema), D.call(this, be);
        }
      }
      function X({ missingSchema: be, missingRef: Ne }) {
        if (this.refs[be])
          throw new Error(`AnySchema ${be} is loaded but ${Ne} cannot be resolved`);
      }
      async function re(be) {
        const Ne = await ke.call(this, be);
        this.refs[be] || await I.call(this, Ne.$schema), this.refs[be] || this.addSchema(Ne, be, q);
      }
      async function ke(be) {
        const Ne = this._loading[be];
        if (Ne)
          return Ne;
        try {
          return await (this._loading[be] = F(be));
        } finally {
          delete this._loading[be];
        }
      }
    }
    // Adds schema to the instance
    addSchema(M, q, F, C = this.opts.validateSchema) {
      if (Array.isArray(M)) {
        for (const D of M)
          this.addSchema(D, void 0, F, C);
        return this;
      }
      let I;
      if (typeof M == "object") {
        const { schemaId: D } = this.opts;
        if (I = M[D], I !== void 0 && typeof I != "string")
          throw new Error(`schema ${D} must be string`);
      }
      return q = (0, l.normalizeId)(q || I), this._checkUnique(q), this.schemas[q] = this._addSchema(M, F, q, C, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(M, q, F = this.opts.validateSchema) {
      return this.addSchema(M, q, !0, F), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(M, q) {
      if (typeof M == "boolean")
        return !0;
      let F;
      if (F = M.$schema, F !== void 0 && typeof F != "string")
        throw new Error("$schema must be a string");
      if (F = F || this.opts.defaultMeta || this.defaultMeta(), !F)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const C = this.validate(F, M);
      if (!C && q) {
        const I = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(I);
        else
          throw new Error(I);
      }
      return C;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(M) {
      let q;
      for (; typeof (q = w.call(this, M)) == "string"; )
        M = q;
      if (q === void 0) {
        const { schemaId: F } = this.opts, C = new i.SchemaEnv({ schema: {}, schemaId: F });
        if (q = i.resolveSchema.call(this, C, M), !q)
          return;
        this.refs[M] = q;
      }
      return q.validate || this._compileSchemaEnv(q);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(M) {
      if (M instanceof RegExp)
        return this._removeAllSchemas(this.schemas, M), this._removeAllSchemas(this.refs, M), this;
      switch (typeof M) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const q = w.call(this, M);
          return typeof q == "object" && this._cache.delete(q.schema), delete this.schemas[M], delete this.refs[M], this;
        }
        case "object": {
          const q = M;
          this._cache.delete(q);
          let F = M[this.opts.schemaId];
          return F && (F = (0, l.normalizeId)(F), delete this.schemas[F], delete this.refs[F]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(M) {
      for (const q of M)
        this.addKeyword(q);
      return this;
    }
    addKeyword(M, q) {
      let F;
      if (typeof M == "string")
        F = M, typeof q == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), q.keyword = F);
      else if (typeof M == "object" && q === void 0) {
        if (q = M, F = q.keyword, Array.isArray(F) && !F.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (ae.call(this, F, q), !q)
        return (0, u.eachItem)(F, (I) => me.call(this, I)), this;
      De.call(this, q);
      const C = {
        ...q,
        type: (0, c.getJSONTypes)(q.type),
        schemaType: (0, c.getJSONTypes)(q.schemaType)
      };
      return (0, u.eachItem)(F, C.type.length === 0 ? (I) => me.call(this, I, C) : (I) => C.type.forEach((D) => me.call(this, I, C, D))), this;
    }
    getKeyword(M) {
      const q = this.RULES.all[M];
      return typeof q == "object" ? q.definition : !!q;
    }
    // Remove keyword
    removeKeyword(M) {
      const { RULES: q } = this;
      delete q.keywords[M], delete q.all[M];
      for (const F of q.rules) {
        const C = F.rules.findIndex((I) => I.keyword === M);
        C >= 0 && F.rules.splice(C, 1);
      }
      return this;
    }
    // Add format
    addFormat(M, q) {
      return typeof q == "string" && (q = new RegExp(q)), this.formats[M] = q, this;
    }
    errorsText(M = this.errors, { separator: q = ", ", dataVar: F = "data" } = {}) {
      return !M || M.length === 0 ? "No errors" : M.map((C) => `${F}${C.instancePath} ${C.message}`).reduce((C, I) => C + q + I);
    }
    $dataMetaSchema(M, q) {
      const F = this.RULES.all;
      M = JSON.parse(JSON.stringify(M));
      for (const C of q) {
        const I = C.split("/").slice(1);
        let D = M;
        for (const X of I)
          D = D[X];
        for (const X in F) {
          const re = F[X];
          if (typeof re != "object")
            continue;
          const { $data: ke } = re.definition, be = D[X];
          ke && be && (D[X] = ve(be));
        }
      }
      return M;
    }
    _removeAllSchemas(M, q) {
      for (const F in M) {
        const C = M[F];
        (!q || q.test(F)) && (typeof C == "string" ? delete M[F] : C && !C.meta && (this._cache.delete(C.schema), delete M[F]));
      }
    }
    _addSchema(M, q, F, C = this.opts.validateSchema, I = this.opts.addUsedSchema) {
      let D;
      const { schemaId: X } = this.opts;
      if (typeof M == "object")
        D = M[X];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof M != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let re = this._cache.get(M);
      if (re !== void 0)
        return re;
      F = (0, l.normalizeId)(D || F);
      const ke = l.getSchemaRefs.call(this, M, F);
      return re = new i.SchemaEnv({ schema: M, schemaId: X, meta: q, baseId: F, localRefs: ke }), this._cache.set(re.schema, re), I && !F.startsWith("#") && (F && this._checkUnique(F), this.refs[F] = re), C && this.validateSchema(M, !0), re;
    }
    _checkUnique(M) {
      if (this.schemas[M] || this.refs[M])
        throw new Error(`schema with key or id "${M}" already exists`);
    }
    _compileSchemaEnv(M) {
      if (M.meta ? this._compileMetaSchema(M) : i.compileSchema.call(this, M), !M.validate)
        throw new Error("ajv implementation error");
      return M.validate;
    }
    _compileMetaSchema(M) {
      const q = this.opts;
      this.opts = this._metaOpts;
      try {
        i.compileSchema.call(this, M);
      } finally {
        this.opts = q;
      }
    }
  }
  r.default = k, k.ValidationError = s.default, k.MissingRefError = n.default;
  function _(Y, M, q, F = "error") {
    for (const C in Y) {
      const I = C;
      I in M && this.logger[F](`${q}: option ${C}. ${Y[I]}`);
    }
  }
  function w(Y) {
    return Y = (0, l.normalizeId)(Y), this.schemas[Y] || this.refs[Y];
  }
  function x() {
    const Y = this.opts.schemas;
    if (Y)
      if (Array.isArray(Y))
        this.addSchema(Y);
      else
        for (const M in Y)
          this.addSchema(Y[M], M);
  }
  function T() {
    for (const Y in this.opts.formats) {
      const M = this.opts.formats[Y];
      M && this.addFormat(Y, M);
    }
  }
  function j(Y) {
    if (Array.isArray(Y)) {
      this.addVocabulary(Y);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const M in Y) {
      const q = Y[M];
      q.keyword || (q.keyword = M), this.addKeyword(q);
    }
  }
  function B() {
    const Y = { ...this.opts };
    for (const M of m)
      delete Y[M];
    return Y;
  }
  const W = { log() {
  }, warn() {
  }, error() {
  } };
  function L(Y) {
    if (Y === !1)
      return W;
    if (Y === void 0)
      return console;
    if (Y.log && Y.warn && Y.error)
      return Y;
    throw new Error("logger must implement log, warn and error methods");
  }
  const ue = /^[a-z_$][a-z0-9_$:-]*$/i;
  function ae(Y, M) {
    const { RULES: q } = this;
    if ((0, u.eachItem)(Y, (F) => {
      if (q.keywords[F])
        throw new Error(`Keyword ${F} is already defined`);
      if (!ue.test(F))
        throw new Error(`Keyword ${F} has invalid name`);
    }), !!M && M.$data && !("code" in M || "validate" in M))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function me(Y, M, q) {
    var F;
    const C = M == null ? void 0 : M.post;
    if (q && C)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: I } = this;
    let D = C ? I.post : I.rules.find(({ type: re }) => re === q);
    if (D || (D = { type: q, rules: [] }, I.rules.push(D)), I.keywords[Y] = !0, !M)
      return;
    const X = {
      keyword: Y,
      definition: {
        ...M,
        type: (0, c.getJSONTypes)(M.type),
        schemaType: (0, c.getJSONTypes)(M.schemaType)
      }
    };
    M.before ? Pe.call(this, D, X, M.before) : D.rules.push(X), I.all[Y] = X, (F = M.implements) === null || F === void 0 || F.forEach((re) => this.addKeyword(re));
  }
  function Pe(Y, M, q) {
    const F = Y.rules.findIndex((C) => C.keyword === q);
    F >= 0 ? Y.rules.splice(F, 0, M) : (Y.rules.push(M), this.logger.warn(`rule ${q} is not defined`));
  }
  function De(Y) {
    let { metaSchema: M } = Y;
    M !== void 0 && (Y.$data && this.opts.$data && (M = ve(M)), Y.validateSchema = this.compile(M, !0));
  }
  const Be = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function ve(Y) {
    return { anyOf: [Y, Be] };
  }
})(yn);
var $f = {}, Mc = {}, _f = {};
Object.defineProperty(_f, "__esModule", { value: !0 });
const oP = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
_f.default = oP;
var qr = {};
Object.defineProperty(qr, "__esModule", { value: !0 });
qr.callRef = qr.getValidate = void 0;
const iP = Do, Ug = Ce, Dt = ye, Un = Wt, zg = Tt, al = Ae, aP = {
  keyword: "$ref",
  schemaType: "string",
  code(r) {
    const { gen: e, schema: t, it: s } = r, { baseId: n, schemaEnv: o, validateName: i, opts: a, self: l } = s, { root: c } = o;
    if ((t === "#" || t === "#/") && n === c.baseId)
      return d();
    const u = zg.resolveRef.call(l, c, n, t);
    if (u === void 0)
      throw new iP.default(s.opts.uriResolver, n, t);
    if (u instanceof zg.SchemaEnv)
      return h(u);
    return f(u);
    function d() {
      if (o === c)
        return Il(r, i, o, o.$async);
      const m = e.scopeValue("root", { ref: c });
      return Il(r, (0, Dt._)`${m}.validate`, c, c.$async);
    }
    function h(m) {
      const g = Dv(r, m);
      Il(r, g, m, m.$async);
    }
    function f(m) {
      const g = e.scopeValue("schema", a.code.source === !0 ? { ref: m, code: (0, Dt.stringify)(m) } : { ref: m }), p = e.name("valid"), y = r.subschema({
        schema: m,
        dataTypes: [],
        schemaPath: Dt.nil,
        topSchemaRef: g,
        errSchemaPath: t
      }, p);
      r.mergeEvaluated(y), r.ok(p);
    }
  }
};
function Dv(r, e) {
  const { gen: t } = r;
  return e.validate ? t.scopeValue("validate", { ref: e.validate }) : (0, Dt._)`${t.scopeValue("wrapper", { ref: e })}.validate`;
}
qr.getValidate = Dv;
function Il(r, e, t, s) {
  const { gen: n, it: o } = r, { allErrors: i, schemaEnv: a, opts: l } = o, c = l.passContext ? Un.default.this : Dt.nil;
  s ? u() : d();
  function u() {
    if (!a.$async)
      throw new Error("async schema referenced by sync schema");
    const m = n.let("valid");
    n.try(() => {
      n.code((0, Dt._)`await ${(0, Ug.callValidateCode)(r, e, c)}`), f(e), i || n.assign(m, !0);
    }, (g) => {
      n.if((0, Dt._)`!(${g} instanceof ${o.ValidationError})`, () => n.throw(g)), h(g), i || n.assign(m, !1);
    }), r.ok(m);
  }
  function d() {
    r.result((0, Ug.callValidateCode)(r, e, c), () => f(e), () => h(e));
  }
  function h(m) {
    const g = (0, Dt._)`${m}.errors`;
    n.assign(Un.default.vErrors, (0, Dt._)`${Un.default.vErrors} === null ? ${g} : ${Un.default.vErrors}.concat(${g})`), n.assign(Un.default.errors, (0, Dt._)`${Un.default.vErrors}.length`);
  }
  function f(m) {
    var g;
    if (!o.opts.unevaluated)
      return;
    const p = (g = t == null ? void 0 : t.validate) === null || g === void 0 ? void 0 : g.evaluated;
    if (o.props !== !0)
      if (p && !p.dynamicProps)
        p.props !== void 0 && (o.props = al.mergeEvaluated.props(n, p.props, o.props));
      else {
        const y = n.var("props", (0, Dt._)`${m}.evaluated.props`);
        o.props = al.mergeEvaluated.props(n, y, o.props, Dt.Name);
      }
    if (o.items !== !0)
      if (p && !p.dynamicItems)
        p.items !== void 0 && (o.items = al.mergeEvaluated.items(n, p.items, o.items));
      else {
        const y = n.var("items", (0, Dt._)`${m}.evaluated.items`);
        o.items = al.mergeEvaluated.items(n, y, o.items, Dt.Name);
      }
  }
}
qr.callRef = Il;
qr.default = aP;
Object.defineProperty(Mc, "__esModule", { value: !0 });
const lP = _f, cP = qr, uP = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  lP.default,
  cP.default
];
Mc.default = uP;
var Dc = {}, xf = {};
Object.defineProperty(xf, "__esModule", { value: !0 });
const nc = ye, ys = nc.operators, oc = {
  maximum: { okStr: "<=", ok: ys.LTE, fail: ys.GT },
  minimum: { okStr: ">=", ok: ys.GTE, fail: ys.LT },
  exclusiveMaximum: { okStr: "<", ok: ys.LT, fail: ys.GTE },
  exclusiveMinimum: { okStr: ">", ok: ys.GT, fail: ys.LTE }
}, dP = {
  message: ({ keyword: r, schemaCode: e }) => (0, nc.str)`must be ${oc[r].okStr} ${e}`,
  params: ({ keyword: r, schemaCode: e }) => (0, nc._)`{comparison: ${oc[r].okStr}, limit: ${e}}`
}, hP = {
  keyword: Object.keys(oc),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: dP,
  code(r) {
    const { keyword: e, data: t, schemaCode: s } = r;
    r.fail$data((0, nc._)`${t} ${oc[e].fail} ${s} || isNaN(${t})`);
  }
};
xf.default = hP;
var Rc = {};
Object.defineProperty(Rc, "__esModule", { value: !0 });
const ji = ye, fP = {
  message: ({ schemaCode: r }) => (0, ji.str)`must be multiple of ${r}`,
  params: ({ schemaCode: r }) => (0, ji._)`{multipleOf: ${r}}`
}, pP = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: fP,
  code(r) {
    const { gen: e, data: t, schemaCode: s, it: n } = r, o = n.opts.multipleOfPrecision, i = e.let("res"), a = o ? (0, ji._)`Math.abs(Math.round(${i}) - ${i}) > 1e-${o}` : (0, ji._)`${i} !== parseInt(${i})`;
    r.fail$data((0, ji._)`(${s} === 0 || (${i} = ${t}/${s}, ${a}))`);
  }
};
Rc.default = pP;
var jc = {}, Cf = {};
Object.defineProperty(Cf, "__esModule", { value: !0 });
function Rv(r) {
  const e = r.length;
  let t = 0, s = 0, n;
  for (; s < e; )
    t++, n = r.charCodeAt(s++), n >= 55296 && n <= 56319 && s < e && (n = r.charCodeAt(s), (n & 64512) === 56320 && s++);
  return t;
}
Cf.default = Rv;
Rv.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(jc, "__esModule", { value: !0 });
const rn = ye, mP = Ae, gP = Cf, yP = {
  message({ keyword: r, schemaCode: e }) {
    const t = r === "maxLength" ? "more" : "fewer";
    return (0, rn.str)`must NOT have ${t} than ${e} characters`;
  },
  params: ({ schemaCode: r }) => (0, rn._)`{limit: ${r}}`
}, bP = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: yP,
  code(r) {
    const { keyword: e, data: t, schemaCode: s, it: n } = r, o = e === "maxLength" ? rn.operators.GT : rn.operators.LT, i = n.opts.unicode === !1 ? (0, rn._)`${t}.length` : (0, rn._)`${(0, mP.useFunc)(r.gen, gP.default)}(${t})`;
    r.fail$data((0, rn._)`${i} ${o} ${s}`);
  }
};
jc.default = bP;
var Lc = {};
Object.defineProperty(Lc, "__esModule", { value: !0 });
const vP = Ce, ic = ye, wP = {
  message: ({ schemaCode: r }) => (0, ic.str)`must match pattern "${r}"`,
  params: ({ schemaCode: r }) => (0, ic._)`{pattern: ${r}}`
}, kP = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: wP,
  code(r) {
    const { data: e, $data: t, schema: s, schemaCode: n, it: o } = r, i = o.opts.unicodeRegExp ? "u" : "", a = t ? (0, ic._)`(new RegExp(${n}, ${i}))` : (0, vP.usePattern)(r, s);
    r.fail$data((0, ic._)`!${a}.test(${e})`);
  }
};
Lc.default = kP;
var Bc = {};
Object.defineProperty(Bc, "__esModule", { value: !0 });
const Li = ye, SP = {
  message({ keyword: r, schemaCode: e }) {
    const t = r === "maxProperties" ? "more" : "fewer";
    return (0, Li.str)`must NOT have ${t} than ${e} properties`;
  },
  params: ({ schemaCode: r }) => (0, Li._)`{limit: ${r}}`
}, $P = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: SP,
  code(r) {
    const { keyword: e, data: t, schemaCode: s } = r, n = e === "maxProperties" ? Li.operators.GT : Li.operators.LT;
    r.fail$data((0, Li._)`Object.keys(${t}).length ${n} ${s}`);
  }
};
Bc.default = $P;
var Fc = {};
Object.defineProperty(Fc, "__esModule", { value: !0 });
const gi = Ce, Bi = ye, _P = Ae, xP = {
  message: ({ params: { missingProperty: r } }) => (0, Bi.str)`must have required property '${r}'`,
  params: ({ params: { missingProperty: r } }) => (0, Bi._)`{missingProperty: ${r}}`
}, CP = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: xP,
  code(r) {
    const { gen: e, schema: t, schemaCode: s, data: n, $data: o, it: i } = r, { opts: a } = i;
    if (!o && t.length === 0)
      return;
    const l = t.length >= a.loopRequired;
    if (i.allErrors ? c() : u(), a.strictRequired) {
      const f = r.parentSchema.properties, { definedProperties: m } = r.it;
      for (const g of t)
        if ((f == null ? void 0 : f[g]) === void 0 && !m.has(g)) {
          const p = i.schemaEnv.baseId + i.errSchemaPath, y = `required property "${g}" is not defined at "${p}" (strictRequired)`;
          (0, _P.checkStrictMode)(i, y, i.opts.strictRequired);
        }
    }
    function c() {
      if (l || o)
        r.block$data(Bi.nil, d);
      else
        for (const f of t)
          (0, gi.checkReportMissingProp)(r, f);
    }
    function u() {
      const f = e.let("missing");
      if (l || o) {
        const m = e.let("valid", !0);
        r.block$data(m, () => h(f, m)), r.ok(m);
      } else
        e.if((0, gi.checkMissingProp)(r, t, f)), (0, gi.reportMissingProp)(r, f), e.else();
    }
    function d() {
      e.forOf("prop", s, (f) => {
        r.setParams({ missingProperty: f }), e.if((0, gi.noPropertyInData)(e, n, f, a.ownProperties), () => r.error());
      });
    }
    function h(f, m) {
      r.setParams({ missingProperty: f }), e.forOf(f, s, () => {
        e.assign(m, (0, gi.propertyInData)(e, n, f, a.ownProperties)), e.if((0, Bi.not)(m), () => {
          r.error(), e.break();
        });
      }, Bi.nil);
    }
  }
};
Fc.default = CP;
var Vc = {};
Object.defineProperty(Vc, "__esModule", { value: !0 });
const Fi = ye, AP = {
  message({ keyword: r, schemaCode: e }) {
    const t = r === "maxItems" ? "more" : "fewer";
    return (0, Fi.str)`must NOT have ${t} than ${e} items`;
  },
  params: ({ schemaCode: r }) => (0, Fi._)`{limit: ${r}}`
}, EP = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: AP,
  code(r) {
    const { keyword: e, data: t, schemaCode: s } = r, n = e === "maxItems" ? Fi.operators.GT : Fi.operators.LT;
    r.fail$data((0, Fi._)`${t}.length ${n} ${s}`);
  }
};
Vc.default = EP;
var Uc = {}, Sa = {};
Object.defineProperty(Sa, "__esModule", { value: !0 });
const jv = yv;
jv.code = 'require("ajv/dist/runtime/equal").default';
Sa.default = jv;
Object.defineProperty(Uc, "__esModule", { value: !0 });
const Lu = ka, mt = ye, OP = Ae, TP = Sa, PP = {
  message: ({ params: { i: r, j: e } }) => (0, mt.str)`must NOT have duplicate items (items ## ${e} and ${r} are identical)`,
  params: ({ params: { i: r, j: e } }) => (0, mt._)`{i: ${r}, j: ${e}}`
}, IP = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: PP,
  code(r) {
    const { gen: e, data: t, $data: s, schema: n, parentSchema: o, schemaCode: i, it: a } = r;
    if (!s && !n)
      return;
    const l = e.let("valid"), c = o.items ? (0, Lu.getSchemaTypes)(o.items) : [];
    r.block$data(l, u, (0, mt._)`${i} === false`), r.ok(l);
    function u() {
      const m = e.let("i", (0, mt._)`${t}.length`), g = e.let("j");
      r.setParams({ i: m, j: g }), e.assign(l, !0), e.if((0, mt._)`${m} > 1`, () => (d() ? h : f)(m, g));
    }
    function d() {
      return c.length > 0 && !c.some((m) => m === "object" || m === "array");
    }
    function h(m, g) {
      const p = e.name("item"), y = (0, Lu.checkDataTypes)(c, p, a.opts.strictNumbers, Lu.DataType.Wrong), b = e.const("indices", (0, mt._)`{}`);
      e.for((0, mt._)`;${m}--;`, () => {
        e.let(p, (0, mt._)`${t}[${m}]`), e.if(y, (0, mt._)`continue`), c.length > 1 && e.if((0, mt._)`typeof ${p} == "string"`, (0, mt._)`${p} += "_"`), e.if((0, mt._)`typeof ${b}[${p}] == "number"`, () => {
          e.assign(g, (0, mt._)`${b}[${p}]`), r.error(), e.assign(l, !1).break();
        }).code((0, mt._)`${b}[${p}] = ${m}`);
      });
    }
    function f(m, g) {
      const p = (0, OP.useFunc)(e, TP.default), y = e.name("outer");
      e.label(y).for((0, mt._)`;${m}--;`, () => e.for((0, mt._)`${g} = ${m}; ${g}--;`, () => e.if((0, mt._)`${p}(${t}[${m}], ${t}[${g}])`, () => {
        r.error(), e.assign(l, !1).break(y);
      })));
    }
  }
};
Uc.default = IP;
var zc = {};
Object.defineProperty(zc, "__esModule", { value: !0 });
const nh = ye, NP = Ae, MP = Sa, DP = {
  message: "must be equal to constant",
  params: ({ schemaCode: r }) => (0, nh._)`{allowedValue: ${r}}`
}, RP = {
  keyword: "const",
  $data: !0,
  error: DP,
  code(r) {
    const { gen: e, data: t, $data: s, schemaCode: n, schema: o } = r;
    s || o && typeof o == "object" ? r.fail$data((0, nh._)`!${(0, NP.useFunc)(e, MP.default)}(${t}, ${n})`) : r.fail((0, nh._)`${o} !== ${t}`);
  }
};
zc.default = RP;
var qc = {};
Object.defineProperty(qc, "__esModule", { value: !0 });
const $i = ye, jP = Ae, LP = Sa, BP = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: r }) => (0, $i._)`{allowedValues: ${r}}`
}, FP = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: BP,
  code(r) {
    const { gen: e, data: t, $data: s, schema: n, schemaCode: o, it: i } = r;
    if (!s && n.length === 0)
      throw new Error("enum must have non-empty array");
    const a = n.length >= i.opts.loopEnum;
    let l;
    const c = () => l ?? (l = (0, jP.useFunc)(e, LP.default));
    let u;
    if (a || s)
      u = e.let("valid"), r.block$data(u, d);
    else {
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      const f = e.const("vSchema", o);
      u = (0, $i.or)(...n.map((m, g) => h(f, g)));
    }
    r.pass(u);
    function d() {
      e.assign(u, !1), e.forOf("v", o, (f) => e.if((0, $i._)`${c()}(${t}, ${f})`, () => e.assign(u, !0).break()));
    }
    function h(f, m) {
      const g = n[m];
      return typeof g == "object" && g !== null ? (0, $i._)`${c()}(${t}, ${f}[${m}])` : (0, $i._)`${t} === ${g}`;
    }
  }
};
qc.default = FP;
Object.defineProperty(Dc, "__esModule", { value: !0 });
const VP = xf, UP = Rc, zP = jc, qP = Lc, HP = Bc, KP = Fc, WP = Vc, GP = Uc, JP = zc, YP = qc, XP = [
  // number
  VP.default,
  UP.default,
  // string
  zP.default,
  qP.default,
  // object
  HP.default,
  KP.default,
  // array
  WP.default,
  GP.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  JP.default,
  YP.default
];
Dc.default = XP;
var $a = {}, Ro = {};
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.validateAdditionalItems = void 0;
const sn = ye, oh = Ae, QP = {
  message: ({ params: { len: r } }) => (0, sn.str)`must NOT have more than ${r} items`,
  params: ({ params: { len: r } }) => (0, sn._)`{limit: ${r}}`
}, ZP = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: QP,
  code(r) {
    const { parentSchema: e, it: t } = r, { items: s } = e;
    if (!Array.isArray(s)) {
      (0, oh.checkStrictMode)(t, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    Lv(r, s);
  }
};
function Lv(r, e) {
  const { gen: t, schema: s, data: n, keyword: o, it: i } = r;
  i.items = !0;
  const a = t.const("len", (0, sn._)`${n}.length`);
  if (s === !1)
    r.setParams({ len: e.length }), r.pass((0, sn._)`${a} <= ${e.length}`);
  else if (typeof s == "object" && !(0, oh.alwaysValidSchema)(i, s)) {
    const c = t.var("valid", (0, sn._)`${a} <= ${e.length}`);
    t.if((0, sn.not)(c), () => l(c)), r.ok(c);
  }
  function l(c) {
    t.forRange("i", e.length, a, (u) => {
      r.subschema({ keyword: o, dataProp: u, dataPropType: oh.Type.Num }, c), i.allErrors || t.if((0, sn.not)(c), () => t.break());
    });
  }
}
Ro.validateAdditionalItems = Lv;
Ro.default = ZP;
var Af = {}, jo = {};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.validateTuple = void 0;
const qg = ye, Nl = Ae, eI = Ce, tI = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(r) {
    const { schema: e, it: t } = r;
    if (Array.isArray(e))
      return Bv(r, "additionalItems", e);
    t.items = !0, !(0, Nl.alwaysValidSchema)(t, e) && r.ok((0, eI.validateArray)(r));
  }
};
function Bv(r, e, t = r.schema) {
  const { gen: s, parentSchema: n, data: o, keyword: i, it: a } = r;
  u(n), a.opts.unevaluated && t.length && a.items !== !0 && (a.items = Nl.mergeEvaluated.items(s, t.length, a.items));
  const l = s.name("valid"), c = s.const("len", (0, qg._)`${o}.length`);
  t.forEach((d, h) => {
    (0, Nl.alwaysValidSchema)(a, d) || (s.if((0, qg._)`${c} > ${h}`, () => r.subschema({
      keyword: i,
      schemaProp: h,
      dataProp: h
    }, l)), r.ok(l));
  });
  function u(d) {
    const { opts: h, errSchemaPath: f } = a, m = t.length, g = m === d.minItems && (m === d.maxItems || d[e] === !1);
    if (h.strictTuples && !g) {
      const p = `"${i}" is ${m}-tuple, but minItems or maxItems/${e} are not specified or different at path "${f}"`;
      (0, Nl.checkStrictMode)(a, p, h.strictTuples);
    }
  }
}
jo.validateTuple = Bv;
jo.default = tI;
Object.defineProperty(Af, "__esModule", { value: !0 });
const rI = jo, sI = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (r) => (0, rI.validateTuple)(r, "items")
};
Af.default = sI;
var Ef = {};
Object.defineProperty(Ef, "__esModule", { value: !0 });
const Hg = ye, nI = Ae, oI = Ce, iI = Ro, aI = {
  message: ({ params: { len: r } }) => (0, Hg.str)`must NOT have more than ${r} items`,
  params: ({ params: { len: r } }) => (0, Hg._)`{limit: ${r}}`
}, lI = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: aI,
  code(r) {
    const { schema: e, parentSchema: t, it: s } = r, { prefixItems: n } = t;
    s.items = !0, !(0, nI.alwaysValidSchema)(s, e) && (n ? (0, iI.validateAdditionalItems)(r, n) : r.ok((0, oI.validateArray)(r)));
  }
};
Ef.default = lI;
var Of = {};
Object.defineProperty(Of, "__esModule", { value: !0 });
const Zt = ye, ll = Ae, cI = {
  message: ({ params: { min: r, max: e } }) => e === void 0 ? (0, Zt.str)`must contain at least ${r} valid item(s)` : (0, Zt.str)`must contain at least ${r} and no more than ${e} valid item(s)`,
  params: ({ params: { min: r, max: e } }) => e === void 0 ? (0, Zt._)`{minContains: ${r}}` : (0, Zt._)`{minContains: ${r}, maxContains: ${e}}`
}, uI = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: cI,
  code(r) {
    const { gen: e, schema: t, parentSchema: s, data: n, it: o } = r;
    let i, a;
    const { minContains: l, maxContains: c } = s;
    o.opts.next ? (i = l === void 0 ? 1 : l, a = c) : i = 1;
    const u = e.const("len", (0, Zt._)`${n}.length`);
    if (r.setParams({ min: i, max: a }), a === void 0 && i === 0) {
      (0, ll.checkStrictMode)(o, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (a !== void 0 && i > a) {
      (0, ll.checkStrictMode)(o, '"minContains" > "maxContains" is always invalid'), r.fail();
      return;
    }
    if ((0, ll.alwaysValidSchema)(o, t)) {
      let g = (0, Zt._)`${u} >= ${i}`;
      a !== void 0 && (g = (0, Zt._)`${g} && ${u} <= ${a}`), r.pass(g);
      return;
    }
    o.items = !0;
    const d = e.name("valid");
    a === void 0 && i === 1 ? f(d, () => e.if(d, () => e.break())) : i === 0 ? (e.let(d, !0), a !== void 0 && e.if((0, Zt._)`${n}.length > 0`, h)) : (e.let(d, !1), h()), r.result(d, () => r.reset());
    function h() {
      const g = e.name("_valid"), p = e.let("count", 0);
      f(g, () => e.if(g, () => m(p)));
    }
    function f(g, p) {
      e.forRange("i", 0, u, (y) => {
        r.subschema({
          keyword: "contains",
          dataProp: y,
          dataPropType: ll.Type.Num,
          compositeRule: !0
        }, g), p();
      });
    }
    function m(g) {
      e.code((0, Zt._)`${g}++`), a === void 0 ? e.if((0, Zt._)`${g} >= ${i}`, () => e.assign(d, !0).break()) : (e.if((0, Zt._)`${g} > ${a}`, () => e.assign(d, !1).break()), i === 1 ? e.assign(d, !0) : e.if((0, Zt._)`${g} >= ${i}`, () => e.assign(d, !0)));
    }
  }
};
Of.default = uI;
var Hc = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.validateSchemaDeps = r.validatePropertyDeps = r.error = void 0;
  const e = ye, t = Ae, s = Ce;
  r.error = {
    message: ({ params: { property: l, depsCount: c, deps: u } }) => {
      const d = c === 1 ? "property" : "properties";
      return (0, e.str)`must have ${d} ${u} when property ${l} is present`;
    },
    params: ({ params: { property: l, depsCount: c, deps: u, missingProperty: d } }) => (0, e._)`{property: ${l},
    missingProperty: ${d},
    depsCount: ${c},
    deps: ${u}}`
    // TODO change to reference
  };
  const n = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: r.error,
    code(l) {
      const [c, u] = o(l);
      i(l, c), a(l, u);
    }
  };
  function o({ schema: l }) {
    const c = {}, u = {};
    for (const d in l) {
      if (d === "__proto__")
        continue;
      const h = Array.isArray(l[d]) ? c : u;
      h[d] = l[d];
    }
    return [c, u];
  }
  function i(l, c = l.schema) {
    const { gen: u, data: d, it: h } = l;
    if (Object.keys(c).length === 0)
      return;
    const f = u.let("missing");
    for (const m in c) {
      const g = c[m];
      if (g.length === 0)
        continue;
      const p = (0, s.propertyInData)(u, d, m, h.opts.ownProperties);
      l.setParams({
        property: m,
        depsCount: g.length,
        deps: g.join(", ")
      }), h.allErrors ? u.if(p, () => {
        for (const y of g)
          (0, s.checkReportMissingProp)(l, y);
      }) : (u.if((0, e._)`${p} && (${(0, s.checkMissingProp)(l, g, f)})`), (0, s.reportMissingProp)(l, f), u.else());
    }
  }
  r.validatePropertyDeps = i;
  function a(l, c = l.schema) {
    const { gen: u, data: d, keyword: h, it: f } = l, m = u.name("valid");
    for (const g in c)
      (0, t.alwaysValidSchema)(f, c[g]) || (u.if(
        (0, s.propertyInData)(u, d, g, f.opts.ownProperties),
        () => {
          const p = l.subschema({ keyword: h, schemaProp: g }, m);
          l.mergeValidEvaluated(p, m);
        },
        () => u.var(m, !0)
        // TODO var
      ), l.ok(m));
  }
  r.validateSchemaDeps = a, r.default = n;
})(Hc);
var Tf = {};
Object.defineProperty(Tf, "__esModule", { value: !0 });
const Fv = ye, dI = Ae, hI = {
  message: "property name must be valid",
  params: ({ params: r }) => (0, Fv._)`{propertyName: ${r.propertyName}}`
}, fI = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: hI,
  code(r) {
    const { gen: e, schema: t, data: s, it: n } = r;
    if ((0, dI.alwaysValidSchema)(n, t))
      return;
    const o = e.name("valid");
    e.forIn("key", s, (i) => {
      r.setParams({ propertyName: i }), r.subschema({
        keyword: "propertyNames",
        data: i,
        dataTypes: ["string"],
        propertyName: i,
        compositeRule: !0
      }, o), e.if((0, Fv.not)(o), () => {
        r.error(!0), n.allErrors || e.break();
      });
    }), r.ok(o);
  }
};
Tf.default = fI;
var Kc = {};
Object.defineProperty(Kc, "__esModule", { value: !0 });
const cl = Ce, lr = ye, pI = Wt, ul = Ae, mI = {
  message: "must NOT have additional properties",
  params: ({ params: r }) => (0, lr._)`{additionalProperty: ${r.additionalProperty}}`
}, gI = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: mI,
  code(r) {
    const { gen: e, schema: t, parentSchema: s, data: n, errsCount: o, it: i } = r;
    if (!o)
      throw new Error("ajv implementation error");
    const { allErrors: a, opts: l } = i;
    if (i.props = !0, l.removeAdditional !== "all" && (0, ul.alwaysValidSchema)(i, t))
      return;
    const c = (0, cl.allSchemaProperties)(s.properties), u = (0, cl.allSchemaProperties)(s.patternProperties);
    d(), r.ok((0, lr._)`${o} === ${pI.default.errors}`);
    function d() {
      e.forIn("key", n, (p) => {
        !c.length && !u.length ? m(p) : e.if(h(p), () => m(p));
      });
    }
    function h(p) {
      let y;
      if (c.length > 8) {
        const b = (0, ul.schemaRefOrVal)(i, s.properties, "properties");
        y = (0, cl.isOwnProperty)(e, b, p);
      } else
        c.length ? y = (0, lr.or)(...c.map((b) => (0, lr._)`${p} === ${b}`)) : y = lr.nil;
      return u.length && (y = (0, lr.or)(y, ...u.map((b) => (0, lr._)`${(0, cl.usePattern)(r, b)}.test(${p})`))), (0, lr.not)(y);
    }
    function f(p) {
      e.code((0, lr._)`delete ${n}[${p}]`);
    }
    function m(p) {
      if (l.removeAdditional === "all" || l.removeAdditional && t === !1) {
        f(p);
        return;
      }
      if (t === !1) {
        r.setParams({ additionalProperty: p }), r.error(), a || e.break();
        return;
      }
      if (typeof t == "object" && !(0, ul.alwaysValidSchema)(i, t)) {
        const y = e.name("valid");
        l.removeAdditional === "failing" ? (g(p, y, !1), e.if((0, lr.not)(y), () => {
          r.reset(), f(p);
        })) : (g(p, y), a || e.if((0, lr.not)(y), () => e.break()));
      }
    }
    function g(p, y, b) {
      const v = {
        keyword: "additionalProperties",
        dataProp: p,
        dataPropType: ul.Type.Str
      };
      b === !1 && Object.assign(v, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), r.subschema(v, y);
    }
  }
};
Kc.default = gI;
var Pf = {};
Object.defineProperty(Pf, "__esModule", { value: !0 });
const yI = rr, Kg = Ce, Bu = Ae, Wg = Kc, bI = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(r) {
    const { gen: e, schema: t, parentSchema: s, data: n, it: o } = r;
    o.opts.removeAdditional === "all" && s.additionalProperties === void 0 && Wg.default.code(new yI.KeywordCxt(o, Wg.default, "additionalProperties"));
    const i = (0, Kg.allSchemaProperties)(t);
    for (const d of i)
      o.definedProperties.add(d);
    o.opts.unevaluated && i.length && o.props !== !0 && (o.props = Bu.mergeEvaluated.props(e, (0, Bu.toHash)(i), o.props));
    const a = i.filter((d) => !(0, Bu.alwaysValidSchema)(o, t[d]));
    if (a.length === 0)
      return;
    const l = e.name("valid");
    for (const d of a)
      c(d) ? u(d) : (e.if((0, Kg.propertyInData)(e, n, d, o.opts.ownProperties)), u(d), o.allErrors || e.else().var(l, !0), e.endIf()), r.it.definedProperties.add(d), r.ok(l);
    function c(d) {
      return o.opts.useDefaults && !o.compositeRule && t[d].default !== void 0;
    }
    function u(d) {
      r.subschema({
        keyword: "properties",
        schemaProp: d,
        dataProp: d
      }, l);
    }
  }
};
Pf.default = bI;
var If = {};
Object.defineProperty(If, "__esModule", { value: !0 });
const Gg = Ce, dl = ye, Jg = Ae, Yg = Ae, vI = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(r) {
    const { gen: e, schema: t, data: s, parentSchema: n, it: o } = r, { opts: i } = o, a = (0, Gg.allSchemaProperties)(t), l = a.filter((g) => (0, Jg.alwaysValidSchema)(o, t[g]));
    if (a.length === 0 || l.length === a.length && (!o.opts.unevaluated || o.props === !0))
      return;
    const c = i.strictSchema && !i.allowMatchingProperties && n.properties, u = e.name("valid");
    o.props !== !0 && !(o.props instanceof dl.Name) && (o.props = (0, Yg.evaluatedPropsToName)(e, o.props));
    const { props: d } = o;
    h();
    function h() {
      for (const g of a)
        c && f(g), o.allErrors ? m(g) : (e.var(u, !0), m(g), e.if(u));
    }
    function f(g) {
      for (const p in c)
        new RegExp(g).test(p) && (0, Jg.checkStrictMode)(o, `property ${p} matches pattern ${g} (use allowMatchingProperties)`);
    }
    function m(g) {
      e.forIn("key", s, (p) => {
        e.if((0, dl._)`${(0, Gg.usePattern)(r, g)}.test(${p})`, () => {
          const y = l.includes(g);
          y || r.subschema({
            keyword: "patternProperties",
            schemaProp: g,
            dataProp: p,
            dataPropType: Yg.Type.Str
          }, u), o.opts.unevaluated && d !== !0 ? e.assign((0, dl._)`${d}[${p}]`, !0) : !y && !o.allErrors && e.if((0, dl.not)(u), () => e.break());
        });
      });
    }
  }
};
If.default = vI;
var Nf = {};
Object.defineProperty(Nf, "__esModule", { value: !0 });
const wI = Ae, kI = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(r) {
    const { gen: e, schema: t, it: s } = r;
    if ((0, wI.alwaysValidSchema)(s, t)) {
      r.fail();
      return;
    }
    const n = e.name("valid");
    r.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, n), r.failResult(n, () => r.reset(), () => r.error());
  },
  error: { message: "must NOT be valid" }
};
Nf.default = kI;
var Mf = {};
Object.defineProperty(Mf, "__esModule", { value: !0 });
const SI = Ce, $I = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: SI.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
Mf.default = $I;
var Df = {};
Object.defineProperty(Df, "__esModule", { value: !0 });
const Ml = ye, _I = Ae, xI = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: r }) => (0, Ml._)`{passingSchemas: ${r.passing}}`
}, CI = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: xI,
  code(r) {
    const { gen: e, schema: t, parentSchema: s, it: n } = r;
    if (!Array.isArray(t))
      throw new Error("ajv implementation error");
    if (n.opts.discriminator && s.discriminator)
      return;
    const o = t, i = e.let("valid", !1), a = e.let("passing", null), l = e.name("_valid");
    r.setParams({ passing: a }), e.block(c), r.result(i, () => r.reset(), () => r.error(!0));
    function c() {
      o.forEach((u, d) => {
        let h;
        (0, _I.alwaysValidSchema)(n, u) ? e.var(l, !0) : h = r.subschema({
          keyword: "oneOf",
          schemaProp: d,
          compositeRule: !0
        }, l), d > 0 && e.if((0, Ml._)`${l} && ${i}`).assign(i, !1).assign(a, (0, Ml._)`[${a}, ${d}]`).else(), e.if(l, () => {
          e.assign(i, !0), e.assign(a, d), h && r.mergeEvaluated(h, Ml.Name);
        });
      });
    }
  }
};
Df.default = CI;
var Rf = {};
Object.defineProperty(Rf, "__esModule", { value: !0 });
const AI = Ae, EI = {
  keyword: "allOf",
  schemaType: "array",
  code(r) {
    const { gen: e, schema: t, it: s } = r;
    if (!Array.isArray(t))
      throw new Error("ajv implementation error");
    const n = e.name("valid");
    t.forEach((o, i) => {
      if ((0, AI.alwaysValidSchema)(s, o))
        return;
      const a = r.subschema({ keyword: "allOf", schemaProp: i }, n);
      r.ok(n), r.mergeEvaluated(a);
    });
  }
};
Rf.default = EI;
var jf = {};
Object.defineProperty(jf, "__esModule", { value: !0 });
const ac = ye, Vv = Ae, OI = {
  message: ({ params: r }) => (0, ac.str)`must match "${r.ifClause}" schema`,
  params: ({ params: r }) => (0, ac._)`{failingKeyword: ${r.ifClause}}`
}, TI = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: OI,
  code(r) {
    const { gen: e, parentSchema: t, it: s } = r;
    t.then === void 0 && t.else === void 0 && (0, Vv.checkStrictMode)(s, '"if" without "then" and "else" is ignored');
    const n = Xg(s, "then"), o = Xg(s, "else");
    if (!n && !o)
      return;
    const i = e.let("valid", !0), a = e.name("_valid");
    if (l(), r.reset(), n && o) {
      const u = e.let("ifClause");
      r.setParams({ ifClause: u }), e.if(a, c("then", u), c("else", u));
    } else
      n ? e.if(a, c("then")) : e.if((0, ac.not)(a), c("else"));
    r.pass(i, () => r.error(!0));
    function l() {
      const u = r.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, a);
      r.mergeEvaluated(u);
    }
    function c(u, d) {
      return () => {
        const h = r.subschema({ keyword: u }, a);
        e.assign(i, a), r.mergeValidEvaluated(h, i), d ? e.assign(d, (0, ac._)`${u}`) : r.setParams({ ifClause: u });
      };
    }
  }
};
function Xg(r, e) {
  const t = r.schema[e];
  return t !== void 0 && !(0, Vv.alwaysValidSchema)(r, t);
}
jf.default = TI;
var Lf = {};
Object.defineProperty(Lf, "__esModule", { value: !0 });
const PI = Ae, II = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: r, parentSchema: e, it: t }) {
    e.if === void 0 && (0, PI.checkStrictMode)(t, `"${r}" without "if" is ignored`);
  }
};
Lf.default = II;
Object.defineProperty($a, "__esModule", { value: !0 });
const NI = Ro, MI = Af, DI = jo, RI = Ef, jI = Of, LI = Hc, BI = Tf, FI = Kc, VI = Pf, UI = If, zI = Nf, qI = Mf, HI = Df, KI = Rf, WI = jf, GI = Lf;
function JI(r = !1) {
  const e = [
    // any
    zI.default,
    qI.default,
    HI.default,
    KI.default,
    WI.default,
    GI.default,
    // object
    BI.default,
    FI.default,
    LI.default,
    VI.default,
    UI.default
  ];
  return r ? e.push(MI.default, RI.default) : e.push(NI.default, DI.default), e.push(jI.default), e;
}
$a.default = JI;
var _a = {}, Bf = {};
Object.defineProperty(Bf, "__esModule", { value: !0 });
const tt = ye, YI = {
  message: ({ schemaCode: r }) => (0, tt.str)`must match format "${r}"`,
  params: ({ schemaCode: r }) => (0, tt._)`{format: ${r}}`
}, XI = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: YI,
  code(r, e) {
    const { gen: t, data: s, $data: n, schema: o, schemaCode: i, it: a } = r, { opts: l, errSchemaPath: c, schemaEnv: u, self: d } = a;
    if (!l.validateFormats)
      return;
    n ? h() : f();
    function h() {
      const m = t.scopeValue("formats", {
        ref: d.formats,
        code: l.code.formats
      }), g = t.const("fDef", (0, tt._)`${m}[${i}]`), p = t.let("fType"), y = t.let("format");
      t.if((0, tt._)`typeof ${g} == "object" && !(${g} instanceof RegExp)`, () => t.assign(p, (0, tt._)`${g}.type || "string"`).assign(y, (0, tt._)`${g}.validate`), () => t.assign(p, (0, tt._)`"string"`).assign(y, g)), r.fail$data((0, tt.or)(b(), v()));
      function b() {
        return l.strictSchema === !1 ? tt.nil : (0, tt._)`${i} && !${y}`;
      }
      function v() {
        const k = u.$async ? (0, tt._)`(${g}.async ? await ${y}(${s}) : ${y}(${s}))` : (0, tt._)`${y}(${s})`, _ = (0, tt._)`(typeof ${y} == "function" ? ${k} : ${y}.test(${s}))`;
        return (0, tt._)`${y} && ${y} !== true && ${p} === ${e} && !${_}`;
      }
    }
    function f() {
      const m = d.formats[o];
      if (!m) {
        b();
        return;
      }
      if (m === !0)
        return;
      const [g, p, y] = v(m);
      g === e && r.pass(k());
      function b() {
        if (l.strictSchema === !1) {
          d.logger.warn(_());
          return;
        }
        throw new Error(_());
        function _() {
          return `unknown format "${o}" ignored in schema at path "${c}"`;
        }
      }
      function v(_) {
        const w = _ instanceof RegExp ? (0, tt.regexpCode)(_) : l.code.formats ? (0, tt._)`${l.code.formats}${(0, tt.getProperty)(o)}` : void 0, x = t.scopeValue("formats", { key: o, ref: _, code: w });
        return typeof _ == "object" && !(_ instanceof RegExp) ? [_.type || "string", _.validate, (0, tt._)`${x}.validate`] : ["string", _, x];
      }
      function k() {
        if (typeof m == "object" && !(m instanceof RegExp) && m.async) {
          if (!u.$async)
            throw new Error("async format in sync schema");
          return (0, tt._)`await ${y}(${s})`;
        }
        return typeof p == "function" ? (0, tt._)`${y}(${s})` : (0, tt._)`${y}.test(${s})`;
      }
    }
  }
};
Bf.default = XI;
Object.defineProperty(_a, "__esModule", { value: !0 });
const QI = Bf, ZI = [QI.default];
_a.default = ZI;
var xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.contentVocabulary = xn.metadataVocabulary = void 0;
xn.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
xn.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty($f, "__esModule", { value: !0 });
const eN = Mc, tN = Dc, rN = $a, sN = _a, Qg = xn, nN = [
  eN.default,
  tN.default,
  (0, rN.default)(),
  sN.default,
  Qg.metadataVocabulary,
  Qg.contentVocabulary
];
$f.default = nN;
var xa = {}, Uv = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.DiscrError = void 0, function(e) {
    e.Tag = "tag", e.Mapping = "mapping";
  }(r.DiscrError || (r.DiscrError = {}));
})(Uv);
Object.defineProperty(xa, "__esModule", { value: !0 });
const Kn = ye, ih = Uv, Zg = Tt, oN = Ae, iN = {
  message: ({ params: { discrError: r, tagName: e } }) => r === ih.DiscrError.Tag ? `tag "${e}" must be string` : `value of tag "${e}" must be in oneOf`,
  params: ({ params: { discrError: r, tag: e, tagName: t } }) => (0, Kn._)`{error: ${r}, tag: ${t}, tagValue: ${e}}`
}, aN = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: iN,
  code(r) {
    const { gen: e, data: t, schema: s, parentSchema: n, it: o } = r, { oneOf: i } = n;
    if (!o.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const a = s.propertyName;
    if (typeof a != "string")
      throw new Error("discriminator: requires propertyName");
    if (s.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!i)
      throw new Error("discriminator: requires oneOf keyword");
    const l = e.let("valid", !1), c = e.const("tag", (0, Kn._)`${t}${(0, Kn.getProperty)(a)}`);
    e.if((0, Kn._)`typeof ${c} == "string"`, () => u(), () => r.error(!1, { discrError: ih.DiscrError.Tag, tag: c, tagName: a })), r.ok(l);
    function u() {
      const f = h();
      e.if(!1);
      for (const m in f)
        e.elseIf((0, Kn._)`${c} === ${m}`), e.assign(l, d(f[m]));
      e.else(), r.error(!1, { discrError: ih.DiscrError.Mapping, tag: c, tagName: a }), e.endIf();
    }
    function d(f) {
      const m = e.name("valid"), g = r.subschema({ keyword: "oneOf", schemaProp: f }, m);
      return r.mergeEvaluated(g, Kn.Name), m;
    }
    function h() {
      var f;
      const m = {}, g = y(n);
      let p = !0;
      for (let k = 0; k < i.length; k++) {
        let _ = i[k];
        _ != null && _.$ref && !(0, oN.schemaHasRulesButRef)(_, o.self.RULES) && (_ = Zg.resolveRef.call(o.self, o.schemaEnv.root, o.baseId, _ == null ? void 0 : _.$ref), _ instanceof Zg.SchemaEnv && (_ = _.schema));
        const w = (f = _ == null ? void 0 : _.properties) === null || f === void 0 ? void 0 : f[a];
        if (typeof w != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a}"`);
        p = p && (g || y(_)), b(w, k);
      }
      if (!p)
        throw new Error(`discriminator: "${a}" must be required`);
      return m;
      function y({ required: k }) {
        return Array.isArray(k) && k.includes(a);
      }
      function b(k, _) {
        if (k.const)
          v(k.const, _);
        else if (k.enum)
          for (const w of k.enum)
            v(w, _);
        else
          throw new Error(`discriminator: "properties/${a}" must have "const" or "enum"`);
      }
      function v(k, _) {
        if (typeof k != "string" || k in m)
          throw new Error(`discriminator: "${a}" values must be unique strings`);
        m[k] = _;
      }
    }
  }
};
xa.default = aN;
const lN = "http://json-schema.org/draft-07/schema#", cN = "http://json-schema.org/draft-07/schema#", uN = "Core schema meta-schema", dN = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, hN = [
  "object",
  "boolean"
], fN = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, pN = {
  $schema: lN,
  $id: cN,
  title: uN,
  definitions: dN,
  type: hN,
  properties: fN,
  default: !0
};
(function(r, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const t = yn, s = $f, n = xa, o = pN, i = ["/properties"], a = "http://json-schema.org/draft-07/schema";
  class l extends t.default {
    _addVocabularies() {
      super._addVocabularies(), s.default.forEach((m) => this.addVocabulary(m)), this.opts.discriminator && this.addKeyword(n.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const m = this.opts.$data ? this.$dataMetaSchema(o, i) : o;
      this.addMetaSchema(m, a, !1), this.refs["http://json-schema.org/schema"] = a;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  r.exports = e = l, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l;
  var c = rr;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var u = ye;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return u._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return u.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return u.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return u.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return u.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return u.CodeGen;
  } });
  var d = Mo;
  Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var h = Do;
  Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
    return h.default;
  } });
})(eh, eh.exports);
var mN = eh.exports;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.formatLimitDefinition = void 0;
  const e = mN, t = ye, s = t.operators, n = {
    formatMaximum: { okStr: "<=", ok: s.LTE, fail: s.GT },
    formatMinimum: { okStr: ">=", ok: s.GTE, fail: s.LT },
    formatExclusiveMaximum: { okStr: "<", ok: s.LT, fail: s.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: s.GT, fail: s.LTE }
  }, o = {
    message: ({ keyword: a, schemaCode: l }) => t.str`should be ${n[a].okStr} ${l}`,
    params: ({ keyword: a, schemaCode: l }) => t._`{comparison: ${n[a].okStr}, limit: ${l}}`
  };
  r.formatLimitDefinition = {
    keyword: Object.keys(n),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: o,
    code(a) {
      const { gen: l, data: c, schemaCode: u, keyword: d, it: h } = a, { opts: f, self: m } = h;
      if (!f.validateFormats)
        return;
      const g = new e.KeywordCxt(h, m.RULES.all.format.definition, "format");
      g.$data ? p() : y();
      function p() {
        const v = l.scopeValue("formats", {
          ref: m.formats,
          code: f.code.formats
        }), k = l.const("fmt", t._`${v}[${g.schemaCode}]`);
        a.fail$data(t.or(t._`typeof ${k} != "object"`, t._`${k} instanceof RegExp`, t._`typeof ${k}.compare != "function"`, b(k)));
      }
      function y() {
        const v = g.schema, k = m.formats[v];
        if (!k || k === !0)
          return;
        if (typeof k != "object" || k instanceof RegExp || typeof k.compare != "function")
          throw new Error(`"${d}": format "${v}" does not define "compare" function`);
        const _ = l.scopeValue("formats", {
          key: v,
          ref: k,
          code: f.code.formats ? t._`${f.code.formats}${t.getProperty(v)}` : void 0
        });
        a.fail$data(b(_));
      }
      function b(v) {
        return t._`${v}.compare(${c}, ${u}) ${n[d].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const i = (a) => (a.addKeyword(r.formatLimitDefinition), a);
  r.default = i;
})(cv);
(function(r, e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const t = lv, s = cv, n = ye, o = new n.Name("fullFormats"), i = new n.Name("fastFormats"), a = (c, u = { keywords: !0 }) => {
    if (Array.isArray(u))
      return l(c, u, t.fullFormats, o), c;
    const [d, h] = u.mode === "fast" ? [t.fastFormats, i] : [t.fullFormats, o], f = u.formats || t.formatNames;
    return l(c, f, d, h), u.keywords && s.default(c), c;
  };
  a.get = (c, u = "full") => {
    const d = (u === "fast" ? t.fastFormats : t.fullFormats)[c];
    if (!d)
      throw new Error(`Unknown format "${c}"`);
    return d;
  };
  function l(c, u, d, h) {
    var f, m;
    (f = (m = c.opts.code).formats) !== null && f !== void 0 || (m.formats = n._`require("ajv-formats/dist/formats").${h}`);
    for (const g of u)
      c.addFormat(g, d[g]);
  }
  r.exports = e = a, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a;
})(Zd, Zd.exports);
var gN = Zd.exports;
const yN = /* @__PURE__ */ mf(gN);
var ah = { exports: {} }, Ff = {}, Vf = {};
Object.defineProperty(Vf, "__esModule", { value: !0 });
const bN = qr, vN = [
  "$schema",
  "id",
  "$defs",
  { keyword: "$comment" },
  "definitions",
  bN.default
];
Vf.default = vN;
var Uf = {}, zf = {};
Object.defineProperty(zf, "__esModule", { value: !0 });
const lh = yn, wN = ye, bs = wN.operators, ch = {
  maximum: {
    exclusive: "exclusiveMaximum",
    ops: [
      { okStr: "<=", ok: bs.LTE, fail: bs.GT },
      { okStr: "<", ok: bs.LT, fail: bs.GTE }
    ]
  },
  minimum: {
    exclusive: "exclusiveMinimum",
    ops: [
      { okStr: ">=", ok: bs.GTE, fail: bs.LT },
      { okStr: ">", ok: bs.GT, fail: bs.LTE }
    ]
  }
}, kN = {
  message: (r) => lh.str`must be ${uh(r).okStr} ${r.schemaCode}`,
  params: (r) => lh._`{comparison: ${uh(r).okStr}, limit: ${r.schemaCode}}`
}, SN = {
  keyword: Object.keys(ch),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: kN,
  code(r) {
    const { data: e, schemaCode: t } = r;
    r.fail$data(lh._`${e} ${uh(r).fail} ${t} || isNaN(${e})`);
  }
};
function uh(r) {
  var e;
  const t = r.keyword, s = !((e = r.parentSchema) === null || e === void 0) && e[ch[t].exclusive] ? 1 : 0;
  return ch[t].ops[s];
}
zf.default = SN;
var qf = {};
Object.defineProperty(qf, "__esModule", { value: !0 });
const e0 = {
  exclusiveMaximum: "maximum",
  exclusiveMinimum: "minimum"
}, $N = {
  keyword: Object.keys(e0),
  type: "number",
  schemaType: "boolean",
  code({ keyword: r, parentSchema: e }) {
    const t = e0[r];
    if (e[t] === void 0)
      throw new Error(`${r} can only be used with ${t}`);
  }
};
qf.default = $N;
Object.defineProperty(Uf, "__esModule", { value: !0 });
const _N = zf, xN = qf, CN = Rc, AN = jc, EN = Lc, ON = Bc, TN = Fc, PN = Vc, IN = Uc, NN = zc, MN = qc, DN = [
  // number
  _N.default,
  xN.default,
  CN.default,
  // string
  AN.default,
  EN.default,
  // object
  ON.default,
  TN.default,
  // array
  PN.default,
  IN.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  NN.default,
  MN.default
];
Uf.default = DN;
Object.defineProperty(Ff, "__esModule", { value: !0 });
const RN = Vf, jN = Uf, LN = $a, BN = _a, FN = ["title", "description", "default"], VN = [
  RN.default,
  jN.default,
  LN.default(),
  BN.default,
  FN
];
Ff.default = VN;
const UN = "http://json-schema.org/draft-04/schema#", zN = "http://json-schema.org/draft-04/schema#", qN = "Core schema meta-schema", HN = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: !0
  }
}, KN = "object", WN = {
  id: {
    type: "string",
    format: "uri"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: !0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: !1
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: !1
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, GN = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, JN = {
  id: UN,
  $schema: zN,
  description: qN,
  definitions: HN,
  type: KN,
  properties: WN,
  dependencies: GN,
  default: {}
};
(function(r, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const t = yn, s = Ff, n = xa, o = JN, i = ["/properties"], a = "http://json-schema.org/draft-04/schema";
  class l extends t.default {
    constructor(h = {}) {
      super({
        ...h,
        schemaId: "id"
      });
    }
    _addVocabularies() {
      super._addVocabularies(), s.default.forEach((h) => this.addVocabulary(h)), this.opts.discriminator && this.addKeyword(n.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const h = this.opts.$data ? this.$dataMetaSchema(o, i) : o;
      this.addMetaSchema(h, a, !1), this.refs["http://json-schema.org/schema"] = a;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  r.exports = e = l, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l;
  var c = yn;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var u = yn;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return u._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return u.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return u.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return u.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return u.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return u.CodeGen;
  } });
})(ah, ah.exports);
var YN = ah.exports;
const XN = /* @__PURE__ */ mf(YN);
var dh = { exports: {} }, Hf = {}, Kf = {}, Lo = {};
Object.defineProperty(Lo, "__esModule", { value: !0 });
Lo.dynamicAnchor = void 0;
const Fu = ye, QN = Wt, t0 = Tt, ZN = qr, eM = {
  keyword: "$dynamicAnchor",
  schemaType: "string",
  code: (r) => zv(r, r.schema)
};
function zv(r, e) {
  const { gen: t, it: s } = r;
  s.schemaEnv.root.dynamicAnchors[e] = !0;
  const n = (0, Fu._)`${QN.default.dynamicAnchors}${(0, Fu.getProperty)(e)}`, o = s.errSchemaPath === "#" ? s.validateName : tM(r);
  t.if((0, Fu._)`!${n}`, () => t.assign(n, o));
}
Lo.dynamicAnchor = zv;
function tM(r) {
  const { schemaEnv: e, schema: t, self: s } = r.it, { root: n, baseId: o, localRefs: i, meta: a } = e.root, { schemaId: l } = s.opts, c = new t0.SchemaEnv({ schema: t, schemaId: l, root: n, baseId: o, localRefs: i, meta: a });
  return t0.compileSchema.call(s, c), (0, ZN.getValidate)(r, c);
}
Lo.default = eM;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.dynamicRef = void 0;
const r0 = ye, rM = Wt, s0 = qr, sM = {
  keyword: "$dynamicRef",
  schemaType: "string",
  code: (r) => qv(r, r.schema)
};
function qv(r, e) {
  const { gen: t, keyword: s, it: n } = r;
  if (e[0] !== "#")
    throw new Error(`"${s}" only supports hash fragment reference`);
  const o = e.slice(1);
  if (n.allErrors)
    i();
  else {
    const l = t.let("valid", !1);
    i(l), r.ok(l);
  }
  function i(l) {
    if (n.schemaEnv.root.dynamicAnchors[o]) {
      const c = t.let("_v", (0, r0._)`${rM.default.dynamicAnchors}${(0, r0.getProperty)(o)}`);
      t.if(c, a(c, l), a(n.validateName, l));
    } else
      a(n.validateName, l)();
  }
  function a(l, c) {
    return c ? () => t.block(() => {
      (0, s0.callRef)(r, l), t.let(c, !0);
    }) : () => (0, s0.callRef)(r, l);
  }
}
Bo.dynamicRef = qv;
Bo.default = sM;
var Wf = {};
Object.defineProperty(Wf, "__esModule", { value: !0 });
const nM = Lo, oM = Ae, iM = {
  keyword: "$recursiveAnchor",
  schemaType: "boolean",
  code(r) {
    r.schema ? (0, nM.dynamicAnchor)(r, "") : (0, oM.checkStrictMode)(r.it, "$recursiveAnchor: false is ignored");
  }
};
Wf.default = iM;
var Gf = {};
Object.defineProperty(Gf, "__esModule", { value: !0 });
const aM = Bo, lM = {
  keyword: "$recursiveRef",
  schemaType: "string",
  code: (r) => (0, aM.dynamicRef)(r, r.schema)
};
Gf.default = lM;
Object.defineProperty(Kf, "__esModule", { value: !0 });
const cM = Lo, uM = Bo, dM = Wf, hM = Gf, fM = [cM.default, uM.default, dM.default, hM.default];
Kf.default = fM;
var Jf = {}, Yf = {};
Object.defineProperty(Yf, "__esModule", { value: !0 });
const n0 = Hc, pM = {
  keyword: "dependentRequired",
  type: "object",
  schemaType: "object",
  error: n0.error,
  code: (r) => (0, n0.validatePropertyDeps)(r)
};
Yf.default = pM;
var Xf = {};
Object.defineProperty(Xf, "__esModule", { value: !0 });
const mM = Hc, gM = {
  keyword: "dependentSchemas",
  type: "object",
  schemaType: "object",
  code: (r) => (0, mM.validateSchemaDeps)(r)
};
Xf.default = gM;
var Qf = {};
Object.defineProperty(Qf, "__esModule", { value: !0 });
const yM = Ae, bM = {
  keyword: ["maxContains", "minContains"],
  type: "array",
  schemaType: "number",
  code({ keyword: r, parentSchema: e, it: t }) {
    e.contains === void 0 && (0, yM.checkStrictMode)(t, `"${r}" without "contains" is ignored`);
  }
};
Qf.default = bM;
Object.defineProperty(Jf, "__esModule", { value: !0 });
const vM = Yf, wM = Xf, kM = Qf, SM = [vM.default, wM.default, kM.default];
Jf.default = SM;
var Zf = {}, ep = {};
Object.defineProperty(ep, "__esModule", { value: !0 });
const ks = ye, o0 = Ae, $M = Wt, _M = {
  message: "must NOT have unevaluated properties",
  params: ({ params: r }) => (0, ks._)`{unevaluatedProperty: ${r.unevaluatedProperty}}`
}, xM = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: !0,
  error: _M,
  code(r) {
    const { gen: e, schema: t, data: s, errsCount: n, it: o } = r;
    if (!n)
      throw new Error("ajv implementation error");
    const { allErrors: i, props: a } = o;
    a instanceof ks.Name ? e.if((0, ks._)`${a} !== true`, () => e.forIn("key", s, (d) => e.if(c(a, d), () => l(d)))) : a !== !0 && e.forIn("key", s, (d) => a === void 0 ? l(d) : e.if(u(a, d), () => l(d))), o.props = !0, r.ok((0, ks._)`${n} === ${$M.default.errors}`);
    function l(d) {
      if (t === !1) {
        r.setParams({ unevaluatedProperty: d }), r.error(), i || e.break();
        return;
      }
      if (!(0, o0.alwaysValidSchema)(o, t)) {
        const h = e.name("valid");
        r.subschema({
          keyword: "unevaluatedProperties",
          dataProp: d,
          dataPropType: o0.Type.Str
        }, h), i || e.if((0, ks.not)(h), () => e.break());
      }
    }
    function c(d, h) {
      return (0, ks._)`!${d} || !${d}[${h}]`;
    }
    function u(d, h) {
      const f = [];
      for (const m in d)
        d[m] === !0 && f.push((0, ks._)`${h} !== ${m}`);
      return (0, ks.and)(...f);
    }
  }
};
ep.default = xM;
var tp = {};
Object.defineProperty(tp, "__esModule", { value: !0 });
const nn = ye, i0 = Ae, CM = {
  message: ({ params: { len: r } }) => (0, nn.str)`must NOT have more than ${r} items`,
  params: ({ params: { len: r } }) => (0, nn._)`{limit: ${r}}`
}, AM = {
  keyword: "unevaluatedItems",
  type: "array",
  schemaType: ["boolean", "object"],
  error: CM,
  code(r) {
    const { gen: e, schema: t, data: s, it: n } = r, o = n.items || 0;
    if (o === !0)
      return;
    const i = e.const("len", (0, nn._)`${s}.length`);
    if (t === !1)
      r.setParams({ len: o }), r.fail((0, nn._)`${i} > ${o}`);
    else if (typeof t == "object" && !(0, i0.alwaysValidSchema)(n, t)) {
      const l = e.var("valid", (0, nn._)`${i} <= ${o}`);
      e.if((0, nn.not)(l), () => a(l, o)), r.ok(l);
    }
    n.items = !0;
    function a(l, c) {
      e.forRange("i", c, i, (u) => {
        r.subschema({ keyword: "unevaluatedItems", dataProp: u, dataPropType: i0.Type.Num }, l), n.allErrors || e.if((0, nn.not)(l), () => e.break());
      });
    }
  }
};
tp.default = AM;
Object.defineProperty(Zf, "__esModule", { value: !0 });
const EM = ep, OM = tp, TM = [EM.default, OM.default];
Zf.default = TM;
Object.defineProperty(Hf, "__esModule", { value: !0 });
const PM = Mc, IM = Dc, NM = $a, MM = Kf, DM = Jf, RM = Zf, jM = _a, a0 = xn, LM = [
  MM.default,
  PM.default,
  IM.default,
  (0, NM.default)(!0),
  jM.default,
  a0.metadataVocabulary,
  a0.contentVocabulary,
  DM.default,
  RM.default
];
Hf.default = LM;
var rp = {};
const BM = "https://json-schema.org/draft/2020-12/schema", FM = "https://json-schema.org/draft/2020-12/schema", VM = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, UM = "meta", zM = "Core and Validation specifications meta-schema", qM = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], HM = [
  "object",
  "boolean"
], KM = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", WM = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: !0,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: !0,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: !0
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: !0
  }
}, GM = {
  $schema: BM,
  $id: FM,
  $vocabulary: VM,
  $dynamicAnchor: UM,
  title: zM,
  allOf: qM,
  type: HM,
  $comment: KM,
  properties: WM
}, JM = "https://json-schema.org/draft/2020-12/schema", YM = "https://json-schema.org/draft/2020-12/meta/applicator", XM = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0
}, QM = "meta", ZM = "Applicator vocabulary meta-schema", e5 = [
  "object",
  "boolean"
], t5 = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, r5 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, s5 = {
  $schema: JM,
  $id: YM,
  $vocabulary: XM,
  $dynamicAnchor: QM,
  title: ZM,
  type: e5,
  properties: t5,
  $defs: r5
}, n5 = "https://json-schema.org/draft/2020-12/schema", o5 = "https://json-schema.org/draft/2020-12/meta/unevaluated", i5 = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, a5 = "meta", l5 = "Unevaluated applicator vocabulary meta-schema", c5 = [
  "object",
  "boolean"
], u5 = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, d5 = {
  $schema: n5,
  $id: o5,
  $vocabulary: i5,
  $dynamicAnchor: a5,
  title: l5,
  type: c5,
  properties: u5
}, h5 = "https://json-schema.org/draft/2020-12/schema", f5 = "https://json-schema.org/draft/2020-12/meta/content", p5 = {
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, m5 = "meta", g5 = "Content vocabulary meta-schema", y5 = [
  "object",
  "boolean"
], b5 = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, v5 = {
  $schema: h5,
  $id: f5,
  $vocabulary: p5,
  $dynamicAnchor: m5,
  title: g5,
  type: y5,
  properties: b5
}, w5 = "https://json-schema.org/draft/2020-12/schema", k5 = "https://json-schema.org/draft/2020-12/meta/core", S5 = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0
}, $5 = "meta", _5 = "Core vocabulary meta-schema", x5 = [
  "object",
  "boolean"
], C5 = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, A5 = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, E5 = {
  $schema: w5,
  $id: k5,
  $vocabulary: S5,
  $dynamicAnchor: $5,
  title: _5,
  type: x5,
  properties: C5,
  $defs: A5
}, O5 = "https://json-schema.org/draft/2020-12/schema", T5 = "https://json-schema.org/draft/2020-12/meta/format-annotation", P5 = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0
}, I5 = "meta", N5 = "Format vocabulary meta-schema for annotation results", M5 = [
  "object",
  "boolean"
], D5 = {
  format: {
    type: "string"
  }
}, R5 = {
  $schema: O5,
  $id: T5,
  $vocabulary: P5,
  $dynamicAnchor: I5,
  title: N5,
  type: M5,
  properties: D5
}, j5 = "https://json-schema.org/draft/2020-12/schema", L5 = "https://json-schema.org/draft/2020-12/meta/meta-data", B5 = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0
}, F5 = "meta", V5 = "Meta-data vocabulary meta-schema", U5 = [
  "object",
  "boolean"
], z5 = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  deprecated: {
    type: "boolean",
    default: !1
  },
  readOnly: {
    type: "boolean",
    default: !1
  },
  writeOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  }
}, q5 = {
  $schema: j5,
  $id: L5,
  $vocabulary: B5,
  $dynamicAnchor: F5,
  title: V5,
  type: U5,
  properties: z5
}, H5 = "https://json-schema.org/draft/2020-12/schema", K5 = "https://json-schema.org/draft/2020-12/meta/validation", W5 = {
  "https://json-schema.org/draft/2020-12/vocab/validation": !0
}, G5 = "meta", J5 = "Validation vocabulary meta-schema", Y5 = [
  "object",
  "boolean"
], X5 = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  const: !0,
  enum: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, Q5 = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, Z5 = {
  $schema: H5,
  $id: K5,
  $vocabulary: W5,
  $dynamicAnchor: G5,
  title: J5,
  type: Y5,
  properties: X5,
  $defs: Q5
};
Object.defineProperty(rp, "__esModule", { value: !0 });
const eD = GM, tD = s5, rD = d5, sD = v5, nD = E5, oD = R5, iD = q5, aD = Z5, lD = ["/properties"];
function cD(r) {
  return [
    eD,
    tD,
    rD,
    sD,
    nD,
    e(this, oD),
    iD,
    e(this, aD)
  ].forEach((t) => this.addMetaSchema(t, void 0, !1)), this;
  function e(t, s) {
    return r ? t.$dataMetaSchema(s, lD) : s;
  }
}
rp.default = cD;
(function(r, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const t = yn, s = Hf, n = xa, o = rp, i = "https://json-schema.org/draft/2020-12/schema";
  class a extends t.default {
    constructor(f = {}) {
      super({
        ...f,
        dynamicRef: !0,
        next: !0,
        unevaluated: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), s.default.forEach((f) => this.addVocabulary(f)), this.opts.discriminator && this.addKeyword(n.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      const { $data: f, meta: m } = this.opts;
      m && (o.default.call(this, f), this.refs["http://json-schema.org/schema"] = i);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(i) ? i : void 0);
    }
  }
  r.exports = e = a, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a;
  var l = rr;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return l.KeywordCxt;
  } });
  var c = ye;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return c._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return c.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return c.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return c.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return c.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return c.CodeGen;
  } });
  var u = Mo;
  Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
    return u.default;
  } });
  var d = Do;
  Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
    return d.default;
  } });
})(dh, dh.exports);
var uD = dh.exports;
const dD = /* @__PURE__ */ mf(uD), Hv = ["2.0", "3.0", "3.1"], hD = {
  "http://json-schema.org/draft-04/schema#": XN,
  "https://json-schema.org/draft/2020-12/schema": dD
}, hh = {
  EMPTY_OR_INVALID: "Cannot find JSON, YAML or filename in data",
  // URI_MUST_BE_STRING: 'uri parameter or $id attribute must be a string',
  OPENAPI_VERSION_NOT_SUPPORTED: "Cannot find supported Swagger/OpenAPI version in specification, version must be a string.",
  INVALID_REFERENCE: "Can’t resolve URI: %s",
  EXTERNAL_REFERENCE_NOT_SUPPORTED: "External references are not supported yet: %s"
}, fD = "x-inlined-refs";
function Mr(r, e) {
  const t = {};
  for (const [s, n] of Object.entries(r))
    Array.isArray(n) ? t[s] = n.map((o) => typeof o == "object" && o !== null ? Mr(o, e) : o) : typeof n == "object" && n !== null ? t[s] = Mr(n, e) : t[s] = n;
  return e(t);
}
function pD(r, e) {
  return Mr(r, (t) => e(t) ? t : void 0);
}
function Kv(r) {
  return typeof r !== void 0 && Array.isArray(r) && r.length > 0 && r.some((e) => e.isEntrypoint === !0);
}
function mD(r) {
  const e = [];
  return !r || typeof r != "object" || Mr(r, (t) => (t.$ref && typeof t.$ref == "string" && !t.$ref.startsWith("#") && e.push(t.$ref.split("#")[0]), t)), e;
}
const sp = Symbol.for("yaml.alias"), fh = Symbol.for("yaml.document"), Ds = Symbol.for("yaml.map"), Wv = Symbol.for("yaml.pair"), ds = Symbol.for("yaml.scalar"), Fo = Symbol.for("yaml.seq"), or = Symbol.for("yaml.node.type"), Pn = (r) => !!r && typeof r == "object" && r[or] === sp, Vo = (r) => !!r && typeof r == "object" && r[or] === fh, Uo = (r) => !!r && typeof r == "object" && r[or] === Ds, Ye = (r) => !!r && typeof r == "object" && r[or] === Wv, ze = (r) => !!r && typeof r == "object" && r[or] === ds, zo = (r) => !!r && typeof r == "object" && r[or] === Fo;
function Qe(r) {
  if (r && typeof r == "object")
    switch (r[or]) {
      case Ds:
      case Fo:
        return !0;
    }
  return !1;
}
function st(r) {
  if (r && typeof r == "object")
    switch (r[or]) {
      case sp:
      case Ds:
      case ds:
      case Fo:
        return !0;
    }
  return !1;
}
const gD = (r) => (ze(r) || Qe(r)) && !!r.anchor, Rt = Symbol("break visit"), Gv = Symbol("skip children"), Ur = Symbol("remove node");
function Vs(r, e) {
  const t = Jv(e);
  Vo(r) ? Qn(null, r.contents, t, Object.freeze([r])) === Ur && (r.contents = null) : Qn(null, r, t, Object.freeze([]));
}
Vs.BREAK = Rt;
Vs.SKIP = Gv;
Vs.REMOVE = Ur;
function Qn(r, e, t, s) {
  const n = Yv(r, e, t, s);
  if (st(n) || Ye(n))
    return Xv(r, s, n), Qn(r, n, t, s);
  if (typeof n != "symbol") {
    if (Qe(e)) {
      s = Object.freeze(s.concat(e));
      for (let o = 0; o < e.items.length; ++o) {
        const i = Qn(o, e.items[o], t, s);
        if (typeof i == "number")
          o = i - 1;
        else {
          if (i === Rt)
            return Rt;
          i === Ur && (e.items.splice(o, 1), o -= 1);
        }
      }
    } else if (Ye(e)) {
      s = Object.freeze(s.concat(e));
      const o = Qn("key", e.key, t, s);
      if (o === Rt)
        return Rt;
      o === Ur && (e.key = null);
      const i = Qn("value", e.value, t, s);
      if (i === Rt)
        return Rt;
      i === Ur && (e.value = null);
    }
  }
  return n;
}
async function Wc(r, e) {
  const t = Jv(e);
  Vo(r) ? await Zn(null, r.contents, t, Object.freeze([r])) === Ur && (r.contents = null) : await Zn(null, r, t, Object.freeze([]));
}
Wc.BREAK = Rt;
Wc.SKIP = Gv;
Wc.REMOVE = Ur;
async function Zn(r, e, t, s) {
  const n = await Yv(r, e, t, s);
  if (st(n) || Ye(n))
    return Xv(r, s, n), Zn(r, n, t, s);
  if (typeof n != "symbol") {
    if (Qe(e)) {
      s = Object.freeze(s.concat(e));
      for (let o = 0; o < e.items.length; ++o) {
        const i = await Zn(o, e.items[o], t, s);
        if (typeof i == "number")
          o = i - 1;
        else {
          if (i === Rt)
            return Rt;
          i === Ur && (e.items.splice(o, 1), o -= 1);
        }
      }
    } else if (Ye(e)) {
      s = Object.freeze(s.concat(e));
      const o = await Zn("key", e.key, t, s);
      if (o === Rt)
        return Rt;
      o === Ur && (e.key = null);
      const i = await Zn("value", e.value, t, s);
      if (i === Rt)
        return Rt;
      i === Ur && (e.value = null);
    }
  }
  return n;
}
function Jv(r) {
  return typeof r == "object" && (r.Collection || r.Node || r.Value) ? Object.assign({
    Alias: r.Node,
    Map: r.Node,
    Scalar: r.Node,
    Seq: r.Node
  }, r.Value && {
    Map: r.Value,
    Scalar: r.Value,
    Seq: r.Value
  }, r.Collection && {
    Map: r.Collection,
    Seq: r.Collection
  }, r) : r;
}
function Yv(r, e, t, s) {
  var n, o, i, a, l;
  if (typeof t == "function")
    return t(r, e, s);
  if (Uo(e))
    return (n = t.Map) == null ? void 0 : n.call(t, r, e, s);
  if (zo(e))
    return (o = t.Seq) == null ? void 0 : o.call(t, r, e, s);
  if (Ye(e))
    return (i = t.Pair) == null ? void 0 : i.call(t, r, e, s);
  if (ze(e))
    return (a = t.Scalar) == null ? void 0 : a.call(t, r, e, s);
  if (Pn(e))
    return (l = t.Alias) == null ? void 0 : l.call(t, r, e, s);
}
function Xv(r, e, t) {
  const s = e[e.length - 1];
  if (Qe(s))
    s.items[r] = t;
  else if (Ye(s))
    r === "key" ? s.key = t : s.value = t;
  else if (Vo(s))
    s.contents = t;
  else {
    const n = Pn(s) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${n} parent`);
  }
}
const yD = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, bD = (r) => r.replace(/[!,[\]{}]/g, (e) => yD[e]);
class Ot {
  constructor(e, t) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Ot.defaultYaml, e), this.tags = Object.assign({}, Ot.defaultTags, t);
  }
  clone() {
    const e = new Ot(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new Ot(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Ot.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Ot.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, t) {
    this.atNextDocument && (this.yaml = { explicit: Ot.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Ot.defaultTags), this.atNextDocument = !1);
    const s = e.trim().split(/[ \t]+/), n = s.shift();
    switch (n) {
      case "%TAG": {
        if (s.length !== 2 && (t(0, "%TAG directive should contain exactly two parts"), s.length < 2))
          return !1;
        const [o, i] = s;
        return this.tags[o] = i, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, s.length !== 1)
          return t(0, "%YAML directive should contain exactly one part"), !1;
        const [o] = s;
        if (o === "1.1" || o === "1.2")
          return this.yaml.version = o, !0;
        {
          const i = /^\d+\.\d+$/.test(o);
          return t(6, `Unsupported YAML version ${o}`, i), !1;
        }
      }
      default:
        return t(0, `Unknown directive ${n}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, t) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return t(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const i = e.slice(2, -1);
      return i === "!" || i === "!!" ? (t(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && t("Verbatim tags must end with a >"), i);
    }
    const [, s, n] = e.match(/^(.*!)([^!]*)$/s);
    n || t(`The ${e} tag has no suffix`);
    const o = this.tags[s];
    if (o)
      try {
        return o + decodeURIComponent(n);
      } catch (i) {
        return t(String(i)), null;
      }
    return s === "!" ? e : (t(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [t, s] of Object.entries(this.tags))
      if (e.startsWith(s))
        return t + bD(e.substring(s.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const t = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], s = Object.entries(this.tags);
    let n;
    if (e && s.length > 0 && st(e.contents)) {
      const o = {};
      Vs(e.contents, (i, a) => {
        st(a) && a.tag && (o[a.tag] = !0);
      }), n = Object.keys(o);
    } else
      n = [];
    for (const [o, i] of s)
      o === "!!" && i === "tag:yaml.org,2002:" || (!e || n.some((a) => a.startsWith(i))) && t.push(`%TAG ${o} ${i}`);
    return t.join(`
`);
  }
}
Ot.defaultYaml = { explicit: !1, version: "1.2" };
Ot.defaultTags = { "!!": "tag:yaml.org,2002:" };
function Qv(r) {
  if (/[\x00-\x19\s,[\]{}]/.test(r)) {
    const e = `Anchor must not contain whitespace or control characters: ${JSON.stringify(r)}`;
    throw new Error(e);
  }
  return !0;
}
function Zv(r) {
  const e = /* @__PURE__ */ new Set();
  return Vs(r, {
    Value(t, s) {
      s.anchor && e.add(s.anchor);
    }
  }), e;
}
function e1(r, e) {
  for (let t = 1; ; ++t) {
    const s = `${r}${t}`;
    if (!e.has(s))
      return s;
  }
}
function vD(r, e) {
  const t = [], s = /* @__PURE__ */ new Map();
  let n = null;
  return {
    onAnchor: (o) => {
      t.push(o), n || (n = Zv(r));
      const i = e1(e, n);
      return n.add(i), i;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const o of t) {
        const i = s.get(o);
        if (typeof i == "object" && i.anchor && (ze(i.node) || Qe(i.node)))
          i.node.anchor = i.anchor;
        else {
          const a = new Error("Failed to resolve repeated object (this should not happen)");
          throw a.source = o, a;
        }
      }
    },
    sourceObjects: s
  };
}
function eo(r, e, t, s) {
  if (s && typeof s == "object")
    if (Array.isArray(s))
      for (let n = 0, o = s.length; n < o; ++n) {
        const i = s[n], a = eo(r, s, String(n), i);
        a === void 0 ? delete s[n] : a !== i && (s[n] = a);
      }
    else if (s instanceof Map)
      for (const n of Array.from(s.keys())) {
        const o = s.get(n), i = eo(r, s, n, o);
        i === void 0 ? s.delete(n) : i !== o && s.set(n, i);
      }
    else if (s instanceof Set)
      for (const n of Array.from(s)) {
        const o = eo(r, s, n, n);
        o === void 0 ? s.delete(n) : o !== n && (s.delete(n), s.add(o));
      }
    else
      for (const [n, o] of Object.entries(s)) {
        const i = eo(r, s, n, o);
        i === void 0 ? delete s[n] : i !== o && (s[n] = i);
      }
  return r.call(e, t, s);
}
function sr(r, e, t) {
  if (Array.isArray(r))
    return r.map((s, n) => sr(s, String(n), t));
  if (r && typeof r.toJSON == "function") {
    if (!t || !gD(r))
      return r.toJSON(e, t);
    const s = { aliasCount: 0, count: 1, res: void 0 };
    t.anchors.set(r, s), t.onCreate = (o) => {
      s.res = o, delete t.onCreate;
    };
    const n = r.toJSON(e, t);
    return t.onCreate && t.onCreate(n), n;
  }
  return typeof r == "bigint" && !(t != null && t.keep) ? Number(r) : r;
}
class np {
  constructor(e) {
    Object.defineProperty(this, or, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: t, maxAliasCount: s, onAnchor: n, reviver: o } = {}) {
    if (!Vo(e))
      throw new TypeError("A document argument is required");
    const i = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: !0,
      mapAsMap: t === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof s == "number" ? s : 100
    }, a = sr(this, "", i);
    if (typeof n == "function")
      for (const { count: l, res: c } of i.anchors.values())
        n(c, l);
    return typeof o == "function" ? eo(o, { "": a }, "", a) : a;
  }
}
class Gc extends np {
  constructor(e) {
    super(sp), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e) {
    let t;
    return Vs(e, {
      Node: (s, n) => {
        if (n === this)
          return Vs.BREAK;
        n.anchor === this.source && (t = n);
      }
    }), t;
  }
  toJSON(e, t) {
    if (!t)
      return { source: this.source };
    const { anchors: s, doc: n, maxAliasCount: o } = t, i = this.resolve(n);
    if (!i) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let a = s.get(i);
    if (a || (sr(i, null, t), a = s.get(i)), !a || a.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (o >= 0 && (a.count += 1, a.aliasCount === 0 && (a.aliasCount = Dl(n, i, s)), a.count * a.aliasCount > o)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return a.res;
  }
  toString(e, t, s) {
    const n = `*${this.source}`;
    if (e) {
      if (Qv(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const o = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(o);
      }
      if (e.implicitKey)
        return `${n} `;
    }
    return n;
  }
}
function Dl(r, e, t) {
  if (Pn(e)) {
    const s = e.resolve(r), n = t && s && t.get(s);
    return n ? n.count * n.aliasCount : 0;
  } else if (Qe(e)) {
    let s = 0;
    for (const n of e.items) {
      const o = Dl(r, n, t);
      o > s && (s = o);
    }
    return s;
  } else if (Ye(e)) {
    const s = Dl(r, e.key, t), n = Dl(r, e.value, t);
    return Math.max(s, n);
  }
  return 1;
}
const t1 = (r) => !r || typeof r != "function" && typeof r != "object";
class $e extends np {
  constructor(e) {
    super(ds), this.value = e;
  }
  toJSON(e, t) {
    return t != null && t.keep ? this.value : sr(this.value, e, t);
  }
  toString() {
    return String(this.value);
  }
}
$e.BLOCK_FOLDED = "BLOCK_FOLDED";
$e.BLOCK_LITERAL = "BLOCK_LITERAL";
$e.PLAIN = "PLAIN";
$e.QUOTE_DOUBLE = "QUOTE_DOUBLE";
$e.QUOTE_SINGLE = "QUOTE_SINGLE";
const wD = "tag:yaml.org,2002:";
function kD(r, e, t) {
  if (e) {
    const s = t.filter((o) => o.tag === e), n = s.find((o) => !o.format) ?? s[0];
    if (!n)
      throw new Error(`Tag ${e} not found`);
    return n;
  }
  return t.find((s) => {
    var n;
    return ((n = s.identify) == null ? void 0 : n.call(s, r)) && !s.format;
  });
}
function ra(r, e, t) {
  var s, n, o;
  if (Vo(r) && (r = r.contents), st(r))
    return r;
  if (Ye(r)) {
    const m = (n = (s = t.schema[Ds]).createNode) == null ? void 0 : n.call(s, t.schema, null, t);
    return m.items.push(r), m;
  }
  (r instanceof String || r instanceof Number || r instanceof Boolean || typeof BigInt < "u" && r instanceof BigInt) && (r = r.valueOf());
  const { aliasDuplicateObjects: i, onAnchor: a, onTagObj: l, schema: c, sourceObjects: u } = t;
  let d;
  if (i && r && typeof r == "object") {
    if (d = u.get(r), d)
      return d.anchor || (d.anchor = a(r)), new Gc(d.anchor);
    d = { anchor: null, node: null }, u.set(r, d);
  }
  e != null && e.startsWith("!!") && (e = wD + e.slice(2));
  let h = kD(r, e, c.tags);
  if (!h) {
    if (r && typeof r.toJSON == "function" && (r = r.toJSON()), !r || typeof r != "object") {
      const m = new $e(r);
      return d && (d.node = m), m;
    }
    h = r instanceof Map ? c[Ds] : Symbol.iterator in Object(r) ? c[Fo] : c[Ds];
  }
  l && (l(h), delete t.onTagObj);
  const f = h != null && h.createNode ? h.createNode(t.schema, r, t) : typeof ((o = h == null ? void 0 : h.nodeClass) == null ? void 0 : o.from) == "function" ? h.nodeClass.from(t.schema, r, t) : new $e(r);
  return e ? f.tag = e : h.default || (f.tag = h.tag), d && (d.node = f), f;
}
function lc(r, e, t) {
  let s = t;
  for (let n = e.length - 1; n >= 0; --n) {
    const o = e[n];
    if (typeof o == "number" && Number.isInteger(o) && o >= 0) {
      const i = [];
      i[o] = s, s = i;
    } else
      s = /* @__PURE__ */ new Map([[o, s]]);
  }
  return ra(s, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: r,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const _i = (r) => r == null || typeof r == "object" && !!r[Symbol.iterator]().next().done;
class op extends np {
  constructor(e, t) {
    super(e), Object.defineProperty(this, "schema", {
      value: t,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (t.schema = e), t.items = t.items.map((s) => st(s) || Ye(s) ? s.clone(e) : s), this.range && (t.range = this.range.slice()), t;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, t) {
    if (_i(e))
      this.add(t);
    else {
      const [s, ...n] = e, o = this.get(s, !0);
      if (Qe(o))
        o.addIn(n, t);
      else if (o === void 0 && this.schema)
        this.set(s, lc(this.schema, n, t));
      else
        throw new Error(`Expected YAML collection at ${s}. Remaining path: ${n}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [t, ...s] = e;
    if (s.length === 0)
      return this.delete(t);
    const n = this.get(t, !0);
    if (Qe(n))
      return n.deleteIn(s);
    throw new Error(`Expected YAML collection at ${t}. Remaining path: ${s}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, t) {
    const [s, ...n] = e, o = this.get(s, !0);
    return n.length === 0 ? !t && ze(o) ? o.value : o : Qe(o) ? o.getIn(n, t) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((t) => {
      if (!Ye(t))
        return !1;
      const s = t.value;
      return s == null || e && ze(s) && s.value == null && !s.commentBefore && !s.comment && !s.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [t, ...s] = e;
    if (s.length === 0)
      return this.has(t);
    const n = this.get(t, !0);
    return Qe(n) ? n.hasIn(s) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, t) {
    const [s, ...n] = e;
    if (n.length === 0)
      this.set(s, t);
    else {
      const o = this.get(s, !0);
      if (Qe(o))
        o.setIn(n, t);
      else if (o === void 0 && this.schema)
        this.set(s, lc(this.schema, n, t));
      else
        throw new Error(`Expected YAML collection at ${s}. Remaining path: ${n}`);
    }
  }
}
op.maxFlowStringSingleLineLength = 60;
const SD = (r) => r.replace(/^(?!$)(?: $)?/gm, "#");
function Zr(r, e) {
  return /^\n+$/.test(r) ? r.substring(1) : e ? r.replace(/^(?! *$)/gm, e) : r;
}
const un = (r, e, t) => r.endsWith(`
`) ? Zr(t, e) : t.includes(`
`) ? `
` + Zr(t, e) : (r.endsWith(" ") ? "" : " ") + t, r1 = "flow", ph = "block", Rl = "quoted";
function Jc(r, e, t = "flow", { indentAtStart: s, lineWidth: n = 80, minContentWidth: o = 20, onFold: i, onOverflow: a } = {}) {
  if (!n || n < 0)
    return r;
  const l = Math.max(1 + o, 1 + n - e.length);
  if (r.length <= l)
    return r;
  const c = [], u = {};
  let d = n - e.length;
  typeof s == "number" && (s > n - Math.max(2, o) ? c.push(0) : d = n - s);
  let h, f, m = !1, g = -1, p = -1, y = -1;
  t === ph && (g = l0(r, g, e.length), g !== -1 && (d = g + l));
  for (let v; v = r[g += 1]; ) {
    if (t === Rl && v === "\\") {
      switch (p = g, r[g + 1]) {
        case "x":
          g += 3;
          break;
        case "u":
          g += 5;
          break;
        case "U":
          g += 9;
          break;
        default:
          g += 1;
      }
      y = g;
    }
    if (v === `
`)
      t === ph && (g = l0(r, g, e.length)), d = g + e.length + l, h = void 0;
    else {
      if (v === " " && f && f !== " " && f !== `
` && f !== "	") {
        const k = r[g + 1];
        k && k !== " " && k !== `
` && k !== "	" && (h = g);
      }
      if (g >= d)
        if (h)
          c.push(h), d = h + l, h = void 0;
        else if (t === Rl) {
          for (; f === " " || f === "	"; )
            f = v, v = r[g += 1], m = !0;
          const k = g > y + 1 ? g - 2 : p - 1;
          if (u[k])
            return r;
          c.push(k), u[k] = !0, d = k + l, h = void 0;
        } else
          m = !0;
    }
    f = v;
  }
  if (m && a && a(), c.length === 0)
    return r;
  i && i();
  let b = r.slice(0, c[0]);
  for (let v = 0; v < c.length; ++v) {
    const k = c[v], _ = c[v + 1] || r.length;
    k === 0 ? b = `
${e}${r.slice(0, _)}` : (t === Rl && u[k] && (b += `${r[k]}\\`), b += `
${e}${r.slice(k + 1, _)}`);
  }
  return b;
}
function l0(r, e, t) {
  let s = e, n = e + 1, o = r[n];
  for (; o === " " || o === "	"; )
    if (e < n + t)
      o = r[++e];
    else {
      do
        o = r[++e];
      while (o && o !== `
`);
      s = e, n = e + 1, o = r[n];
    }
  return s;
}
const Yc = (r, e) => ({
  indentAtStart: e ? r.indent.length : r.indentAtStart,
  lineWidth: r.options.lineWidth,
  minContentWidth: r.options.minContentWidth
}), Xc = (r) => /^(%|---|\.\.\.)/m.test(r);
function $D(r, e, t) {
  if (!e || e < 0)
    return !1;
  const s = e - t, n = r.length;
  if (n <= s)
    return !1;
  for (let o = 0, i = 0; o < n; ++o)
    if (r[o] === `
`) {
      if (o - i > s)
        return !0;
      if (i = o + 1, n - i <= s)
        return !1;
    }
  return !0;
}
function Vi(r, e) {
  const t = JSON.stringify(r);
  if (e.options.doubleQuotedAsJSON)
    return t;
  const { implicitKey: s } = e, n = e.options.doubleQuotedMinMultiLineLength, o = e.indent || (Xc(r) ? "  " : "");
  let i = "", a = 0;
  for (let l = 0, c = t[l]; c; c = t[++l])
    if (c === " " && t[l + 1] === "\\" && t[l + 2] === "n" && (i += t.slice(a, l) + "\\ ", l += 1, a = l, c = "\\"), c === "\\")
      switch (t[l + 1]) {
        case "u":
          {
            i += t.slice(a, l);
            const u = t.substr(l + 2, 4);
            switch (u) {
              case "0000":
                i += "\\0";
                break;
              case "0007":
                i += "\\a";
                break;
              case "000b":
                i += "\\v";
                break;
              case "001b":
                i += "\\e";
                break;
              case "0085":
                i += "\\N";
                break;
              case "00a0":
                i += "\\_";
                break;
              case "2028":
                i += "\\L";
                break;
              case "2029":
                i += "\\P";
                break;
              default:
                u.substr(0, 2) === "00" ? i += "\\x" + u.substr(2) : i += t.substr(l, 6);
            }
            l += 5, a = l + 1;
          }
          break;
        case "n":
          if (s || t[l + 2] === '"' || t.length < n)
            l += 1;
          else {
            for (i += t.slice(a, l) + `

`; t[l + 2] === "\\" && t[l + 3] === "n" && t[l + 4] !== '"'; )
              i += `
`, l += 2;
            i += o, t[l + 2] === " " && (i += "\\"), l += 1, a = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return i = a ? i + t.slice(a) : t, s ? i : Jc(i, o, Rl, Yc(e, !1));
}
function mh(r, e) {
  if (e.options.singleQuote === !1 || e.implicitKey && r.includes(`
`) || /[ \t]\n|\n[ \t]/.test(r))
    return Vi(r, e);
  const t = e.indent || (Xc(r) ? "  " : ""), s = "'" + r.replace(/'/g, "''").replace(/\n+/g, `$&
${t}`) + "'";
  return e.implicitKey ? s : Jc(s, t, r1, Yc(e, !1));
}
function to(r, e) {
  const { singleQuote: t } = e.options;
  let s;
  if (t === !1)
    s = Vi;
  else {
    const n = r.includes('"'), o = r.includes("'");
    n && !o ? s = mh : o && !n ? s = Vi : s = t ? mh : Vi;
  }
  return s(r, e);
}
let gh;
try {
  gh = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  gh = /\n+(?!\n|$)/g;
}
function jl({ comment: r, type: e, value: t }, s, n, o) {
  const { blockQuote: i, commentString: a, lineWidth: l } = s.options;
  if (!i || /\n[\t ]+$/.test(t) || /^\s*$/.test(t))
    return to(t, s);
  const c = s.indent || (s.forceBlockIndent || Xc(t) ? "  " : ""), u = i === "literal" ? !0 : i === "folded" || e === $e.BLOCK_FOLDED ? !1 : e === $e.BLOCK_LITERAL ? !0 : !$D(t, l, c.length);
  if (!t)
    return u ? `|
` : `>
`;
  let d, h;
  for (h = t.length; h > 0; --h) {
    const _ = t[h - 1];
    if (_ !== `
` && _ !== "	" && _ !== " ")
      break;
  }
  let f = t.substring(h);
  const m = f.indexOf(`
`);
  m === -1 ? d = "-" : t === f || m !== f.length - 1 ? (d = "+", o && o()) : d = "", f && (t = t.slice(0, -f.length), f[f.length - 1] === `
` && (f = f.slice(0, -1)), f = f.replace(gh, `$&${c}`));
  let g = !1, p, y = -1;
  for (p = 0; p < t.length; ++p) {
    const _ = t[p];
    if (_ === " ")
      g = !0;
    else if (_ === `
`)
      y = p;
    else
      break;
  }
  let b = t.substring(0, y < p ? y + 1 : p);
  b && (t = t.substring(b.length), b = b.replace(/\n+/g, `$&${c}`));
  let v = (u ? "|" : ">") + (g ? c ? "2" : "1" : "") + d;
  if (r && (v += " " + a(r.replace(/ ?[\r\n]+/g, " ")), n && n()), u)
    return t = t.replace(/\n+/g, `$&${c}`), `${v}
${c}${b}${t}${f}`;
  t = t.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`);
  const k = Jc(`${b}${t}${f}`, c, ph, Yc(s, !0));
  return `${v}
${c}${k}`;
}
function _D(r, e, t, s) {
  const { type: n, value: o } = r, { actualString: i, implicitKey: a, indent: l, indentStep: c, inFlow: u } = e;
  if (a && o.includes(`
`) || u && /[[\]{},]/.test(o))
    return to(o, e);
  if (!o || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))
    return a || u || !o.includes(`
`) ? to(o, e) : jl(r, e, t, s);
  if (!a && !u && n !== $e.PLAIN && o.includes(`
`))
    return jl(r, e, t, s);
  if (Xc(o)) {
    if (l === "")
      return e.forceBlockIndent = !0, jl(r, e, t, s);
    if (a && l === c)
      return to(o, e);
  }
  const d = o.replace(/\n+/g, `$&
${l}`);
  if (i) {
    const h = (g) => {
      var p;
      return g.default && g.tag !== "tag:yaml.org,2002:str" && ((p = g.test) == null ? void 0 : p.test(d));
    }, { compat: f, tags: m } = e.doc.schema;
    if (m.some(h) || f != null && f.some(h))
      return to(o, e);
  }
  return a ? d : Jc(d, l, r1, Yc(e, !1));
}
function Ca(r, e, t, s) {
  const { implicitKey: n, inFlow: o } = e, i = typeof r.value == "string" ? r : Object.assign({}, r, { value: String(r.value) });
  let { type: a } = r;
  a !== $e.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(i.value) && (a = $e.QUOTE_DOUBLE);
  const l = (u) => {
    switch (u) {
      case $e.BLOCK_FOLDED:
      case $e.BLOCK_LITERAL:
        return n || o ? to(i.value, e) : jl(i, e, t, s);
      case $e.QUOTE_DOUBLE:
        return Vi(i.value, e);
      case $e.QUOTE_SINGLE:
        return mh(i.value, e);
      case $e.PLAIN:
        return _D(i, e, t, s);
      default:
        return null;
    }
  };
  let c = l(a);
  if (c === null) {
    const { defaultKeyType: u, defaultStringType: d } = e.options, h = n && u || d;
    if (c = l(h), c === null)
      throw new Error(`Unsupported default string type ${h}`);
  }
  return c;
}
function s1(r, e) {
  const t = Object.assign({
    blockQuote: !0,
    commentString: SD,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, r.schema.toStringOptions, e);
  let s;
  switch (t.collectionStyle) {
    case "block":
      s = !1;
      break;
    case "flow":
      s = !0;
      break;
    default:
      s = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: r,
    flowCollectionPadding: t.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof t.indent == "number" ? " ".repeat(t.indent) : "  ",
    inFlow: s,
    options: t
  };
}
function xD(r, e) {
  var t;
  if (e.tag) {
    const o = r.filter((i) => i.tag === e.tag);
    if (o.length > 0)
      return o.find((i) => i.format === e.format) ?? o[0];
  }
  let s, n;
  if (ze(e)) {
    n = e.value;
    const o = r.filter((i) => {
      var a;
      return (a = i.identify) == null ? void 0 : a.call(i, n);
    });
    s = o.find((i) => i.format === e.format) ?? o.find((i) => !i.format);
  } else
    n = e, s = r.find((o) => o.nodeClass && n instanceof o.nodeClass);
  if (!s) {
    const o = ((t = n == null ? void 0 : n.constructor) == null ? void 0 : t.name) ?? typeof n;
    throw new Error(`Tag not resolved for ${o} value`);
  }
  return s;
}
function CD(r, e, { anchors: t, doc: s }) {
  if (!s.directives)
    return "";
  const n = [], o = (ze(r) || Qe(r)) && r.anchor;
  o && Qv(o) && (t.add(o), n.push(`&${o}`));
  const i = r.tag ? r.tag : e.default ? null : e.tag;
  return i && n.push(s.directives.tagString(i)), n.join(" ");
}
function $o(r, e, t, s) {
  var n;
  if (Ye(r))
    return r.toString(e, t, s);
  if (Pn(r)) {
    if (e.doc.directives)
      return r.toString(e);
    if ((n = e.resolvedAliases) != null && n.has(r))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(r) : e.resolvedAliases = /* @__PURE__ */ new Set([r]), r = r.resolve(e.doc);
  }
  let o;
  const i = st(r) ? r : e.doc.createNode(r, { onTagObj: (c) => o = c });
  o || (o = xD(e.doc.schema.tags, i));
  const a = CD(i, o, e);
  a.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + a.length + 1);
  const l = typeof o.stringify == "function" ? o.stringify(i, e, t, s) : ze(i) ? Ca(i, e, t, s) : i.toString(e, t, s);
  return a ? ze(i) || l[0] === "{" || l[0] === "[" ? `${a} ${l}` : `${a}
${e.indent}${l}` : l;
}
function AD({ key: r, value: e }, t, s, n) {
  const { allNullValues: o, doc: i, indent: a, indentStep: l, options: { commentString: c, indentSeq: u, simpleKeys: d } } = t;
  let h = st(r) && r.comment || null;
  if (d) {
    if (h)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (Qe(r)) {
      const x = "With simple keys, collection cannot be used as a key value";
      throw new Error(x);
    }
  }
  let f = !d && (!r || h && e == null && !t.inFlow || Qe(r) || (ze(r) ? r.type === $e.BLOCK_FOLDED || r.type === $e.BLOCK_LITERAL : typeof r == "object"));
  t = Object.assign({}, t, {
    allNullValues: !1,
    implicitKey: !f && (d || !o),
    indent: a + l
  });
  let m = !1, g = !1, p = $o(r, t, () => m = !0, () => g = !0);
  if (!f && !t.inFlow && p.length > 1024) {
    if (d)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    f = !0;
  }
  if (t.inFlow) {
    if (o || e == null)
      return m && s && s(), p === "" ? "?" : f ? `? ${p}` : p;
  } else if (o && !d || e == null && f)
    return p = `? ${p}`, h && !m ? p += un(p, t.indent, c(h)) : g && n && n(), p;
  m && (h = null), f ? (h && (p += un(p, t.indent, c(h))), p = `? ${p}
${a}:`) : (p = `${p}:`, h && (p += un(p, t.indent, c(h))));
  let y, b, v;
  st(e) ? (y = !!e.spaceBefore, b = e.commentBefore, v = e.comment) : (y = !1, b = null, v = null, e && typeof e == "object" && (e = i.createNode(e))), t.implicitKey = !1, !f && !h && ze(e) && (t.indentAtStart = p.length + 1), g = !1, !u && l.length >= 2 && !t.inFlow && !f && zo(e) && !e.flow && !e.tag && !e.anchor && (t.indent = t.indent.substring(2));
  let k = !1;
  const _ = $o(e, t, () => k = !0, () => g = !0);
  let w = " ";
  if (h || y || b) {
    if (w = y ? `
` : "", b) {
      const x = c(b);
      w += `
${Zr(x, t.indent)}`;
    }
    _ === "" && !t.inFlow ? w === `
` && (w = `

`) : w += `
${t.indent}`;
  } else if (!f && Qe(e)) {
    const x = _[0], T = _.indexOf(`
`), j = T !== -1, B = t.inFlow ?? e.flow ?? e.items.length === 0;
    if (j || !B) {
      let W = !1;
      if (j && (x === "&" || x === "!")) {
        let L = _.indexOf(" ");
        x === "&" && L !== -1 && L < T && _[L + 1] === "!" && (L = _.indexOf(" ", L + 1)), (L === -1 || T < L) && (W = !0);
      }
      W || (w = `
${t.indent}`);
    }
  } else
    (_ === "" || _[0] === `
`) && (w = "");
  return p += w + _, t.inFlow ? k && s && s() : v && !k ? p += un(p, t.indent, c(v)) : g && n && n(), p;
}
function n1(r, e) {
  (r === "debug" || r === "warn") && (typeof process < "u" && process.emitWarning ? process.emitWarning(e) : console.warn(e));
}
const c0 = "<<";
function o1(r, e, { key: t, value: s }) {
  if (r != null && r.doc.schema.merge && ED(t))
    if (s = Pn(s) ? s.resolve(r.doc) : s, zo(s))
      for (const n of s.items)
        Vu(r, e, n);
    else if (Array.isArray(s))
      for (const n of s)
        Vu(r, e, n);
    else
      Vu(r, e, s);
  else {
    const n = sr(t, "", r);
    if (e instanceof Map)
      e.set(n, sr(s, n, r));
    else if (e instanceof Set)
      e.add(n);
    else {
      const o = OD(t, n, r), i = sr(s, o, r);
      o in e ? Object.defineProperty(e, o, {
        value: i,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : e[o] = i;
    }
  }
  return e;
}
const ED = (r) => r === c0 || ze(r) && r.value === c0 && (!r.type || r.type === $e.PLAIN);
function Vu(r, e, t) {
  const s = r && Pn(t) ? t.resolve(r.doc) : t;
  if (!Uo(s))
    throw new Error("Merge sources must be maps or map aliases");
  const n = s.toJSON(null, r, Map);
  for (const [o, i] of n)
    e instanceof Map ? e.has(o) || e.set(o, i) : e instanceof Set ? e.add(o) : Object.prototype.hasOwnProperty.call(e, o) || Object.defineProperty(e, o, {
      value: i,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return e;
}
function OD(r, e, t) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (st(r) && t != null && t.doc) {
    const s = s1(t.doc, {});
    s.anchors = /* @__PURE__ */ new Set();
    for (const o of t.anchors.keys())
      s.anchors.add(o.anchor);
    s.inFlow = !0, s.inStringifyKey = !0;
    const n = r.toString(s);
    if (!t.mapKeyWarned) {
      let o = JSON.stringify(n);
      o.length > 40 && (o = o.substring(0, 36) + '..."'), n1(t.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${o}. Set mapAsMap: true to use object keys.`), t.mapKeyWarned = !0;
    }
    return n;
  }
  return JSON.stringify(e);
}
function ip(r, e, t) {
  const s = ra(r, void 0, t), n = ra(e, void 0, t);
  return new xt(s, n);
}
class xt {
  constructor(e, t = null) {
    Object.defineProperty(this, or, { value: Wv }), this.key = e, this.value = t;
  }
  clone(e) {
    let { key: t, value: s } = this;
    return st(t) && (t = t.clone(e)), st(s) && (s = s.clone(e)), new xt(t, s);
  }
  toJSON(e, t) {
    const s = t != null && t.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return o1(t, s, this);
  }
  toString(e, t, s) {
    return e != null && e.doc ? AD(this, e, t, s) : JSON.stringify(this);
  }
}
function i1(r, e, t) {
  return (e.inFlow ?? r.flow ? PD : TD)(r, e, t);
}
function TD({ comment: r, items: e }, t, { blockItemPrefix: s, flowChars: n, itemIndent: o, onChompKeep: i, onComment: a }) {
  const { indent: l, options: { commentString: c } } = t, u = Object.assign({}, t, { indent: o, type: null });
  let d = !1;
  const h = [];
  for (let m = 0; m < e.length; ++m) {
    const g = e[m];
    let p = null;
    if (st(g))
      !d && g.spaceBefore && h.push(""), cc(t, h, g.commentBefore, d), g.comment && (p = g.comment);
    else if (Ye(g)) {
      const b = st(g.key) ? g.key : null;
      b && (!d && b.spaceBefore && h.push(""), cc(t, h, b.commentBefore, d));
    }
    d = !1;
    let y = $o(g, u, () => p = null, () => d = !0);
    p && (y += un(y, o, c(p))), d && p && (d = !1), h.push(s + y);
  }
  let f;
  if (h.length === 0)
    f = n.start + n.end;
  else {
    f = h[0];
    for (let m = 1; m < h.length; ++m) {
      const g = h[m];
      f += g ? `
${l}${g}` : `
`;
    }
  }
  return r ? (f += `
` + Zr(c(r), l), a && a()) : d && i && i(), f;
}
function PD({ items: r }, e, { flowChars: t, itemIndent: s }) {
  const { indent: n, indentStep: o, flowCollectionPadding: i, options: { commentString: a } } = e;
  s += o;
  const l = Object.assign({}, e, {
    indent: s,
    inFlow: !0,
    type: null
  });
  let c = !1, u = 0;
  const d = [];
  for (let m = 0; m < r.length; ++m) {
    const g = r[m];
    let p = null;
    if (st(g))
      g.spaceBefore && d.push(""), cc(e, d, g.commentBefore, !1), g.comment && (p = g.comment);
    else if (Ye(g)) {
      const b = st(g.key) ? g.key : null;
      b && (b.spaceBefore && d.push(""), cc(e, d, b.commentBefore, !1), b.comment && (c = !0));
      const v = st(g.value) ? g.value : null;
      v ? (v.comment && (p = v.comment), v.commentBefore && (c = !0)) : g.value == null && b != null && b.comment && (p = b.comment);
    }
    p && (c = !0);
    let y = $o(g, l, () => p = null);
    m < r.length - 1 && (y += ","), p && (y += un(y, s, a(p))), !c && (d.length > u || y.includes(`
`)) && (c = !0), d.push(y), u = d.length;
  }
  const { start: h, end: f } = t;
  if (d.length === 0)
    return h + f;
  if (!c) {
    const m = d.reduce((g, p) => g + p.length + 2, 2);
    c = e.options.lineWidth > 0 && m > e.options.lineWidth;
  }
  if (c) {
    let m = h;
    for (const g of d)
      m += g ? `
${o}${n}${g}` : `
`;
    return `${m}
${n}${f}`;
  } else
    return `${h}${i}${d.join(" ")}${i}${f}`;
}
function cc({ indent: r, options: { commentString: e } }, t, s, n) {
  if (s && n && (s = s.replace(/^\n+/, "")), s) {
    const o = Zr(e(s), r);
    t.push(o.trimStart());
  }
}
function dn(r, e) {
  const t = ze(e) ? e.value : e;
  for (const s of r)
    if (Ye(s) && (s.key === e || s.key === t || ze(s.key) && s.key.value === t))
      return s;
}
class Ht extends op {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(Ds, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, t, s) {
    const { keepUndefined: n, replacer: o } = s, i = new this(e), a = (l, c) => {
      if (typeof o == "function")
        c = o.call(t, l, c);
      else if (Array.isArray(o) && !o.includes(l))
        return;
      (c !== void 0 || n) && i.items.push(ip(l, c, s));
    };
    if (t instanceof Map)
      for (const [l, c] of t)
        a(l, c);
    else if (t && typeof t == "object")
      for (const l of Object.keys(t))
        a(l, t[l]);
    return typeof e.sortMapEntries == "function" && i.items.sort(e.sortMapEntries), i;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, t) {
    var s;
    let n;
    Ye(e) ? n = e : !e || typeof e != "object" || !("key" in e) ? n = new xt(e, e == null ? void 0 : e.value) : n = new xt(e.key, e.value);
    const o = dn(this.items, n.key), i = (s = this.schema) == null ? void 0 : s.sortMapEntries;
    if (o) {
      if (!t)
        throw new Error(`Key ${n.key} already set`);
      ze(o.value) && t1(n.value) ? o.value.value = n.value : o.value = n.value;
    } else if (i) {
      const a = this.items.findIndex((l) => i(n, l) < 0);
      a === -1 ? this.items.push(n) : this.items.splice(a, 0, n);
    } else
      this.items.push(n);
  }
  delete(e) {
    const t = dn(this.items, e);
    return t ? this.items.splice(this.items.indexOf(t), 1).length > 0 : !1;
  }
  get(e, t) {
    const s = dn(this.items, e), n = s == null ? void 0 : s.value;
    return (!t && ze(n) ? n.value : n) ?? void 0;
  }
  has(e) {
    return !!dn(this.items, e);
  }
  set(e, t) {
    this.add(new xt(e, t), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, t, s) {
    const n = s ? new s() : t != null && t.mapAsMap ? /* @__PURE__ */ new Map() : {};
    t != null && t.onCreate && t.onCreate(n);
    for (const o of this.items)
      o1(t, n, o);
    return n;
  }
  toString(e, t, s) {
    if (!e)
      return JSON.stringify(this);
    for (const n of this.items)
      if (!Ye(n))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(n)} instead`);
    return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), i1(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: s,
      onComment: t
    });
  }
}
const qo = {
  collection: "map",
  default: !0,
  nodeClass: Ht,
  tag: "tag:yaml.org,2002:map",
  resolve(r, e) {
    return Uo(r) || e("Expected a mapping for this tag"), r;
  },
  createNode: (r, e, t) => Ht.from(r, e, t)
};
class Us extends op {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(Fo, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const t = hl(e);
    return typeof t != "number" ? !1 : this.items.splice(t, 1).length > 0;
  }
  get(e, t) {
    const s = hl(e);
    if (typeof s != "number")
      return;
    const n = this.items[s];
    return !t && ze(n) ? n.value : n;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const t = hl(e);
    return typeof t == "number" && t < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, t) {
    const s = hl(e);
    if (typeof s != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const n = this.items[s];
    ze(n) && t1(t) ? n.value = t : this.items[s] = t;
  }
  toJSON(e, t) {
    const s = [];
    t != null && t.onCreate && t.onCreate(s);
    let n = 0;
    for (const o of this.items)
      s.push(sr(o, String(n++), t));
    return s;
  }
  toString(e, t, s) {
    return e ? i1(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: s,
      onComment: t
    }) : JSON.stringify(this);
  }
  static from(e, t, s) {
    const { replacer: n } = s, o = new this(e);
    if (t && Symbol.iterator in Object(t)) {
      let i = 0;
      for (let a of t) {
        if (typeof n == "function") {
          const l = t instanceof Set ? a : String(i++);
          a = n.call(t, l, a);
        }
        o.items.push(ra(a, void 0, s));
      }
    }
    return o;
  }
}
function hl(r) {
  let e = ze(r) ? r.value : r;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
const Ho = {
  collection: "seq",
  default: !0,
  nodeClass: Us,
  tag: "tag:yaml.org,2002:seq",
  resolve(r, e) {
    return zo(r) || e("Expected a sequence for this tag"), r;
  },
  createNode: (r, e, t) => Us.from(r, e, t)
}, Qc = {
  identify: (r) => typeof r == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (r) => r,
  stringify(r, e, t, s) {
    return e = Object.assign({ actualString: !0 }, e), Ca(r, e, t, s);
  }
}, Zc = {
  identify: (r) => r == null,
  createNode: () => new $e(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new $e(null),
  stringify: ({ source: r }, e) => typeof r == "string" && Zc.test.test(r) ? r : e.options.nullStr
}, ap = {
  identify: (r) => typeof r == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (r) => new $e(r[0] === "t" || r[0] === "T"),
  stringify({ source: r, value: e }, t) {
    if (r && ap.test.test(r)) {
      const s = r[0] === "t" || r[0] === "T";
      if (e === s)
        return r;
    }
    return e ? t.options.trueStr : t.options.falseStr;
  }
};
function _r({ format: r, minFractionDigits: e, tag: t, value: s }) {
  if (typeof s == "bigint")
    return String(s);
  const n = typeof s == "number" ? s : Number(s);
  if (!isFinite(n))
    return isNaN(n) ? ".nan" : n < 0 ? "-.inf" : ".inf";
  let o = JSON.stringify(s);
  if (!r && e && (!t || t === "tag:yaml.org,2002:float") && /^\d/.test(o)) {
    let i = o.indexOf(".");
    i < 0 && (i = o.length, o += ".");
    let a = e - (o.length - i - 1);
    for (; a-- > 0; )
      o += "0";
  }
  return o;
}
const a1 = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (r) => r.slice(-3).toLowerCase() === "nan" ? NaN : r[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: _r
}, l1 = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (r) => parseFloat(r),
  stringify(r) {
    const e = Number(r.value);
    return isFinite(e) ? e.toExponential() : _r(r);
  }
}, c1 = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(r) {
    const e = new $e(parseFloat(r)), t = r.indexOf(".");
    return t !== -1 && r[r.length - 1] === "0" && (e.minFractionDigits = r.length - t - 1), e;
  },
  stringify: _r
}, eu = (r) => typeof r == "bigint" || Number.isInteger(r), lp = (r, e, t, { intAsBigInt: s }) => s ? BigInt(r) : parseInt(r.substring(e), t);
function u1(r, e, t) {
  const { value: s } = r;
  return eu(s) && s >= 0 ? t + s.toString(e) : _r(r);
}
const d1 = {
  identify: (r) => eu(r) && r >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (r, e, t) => lp(r, 2, 8, t),
  stringify: (r) => u1(r, 8, "0o")
}, h1 = {
  identify: eu,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (r, e, t) => lp(r, 0, 10, t),
  stringify: _r
}, f1 = {
  identify: (r) => eu(r) && r >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (r, e, t) => lp(r, 2, 16, t),
  stringify: (r) => u1(r, 16, "0x")
}, ID = [
  qo,
  Ho,
  Qc,
  Zc,
  ap,
  d1,
  h1,
  f1,
  a1,
  l1,
  c1
];
function u0(r) {
  return typeof r == "bigint" || Number.isInteger(r);
}
const fl = ({ value: r }) => JSON.stringify(r), ND = [
  {
    identify: (r) => typeof r == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (r) => r,
    stringify: fl
  },
  {
    identify: (r) => r == null,
    createNode: () => new $e(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: fl
  },
  {
    identify: (r) => typeof r == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (r) => r === "true",
    stringify: fl
  },
  {
    identify: u0,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (r, e, { intAsBigInt: t }) => t ? BigInt(r) : parseInt(r, 10),
    stringify: ({ value: r }) => u0(r) ? r.toString() : JSON.stringify(r)
  },
  {
    identify: (r) => typeof r == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (r) => parseFloat(r),
    stringify: fl
  }
], MD = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(r, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(r)}`), r;
  }
}, DD = [qo, Ho].concat(ND, MD), cp = {
  identify: (r) => r instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(r, e) {
    if (typeof Buffer == "function")
      return Buffer.from(r, "base64");
    if (typeof atob == "function") {
      const t = atob(r.replace(/[\n\r]/g, "")), s = new Uint8Array(t.length);
      for (let n = 0; n < t.length; ++n)
        s[n] = t.charCodeAt(n);
      return s;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), r;
  },
  stringify({ comment: r, type: e, value: t }, s, n, o) {
    const i = t;
    let a;
    if (typeof Buffer == "function")
      a = i instanceof Buffer ? i.toString("base64") : Buffer.from(i.buffer).toString("base64");
    else if (typeof btoa == "function") {
      let l = "";
      for (let c = 0; c < i.length; ++c)
        l += String.fromCharCode(i[c]);
      a = btoa(l);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e || (e = $e.BLOCK_LITERAL), e !== $e.QUOTE_DOUBLE) {
      const l = Math.max(s.options.lineWidth - s.indent.length, s.options.minContentWidth), c = Math.ceil(a.length / l), u = new Array(c);
      for (let d = 0, h = 0; d < c; ++d, h += l)
        u[d] = a.substr(h, l);
      a = u.join(e === $e.BLOCK_LITERAL ? `
` : " ");
    }
    return Ca({ comment: r, type: e, value: a }, s, n, o);
  }
};
function p1(r, e) {
  if (zo(r))
    for (let t = 0; t < r.items.length; ++t) {
      let s = r.items[t];
      if (!Ye(s)) {
        if (Uo(s)) {
          s.items.length > 1 && e("Each pair must have its own sequence indicator");
          const n = s.items[0] || new xt(new $e(null));
          if (s.commentBefore && (n.key.commentBefore = n.key.commentBefore ? `${s.commentBefore}
${n.key.commentBefore}` : s.commentBefore), s.comment) {
            const o = n.value ?? n.key;
            o.comment = o.comment ? `${s.comment}
${o.comment}` : s.comment;
          }
          s = n;
        }
        r.items[t] = Ye(s) ? s : new xt(s);
      }
    }
  else
    e("Expected a sequence for this tag");
  return r;
}
function m1(r, e, t) {
  const { replacer: s } = t, n = new Us(r);
  n.tag = "tag:yaml.org,2002:pairs";
  let o = 0;
  if (e && Symbol.iterator in Object(e))
    for (let i of e) {
      typeof s == "function" && (i = s.call(e, String(o++), i));
      let a, l;
      if (Array.isArray(i))
        if (i.length === 2)
          a = i[0], l = i[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${i}`);
      else if (i && i instanceof Object) {
        const c = Object.keys(i);
        if (c.length === 1)
          a = c[0], l = i[a];
        else
          throw new TypeError(`Expected tuple with one key, not ${c.length} keys`);
      } else
        a = i;
      n.items.push(ip(a, l, t));
    }
  return n;
}
const up = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: p1,
  createNode: m1
};
class uo extends Us {
  constructor() {
    super(), this.add = Ht.prototype.add.bind(this), this.delete = Ht.prototype.delete.bind(this), this.get = Ht.prototype.get.bind(this), this.has = Ht.prototype.has.bind(this), this.set = Ht.prototype.set.bind(this), this.tag = uo.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, t) {
    if (!t)
      return super.toJSON(e);
    const s = /* @__PURE__ */ new Map();
    t != null && t.onCreate && t.onCreate(s);
    for (const n of this.items) {
      let o, i;
      if (Ye(n) ? (o = sr(n.key, "", t), i = sr(n.value, o, t)) : o = sr(n, "", t), s.has(o))
        throw new Error("Ordered maps must not include duplicate keys");
      s.set(o, i);
    }
    return s;
  }
  static from(e, t, s) {
    const n = m1(e, t, s), o = new this();
    return o.items = n.items, o;
  }
}
uo.tag = "tag:yaml.org,2002:omap";
const dp = {
  collection: "seq",
  identify: (r) => r instanceof Map,
  nodeClass: uo,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(r, e) {
    const t = p1(r, e), s = [];
    for (const { key: n } of t.items)
      ze(n) && (s.includes(n.value) ? e(`Ordered maps must not include duplicate keys: ${n.value}`) : s.push(n.value));
    return Object.assign(new uo(), t);
  },
  createNode: (r, e, t) => uo.from(r, e, t)
};
function g1({ value: r, source: e }, t) {
  return e && (r ? y1 : b1).test.test(e) ? e : r ? t.options.trueStr : t.options.falseStr;
}
const y1 = {
  identify: (r) => r === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new $e(!0),
  stringify: g1
}, b1 = {
  identify: (r) => r === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new $e(!1),
  stringify: g1
}, RD = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (r) => r.slice(-3).toLowerCase() === "nan" ? NaN : r[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: _r
}, jD = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (r) => parseFloat(r.replace(/_/g, "")),
  stringify(r) {
    const e = Number(r.value);
    return isFinite(e) ? e.toExponential() : _r(r);
  }
}, LD = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(r) {
    const e = new $e(parseFloat(r.replace(/_/g, ""))), t = r.indexOf(".");
    if (t !== -1) {
      const s = r.substring(t + 1).replace(/_/g, "");
      s[s.length - 1] === "0" && (e.minFractionDigits = s.length);
    }
    return e;
  },
  stringify: _r
}, Aa = (r) => typeof r == "bigint" || Number.isInteger(r);
function tu(r, e, t, { intAsBigInt: s }) {
  const n = r[0];
  if ((n === "-" || n === "+") && (e += 1), r = r.substring(e).replace(/_/g, ""), s) {
    switch (t) {
      case 2:
        r = `0b${r}`;
        break;
      case 8:
        r = `0o${r}`;
        break;
      case 16:
        r = `0x${r}`;
        break;
    }
    const i = BigInt(r);
    return n === "-" ? BigInt(-1) * i : i;
  }
  const o = parseInt(r, t);
  return n === "-" ? -1 * o : o;
}
function hp(r, e, t) {
  const { value: s } = r;
  if (Aa(s)) {
    const n = s.toString(e);
    return s < 0 ? "-" + t + n.substr(1) : t + n;
  }
  return _r(r);
}
const BD = {
  identify: Aa,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (r, e, t) => tu(r, 2, 2, t),
  stringify: (r) => hp(r, 2, "0b")
}, FD = {
  identify: Aa,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (r, e, t) => tu(r, 1, 8, t),
  stringify: (r) => hp(r, 8, "0")
}, VD = {
  identify: Aa,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (r, e, t) => tu(r, 0, 10, t),
  stringify: _r
}, UD = {
  identify: Aa,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (r, e, t) => tu(r, 2, 16, t),
  stringify: (r) => hp(r, 16, "0x")
};
class ho extends Ht {
  constructor(e) {
    super(e), this.tag = ho.tag;
  }
  add(e) {
    let t;
    Ye(e) ? t = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? t = new xt(e.key, null) : t = new xt(e, null), dn(this.items, t.key) || this.items.push(t);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, t) {
    const s = dn(this.items, e);
    return !t && Ye(s) ? ze(s.key) ? s.key.value : s.key : s;
  }
  set(e, t) {
    if (typeof t != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof t}`);
    const s = dn(this.items, e);
    s && !t ? this.items.splice(this.items.indexOf(s), 1) : !s && t && this.items.push(new xt(e));
  }
  toJSON(e, t) {
    return super.toJSON(e, t, Set);
  }
  toString(e, t, s) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, e, { allNullValues: !0 }), t, s);
    throw new Error("Set items must all have null values");
  }
  static from(e, t, s) {
    const { replacer: n } = s, o = new this(e);
    if (t && Symbol.iterator in Object(t))
      for (let i of t)
        typeof n == "function" && (i = n.call(t, i, i)), o.items.push(ip(i, null, s));
    return o;
  }
}
ho.tag = "tag:yaml.org,2002:set";
const fp = {
  collection: "map",
  identify: (r) => r instanceof Set,
  nodeClass: ho,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (r, e, t) => ho.from(r, e, t),
  resolve(r, e) {
    if (Uo(r)) {
      if (r.hasAllNullValues(!0))
        return Object.assign(new ho(), r);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return r;
  }
};
function pp(r, e) {
  const t = r[0], s = t === "-" || t === "+" ? r.substring(1) : r, n = (i) => e ? BigInt(i) : Number(i), o = s.replace(/_/g, "").split(":").reduce((i, a) => i * n(60) + n(a), n(0));
  return t === "-" ? n(-1) * o : o;
}
function v1(r) {
  let { value: e } = r, t = (i) => i;
  if (typeof e == "bigint")
    t = (i) => BigInt(i);
  else if (isNaN(e) || !isFinite(e))
    return _r(r);
  let s = "";
  e < 0 && (s = "-", e *= t(-1));
  const n = t(60), o = [e % n];
  return e < 60 ? o.unshift(0) : (e = (e - o[0]) / n, o.unshift(e % n), e >= 60 && (e = (e - o[0]) / n, o.unshift(e))), s + o.map((i) => String(i).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const w1 = {
  identify: (r) => typeof r == "bigint" || Number.isInteger(r),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (r, e, { intAsBigInt: t }) => pp(r, t),
  stringify: v1
}, k1 = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (r) => pp(r, !1),
  stringify: v1
}, ru = {
  identify: (r) => r instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(r) {
    const e = r.match(ru.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, t, s, n, o, i, a] = e.map(Number), l = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let c = Date.UTC(t, s - 1, n, o || 0, i || 0, a || 0, l);
    const u = e[8];
    if (u && u !== "Z") {
      let d = pp(u, !1);
      Math.abs(d) < 30 && (d *= 60), c -= 6e4 * d;
    }
    return new Date(c);
  },
  stringify: ({ value: r }) => r.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
}, d0 = [
  qo,
  Ho,
  Qc,
  Zc,
  y1,
  b1,
  BD,
  FD,
  VD,
  UD,
  RD,
  jD,
  LD,
  cp,
  dp,
  up,
  fp,
  w1,
  k1,
  ru
], h0 = /* @__PURE__ */ new Map([
  ["core", ID],
  ["failsafe", [qo, Ho, Qc]],
  ["json", DD],
  ["yaml11", d0],
  ["yaml-1.1", d0]
]), f0 = {
  binary: cp,
  bool: ap,
  float: c1,
  floatExp: l1,
  floatNaN: a1,
  floatTime: k1,
  int: h1,
  intHex: f1,
  intOct: d1,
  intTime: w1,
  map: qo,
  null: Zc,
  omap: dp,
  pairs: up,
  seq: Ho,
  set: fp,
  timestamp: ru
}, zD = {
  "tag:yaml.org,2002:binary": cp,
  "tag:yaml.org,2002:omap": dp,
  "tag:yaml.org,2002:pairs": up,
  "tag:yaml.org,2002:set": fp,
  "tag:yaml.org,2002:timestamp": ru
};
function Uu(r, e) {
  let t = h0.get(e);
  if (!t)
    if (Array.isArray(r))
      t = [];
    else {
      const s = Array.from(h0.keys()).filter((n) => n !== "yaml11").map((n) => JSON.stringify(n)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${s} or define customTags array`);
    }
  if (Array.isArray(r))
    for (const s of r)
      t = t.concat(s);
  else
    typeof r == "function" && (t = r(t.slice()));
  return t.map((s) => {
    if (typeof s != "string")
      return s;
    const n = f0[s];
    if (n)
      return n;
    const o = Object.keys(f0).map((i) => JSON.stringify(i)).join(", ");
    throw new Error(`Unknown custom tag "${s}"; use one of ${o}`);
  });
}
const qD = (r, e) => r.key < e.key ? -1 : r.key > e.key ? 1 : 0;
class su {
  constructor({ compat: e, customTags: t, merge: s, resolveKnownTags: n, schema: o, sortMapEntries: i, toStringDefaults: a }) {
    this.compat = Array.isArray(e) ? Uu(e, "compat") : e ? Uu(null, e) : null, this.merge = !!s, this.name = typeof o == "string" && o || "core", this.knownTags = n ? zD : {}, this.tags = Uu(t, this.name), this.toStringOptions = a ?? null, Object.defineProperty(this, Ds, { value: qo }), Object.defineProperty(this, ds, { value: Qc }), Object.defineProperty(this, Fo, { value: Ho }), this.sortMapEntries = typeof i == "function" ? i : i === !0 ? qD : null;
  }
  clone() {
    const e = Object.create(su.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
}
function HD(r, e) {
  var t;
  const s = [];
  let n = e.directives === !0;
  if (e.directives !== !1 && r.directives) {
    const c = r.directives.toString(r);
    c ? (s.push(c), n = !0) : r.directives.docStart && (n = !0);
  }
  n && s.push("---");
  const o = s1(r, e), { commentString: i } = o.options;
  if (r.commentBefore) {
    s.length !== 1 && s.unshift("");
    const c = i(r.commentBefore);
    s.unshift(Zr(c, ""));
  }
  let a = !1, l = null;
  if (r.contents) {
    if (st(r.contents)) {
      if (r.contents.spaceBefore && n && s.push(""), r.contents.commentBefore) {
        const d = i(r.contents.commentBefore);
        s.push(Zr(d, ""));
      }
      o.forceBlockIndent = !!r.comment, l = r.contents.comment;
    }
    const c = l ? void 0 : () => a = !0;
    let u = $o(r.contents, o, () => l = null, c);
    l && (u += un(u, "", i(l))), (u[0] === "|" || u[0] === ">") && s[s.length - 1] === "---" ? s[s.length - 1] = `--- ${u}` : s.push(u);
  } else
    s.push($o(r.contents, o));
  if ((t = r.directives) != null && t.docEnd)
    if (r.comment) {
      const c = i(r.comment);
      c.includes(`
`) ? (s.push("..."), s.push(Zr(c, ""))) : s.push(`... ${c}`);
    } else
      s.push("...");
  else {
    let c = r.comment;
    c && a && (c = c.replace(/^\n+/, "")), c && ((!a || l) && s[s.length - 1] !== "" && s.push(""), s.push(Zr(i(c), "")));
  }
  return s.join(`
`) + `
`;
}
class Ko {
  constructor(e, t, s) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, or, { value: fh });
    let n = null;
    typeof t == "function" || Array.isArray(t) ? n = t : s === void 0 && t && (s = t, t = void 0);
    const o = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      uniqueKeys: !0,
      version: "1.2"
    }, s);
    this.options = o;
    let { version: i } = o;
    s != null && s._directives ? (this.directives = s._directives.atDocument(), this.directives.yaml.explicit && (i = this.directives.yaml.version)) : this.directives = new Ot({ version: i }), this.setSchema(i, s), this.contents = e === void 0 ? null : this.createNode(e, n, s);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(Ko.prototype, {
      [or]: { value: fh }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = st(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    zn(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, t) {
    zn(this.contents) && this.contents.addIn(e, t);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, t) {
    if (!e.anchor) {
      const s = Zv(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !t || s.has(t) ? e1(t || "a", s) : t;
    }
    return new Gc(e.anchor);
  }
  createNode(e, t, s) {
    let n;
    if (typeof t == "function")
      e = t.call({ "": e }, "", e), n = t;
    else if (Array.isArray(t)) {
      const p = (b) => typeof b == "number" || b instanceof String || b instanceof Number, y = t.filter(p).map(String);
      y.length > 0 && (t = t.concat(y)), n = t;
    } else
      s === void 0 && t && (s = t, t = void 0);
    const { aliasDuplicateObjects: o, anchorPrefix: i, flow: a, keepUndefined: l, onTagObj: c, tag: u } = s ?? {}, { onAnchor: d, setAnchors: h, sourceObjects: f } = vD(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      i || "a"
    ), m = {
      aliasDuplicateObjects: o ?? !0,
      keepUndefined: l ?? !1,
      onAnchor: d,
      onTagObj: c,
      replacer: n,
      schema: this.schema,
      sourceObjects: f
    }, g = ra(e, u, m);
    return a && Qe(g) && (g.flow = !0), h(), g;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, t, s = {}) {
    const n = this.createNode(e, null, s), o = this.createNode(t, null, s);
    return new xt(n, o);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return zn(this.contents) ? this.contents.delete(e) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return _i(e) ? this.contents == null ? !1 : (this.contents = null, !0) : zn(this.contents) ? this.contents.deleteIn(e) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, t) {
    return Qe(this.contents) ? this.contents.get(e, t) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, t) {
    return _i(e) ? !t && ze(this.contents) ? this.contents.value : this.contents : Qe(this.contents) ? this.contents.getIn(e, t) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return Qe(this.contents) ? this.contents.has(e) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return _i(e) ? this.contents !== void 0 : Qe(this.contents) ? this.contents.hasIn(e) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, t) {
    this.contents == null ? this.contents = lc(this.schema, [e], t) : zn(this.contents) && this.contents.set(e, t);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, t) {
    _i(e) ? this.contents = t : this.contents == null ? this.contents = lc(this.schema, Array.from(e), t) : zn(this.contents) && this.contents.setIn(e, t);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, t = {}) {
    typeof e == "number" && (e = String(e));
    let s;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Ot({ version: "1.1" }), s = { merge: !0, resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Ot({ version: e }), s = { merge: !1, resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, s = null;
        break;
      default: {
        const n = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${n}`);
      }
    }
    if (t.schema instanceof Object)
      this.schema = t.schema;
    else if (s)
      this.schema = new su(Object.assign(s, t));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: t, mapAsMap: s, maxAliasCount: n, onAnchor: o, reviver: i } = {}) {
    const a = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: s === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof n == "number" ? n : 100
    }, l = sr(this.contents, t ?? "", a);
    if (typeof o == "function")
      for (const { count: c, res: u } of a.anchors.values())
        o(u, c);
    return typeof i == "function" ? eo(i, { "": l }, "", l) : l;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, t) {
    return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: t });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const t = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${t}`);
    }
    return HD(this, e);
  }
}
function zn(r) {
  if (Qe(r))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class mp extends Error {
  constructor(e, t, s, n) {
    super(), this.name = e, this.code = s, this.message = n, this.pos = t;
  }
}
class hn extends mp {
  constructor(e, t, s) {
    super("YAMLParseError", e, t, s);
  }
}
class S1 extends mp {
  constructor(e, t, s) {
    super("YAMLWarning", e, t, s);
  }
}
const uc = (r, e) => (t) => {
  if (t.pos[0] === -1)
    return;
  t.linePos = t.pos.map((a) => e.linePos(a));
  const { line: s, col: n } = t.linePos[0];
  t.message += ` at line ${s}, column ${n}`;
  let o = n - 1, i = r.substring(e.lineStarts[s - 1], e.lineStarts[s]).replace(/[\n\r]+$/, "");
  if (o >= 60 && i.length > 80) {
    const a = Math.min(o - 39, i.length - 79);
    i = "…" + i.substring(a), o -= a - 1;
  }
  if (i.length > 80 && (i = i.substring(0, 79) + "…"), s > 1 && /^ *$/.test(i.substring(0, o))) {
    let a = r.substring(e.lineStarts[s - 2], e.lineStarts[s - 1]);
    a.length > 80 && (a = a.substring(0, 79) + `…
`), i = a + i;
  }
  if (/[^ ]/.test(i)) {
    let a = 1;
    const l = t.linePos[1];
    l && l.line === s && l.col > n && (a = Math.max(1, Math.min(l.col - n, 80 - o)));
    const c = " ".repeat(o) + "^".repeat(a);
    t.message += `:

${i}
${c}
`;
  }
};
function _o(r, { flow: e, indicator: t, next: s, offset: n, onError: o, startOnNewline: i }) {
  let a = !1, l = i, c = i, u = "", d = "", h = !1, f = !1, m = !1, g = null, p = null, y = null, b = null, v = null;
  for (const w of r)
    switch (m && (w.type !== "space" && w.type !== "newline" && w.type !== "comma" && o(w.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), m = !1), w.type) {
      case "space":
        !e && l && t !== "doc-start" && w.source[0] === "	" && o(w, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), c = !0;
        break;
      case "comment": {
        c || o(w, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const x = w.source.substring(1) || " ";
        u ? u += d + x : u = x, d = "", l = !1;
        break;
      }
      case "newline":
        l ? u ? u += w.source : a = !0 : d += w.source, l = !0, h = !0, (g || p) && (f = !0), c = !0;
        break;
      case "anchor":
        g && o(w, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), w.source.endsWith(":") && o(w.offset + w.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), g = w, v === null && (v = w.offset), l = !1, c = !1, m = !0;
        break;
      case "tag": {
        p && o(w, "MULTIPLE_TAGS", "A node can have at most one tag"), p = w, v === null && (v = w.offset), l = !1, c = !1, m = !0;
        break;
      }
      case t:
        (g || p) && o(w, "BAD_PROP_ORDER", `Anchors and tags must be after the ${w.source} indicator`), b && o(w, "UNEXPECTED_TOKEN", `Unexpected ${w.source} in ${e ?? "collection"}`), b = w, l = !1, c = !1;
        break;
      case "comma":
        if (e) {
          y && o(w, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), y = w, l = !1, c = !1;
          break;
        }
      default:
        o(w, "UNEXPECTED_TOKEN", `Unexpected ${w.type} token`), l = !1, c = !1;
    }
  const k = r[r.length - 1], _ = k ? k.offset + k.source.length : n;
  return m && s && s.type !== "space" && s.type !== "newline" && s.type !== "comma" && (s.type !== "scalar" || s.source !== "") && o(s.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), {
    comma: y,
    found: b,
    spaceBefore: a,
    comment: u,
    hasNewline: h,
    hasNewlineAfterProp: f,
    anchor: g,
    tag: p,
    end: _,
    start: v ?? _
  };
}
function sa(r) {
  if (!r)
    return null;
  switch (r.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (r.source.includes(`
`))
        return !0;
      if (r.end) {
        for (const e of r.end)
          if (e.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const e of r.items) {
        for (const t of e.start)
          if (t.type === "newline")
            return !0;
        if (e.sep) {
          for (const t of e.sep)
            if (t.type === "newline")
              return !0;
        }
        if (sa(e.key) || sa(e.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function yh(r, e, t) {
  if ((e == null ? void 0 : e.type) === "flow-collection") {
    const s = e.end[0];
    s.indent === r && (s.source === "]" || s.source === "}") && sa(e) && t(s, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function $1(r, e, t) {
  const { uniqueKeys: s } = r.options;
  if (s === !1)
    return !1;
  const n = typeof s == "function" ? s : (o, i) => o === i || ze(o) && ze(i) && o.value === i.value && !(o.value === "<<" && r.schema.merge);
  return e.some((o) => n(o.key, t));
}
const p0 = "All mapping items must start at the same column";
function KD({ composeNode: r, composeEmptyNode: e }, t, s, n, o) {
  var i;
  const a = (o == null ? void 0 : o.nodeClass) ?? Ht, l = new a(t.schema);
  t.atRoot && (t.atRoot = !1);
  let c = s.offset, u = null;
  for (const d of s.items) {
    const { start: h, key: f, sep: m, value: g } = d, p = _o(h, {
      indicator: "explicit-key-ind",
      next: f ?? (m == null ? void 0 : m[0]),
      offset: c,
      onError: n,
      startOnNewline: !0
    }), y = !p.found;
    if (y) {
      if (f && (f.type === "block-seq" ? n(c, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in f && f.indent !== s.indent && n(c, "BAD_INDENT", p0)), !p.anchor && !p.tag && !m) {
        u = p.end, p.comment && (l.comment ? l.comment += `
` + p.comment : l.comment = p.comment);
        continue;
      }
      (p.hasNewlineAfterProp || sa(f)) && n(f ?? h[h.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else
      ((i = p.found) == null ? void 0 : i.indent) !== s.indent && n(c, "BAD_INDENT", p0);
    const b = p.end, v = f ? r(t, f, p, n) : e(t, b, h, null, p, n);
    t.schema.compat && yh(s.indent, f, n), $1(t, l.items, v) && n(b, "DUPLICATE_KEY", "Map keys must be unique");
    const k = _o(m ?? [], {
      indicator: "map-value-ind",
      next: g,
      offset: v.range[2],
      onError: n,
      startOnNewline: !f || f.type === "block-scalar"
    });
    if (c = k.end, k.found) {
      y && ((g == null ? void 0 : g.type) === "block-map" && !k.hasNewline && n(c, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), t.options.strict && p.start < k.found.offset - 1024 && n(v.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const _ = g ? r(t, g, k, n) : e(t, c, m, null, k, n);
      t.schema.compat && yh(s.indent, g, n), c = _.range[2];
      const w = new xt(v, _);
      t.options.keepSourceTokens && (w.srcToken = d), l.items.push(w);
    } else {
      y && n(v.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), k.comment && (v.comment ? v.comment += `
` + k.comment : v.comment = k.comment);
      const _ = new xt(v);
      t.options.keepSourceTokens && (_.srcToken = d), l.items.push(_);
    }
  }
  return u && u < c && n(u, "IMPOSSIBLE", "Map comment with trailing content"), l.range = [s.offset, c, u ?? c], l;
}
function WD({ composeNode: r, composeEmptyNode: e }, t, s, n, o) {
  const i = (o == null ? void 0 : o.nodeClass) ?? Us, a = new i(t.schema);
  t.atRoot && (t.atRoot = !1);
  let l = s.offset, c = null;
  for (const { start: u, value: d } of s.items) {
    const h = _o(u, {
      indicator: "seq-item-ind",
      next: d,
      offset: l,
      onError: n,
      startOnNewline: !0
    });
    if (!h.found)
      if (h.anchor || h.tag || d)
        d && d.type === "block-seq" ? n(h.end, "BAD_INDENT", "All sequence items must start at the same column") : n(l, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        c = h.end, h.comment && (a.comment = h.comment);
        continue;
      }
    const f = d ? r(t, d, h, n) : e(t, h.end, u, null, h, n);
    t.schema.compat && yh(s.indent, d, n), l = f.range[2], a.items.push(f);
  }
  return a.range = [s.offset, l, c ?? l], a;
}
function Ea(r, e, t, s) {
  let n = "";
  if (r) {
    let o = !1, i = "";
    for (const a of r) {
      const { source: l, type: c } = a;
      switch (c) {
        case "space":
          o = !0;
          break;
        case "comment": {
          t && !o && s(a, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const u = l.substring(1) || " ";
          n ? n += i + u : n = u, i = "";
          break;
        }
        case "newline":
          n && (i += l), o = !0;
          break;
        default:
          s(a, "UNEXPECTED_TOKEN", `Unexpected ${c} at node end`);
      }
      e += l.length;
    }
  }
  return { comment: n, offset: e };
}
const zu = "Block collections are not allowed within flow collections", qu = (r) => r && (r.type === "block-map" || r.type === "block-seq");
function GD({ composeNode: r, composeEmptyNode: e }, t, s, n, o) {
  const i = s.start.source === "{", a = i ? "flow map" : "flow sequence", l = (o == null ? void 0 : o.nodeClass) ?? (i ? Ht : Us), c = new l(t.schema);
  c.flow = !0;
  const u = t.atRoot;
  u && (t.atRoot = !1);
  let d = s.offset + s.start.source.length;
  for (let p = 0; p < s.items.length; ++p) {
    const y = s.items[p], { start: b, key: v, sep: k, value: _ } = y, w = _o(b, {
      flow: a,
      indicator: "explicit-key-ind",
      next: v ?? (k == null ? void 0 : k[0]),
      offset: d,
      onError: n,
      startOnNewline: !1
    });
    if (!w.found) {
      if (!w.anchor && !w.tag && !k && !_) {
        p === 0 && w.comma ? n(w.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`) : p < s.items.length - 1 && n(w.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${a}`), w.comment && (c.comment ? c.comment += `
` + w.comment : c.comment = w.comment), d = w.end;
        continue;
      }
      !i && t.options.strict && sa(v) && n(
        v,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (p === 0)
      w.comma && n(w.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`);
    else if (w.comma || n(w.start, "MISSING_CHAR", `Missing , between ${a} items`), w.comment) {
      let x = "";
      e:
        for (const T of b)
          switch (T.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              x = T.source.substring(1);
              break e;
            default:
              break e;
          }
      if (x) {
        let T = c.items[c.items.length - 1];
        Ye(T) && (T = T.value ?? T.key), T.comment ? T.comment += `
` + x : T.comment = x, w.comment = w.comment.substring(x.length + 1);
      }
    }
    if (!i && !k && !w.found) {
      const x = _ ? r(t, _, w, n) : e(t, w.end, k, null, w, n);
      c.items.push(x), d = x.range[2], qu(_) && n(x.range, "BLOCK_IN_FLOW", zu);
    } else {
      const x = w.end, T = v ? r(t, v, w, n) : e(t, x, b, null, w, n);
      qu(v) && n(T.range, "BLOCK_IN_FLOW", zu);
      const j = _o(k ?? [], {
        flow: a,
        indicator: "map-value-ind",
        next: _,
        offset: T.range[2],
        onError: n,
        startOnNewline: !1
      });
      if (j.found) {
        if (!i && !w.found && t.options.strict) {
          if (k)
            for (const L of k) {
              if (L === j.found)
                break;
              if (L.type === "newline") {
                n(L, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          w.start < j.found.offset - 1024 && n(j.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else
        _ && ("source" in _ && _.source && _.source[0] === ":" ? n(_, "MISSING_CHAR", `Missing space after : in ${a}`) : n(j.start, "MISSING_CHAR", `Missing , or : between ${a} items`));
      const B = _ ? r(t, _, j, n) : j.found ? e(t, j.end, k, null, j, n) : null;
      B ? qu(_) && n(B.range, "BLOCK_IN_FLOW", zu) : j.comment && (T.comment ? T.comment += `
` + j.comment : T.comment = j.comment);
      const W = new xt(T, B);
      if (t.options.keepSourceTokens && (W.srcToken = y), i) {
        const L = c;
        $1(t, L.items, T) && n(x, "DUPLICATE_KEY", "Map keys must be unique"), L.items.push(W);
      } else {
        const L = new Ht(t.schema);
        L.flow = !0, L.items.push(W), c.items.push(L);
      }
      d = B ? B.range[2] : j.end;
    }
  }
  const h = i ? "}" : "]", [f, ...m] = s.end;
  let g = d;
  if (f && f.source === h)
    g = f.offset + f.source.length;
  else {
    const p = a[0].toUpperCase() + a.substring(1), y = u ? `${p} must end with a ${h}` : `${p} in block collection must be sufficiently indented and end with a ${h}`;
    n(d, u ? "MISSING_CHAR" : "BAD_INDENT", y), f && f.source.length !== 1 && m.unshift(f);
  }
  if (m.length > 0) {
    const p = Ea(m, g, t.options.strict, n);
    p.comment && (c.comment ? c.comment += `
` + p.comment : c.comment = p.comment), c.range = [s.offset, g, p.offset];
  } else
    c.range = [s.offset, g, g];
  return c;
}
function Hu(r, e, t, s, n, o) {
  const i = t.type === "block-map" ? KD(r, e, t, s, o) : t.type === "block-seq" ? WD(r, e, t, s, o) : GD(r, e, t, s, o), a = i.constructor;
  return n === "!" || n === a.tagName ? (i.tag = a.tagName, i) : (n && (i.tag = n), i);
}
function JD(r, e, t, s, n) {
  var o;
  const i = s ? e.directives.tagName(s.source, (h) => n(s, "TAG_RESOLVE_FAILED", h)) : null, a = t.type === "block-map" ? "map" : t.type === "block-seq" ? "seq" : t.start.source === "{" ? "map" : "seq";
  if (!s || !i || i === "!" || i === Ht.tagName && a === "map" || i === Us.tagName && a === "seq" || !a)
    return Hu(r, e, t, n, i);
  let l = e.schema.tags.find((h) => h.tag === i && h.collection === a);
  if (!l) {
    const h = e.schema.knownTags[i];
    if (h && h.collection === a)
      e.schema.tags.push(Object.assign({}, h, { default: !1 })), l = h;
    else
      return h != null && h.collection ? n(s, "BAD_COLLECTION_TYPE", `${h.tag} used for ${a} collection, but expects ${h.collection}`, !0) : n(s, "TAG_RESOLVE_FAILED", `Unresolved tag: ${i}`, !0), Hu(r, e, t, n, i);
  }
  const c = Hu(r, e, t, n, i, l), u = ((o = l.resolve) == null ? void 0 : o.call(l, c, (h) => n(s, "TAG_RESOLVE_FAILED", h), e.options)) ?? c, d = st(u) ? u : new $e(u);
  return d.range = c.range, d.tag = i, l != null && l.format && (d.format = l.format), d;
}
function _1(r, e, t) {
  const s = r.offset, n = YD(r, e, t);
  if (!n)
    return { value: "", type: null, comment: "", range: [s, s, s] };
  const o = n.mode === ">" ? $e.BLOCK_FOLDED : $e.BLOCK_LITERAL, i = r.source ? XD(r.source) : [];
  let a = i.length;
  for (let g = i.length - 1; g >= 0; --g) {
    const p = i[g][1];
    if (p === "" || p === "\r")
      a = g;
    else
      break;
  }
  if (a === 0) {
    const g = n.chomp === "+" && i.length > 0 ? `
`.repeat(Math.max(1, i.length - 1)) : "";
    let p = s + n.length;
    return r.source && (p += r.source.length), { value: g, type: o, comment: n.comment, range: [s, p, p] };
  }
  let l = r.indent + n.indent, c = r.offset + n.length, u = 0;
  for (let g = 0; g < a; ++g) {
    const [p, y] = i[g];
    if (y === "" || y === "\r")
      n.indent === 0 && p.length > l && (l = p.length);
    else {
      p.length < l && t(c + p.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), n.indent === 0 && (l = p.length), u = g;
      break;
    }
    c += p.length + y.length + 1;
  }
  for (let g = i.length - 1; g >= a; --g)
    i[g][0].length > l && (a = g + 1);
  let d = "", h = "", f = !1;
  for (let g = 0; g < u; ++g)
    d += i[g][0].slice(l) + `
`;
  for (let g = u; g < a; ++g) {
    let [p, y] = i[g];
    c += p.length + y.length + 1;
    const b = y[y.length - 1] === "\r";
    if (b && (y = y.slice(0, -1)), y && p.length < l) {
      const v = `Block scalar lines must not be less indented than their ${n.indent ? "explicit indentation indicator" : "first line"}`;
      t(c - y.length - (b ? 2 : 1), "BAD_INDENT", v), p = "";
    }
    o === $e.BLOCK_LITERAL ? (d += h + p.slice(l) + y, h = `
`) : p.length > l || y[0] === "	" ? (h === " " ? h = `
` : !f && h === `
` && (h = `

`), d += h + p.slice(l) + y, h = `
`, f = !0) : y === "" ? h === `
` ? d += `
` : h = `
` : (d += h + y, h = " ", f = !1);
  }
  switch (n.chomp) {
    case "-":
      break;
    case "+":
      for (let g = a; g < i.length; ++g)
        d += `
` + i[g][0].slice(l);
      d[d.length - 1] !== `
` && (d += `
`);
      break;
    default:
      d += `
`;
  }
  const m = s + n.length + r.source.length;
  return { value: d, type: o, comment: n.comment, range: [s, m, m] };
}
function YD({ offset: r, props: e }, t, s) {
  if (e[0].type !== "block-scalar-header")
    return s(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: n } = e[0], o = n[0];
  let i = 0, a = "", l = -1;
  for (let h = 1; h < n.length; ++h) {
    const f = n[h];
    if (!a && (f === "-" || f === "+"))
      a = f;
    else {
      const m = Number(f);
      !i && m ? i = m : l === -1 && (l = r + h);
    }
  }
  l !== -1 && s(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${n}`);
  let c = !1, u = "", d = n.length;
  for (let h = 1; h < e.length; ++h) {
    const f = e[h];
    switch (f.type) {
      case "space":
        c = !0;
      case "newline":
        d += f.source.length;
        break;
      case "comment":
        t && !c && s(f, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), d += f.source.length, u = f.source.substring(1);
        break;
      case "error":
        s(f, "UNEXPECTED_TOKEN", f.message), d += f.source.length;
        break;
      default: {
        const m = `Unexpected token in block scalar header: ${f.type}`;
        s(f, "UNEXPECTED_TOKEN", m);
        const g = f.source;
        g && typeof g == "string" && (d += g.length);
      }
    }
  }
  return { mode: o, indent: i, chomp: a, comment: u, length: d };
}
function XD(r) {
  const e = r.split(/\n( *)/), t = e[0], s = t.match(/^( *)/), n = [s != null && s[1] ? [s[1], t.slice(s[1].length)] : ["", t]];
  for (let o = 1; o < e.length; o += 2)
    n.push([e[o], e[o + 1]]);
  return n;
}
function x1(r, e, t) {
  const { offset: s, type: n, source: o, end: i } = r;
  let a, l;
  const c = (h, f, m) => t(s + h, f, m);
  switch (n) {
    case "scalar":
      a = $e.PLAIN, l = QD(o, c);
      break;
    case "single-quoted-scalar":
      a = $e.QUOTE_SINGLE, l = ZD(o, c);
      break;
    case "double-quoted-scalar":
      a = $e.QUOTE_DOUBLE, l = eR(o, c);
      break;
    default:
      return t(r, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${n}`), {
        value: "",
        type: null,
        comment: "",
        range: [s, s + o.length, s + o.length]
      };
  }
  const u = s + o.length, d = Ea(i, u, e, t);
  return {
    value: l,
    type: a,
    comment: d.comment,
    range: [s, u, d.offset]
  };
}
function QD(r, e) {
  let t = "";
  switch (r[0]) {
    case "	":
      t = "a tab character";
      break;
    case ",":
      t = "flow indicator character ,";
      break;
    case "%":
      t = "directive indicator character %";
      break;
    case "|":
    case ">": {
      t = `block scalar indicator ${r[0]}`;
      break;
    }
    case "@":
    case "`": {
      t = `reserved character ${r[0]}`;
      break;
    }
  }
  return t && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${t}`), C1(r);
}
function ZD(r, e) {
  return (r[r.length - 1] !== "'" || r.length === 1) && e(r.length, "MISSING_CHAR", "Missing closing 'quote"), C1(r.slice(1, -1)).replace(/''/g, "'");
}
function C1(r) {
  let e, t;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), t = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, t = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let s = e.exec(r);
  if (!s)
    return r;
  let n = s[1], o = " ", i = e.lastIndex;
  for (t.lastIndex = i; s = t.exec(r); )
    s[1] === "" ? o === `
` ? n += o : o = `
` : (n += o + s[1], o = " "), i = t.lastIndex;
  const a = /[ \t]*(.*)/sy;
  return a.lastIndex = i, s = a.exec(r), n + o + ((s == null ? void 0 : s[1]) ?? "");
}
function eR(r, e) {
  let t = "";
  for (let s = 1; s < r.length - 1; ++s) {
    const n = r[s];
    if (!(n === "\r" && r[s + 1] === `
`))
      if (n === `
`) {
        const { fold: o, offset: i } = tR(r, s);
        t += o, s = i;
      } else if (n === "\\") {
        let o = r[++s];
        const i = rR[o];
        if (i)
          t += i;
        else if (o === `
`)
          for (o = r[s + 1]; o === " " || o === "	"; )
            o = r[++s + 1];
        else if (o === "\r" && r[s + 1] === `
`)
          for (o = r[++s + 1]; o === " " || o === "	"; )
            o = r[++s + 1];
        else if (o === "x" || o === "u" || o === "U") {
          const a = { x: 2, u: 4, U: 8 }[o];
          t += sR(r, s + 1, a, e), s += a;
        } else {
          const a = r.substr(s - 1, 2);
          e(s - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), t += a;
        }
      } else if (n === " " || n === "	") {
        const o = s;
        let i = r[s + 1];
        for (; i === " " || i === "	"; )
          i = r[++s + 1];
        i !== `
` && !(i === "\r" && r[s + 2] === `
`) && (t += s > o ? r.slice(o, s + 1) : n);
      } else
        t += n;
  }
  return (r[r.length - 1] !== '"' || r.length === 1) && e(r.length, "MISSING_CHAR", 'Missing closing "quote'), t;
}
function tR(r, e) {
  let t = "", s = r[e + 1];
  for (; (s === " " || s === "	" || s === `
` || s === "\r") && !(s === "\r" && r[e + 2] !== `
`); )
    s === `
` && (t += `
`), e += 1, s = r[e + 1];
  return t || (t = " "), { fold: t, offset: e };
}
const rR = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: " ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function sR(r, e, t, s) {
  const n = r.substr(e, t), o = n.length === t && /^[0-9a-fA-F]+$/.test(n) ? parseInt(n, 16) : NaN;
  if (isNaN(o)) {
    const i = r.substr(e - 2, t + 2);
    return s(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${i}`), i;
  }
  return String.fromCodePoint(o);
}
function A1(r, e, t, s) {
  const { value: n, type: o, comment: i, range: a } = e.type === "block-scalar" ? _1(e, r.options.strict, s) : x1(e, r.options.strict, s), l = t ? r.directives.tagName(t.source, (d) => s(t, "TAG_RESOLVE_FAILED", d)) : null, c = t && l ? nR(r.schema, n, l, t, s) : e.type === "scalar" ? oR(r, n, e, s) : r.schema[ds];
  let u;
  try {
    const d = c.resolve(n, (h) => s(t ?? e, "TAG_RESOLVE_FAILED", h), r.options);
    u = ze(d) ? d : new $e(d);
  } catch (d) {
    const h = d instanceof Error ? d.message : String(d);
    s(t ?? e, "TAG_RESOLVE_FAILED", h), u = new $e(n);
  }
  return u.range = a, u.source = n, o && (u.type = o), l && (u.tag = l), c.format && (u.format = c.format), i && (u.comment = i), u;
}
function nR(r, e, t, s, n) {
  var o;
  if (t === "!")
    return r[ds];
  const i = [];
  for (const l of r.tags)
    if (!l.collection && l.tag === t)
      if (l.default && l.test)
        i.push(l);
      else
        return l;
  for (const l of i)
    if ((o = l.test) != null && o.test(e))
      return l;
  const a = r.knownTags[t];
  return a && !a.collection ? (r.tags.push(Object.assign({}, a, { default: !1, test: void 0 })), a) : (n(s, "TAG_RESOLVE_FAILED", `Unresolved tag: ${t}`, t !== "tag:yaml.org,2002:str"), r[ds]);
}
function oR({ directives: r, schema: e }, t, s, n) {
  const o = e.tags.find((i) => {
    var a;
    return i.default && ((a = i.test) == null ? void 0 : a.test(t));
  }) || e[ds];
  if (e.compat) {
    const i = e.compat.find((a) => {
      var l;
      return a.default && ((l = a.test) == null ? void 0 : l.test(t));
    }) ?? e[ds];
    if (o.tag !== i.tag) {
      const a = r.tagString(o.tag), l = r.tagString(i.tag), c = `Value may be parsed as either ${a} or ${l}`;
      n(s, "TAG_RESOLVE_FAILED", c, !0);
    }
  }
  return o;
}
function iR(r, e, t) {
  if (e) {
    t === null && (t = e.length);
    for (let s = t - 1; s >= 0; --s) {
      let n = e[s];
      switch (n.type) {
        case "space":
        case "comment":
        case "newline":
          r -= n.source.length;
          continue;
      }
      for (n = e[++s]; (n == null ? void 0 : n.type) === "space"; )
        r += n.source.length, n = e[++s];
      break;
    }
  }
  return r;
}
const aR = { composeNode: E1, composeEmptyNode: gp };
function E1(r, e, t, s) {
  const { spaceBefore: n, comment: o, anchor: i, tag: a } = t;
  let l, c = !0;
  switch (e.type) {
    case "alias":
      l = lR(r, e, s), (i || a) && s(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      l = A1(r, e, a, s), i && (l.anchor = i.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      l = JD(aR, r, e, a, s), i && (l.anchor = i.source.substring(1));
      break;
    default: {
      const u = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      s(e, "UNEXPECTED_TOKEN", u), l = gp(r, e.offset, void 0, null, t, s), c = !1;
    }
  }
  return i && l.anchor === "" && s(i, "BAD_ALIAS", "Anchor cannot be an empty string"), n && (l.spaceBefore = !0), o && (e.type === "scalar" && e.source === "" ? l.comment = o : l.commentBefore = o), r.options.keepSourceTokens && c && (l.srcToken = e), l;
}
function gp(r, e, t, s, { spaceBefore: n, comment: o, anchor: i, tag: a, end: l }, c) {
  const u = {
    type: "scalar",
    offset: iR(e, t, s),
    indent: -1,
    source: ""
  }, d = A1(r, u, a, c);
  return i && (d.anchor = i.source.substring(1), d.anchor === "" && c(i, "BAD_ALIAS", "Anchor cannot be an empty string")), n && (d.spaceBefore = !0), o && (d.comment = o, d.range[2] = l), d;
}
function lR({ options: r }, { offset: e, source: t, end: s }, n) {
  const o = new Gc(t.substring(1));
  o.source === "" && n(e, "BAD_ALIAS", "Alias cannot be an empty string"), o.source.endsWith(":") && n(e + t.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const i = e + t.length, a = Ea(s, i, r.strict, n);
  return o.range = [e, i, a.offset], a.comment && (o.comment = a.comment), o;
}
function cR(r, e, { offset: t, start: s, value: n, end: o }, i) {
  const a = Object.assign({ _directives: e }, r), l = new Ko(void 0, a), c = {
    atRoot: !0,
    directives: l.directives,
    options: l.options,
    schema: l.schema
  }, u = _o(s, {
    indicator: "doc-start",
    next: n ?? (o == null ? void 0 : o[0]),
    offset: t,
    onError: i,
    startOnNewline: !0
  });
  u.found && (l.directives.docStart = !0, n && (n.type === "block-map" || n.type === "block-seq") && !u.hasNewline && i(u.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l.contents = n ? E1(c, n, u, i) : gp(c, u.end, s, null, u, i);
  const d = l.contents.range[2], h = Ea(o, d, !1, i);
  return h.comment && (l.comment = h.comment), l.range = [t, d, h.offset], l;
}
function yi(r) {
  if (typeof r == "number")
    return [r, r + 1];
  if (Array.isArray(r))
    return r.length === 2 ? r : [r[0], r[1]];
  const { offset: e, source: t } = r;
  return [e, e + (typeof t == "string" ? t.length : 1)];
}
function m0(r) {
  var e;
  let t = "", s = !1, n = !1;
  for (let o = 0; o < r.length; ++o) {
    const i = r[o];
    switch (i[0]) {
      case "#":
        t += (t === "" ? "" : n ? `

` : `
`) + (i.substring(1) || " "), s = !0, n = !1;
        break;
      case "%":
        ((e = r[o + 1]) == null ? void 0 : e[0]) !== "#" && (o += 1), s = !1;
        break;
      default:
        s || (n = !0), s = !1;
    }
  }
  return { comment: t, afterEmptyLine: n };
}
class yp {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (t, s, n, o) => {
      const i = yi(t);
      o ? this.warnings.push(new S1(i, s, n)) : this.errors.push(new hn(i, s, n));
    }, this.directives = new Ot({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, t) {
    const { comment: s, afterEmptyLine: n } = m0(this.prelude);
    if (s) {
      const o = e.contents;
      if (t)
        e.comment = e.comment ? `${e.comment}
${s}` : s;
      else if (n || e.directives.docStart || !o)
        e.commentBefore = s;
      else if (Qe(o) && !o.flow && o.items.length > 0) {
        let i = o.items[0];
        Ye(i) && (i = i.key);
        const a = i.commentBefore;
        i.commentBefore = a ? `${s}
${a}` : s;
      } else {
        const i = o.commentBefore;
        o.commentBefore = i ? `${s}
${i}` : s;
      }
    }
    t ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: m0(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, t = !1, s = -1) {
    for (const n of e)
      yield* this.next(n);
    yield* this.end(t, s);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (t, s, n) => {
          const o = yi(e);
          o[0] += t, this.onError(o, "BAD_DIRECTIVE", s, n);
        }), this.prelude.push(e.source), this.atDirectives = !0;
        break;
      case "document": {
        const t = cR(this.options, this.directives, e, this.onError);
        this.atDirectives && !t.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(t, !1), this.doc && (yield this.doc), this.doc = t, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const t = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, s = new hn(yi(e), "UNEXPECTED_TOKEN", t);
        this.atDirectives || !this.doc ? this.errors.push(s) : this.doc.errors.push(s);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const s = "Unexpected doc-end without preceding document";
          this.errors.push(new hn(yi(e), "UNEXPECTED_TOKEN", s));
          break;
        }
        this.doc.directives.docEnd = !0;
        const t = Ea(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), t.comment) {
          const s = this.doc.comment;
          this.doc.comment = s ? `${s}
${t.comment}` : t.comment;
        }
        this.doc.range[2] = t.offset;
        break;
      }
      default:
        this.errors.push(new hn(yi(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = !1, t = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (e) {
      const s = Object.assign({ _directives: this.directives }, this.options), n = new Ko(void 0, s);
      this.atDirectives && this.onError(t, "MISSING_CHAR", "Missing directives-end indicator line"), n.range = [0, t, t], this.decorate(n, !1), yield n;
    }
  }
}
function uR(r, e = !0, t) {
  if (r) {
    const s = (n, o, i) => {
      const a = typeof n == "number" ? n : Array.isArray(n) ? n[0] : n.offset;
      if (t)
        t(a, o, i);
      else
        throw new hn([a, a + 1], o, i);
    };
    switch (r.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return x1(r, e, s);
      case "block-scalar":
        return _1(r, e, s);
    }
  }
  return null;
}
function dR(r, e) {
  const { implicitKey: t = !1, indent: s, inFlow: n = !1, offset: o = -1, type: i = "PLAIN" } = e, a = Ca({ type: i, value: r }, {
    implicitKey: t,
    indent: s > 0 ? " ".repeat(s) : "",
    inFlow: n,
    options: { blockQuote: !0, lineWidth: -1 }
  }), l = e.end ?? [
    { type: "newline", offset: -1, indent: s, source: `
` }
  ];
  switch (a[0]) {
    case "|":
    case ">": {
      const c = a.indexOf(`
`), u = a.substring(0, c), d = a.substring(c + 1) + `
`, h = [
        { type: "block-scalar-header", offset: o, indent: s, source: u }
      ];
      return O1(h, l) || h.push({ type: "newline", offset: -1, indent: s, source: `
` }), { type: "block-scalar", offset: o, indent: s, props: h, source: d };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: o, indent: s, source: a, end: l };
    case "'":
      return { type: "single-quoted-scalar", offset: o, indent: s, source: a, end: l };
    default:
      return { type: "scalar", offset: o, indent: s, source: a, end: l };
  }
}
function hR(r, e, t = {}) {
  let { afterKey: s = !1, implicitKey: n = !1, inFlow: o = !1, type: i } = t, a = "indent" in r ? r.indent : null;
  if (s && typeof a == "number" && (a += 2), !i)
    switch (r.type) {
      case "single-quoted-scalar":
        i = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        i = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const c = r.props[0];
        if (c.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        i = c.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        i = "PLAIN";
    }
  const l = Ca({ type: i, value: e }, {
    implicitKey: n || a === null,
    indent: a !== null && a > 0 ? " ".repeat(a) : "",
    inFlow: o,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (l[0]) {
    case "|":
    case ">":
      fR(r, l);
      break;
    case '"':
      Ku(r, l, "double-quoted-scalar");
      break;
    case "'":
      Ku(r, l, "single-quoted-scalar");
      break;
    default:
      Ku(r, l, "scalar");
  }
}
function fR(r, e) {
  const t = e.indexOf(`
`), s = e.substring(0, t), n = e.substring(t + 1) + `
`;
  if (r.type === "block-scalar") {
    const o = r.props[0];
    if (o.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    o.source = s, r.source = n;
  } else {
    const { offset: o } = r, i = "indent" in r ? r.indent : -1, a = [
      { type: "block-scalar-header", offset: o, indent: i, source: s }
    ];
    O1(a, "end" in r ? r.end : void 0) || a.push({ type: "newline", offset: -1, indent: i, source: `
` });
    for (const l of Object.keys(r))
      l !== "type" && l !== "offset" && delete r[l];
    Object.assign(r, { type: "block-scalar", indent: i, props: a, source: n });
  }
}
function O1(r, e) {
  if (e)
    for (const t of e)
      switch (t.type) {
        case "space":
        case "comment":
          r.push(t);
          break;
        case "newline":
          return r.push(t), !0;
      }
  return !1;
}
function Ku(r, e, t) {
  switch (r.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      r.type = t, r.source = e;
      break;
    case "block-scalar": {
      const s = r.props.slice(1);
      let n = e.length;
      r.props[0].type === "block-scalar-header" && (n -= r.props[0].source.length);
      for (const o of s)
        o.offset += n;
      delete r.props, Object.assign(r, { type: t, source: e, end: s });
      break;
    }
    case "block-map":
    case "block-seq": {
      const s = { type: "newline", offset: r.offset + e.length, indent: r.indent, source: `
` };
      delete r.items, Object.assign(r, { type: t, source: e, end: [s] });
      break;
    }
    default: {
      const s = "indent" in r ? r.indent : -1, n = "end" in r && Array.isArray(r.end) ? r.end.filter((o) => o.type === "space" || o.type === "comment" || o.type === "newline") : [];
      for (const o of Object.keys(r))
        o !== "type" && o !== "offset" && delete r[o];
      Object.assign(r, { type: t, indent: s, source: e, end: n });
    }
  }
}
const pR = (r) => "type" in r ? dc(r) : Ll(r);
function dc(r) {
  switch (r.type) {
    case "block-scalar": {
      let e = "";
      for (const t of r.props)
        e += dc(t);
      return e + r.source;
    }
    case "block-map":
    case "block-seq": {
      let e = "";
      for (const t of r.items)
        e += Ll(t);
      return e;
    }
    case "flow-collection": {
      let e = r.start.source;
      for (const t of r.items)
        e += Ll(t);
      for (const t of r.end)
        e += t.source;
      return e;
    }
    case "document": {
      let e = Ll(r);
      if (r.end)
        for (const t of r.end)
          e += t.source;
      return e;
    }
    default: {
      let e = r.source;
      if ("end" in r && r.end)
        for (const t of r.end)
          e += t.source;
      return e;
    }
  }
}
function Ll({ start: r, key: e, sep: t, value: s }) {
  let n = "";
  for (const o of r)
    n += o.source;
  if (e && (n += dc(e)), t)
    for (const o of t)
      n += o.source;
  return s && (n += dc(s)), n;
}
const bh = Symbol("break visit"), mR = Symbol("skip children"), T1 = Symbol("remove item");
function Cn(r, e) {
  "type" in r && r.type === "document" && (r = { start: r.start, value: r.value }), P1(Object.freeze([]), r, e);
}
Cn.BREAK = bh;
Cn.SKIP = mR;
Cn.REMOVE = T1;
Cn.itemAtPath = (r, e) => {
  let t = r;
  for (const [s, n] of e) {
    const o = t == null ? void 0 : t[s];
    if (o && "items" in o)
      t = o.items[n];
    else
      return;
  }
  return t;
};
Cn.parentCollection = (r, e) => {
  const t = Cn.itemAtPath(r, e.slice(0, -1)), s = e[e.length - 1][0], n = t == null ? void 0 : t[s];
  if (n && "items" in n)
    return n;
  throw new Error("Parent collection not found");
};
function P1(r, e, t) {
  let s = t(e, r);
  if (typeof s == "symbol")
    return s;
  for (const n of ["key", "value"]) {
    const o = e[n];
    if (o && "items" in o) {
      for (let i = 0; i < o.items.length; ++i) {
        const a = P1(Object.freeze(r.concat([[n, i]])), o.items[i], t);
        if (typeof a == "number")
          i = a - 1;
        else {
          if (a === bh)
            return bh;
          a === T1 && (o.items.splice(i, 1), i -= 1);
        }
      }
      typeof s == "function" && n === "key" && (s = s(e, r));
    }
  }
  return typeof s == "function" ? s(e, r) : s;
}
const nu = "\uFEFF", ou = "", iu = "", na = "", gR = (r) => !!r && "items" in r, yR = (r) => !!r && (r.type === "scalar" || r.type === "single-quoted-scalar" || r.type === "double-quoted-scalar" || r.type === "block-scalar");
function bR(r) {
  switch (r) {
    case nu:
      return "<BOM>";
    case ou:
      return "<DOC>";
    case iu:
      return "<FLOW_END>";
    case na:
      return "<SCALAR>";
    default:
      return JSON.stringify(r);
  }
}
function I1(r) {
  switch (r) {
    case nu:
      return "byte-order-mark";
    case ou:
      return "doc-mode";
    case iu:
      return "flow-error-end";
    case na:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (r[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const vR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM: nu,
  DOCUMENT: ou,
  FLOW_END: iu,
  SCALAR: na,
  createScalarToken: dR,
  isCollection: gR,
  isScalar: yR,
  prettyToken: bR,
  resolveAsScalar: uR,
  setScalarValue: hR,
  stringify: pR,
  tokenType: I1,
  visit: Cn
}, Symbol.toStringTag, { value: "Module" }));
function Xt(r) {
  switch (r) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const g0 = "0123456789ABCDEFabcdef".split(""), wR = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split(""), Wu = ",[]{}".split(""), kR = ` ,[]{}
\r	`.split(""), Gu = (r) => !r || kR.includes(r);
class N1 {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, t = !1) {
    e && (this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null), this.atEnd = !t;
    let s = this.next ?? "stream";
    for (; s && (t || this.hasChars(1)); )
      s = yield* this.parseNext(s);
  }
  atLineEnd() {
    let e = this.pos, t = this.buffer[e];
    for (; t === " " || t === "	"; )
      t = this.buffer[++e];
    return !t || t === "#" || t === `
` ? !0 : t === "\r" ? this.buffer[e + 1] === `
` : !1;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let t = this.buffer[e];
    if (this.indentNext > 0) {
      let s = 0;
      for (; t === " "; )
        t = this.buffer[++s + e];
      if (t === "\r") {
        const n = this.buffer[s + e + 1];
        if (n === `
` || !n && !this.atEnd)
          return e + s + 1;
      }
      return t === `
` || s >= this.indentNext || !t && !this.atEnd ? e + s : -1;
    }
    if (t === "-" || t === ".") {
      const s = this.buffer.substr(e, 3);
      if ((s === "---" || s === "...") && Xt(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === nu && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let t = e.length;
      const s = e.indexOf("#");
      if (s !== -1) {
        const o = e[s - 1];
        (o === " " || o === "	") && (t = s - 1);
      }
      for (; ; ) {
        const o = e[t - 1];
        if (o === " " || o === "	")
          t -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(t)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(e.length - n), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const t = yield* this.pushSpaces(!0);
      return yield* this.pushCount(e.length - t), yield* this.pushNewline(), "stream";
    }
    return yield ou, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const t = this.peek(3);
      if (t === "---" && Xt(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, "doc";
      if (t === "..." && Xt(this.charAt(3)))
        return yield* this.pushCount(3), "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !Xt(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, t] = this.peek(2);
    if (!t && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && Xt(t)) {
      const s = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += s, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let t = yield* this.pushIndicators();
    switch (e[t]) {
      case "#":
        yield* this.pushCount(e.length - t);
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(Gu), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return t += yield* this.parseBlockScalarHeader(), t += yield* this.pushSpaces(!0), yield* this.pushCount(e.length - t), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, t, s = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (t = yield* this.pushSpaces(!1), this.indentValue = s = t) : t = 0, t += yield* this.pushSpaces(!0);
    while (e + t > 0);
    const n = this.getLine();
    if (n === null)
      return this.setNext("flow");
    if ((s !== -1 && s < this.indentNext && n[0] !== "#" || s === 0 && (n.startsWith("---") || n.startsWith("...")) && Xt(n[3])) && !(s === this.indentNext - 1 && this.flowLevel === 1 && (n[0] === "]" || n[0] === "}")))
      return this.flowLevel = 0, yield iu, yield* this.parseLineStart();
    let o = 0;
    for (; n[o] === ","; )
      o += yield* this.pushCount(1), o += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (o += yield* this.pushIndicators(), n[o]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(n.length - o), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(Gu), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const i = this.charAt(1);
        if (this.flowKey || Xt(i) || i === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let t = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; t !== -1 && this.buffer[t + 1] === "'"; )
        t = this.buffer.indexOf("'", t + 2);
    else
      for (; t !== -1; ) {
        let o = 0;
        for (; this.buffer[t - 1 - o] === "\\"; )
          o += 1;
        if (o % 2 === 0)
          break;
        t = this.buffer.indexOf('"', t + 1);
      }
    const s = this.buffer.substring(0, t);
    let n = s.indexOf(`
`, this.pos);
    if (n !== -1) {
      for (; n !== -1; ) {
        const o = this.continueScalar(n + 1);
        if (o === -1)
          break;
        n = s.indexOf(`
`, o);
      }
      n !== -1 && (t = n - (s[n - 1] === "\r" ? 2 : 1));
    }
    if (t === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      t = this.buffer.length;
    }
    return yield* this.pushToIndex(t + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let e = this.pos;
    for (; ; ) {
      const t = this.buffer[++e];
      if (t === "+")
        this.blockScalarKeep = !0;
      else if (t > "0" && t <= "9")
        this.blockScalarIndent = Number(t) - 1;
      else if (t !== "-")
        break;
    }
    return yield* this.pushUntil((t) => Xt(t) || t === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, t = 0, s;
    e:
      for (let n = this.pos; s = this.buffer[n]; ++n)
        switch (s) {
          case " ":
            t += 1;
            break;
          case `
`:
            e = n, t = 0;
            break;
          case "\r": {
            const o = this.buffer[n + 1];
            if (!o && !this.atEnd)
              return this.setNext("block-scalar");
            if (o === `
`)
              break;
          }
          default:
            break e;
        }
    if (!s && !this.atEnd)
      return this.setNext("block-scalar");
    if (t >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = t : this.indentNext += this.blockScalarIndent;
      do {
        const n = this.continueScalar(e + 1);
        if (n === -1)
          break;
        e = this.buffer.indexOf(`
`, n);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep)
      do {
        let n = e - 1, o = this.buffer[n];
        o === "\r" && (o = this.buffer[--n]);
        const i = n;
        for (; o === " " || o === "	"; )
          o = this.buffer[--n];
        if (o === `
` && n >= this.pos && n + 1 + t > i)
          e = n;
        else
          break;
      } while (!0);
    return yield na, yield* this.pushToIndex(e + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let t = this.pos - 1, s = this.pos - 1, n;
    for (; n = this.buffer[++s]; )
      if (n === ":") {
        const o = this.buffer[s + 1];
        if (Xt(o) || e && o === ",")
          break;
        t = s;
      } else if (Xt(n)) {
        let o = this.buffer[s + 1];
        if (n === "\r" && (o === `
` ? (s += 1, n = `
`, o = this.buffer[s + 1]) : t = s), o === "#" || e && Wu.includes(o))
          break;
        if (n === `
`) {
          const i = this.continueScalar(s + 1);
          if (i === -1)
            break;
          s = Math.max(s, i - 2);
        }
      } else {
        if (e && Wu.includes(n))
          break;
        t = s;
      }
    return !n && !this.atEnd ? this.setNext("plain-scalar") : (yield na, yield* this.pushToIndex(t + 1, !0), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, t) {
    const s = this.buffer.slice(this.pos, e);
    return s ? (yield s, this.pos += s.length, s.length) : (t && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(Gu)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const e = this.flowLevel > 0, t = this.charAt(1);
        if (Xt(t) || e && Wu.includes(t))
          return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, t = this.buffer[e];
      for (; !Xt(t) && t !== ">"; )
        t = this.buffer[++e];
      return yield* this.pushToIndex(t === ">" ? e + 1 : e, !1);
    } else {
      let e = this.pos + 1, t = this.buffer[e];
      for (; t; )
        if (wR.includes(t))
          t = this.buffer[++e];
        else if (t === "%" && g0.includes(this.buffer[e + 1]) && g0.includes(this.buffer[e + 2]))
          t = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, !1);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let t = this.pos - 1, s;
    do
      s = this.buffer[++t];
    while (s === " " || e && s === "	");
    const n = t - this.pos;
    return n > 0 && (yield this.buffer.substr(this.pos, n), this.pos = t), n;
  }
  *pushUntil(e) {
    let t = this.pos, s = this.buffer[t];
    for (; !e(s); )
      s = this.buffer[++t];
    return yield* this.pushToIndex(t, !1);
  }
}
class M1 {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let t = 0, s = this.lineStarts.length;
      for (; t < s; ) {
        const o = t + s >> 1;
        this.lineStarts[o] < e ? t = o + 1 : s = o;
      }
      if (this.lineStarts[t] === e)
        return { line: t + 1, col: 1 };
      if (t === 0)
        return { line: 0, col: e };
      const n = this.lineStarts[t - 1];
      return { line: t, col: e - n + 1 };
    };
  }
}
function hr(r, e) {
  for (let t = 0; t < r.length; ++t)
    if (r[t].type === e)
      return !0;
  return !1;
}
function y0(r) {
  for (let e = 0; e < r.length; ++e)
    switch (r[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function D1(r) {
  switch (r == null ? void 0 : r.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function pl(r) {
  switch (r.type) {
    case "document":
      return r.start;
    case "block-map": {
      const e = r.items[r.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return r.items[r.items.length - 1].start;
    default:
      return [];
  }
}
function qn(r) {
  var e;
  if (r.length === 0)
    return [];
  let t = r.length;
  e:
    for (; --t >= 0; )
      switch (r[t].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break e;
      }
  for (; ((e = r[++t]) == null ? void 0 : e.type) === "space"; )
    ;
  return r.splice(t, r.length);
}
function b0(r) {
  if (r.start.type === "flow-seq-start")
    for (const e of r.items)
      e.sep && !e.value && !hr(e.start, "explicit-key-ind") && !hr(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, D1(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
class bp {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new N1(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, t = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const s of this.lexer.lex(e, t))
      yield* this.next(s);
    t || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += e.length;
      return;
    }
    const t = I1(e);
    if (t)
      if (t === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = t, yield* this.step(), t) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += e.length;
      }
    else {
      const s = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: s, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const t = e ?? this.stack.pop();
    if (!t)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield t;
    else {
      const s = this.peek(1);
      switch (t.type === "block-scalar" ? t.indent = "indent" in s ? s.indent : 0 : t.type === "flow-collection" && s.type === "document" && (t.indent = 0), t.type === "flow-collection" && b0(t), s.type) {
        case "document":
          s.value = t;
          break;
        case "block-scalar":
          s.props.push(t);
          break;
        case "block-map": {
          const n = s.items[s.items.length - 1];
          if (n.value) {
            s.items.push({ start: [], key: t, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (n.sep)
            n.value = t;
          else {
            Object.assign(n, { key: t, sep: [] }), this.onKeyLine = !hr(n.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const n = s.items[s.items.length - 1];
          n.value ? s.items.push({ start: [], value: t }) : n.value = t;
          break;
        }
        case "flow-collection": {
          const n = s.items[s.items.length - 1];
          !n || n.value ? s.items.push({ start: [], key: t, sep: [] }) : n.sep ? n.value = t : Object.assign(n, { key: t, sep: [] });
          return;
        }
        default:
          yield* this.pop(), yield* this.pop(t);
      }
      if ((s.type === "document" || s.type === "block-map" || s.type === "block-seq") && (t.type === "block-map" || t.type === "block-seq")) {
        const n = t.items[t.items.length - 1];
        n && !n.sep && !n.value && n.start.length > 0 && y0(n.start) === -1 && (t.indent === 0 || n.start.every((o) => o.type !== "comment" || o.indent < t.indent)) && (s.type === "document" ? s.end = n.start : s.items.push({ start: n.start }), t.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        y0(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const t = this.startBlockValue(e);
    t ? this.stack.push(t) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const t = pl(this.peek(2)), s = qn(t);
      let n;
      e.end ? (n = e.end, n.push(this.sourceToken), delete e.end) : n = [this.sourceToken];
      const o = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: s, key: e, sep: n }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = o;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let t = this.source.indexOf(`
`) + 1;
          for (; t !== 0; )
            this.onNewLine(this.offset + t), t = this.source.indexOf(`
`, t) + 1;
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    var t;
    const s = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, s.value) {
          const n = "end" in s.value ? s.value.end : void 0, o = Array.isArray(n) ? n[n.length - 1] : void 0;
          (o == null ? void 0 : o.type) === "comment" ? n == null || n.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          s.sep ? s.sep.push(this.sourceToken) : s.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (s.value)
          e.items.push({ start: [this.sourceToken] });
        else if (s.sep)
          s.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(s.start, e.indent)) {
            const n = e.items[e.items.length - 2], o = (t = n == null ? void 0 : n.value) == null ? void 0 : t.end;
            if (Array.isArray(o)) {
              Array.prototype.push.apply(o, s.start), o.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          s.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const n = !this.onKeyLine && this.indent === e.indent && s.sep && this.type !== "seq-item-ind";
      let o = [];
      if (n && s.sep && !s.value) {
        const i = [];
        for (let a = 0; a < s.sep.length; ++a) {
          const l = s.sep[a];
          switch (l.type) {
            case "newline":
              i.push(a);
              break;
            case "space":
              break;
            case "comment":
              l.indent > e.indent && (i.length = 0);
              break;
            default:
              i.length = 0;
          }
        }
        i.length >= 2 && (o = s.sep.splice(i[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          n || s.value ? (o.push(this.sourceToken), e.items.push({ start: o }), this.onKeyLine = !0) : s.sep ? s.sep.push(this.sourceToken) : s.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !s.sep && !hr(s.start, "explicit-key-ind") ? s.start.push(this.sourceToken) : n || s.value ? (o.push(this.sourceToken), e.items.push({ start: o })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (hr(s.start, "explicit-key-ind"))
            if (s.sep)
              if (s.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (hr(s.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: null, sep: [this.sourceToken] }]
                });
              else if (D1(s.key) && !hr(s.sep, "newline")) {
                const i = qn(s.start), a = s.key, l = s.sep;
                l.push(this.sourceToken), delete s.key, delete s.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: i, key: a, sep: l }]
                });
              } else
                o.length > 0 ? s.sep = s.sep.concat(o, this.sourceToken) : s.sep.push(this.sourceToken);
            else if (hr(s.start, "newline"))
              Object.assign(s, { key: null, sep: [this.sourceToken] });
            else {
              const i = qn(s.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: i, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            s.sep ? s.value || n ? e.items.push({ start: o, key: null, sep: [this.sourceToken] }) : hr(s.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : s.sep.push(this.sourceToken) : Object.assign(s, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          n || s.value ? (e.items.push({ start: o, key: i, sep: [] }), this.onKeyLine = !0) : s.sep ? this.stack.push(i) : (Object.assign(s, { key: i, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const i = this.startBlockValue(e);
          if (i) {
            n && i.type !== "block-seq" && hr(s.start, "explicit-key-ind") && e.items.push({ start: o }), this.stack.push(i);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    var t;
    const s = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (s.value) {
          const n = "end" in s.value ? s.value.end : void 0, o = Array.isArray(n) ? n[n.length - 1] : void 0;
          (o == null ? void 0 : o.type) === "comment" ? n == null || n.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          s.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (s.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(s.start, e.indent)) {
            const n = e.items[e.items.length - 2], o = (t = n == null ? void 0 : n.value) == null ? void 0 : t.end;
            if (Array.isArray(o)) {
              Array.prototype.push.apply(o, s.start), o.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          s.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (s.value || this.indent <= e.indent)
          break;
        s.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        s.value || hr(s.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : s.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const n = this.startBlockValue(e);
      if (n) {
        this.stack.push(n);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const t = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let s;
      do
        yield* this.pop(), s = this.peek(1);
      while (s && s.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !t || t.sep ? e.items.push({ start: [this.sourceToken] }) : t.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !t || t.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : t.sep ? t.sep.push(this.sourceToken) : Object.assign(t, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !t || t.value ? e.items.push({ start: [this.sourceToken] }) : t.sep ? t.sep.push(this.sourceToken) : t.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const n = this.flowScalar(this.type);
          !t || t.value ? e.items.push({ start: [], key: n, sep: [] }) : t.sep ? this.stack.push(n) : Object.assign(t, { key: n, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const s = this.startBlockValue(e);
      s ? this.stack.push(s) : (yield* this.pop(), yield* this.step());
    } else {
      const s = this.peek(2);
      if (s.type === "block-map" && (this.type === "map-value-ind" && s.indent === e.indent || this.type === "newline" && !s.items[s.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && s.type !== "flow-collection") {
        const n = pl(s), o = qn(n);
        b0(e);
        const i = e.end.splice(1, e.end.length);
        i.push(this.sourceToken);
        const a = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: o, key: e, sep: i }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = a;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let t = this.source.indexOf(`
`) + 1;
      for (; t !== 0; )
        this.onNewLine(this.offset + t), t = this.source.indexOf(`
`, t) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const t = pl(e), s = qn(t);
        return s.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: s }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const t = pl(e), s = qn(t);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: s, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, t) {
    return this.type !== "comment" || this.indent <= t ? !1 : e.every((s) => s.type === "newline" || s.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function R1(r) {
  const e = r.prettyErrors !== !1;
  return { lineCounter: r.lineCounter || e && new M1() || null, prettyErrors: e };
}
function SR(r, e = {}) {
  const { lineCounter: t, prettyErrors: s } = R1(e), n = new bp(t == null ? void 0 : t.addNewLine), o = new yp(e), i = Array.from(o.compose(n.parse(r)));
  if (s && t)
    for (const a of i)
      a.errors.forEach(uc(r, t)), a.warnings.forEach(uc(r, t));
  return i.length > 0 ? i : Object.assign([], { empty: !0 }, o.streamInfo());
}
function j1(r, e = {}) {
  const { lineCounter: t, prettyErrors: s } = R1(e), n = new bp(t == null ? void 0 : t.addNewLine), o = new yp(e);
  let i = null;
  for (const a of o.compose(n.parse(r), !0, r.length))
    if (!i)
      i = a;
    else if (i.options.logLevel !== "silent") {
      i.errors.push(new hn(a.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return s && t && (i.errors.forEach(uc(r, t)), i.warnings.forEach(uc(r, t))), i;
}
function $R(r, e, t) {
  let s;
  typeof e == "function" ? s = e : t === void 0 && e && typeof e == "object" && (t = e);
  const n = j1(r, t);
  if (!n)
    return null;
  if (n.warnings.forEach((o) => n1(n.options.logLevel, o)), n.errors.length > 0) {
    if (n.options.logLevel !== "silent")
      throw n.errors[0];
    n.errors = [];
  }
  return n.toJS(Object.assign({ reviver: s }, t));
}
function _R(r, e, t) {
  let s = null;
  if (typeof e == "function" || Array.isArray(e) ? s = e : t === void 0 && e && (t = e), typeof t == "string" && (t = t.length), typeof t == "number") {
    const n = Math.round(t);
    t = n < 1 ? void 0 : n > 8 ? { indent: 8 } : { indent: n };
  }
  if (r === void 0) {
    const { keepUndefined: n } = t ?? e ?? {};
    if (!n)
      return;
  }
  return new Ko(r, s, t).toString(t);
}
const L1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: Gc,
  CST: vR,
  Composer: yp,
  Document: Ko,
  Lexer: N1,
  LineCounter: M1,
  Pair: xt,
  Parser: bp,
  Scalar: $e,
  Schema: su,
  YAMLError: mp,
  YAMLMap: Ht,
  YAMLParseError: hn,
  YAMLSeq: Us,
  YAMLWarning: S1,
  isAlias: Pn,
  isCollection: Qe,
  isDocument: Vo,
  isMap: Uo,
  isNode: st,
  isPair: Ye,
  isScalar: ze,
  isSeq: zo,
  parse: $R,
  parseAllDocuments: SR,
  parseDocument: j1,
  stringify: _R,
  visit: Vs,
  visitAsync: Wc
}, Symbol.toStringTag, { value: "Module" }));
function B1(r) {
  if (Kv(r))
    return r;
  if (typeof r == "string")
    try {
      return JSON.parse(r);
    } catch {
      return L1.parse(r);
    }
  return r;
}
function F1(r) {
  if (Kv(r))
    return r;
  const e = B1(r);
  return [
    {
      isEntrypoint: !0,
      specification: e,
      filename: "openapi.json",
      dir: "./",
      references: mD(e)
    }
  ];
}
async function xR(r) {
  const e = new kp(), t = F1(r), s = await e.validate(t), n = structuredClone(
    e.specification
  ), o = e.resolveReferences(t);
  return {
    valid: s.valid,
    version: e.version,
    errors: s.errors,
    specification: n,
    schema: o
  };
}
const CR = (r) => JSON.stringify(r, null, 2), AR = (r) => L1.stringify(r);
function ER(r) {
  var e;
  if ((e = r.openapi) != null && e.startsWith("3.0"))
    r.openapi = "3.1.0";
  else
    return r;
  return r = Mr(r, (t) => (t.type !== "undefined" && t.nullable === !0 && (t.type = ["null", t.type], delete t.nullable), t)), r = Mr(r, (t) => (t.exclusiveMinimum === !0 ? (t.exclusiveMinimum = t.minimum, delete t.minimum) : t.exclusiveMinimum === !1 && delete t.exclusiveMinimum, t.exclusiveMaximum === !0 ? (t.exclusiveMaximum = t.maximum, delete t.maximum) : t.exclusiveMaximum === !1 && delete t.exclusiveMaximum, t)), r = Mr(r, (t) => (t.example !== void 0 && (t.examples = {
    default: t.example
  }, delete t.example), t)), r = Mr(r, (t) => {
    if (t.type === "object" && t.properties !== void 0)
      for (const [s, n] of Object.entries(t.properties))
        n !== void 0 && // @ts-ignore
        n.type === "string" && // @ts-ignore
        n.format === "binary" && (n.contentEncoding = "application/octet-stream", delete n.format);
    return t;
  }), r = Mr(r, (t) => {
    if (!(t.type === "string" && t.format === "binary"))
      return t;
  }), r = Mr(r, (t) => t.type === "string" && t.format === "base64" ? {
    type: "string",
    contentEncoding: "base64"
  } : t), r;
}
function OR(r) {
  return r;
}
function TR(r) {
  return [OR, ER].reduce(
    (e, t) => t(e),
    r
  );
}
async function PR(r) {
  const e = new kp(), t = F1(r);
  return {
    ...await e.validate(t),
    specification: e.specification,
    version: e.version
  };
}
function V1(r) {
  for (const e of new Set(Hv)) {
    const t = e === "2.0" ? "swagger" : "openapi", s = r[t];
    if (typeof s == "string" && s.startsWith(e))
      return {
        version: e,
        specificationType: t,
        specificationVersion: s
      };
  }
  return {
    version: void 0,
    specificationType: void 0,
    specificationVersion: void 0
  };
}
function IR(r) {
  return decodeURI(r.replace(/~1/g, "/").replace(/~0/g, "~"));
}
function U1(r) {
  const e = structuredClone(r);
  return t(e), t(e), e;
  function t(s) {
    Object.entries(s ?? {}).forEach(([n, o]) => {
      if (s.$ref !== void 0) {
        const i = MR(e, s.$ref);
        delete s.$ref, typeof i == "object" && Object.keys(i).forEach((a) => {
          s[a] === void 0 && (s[a] = i[a]);
        });
      }
      typeof o == "object" && !NR(o) && t(o);
    });
  }
}
function NR(r) {
  try {
    return JSON.stringify(r), !1;
  } catch {
    return !0;
  }
}
function MR(r, e) {
  if (typeof e != "string")
    return;
  const [t, s] = e.split("#", 2);
  if (t)
    throw new Error(hh.EXTERNAL_REFERENCE_NOT_SUPPORTED.replace("%s", e));
  return IR(s).split("/").slice(1).reduce((n, o) => n[o], r);
}
const DR = "[", RR = "]", jR = "{", LR = "}", BR = ":", FR = ",", z1 = "true", q1 = "false", H1 = "null", v0 = '"', VR = /* @__PURE__ */ new Map([
  ["t", z1],
  ["f", q1],
  ["n", H1]
]), vh = /* @__PURE__ */ new Map([
  [v0, v0],
  ["\\", "\\"],
  ["/", "/"],
  ["b", "\b"],
  ["n", `
`],
  ["f", "\f"],
  ["r", "\r"],
  ["t", "	"]
]), Ju = /* @__PURE__ */ new Map([
  [DR, "LBracket"],
  [RR, "RBracket"],
  [jR, "LBrace"],
  [LR, "RBrace"],
  [BR, "Colon"],
  [FR, "Comma"],
  [z1, "Boolean"],
  [q1, "Boolean"],
  [H1, "Null"]
]);
class oa extends Error {
  /**
   * Creates a new instance.
   * @param {string} message The error message to report. 
   * @param {Location} loc The location information for the error.
   */
  constructor(e, { line: t, column: s, offset: n }) {
    super(`${e} (${t}:${s})`), this.line = t, this.column = s, this.offset = n;
  }
}
class UR extends oa {
  /**
   * Creates a new instance.
   * @param {string} unexpected The character that was found.
   * @param {Location} loc The location information for the found character.
   */
  constructor(e, t) {
    super(`Unexpected character '${e}' found.`, t);
  }
}
class Yu extends oa {
  /**
   * Creates a new instance.
   * @param {Token} token The token that was found. 
   */
  constructor(e) {
    super(`Unexpected token ${e.type} found.`, e.loc.start);
  }
}
class zR extends oa {
  /**
   * Creates a new instance.
   * @param {Location} loc The location information for the found character.
   */
  constructor(e) {
    super("Unexpected end of input found.", e);
  }
}
const w0 = '"', k0 = "/", S0 = "*", qR = {
  mode: "json",
  ranges: !1
};
function HR(r) {
  return /[\s\n]/.test(r);
}
function xs(r) {
  return r >= "0" && r <= "9";
}
function KR(r) {
  return xs(r) || /[a-f]/i.test(r);
}
function WR(r) {
  return r >= "1" && r <= "9";
}
function GR(r) {
  return /[tfn]/.test(r);
}
function JR(r) {
  return xs(r) || r === "." || r === "-";
}
function YR(r, e) {
  e = Object.freeze({
    ...qR,
    ...e
  });
  let t = -1, s = 1, n = 0, o = !1;
  const i = [];
  function a(y, b, v, k) {
    const _ = v.offset + b.length;
    let w = e.ranges ? {
      range: [v.offset, _]
    } : void 0;
    return {
      type: y,
      loc: {
        start: v,
        end: k || {
          line: v.line,
          column: v.column + b.length,
          offset: _
        }
      },
      ...w
    };
  }
  function l() {
    let y = r.charAt(++t);
    return o ? (s++, n = 1, o = !1) : n++, y === "\r" ? (o = !0, r.charAt(t + 1) === `
` && t++) : y === `
` && (o = !0), y;
  }
  function c() {
    return {
      line: s,
      column: n,
      offset: t
    };
  }
  function u(y) {
    let b = VR.get(y);
    if (r.slice(t, t + b.length) === b)
      return t += b.length - 1, n += b.length - 1, { value: b, c: l() };
    for (let v = 1; v < b.length; v++)
      b[v] !== r.charAt(t + v) && m(l());
  }
  function d(y) {
    let b = y;
    for (y = l(); y && y !== w0; ) {
      if (y === "\\")
        if (b += y, y = l(), vh.has(y))
          b += y;
        else if (y === "u") {
          b += y;
          for (let v = 0; v < 4; v++)
            y = l(), KR(y) ? b += y : m(y);
        } else
          m(y);
      else
        b += y;
      y = l();
    }
    return y || g(), b += y, { value: b, c: l() };
  }
  function h(y) {
    let b = "";
    if (y === "-" && (b += y, y = l(), xs(y) || m(y)), y === "0")
      b += y, y = l(), xs(y) && m(y);
    else {
      WR(y) || m(y);
      do
        b += y, y = l();
      while (xs(y));
    }
    if (y === ".")
      do
        b += y, y = l();
      while (xs(y));
    if (y === "e" || y === "E")
      for (b += y, y = l(), (y === "+" || y === "-") && (b += y, y = l()), y || g(), xs(y) || m(y); xs(y); )
        b += y, y = l();
    return { value: b, c: y };
  }
  function f(y) {
    let b = y;
    if (y = l(), y === "/") {
      do
        b += y, y = l();
      while (y && y !== "\r" && y !== `
`);
      return { value: b, c: y };
    }
    if (y === S0) {
      for (; y; )
        if (b += y, y = l(), y === S0 && (b += y, y = l(), y === k0))
          return b += y, y = l(), { value: b, c: y };
      g();
    }
    m(y);
  }
  function m(y) {
    throw new UR(y, c());
  }
  function g() {
    throw new zR(c());
  }
  let p = l();
  for (; t < r.length; ) {
    for (; HR(p); )
      p = l();
    if (!p)
      break;
    const y = c();
    if (Ju.has(p))
      i.push(a(Ju.get(p), p, y)), p = l();
    else if (GR(p)) {
      const b = u(p);
      let v = b.value;
      p = b.c, i.push(a(Ju.get(v), v, y));
    } else if (JR(p)) {
      const b = h(p);
      let v = b.value;
      p = b.c, i.push(a("Number", v, y));
    } else if (p === w0) {
      const b = d(p);
      let v = b.value;
      p = b.c, i.push(a("String", v, y));
    } else if (p === k0 && e.mode === "jsonc") {
      const b = f(p);
      let v = b.value;
      p = b.c, i.push(a(v.startsWith("//") ? "LineComment" : "BlockComment", v, y, c()));
    } else
      m(p);
  }
  return i;
}
const Xr = {
  /**
   * Creates a document node.
   * @param {ValueNode} body The body of the document.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {DocumentNode} The document node.
   */
  document(r, e = {}) {
    return {
      type: "Document",
      body: r,
      ...e
    };
  },
  /**
   * Creates a string node.
   * @param {string} value The value for the string.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {StringNode} The string node.
   */
  string(r, e = {}) {
    return {
      type: "String",
      value: r,
      ...e
    };
  },
  /**
   * Creates a number node.
   * @param {number} value The value for the number.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {NumberNode} The number node.
   */
  number(r, e = {}) {
    return {
      type: "Number",
      value: r,
      ...e
    };
  },
  /**
   * Creates a boolean node.
   * @param {boolean} value The value for the boolean.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {BooleanNode} The boolean node.
   */
  boolean(r, e = {}) {
    return {
      type: "Boolean",
      value: r,
      ...e
    };
  },
  /**
   * Creates a null node.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {NullNode} The null node.
   */
  null(r = {}) {
    return {
      type: "Null",
      ...r
    };
  },
  /**
   * Creates an array node.
   * @param {Array<ElementNode>} elements The elements to add.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ArrayNode} The array node.
   */
  array(r, e = {}) {
    return {
      type: "Array",
      elements: r,
      ...e
    };
  },
  /**
   * Creates an element node.
   * @param {ValueNode} value The value for the element.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ElementNode} The element node.
   */
  element(r, e = {}) {
    return {
      type: "Element",
      value: r,
      ...e
    };
  },
  /**
   * Creates an object node.
   * @param {Array<MemberNode>} members The members to add.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ObjectNode} The object node.
   */
  object(r, e = {}) {
    return {
      type: "Object",
      members: r,
      ...e
    };
  },
  /**
   * Creates a member node.
   * @param {StringNode} name The name for the member.
   * @param {ValueNode} value The value for the member.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {MemberNode} The member node.
   */
  member(r, e, t = {}) {
    return {
      type: "Member",
      name: r,
      value: e,
      ...t
    };
  }
}, XR = {
  mode: "json",
  ranges: !1,
  tokens: !1
};
function QR(r, e) {
  let t = "", s = r.indexOf("\\"), n = 0;
  for (; s >= 0; ) {
    t += r.slice(n, s);
    const o = r.charAt(s + 1);
    if (vh.has(o))
      t += vh.get(o), n = s + 2;
    else if (o === "u") {
      const i = r.slice(s + 2, s + 6);
      if (i.length < 4 || /[^0-9a-f]/i.test(i))
        throw new oa(
          `Invalid unicode escape \\u${i}.`,
          {
            line: e.loc.start.line,
            column: e.loc.start.column + s,
            offset: e.loc.start.offset + s
          }
        );
      t += String.fromCharCode(parseInt(i, 16)), n = s + 6;
    } else
      throw new oa(
        `Invalid escape \\${o}.`,
        {
          line: e.loc.start.line,
          column: e.loc.start.column + s,
          offset: e.loc.start.offset + s
        }
      );
    s = r.indexOf("\\", n);
  }
  return t += r.slice(n), t;
}
function ZR(r, e) {
  switch (e.type) {
    case "Boolean":
      return r === "true";
    case "Number":
      return Number(r);
    case "String":
      return QR(r.slice(1, -1), e);
    default:
      throw new TypeError(`Unknown token type "${e.type}.`);
  }
}
function e3(r, e) {
  e = Object.freeze({
    ...XR,
    ...e
  });
  const t = YR(r, {
    mode: e.mode,
    ranges: e.ranges
  });
  let s = 0;
  function n() {
    return t[s++];
  }
  function o() {
    const b = t[s++];
    return b && b.type.endsWith("Comment") ? o() : b;
  }
  const i = e.mode === "jsonc" ? o : n;
  function a(b, v) {
    if (!b || b.type !== v)
      throw new Yu(b);
  }
  function l(b, v) {
    return e.ranges ? {
      range: [b.offset, v.offset]
    } : void 0;
  }
  function c(b) {
    const v = l(b.loc.start, b.loc.end), k = ZR(
      r.slice(b.loc.start.offset, b.loc.end.offset),
      b
    ), _ = { loc: {
      start: {
        ...b.loc.start
      },
      end: {
        ...b.loc.end
      }
    }, ...v };
    switch (b.type) {
      case "String":
        return Xr.string(
          /** @type {string} */
          k,
          _
        );
      case "Number":
        return Xr.number(
          /** @type {number} */
          k,
          _
        );
      case "Boolean":
        return Xr.boolean(
          /** @type {boolean} */
          k,
          _
        );
      default:
        throw new TypeError(`Unknown token type ${b.type}.`);
    }
  }
  function u(b) {
    const v = l(b.loc.start, b.loc.end);
    return Xr.null({
      loc: {
        start: {
          ...b.loc.start
        },
        end: {
          ...b.loc.end
        }
      },
      ...v
    });
  }
  function d(b) {
    a(b, "String");
    const v = c(b);
    b = i(), a(b, "Colon");
    const k = m(), _ = l(v.loc.start, k.loc.end);
    return Xr.member(
      /** @type {StringNode} */
      v,
      k,
      {
        loc: {
          start: {
            ...v.loc.start
          },
          end: {
            ...k.loc.end
          }
        },
        ..._
      }
    );
  }
  function h(b) {
    a(b, "LBrace");
    const v = [];
    let k = i();
    if (k && k.type !== "RBrace")
      do
        if (v.push(d(k)), k = i(), k.type === "Comma")
          k = i();
        else
          break;
      while (k);
    a(k, "RBrace");
    const _ = l(b.loc.start, k.loc.end);
    return Xr.object(v, {
      loc: {
        start: {
          ...b.loc.start
        },
        end: {
          ...k.loc.end
        }
      },
      ..._
    });
  }
  function f(b) {
    a(b, "LBracket");
    const v = [];
    let k = i();
    if (k && k.type !== "RBracket")
      do {
        const w = m(k);
        if (v.push(Xr.element(
          w,
          { loc: w.loc }
        )), k = i(), k.type === "Comma")
          k = i();
        else
          break;
      } while (k);
    a(k, "RBracket");
    const _ = l(b.loc.start, k.loc.end);
    return Xr.array(v, {
      loc: {
        start: {
          ...b.loc.start
        },
        end: {
          ...k.loc.end
        }
      },
      ..._
    });
  }
  function m(b) {
    switch (b = b || i(), b.type) {
      case "String":
      case "Boolean":
      case "Number":
        return c(b);
      case "Null":
        return u(b);
      case "LBrace":
        return h(b);
      case "LBracket":
        return f(b);
      default:
        throw new Yu(b);
    }
  }
  const g = m(), p = i();
  if (p)
    throw new Yu(p);
  const y = {
    loc: {
      start: {
        line: 1,
        column: 1,
        offset: 0
      },
      end: {
        ...g.loc.end
      }
    }
  };
  return e.tokens && (y.tokens = t), e.ranges && (y.range = [
    y.loc.start.offset,
    y.loc.end.offset
  ]), Xr.document(g, y);
}
const t3 = (r) => (e) => r === e, r3 = (r) => (e) => !r(e), s3 = (r) => Object.values(r), n3 = (r) => r !== void 0, vp = (r) => (e) => e.keyword === r, o3 = vp("required"), i3 = vp("anyOf"), K1 = vp("enum"), xi = (r) => r && r.errors || [], W1 = (r) => r && s3(r.children) || [], a3 = (r) => (e) => W1(r).filter(r3(t3(e))), $0 = (
  /* ::<T> */
  (r) => (e) => e.reduce((t, s) => t.concat(s), r)
), G1 = (r) => {
  const e = r.split("/").slice(1);
  for (const t in e)
    e[t] = e[t].split("~1").join("/").split("~0").join("~");
  return e;
};
function l3(r, e, t) {
  const s = G1(e), n = s.length - 1;
  return s.reduce((o, i, a) => {
    switch (o == null ? void 0 : o.type) {
      case "Object": {
        const l = o.members.filter(
          (d) => d.name.value === i
        );
        if (l.length !== 1)
          throw new Error(`Couldn't find property ${i} of ${e}`);
        const { name: c, value: u } = l[0];
        return t && a === n ? c : u;
      }
      case "Array":
        return o.elements[i];
      default:
        if (o.loc)
          return o;
    }
  }, r.body);
}
function c3(r) {
  if (!r || !r.elements)
    return "";
  const e = r.elements.filter(
    (t) => t && t.name && t.name.value === "type"
  );
  return e.length && e[0].value && `:${e[0].value.value}` || "";
}
function u3(r, e) {
  let t = "";
  return G1(e).reduce((s, n) => {
    switch (s == null ? void 0 : s.type) {
      case "Object": {
        t += `/${n}`;
        const o = s.members.filter(
          (i) => i.name.value === n
        );
        if (o.length !== 1)
          throw new Error(`Couldn't find property ${n} of ${e}`);
        return o[0].value;
      }
      case "Array":
        return t += `/${n}${c3(s.elements[n])}`, s.elements[n];
    }
  }, r.body), t;
}
class Wo {
  // eslint-disable-next-line default-param-last
  constructor(e = { isIdentifierLocation: !1 }, { colorize: t, data: s, schema: n, jsonAst: o, jsonRaw: i }) {
    this.options = e, this.colorize = !!(t || t === void 0), this.data = s, this.schema = n, this.jsonAst = o, this.jsonRaw = i;
  }
  getChalk() {
    return this.colorize ? chalk : new chalk.Instance({ level: 0 });
  }
  getLocation(e = this.instancePath) {
    const { isIdentifierLocation: t, isSkipEndLocation: s } = this.options, { loc: n } = l3(
      this.jsonAst,
      e,
      t
    );
    return {
      start: n.start,
      end: s ? void 0 : n.end
    };
  }
  getDecoratedPath(e = this.instancePath) {
    return u3(this.jsonAst, e);
  }
  getCodeFrame(e, t = this.instancePath) {
    return codeFrameColumns(this.jsonRaw, this.getLocation(t), {
      /**
       * `@babel/highlight`, by way of `@babel/code-frame`, highlights out entire block of raw JSON
       * instead of just our `location` block -- so if you have a block of raw JSON that's upwards
       * of 2mb+ and have a lot of errors to generate code frames for then we're re-highlighting
       * the same huge chunk of code over and over and over and over again, all just so
       * `@babel/code-frame` will eventually extract a small <10 line chunk out of it to return to
       * us.
       *
       * Disabling `highlightCode` here will only disable highlighting the code we're showing users;
       * if `options.colorize` is supplied to this library then the error message we're adding will
       * still be highlighted.
       */
      highlightCode: !1,
      message: e
    });
  }
  /**
   * @return {string}
   */
  get instancePath() {
    return typeof this.options.instancePath < "u" ? this.options.instancePath : this.options.dataPath;
  }
  print() {
    throw new Error(
      `Implement the 'print' method inside ${this.constructor.name}!`
    );
  }
  getError() {
    throw new Error(
      `Implement the 'getError' method inside ${this.constructor.name}!`
    );
  }
}
class d3 extends Wo {
  constructor(...e) {
    super(...e), this.name = "AdditionalPropValidationError", this.options.isIdentifierLocation = !0;
  }
  print() {
    const { message: e, params: t } = this.options, s = this.getChalk();
    return [s`{red {bold ADDITIONAL PROPERTY} ${e}}\n`].concat(
      this.getCodeFrame(
        s`😲  {magentaBright ${t.additionalProperty}} is not expected to be here!`,
        `${this.instancePath}/${t.additionalProperty}`
      )
    );
  }
  getError() {
    const { params: e } = this.options;
    return {
      ...this.getLocation(`${this.instancePath}/${e.additionalProperty}`),
      error: `${this.getDecoratedPath()} Property ${e.additionalProperty} is not expected to be here`,
      path: this.instancePath
    };
  }
}
class h3 extends Wo {
  constructor(...e) {
    super(...e), this.name = "DefaultValidationError", this.options.isSkipEndLocation = !0;
  }
  print() {
    const { keyword: e, message: t } = this.options, s = this.getChalk();
    return [s`{red {bold ${e.toUpperCase()}} ${t}}\n`].concat(
      this.getCodeFrame(s`👈🏽  {magentaBright ${e}} ${t}`)
    );
  }
  getError() {
    const { keyword: e, message: t } = this.options;
    return {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()}: ${e} ${t}`,
      path: this.instancePath
    };
  }
}
var au = {}, f3 = /~/, p3 = /~[01]/g;
function m3(r) {
  switch (r) {
    case "~1":
      return "/";
    case "~0":
      return "~";
  }
  throw new Error("Invalid tilde escape: " + r);
}
function J1(r) {
  return f3.test(r) ? r.replace(p3, m3) : r;
}
function g3(r, e, t) {
  for (var s, n, o = 1, i = e.length; o < i; ) {
    if (e[o] === "constructor" || e[o] === "prototype" || e[o] === "__proto__")
      return r;
    if (s = J1(e[o++]), n = i > o, typeof r[s] > "u" && (Array.isArray(r) && s === "-" && (s = r.length), n && (e[o] !== "" && e[o] < 1 / 0 || e[o] === "-" ? r[s] = [] : r[s] = {})), !n)
      break;
    r = r[s];
  }
  var a = r[s];
  return t === void 0 ? delete r[s] : r[s] = t, a;
}
function wp(r) {
  if (typeof r == "string") {
    if (r = r.split("/"), r[0] === "")
      return r;
    throw new Error("Invalid JSON pointer.");
  } else if (Array.isArray(r)) {
    for (const e of r)
      if (typeof e != "string" && typeof e != "number")
        throw new Error("Invalid JSON pointer. Must be of type string or number.");
    return r;
  }
  throw new Error("Invalid JSON pointer.");
}
function Y1(r, e) {
  if (typeof r != "object")
    throw new Error("Invalid input object.");
  e = wp(e);
  var t = e.length;
  if (t === 1)
    return r;
  for (var s = 1; s < t; ) {
    if (r = r[J1(e[s++])], t === s)
      return r;
    if (typeof r != "object" || r === null)
      return;
  }
}
function X1(r, e, t) {
  if (typeof r != "object")
    throw new Error("Invalid input object.");
  if (e = wp(e), e.length === 0)
    throw new Error("Invalid JSON pointer for set.");
  return g3(r, e, t);
}
function y3(r) {
  var e = wp(r);
  return {
    get: function(t) {
      return Y1(t, e);
    },
    set: function(t, s) {
      return X1(t, e, s);
    }
  };
}
au.get = Y1;
au.set = X1;
au.compile = y3;
const Xu = [], _0 = [];
function b3(r, e) {
  if (r === e)
    return 0;
  const t = r;
  r.length > e.length && (r = e, e = t);
  let s = r.length, n = e.length;
  for (; s > 0 && r.charCodeAt(~-s) === e.charCodeAt(~-n); )
    s--, n--;
  let o = 0;
  for (; o < s && r.charCodeAt(o) === e.charCodeAt(o); )
    o++;
  if (s -= o, n -= o, s === 0)
    return n;
  let i, a, l, c, u = 0, d = 0;
  for (; u < s; )
    _0[u] = r.charCodeAt(o + u), Xu[u] = ++u;
  for (; d < n; )
    for (i = e.charCodeAt(o + d), l = d++, a = d, u = 0; u < s; u++)
      c = i === _0[u] ? l : l + 1, l = Xu[u], a = Xu[u] = l > a ? c > a ? a + 1 : c : c > l ? l + 1 : c;
  return a;
}
class v3 extends Wo {
  constructor(...e) {
    super(...e), this.name = "EnumValidationError";
  }
  print() {
    const {
      message: e,
      params: { allowedValues: t }
    } = this.options, s = this.getChalk(), n = this.findBestMatch();
    return [
      s`{red {bold ENUM} ${e}}`,
      s`{red (${t.join(", ")})}\n`
    ].concat(
      this.getCodeFrame(
        n !== null ? s`👈🏽  Did you mean {magentaBright ${n}} here?` : s`👈🏽  Unexpected value, should be equal to one of the allowed values`
      )
    );
  }
  getError() {
    const { message: e, params: t } = this.options, s = this.findBestMatch(), n = t.allowedValues.join(", "), o = {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()} ${e}: ${n}`,
      path: this.instancePath
    };
    return s !== null && (o.suggestion = `Did you mean ${s}?`), o;
  }
  findBestMatch() {
    const {
      params: { allowedValues: e }
    } = this.options, t = this.instancePath === "" ? this.data : au.get(this.data, this.instancePath);
    if (!t)
      return null;
    const s = e.map((n) => ({
      value: n,
      weight: b3(n, t.toString())
    })).sort(
      (n, o) => n.weight > o.weight ? 1 : n.weight < o.weight ? -1 : 0
    )[0];
    return e.length === 1 || s.weight < s.value.length ? s.value : null;
  }
}
class w3 extends Wo {
  constructor(...e) {
    super(...e), this.name = "PatternValidationError", this.options.isIdentifierLocation = !0;
  }
  print() {
    const { message: e, params: t, propertyName: s } = this.options, n = this.getChalk();
    return [n`{red {bold PROPERTY} ${e}}\n`].concat(
      this.getCodeFrame(
        n`😲  must match pattern {magentaBright ${t.pattern}}`,
        `${this.instancePath}/${s}`
      )
    );
  }
  getError() {
    const { params: e, propertyName: t } = this.options;
    return {
      // ...this.getLocation(`${this.instancePath}/${params.propertyName}`),
      ...this.getLocation(),
      error: `${this.getDecoratedPath()} Property "${t}" must match pattern ${e.pattern}`,
      path: this.instancePath
    };
  }
}
class k3 extends Wo {
  constructor(...e) {
    super(...e), this.name = "RequiredValidationError";
  }
  getLocation(e = this.instancePath) {
    const { start: t } = super.getLocation(e);
    return { start: t };
  }
  print() {
    const { message: e, params: t } = this.options, s = this.getChalk();
    return [s`{red {bold REQUIRED} ${e}}\n`].concat(
      this.getCodeFrame(
        s`☹️  {magentaBright ${t.missingProperty}} is missing here!`
      )
    );
  }
  getError() {
    const { message: e } = this.options;
    return {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()} ${e}`,
      path: this.instancePath
    };
  }
}
class S3 extends Wo {
  constructor(...e) {
    super(...e), this.name = "UnevaluatedPropValidationError", this.options.isIdentifierLocation = !0;
  }
  print() {
    const { message: e, params: t } = this.options, s = this.getChalk();
    return [s`{red {bold UNEVALUATED PROPERTY} ${e}}\n`].concat(
      this.getCodeFrame(
        s`😲  {magentaBright ${t.unevaluatedProperty}} is not expected to be here!`,
        `${this.instancePath}/${t.unevaluatedProperty}`
      )
    );
  }
  getError() {
    const { params: e } = this.options;
    return {
      ...this.getLocation(`${this.instancePath}/${e.unevaluatedProperty}`),
      error: `${this.getDecoratedPath()} Property ${e.unevaluatedProperty} is not expected to be here`,
      path: this.instancePath
    };
  }
}
const $3 = /\/[\w_-]+(\/\d+)?/g;
function _3(r = []) {
  const e = { children: {} };
  return r.forEach((t) => {
    const s = typeof t.instancePath < "u" ? t.instancePath : t.dataPath, n = s === "" ? [""] : s.match($3);
    n && n.reduce((o, i, a) => (o.children[i] = o.children[i] || { children: {}, errors: [] }, a === n.length - 1 && o.children[i].errors.push(t), o.children[i]), e);
  }), e;
}
function Q1(r, e, t) {
  xi(r).forEach((s) => {
    o3(s) && (r.errors = [s], r.children = {});
  }), xi(r).some(i3) && Object.keys(r.children).length > 0 && delete r.errors, r.errors && r.errors.length && xi(r).every(K1) && a3(e)(r).filter(n3).some(xi) && delete e.children[t], Object.entries(r.children).forEach(
    ([s, n]) => Q1(n, r, s)
  );
}
function Z1(r, e) {
  const t = xi(r);
  if (t.length && t.every(K1)) {
    const s = [...new Set(
      $0([])(t.map((o) => o.params.allowedValues))
    )], n = t[0];
    return [
      new v3(
        {
          ...n,
          params: { allowedValues: s }
        },
        e
      )
    ];
  }
  return $0(
    t.reduce((s, n) => {
      switch (n.keyword) {
        case "additionalProperties":
          return s.concat(new d3(n, e));
        case "pattern":
          return s.concat(new w3(n, e));
        case "required":
          return s.concat(new k3(n, e));
        case "unevaluatedProperties":
          return s.concat(new S3(n, e));
        default:
          return s.concat(new h3(n, e));
      }
    }, [])
  )(W1(r).map((s) => Z1(s, e)));
}
function x3(r, e) {
  const t = _3(r || []);
  return Q1(t), Z1(t, e);
}
function C3(r, e, t, s = {}) {
  const {
    colorize: n = !0,
    format: o = "cli",
    indent: i = null,
    json: a = null
  } = s, l = a || JSON.stringify(e, null, i), c = e3(l), u = (f) => f.print().join(`
`), d = (f) => f.getError(), h = x3(t, {
    colorize: n,
    data: e,
    schema: r,
    jsonAst: c,
    jsonRaw: l
  });
  return o === "cli" ? h.map(u).join(`

`) : h.map(d);
}
function Ci(r, e) {
  return typeof e == "string" ? [
    {
      start: {
        line: 1,
        column: 1,
        offset: 0
      },
      error: e,
      path: ""
    }
  ] : C3(r, null, e, {
    format: "js",
    indent: 2,
    colorize: !1
  }).map((t) => (t.error = t.error.trim(), t));
}
function A3(r) {
  try {
    return U1(r), {
      valid: !0
    };
  } catch (e) {
    return {
      valid: !1,
      errors: Ci(r, e.message)
    };
  }
}
class kp {
  constructor() {
    ws(this, "version"), ws(this, "ajvValidators", {}), ws(this, "externalRefs", {}), ws(this, "errors"), ws(this, "specificationVersion"), ws(this, "specificationType"), ws(this, "specification");
  }
  resolveReferences(e) {
    return U1(
      e.find((t) => t.isEntrypoint === !0).specification
    );
  }
  /**
   * Checks whether a specification is valid and all references can be resolved.
   */
  async validate(e) {
    var t;
    const s = e.find((o) => o.isEntrypoint), n = s == null ? void 0 : s.specification;
    this.specification = n, (t = this.specification) != null && t.info && !this.specification.info.version && (this.specification.info.version = "0.0.1");
    try {
      if (n == null)
        return {
          valid: !1,
          errors: Ci(s, hh.EMPTY_OR_INVALID)
        };
      Object.keys(this.externalRefs).length > 0 && (n[fD] = this.externalRefs);
      const { version: o, specificationType: i, specificationVersion: a } = V1(n);
      if (this.version = o, this.specificationVersion = a, this.specificationType = i, !o)
        return {
          valid: !1,
          errors: Ci(
            s,
            hh.OPENAPI_VERSION_NOT_SUPPORTED
          )
        };
      const l = await this.getAjvValidator(o);
      return l(n) ? A3(s.specification) : l.errors && l.errors.length > 0 ? {
        valid: !1,
        errors: Ci(s, l.errors)
      } : {
        valid: !1
      };
    } catch (o) {
      return {
        valid: !1,
        errors: Ci(s, o.message ?? o)
      };
    }
  }
  /**
   * Ajv JSON schema validator
   */
  async getAjvValidator(e) {
    if (this.ajvValidators[e])
      return this.ajvValidators[e];
    const t = await $O(/* @__PURE__ */ Object.assign({ "../../../schemas/v2.0/schema.json": () => import("./schema-BQQoKgNw-DQKLRVph.js"), "../../../schemas/v3.0/schema.json": () => import("./schema-BjykgtPd-D3b7mB1v.js"), "../../../schemas/v3.1/schema.json": () => import("./schema-ZROhtp0X-ZROhtp0X.js") }), `../../../schemas/v${e}/schema.json`), s = hD[t.$schema], n = new s({
      // Ajv is a bit too strict in its strict validation of OpenAPI schemas.
      // Switch strict mode off.
      strict: !1
    });
    return yN(n), e === "3.1" && n.addFormat("media-range", !0), this.ajvValidators[e] = n.compile(t);
  }
}
ws(kp, "supportedVersions", Hv);
function E3() {
  return {
    load: O3
  };
}
function O3(r) {
  const e = B1(r);
  return {
    get: () => e,
    details: () => cu(e),
    filter: (t) => Oa(e, t),
    upgrade: () => ew(e),
    validate: () => Sp(e),
    resolve: () => lu(e),
    toJson: () => Ta(e),
    toYaml: () => Pa(e)
  };
}
function ew(r) {
  const e = TR(r);
  return {
    get: () => e,
    details: () => cu(e),
    filter: (t) => Oa(e, t),
    validate: () => Sp(e),
    resolve: () => lu(e),
    toJson: () => Ta(e),
    toYaml: () => Pa(e)
  };
}
async function Sp(r) {
  return {
    ...await PR(r),
    filter: (e) => Oa(r, e),
    get: () => r,
    details: () => cu(r),
    resolve: () => lu(r),
    toJson: () => Ta(r),
    toYaml: () => Pa(r)
  };
}
async function lu(r) {
  return {
    ...await xR(r),
    filter: (e) => Oa(r, e),
    toJson: () => Ta(r),
    toYaml: () => Pa(r)
  };
}
function Oa(r, e) {
  const t = pD(r, e);
  return {
    get: () => t,
    details: () => cu(t),
    filter: () => Oa(t, e),
    upgrade: () => ew(t),
    validate: () => Sp(t),
    resolve: () => lu(t),
    toJson: () => Ta(t),
    toYaml: () => Pa(t)
  };
}
function cu(r) {
  return V1(r);
}
function Ta(r) {
  return CR(r);
}
function Pa(r) {
  return AR(r);
}
const T3 = (r) => new Promise(async (e, t) => {
  var s;
  try {
    if (!r)
      return e(
        ml(
          lo()
        )
      );
    const { schema: n, errors: o } = await E3().load(r).resolve();
    return o != null && o.length && console.warn(
      `Please open an issue on https://github.com/scalar/scalar
`,
      `Scalar OpenAPI Parser Warning:
`,
      o
    ), n === void 0 ? (t(((s = o == null ? void 0 : o[0]) == null ? void 0 : s.error) ?? "Failed to parse the OpenAPI file."), e(
      ml(
        lo()
      )
    )) : e(ml(n));
  } catch (n) {
    t(n);
  }
  return e(
    ml(lo())
  );
}), ml = (r) => {
  let e = {};
  r && typeof r == "object" ? e = structuredClone(r) : e = lo(), e.tags || (e.tags = []), e.paths || (e.paths = {});
  const t = {};
  return Object.keys(e.webhooks ?? {}).forEach((n) => {
    var o;
    Object.keys(((o = e.webhooks) == null ? void 0 : o[n]) ?? {}).forEach((i) => {
      var l, c, u;
      const a = (l = e.webhooks) == null ? void 0 : l[n][i];
      (a == null ? void 0 : a["x-internal"]) !== !0 && (t[n] === void 0 && (t[n] = {}), t[n][i] = {
        // Transformed data
        httpVerb: i,
        path: n,
        operationId: (a == null ? void 0 : a.operationId) || n,
        name: (a == null ? void 0 : a.summary) || n || "",
        description: (a == null ? void 0 : a.description) || "",
        pathParameters: (u = (c = e.paths) == null ? void 0 : c[n]) == null ? void 0 : u.parameters,
        // Original webhook
        information: {
          ...a
        }
      });
    });
  }), Object.keys(e.paths).forEach((n) => {
    Object.keys(e.paths[n]).filter(
      (i) => sy.includes(i.toUpperCase())
    ).forEach((i) => {
      var c, u, d, h, f, m;
      const a = e.paths[n][i];
      if (a === void 0 || a["x-internal"] === !0)
        return;
      const l = {
        httpVerb: i,
        path: n,
        operationId: a.operationId || n,
        name: a.summary || n || "",
        description: a.description || "",
        information: {
          ...a
        },
        pathParameters: (u = (c = e.paths) == null ? void 0 : c[n]) == null ? void 0 : u.parameters
      };
      if (!a.tags || a.tags.length === 0) {
        (d = e.tags) != null && d.find(
          (p) => p.name === "default"
        ) || (h = e.tags) == null || h.push({
          name: "default",
          description: "",
          operations: []
        });
        const g = (f = e.tags) == null ? void 0 : f.findIndex(
          (p) => p.name === "default"
        );
        g >= 0 && ((m = e.tags[g]) == null || m.operations.push(l));
      } else
        a.tags.forEach((g) => {
          var b, v, k;
          const p = (b = e.tags) == null ? void 0 : b.findIndex(
            // @ts-expect-error TODO: The types are just screwed, needs refactoring
            (_) => _.name === g
          );
          p === -1 && ((v = e.tags) == null || v.push({
            name: g,
            description: ""
          }));
          const y = p !== -1 ? p : e.tags.length - 1;
          typeof ((k = e.tags[y]) == null ? void 0 : k.operations) > "u" && (e.tags[y].operations = []), e.tags[y].operations.push(l);
        });
    });
  }), {
    ...e,
    webhooks: t
  };
}, $p = Symbol(), tw = Symbol(), hc = async (r) => {
  var e;
  (e = document.getElementById(r)) == null || e.scrollIntoView();
}, hs = (r) => new Promise((e) => setTimeout(e, r)), P3 = Symbol("downloadSpec"), rw = Oh(P3);
function I3(r, e) {
  const t = OS(r), s = t ? new Blob([r], { type: "application/json" }) : new Blob([r], { type: "application/x-yaml" }), n = URL.createObjectURL(s), o = t ? ".json" : ".yaml", i = "spec" + o, a = e ? e + o : i, l = document.createElement("a");
  l.href = n, l.download = a, l.dispatchEvent(
    new MouseEvent("click", {
      bubbles: !0,
      cancelable: !0,
      view: window
    })
  ), setTimeout(() => {
    window.URL.revokeObjectURL(n), l.remove();
  }, 100);
}
function N3(r, e = 1) {
  const t = new RegExp(`^(?=#{${e}} )`, "m");
  return r.split(t).map((s) => s.trim()).filter(Boolean);
}
const Go = () => {
  const { toast: r } = of();
  return {
    copyToClipboard: (t) => {
      navigator.clipboard.writeText(t).then(() => {
        r("Copied to the clipboard", "info");
      });
    }
  };
}, vs = ie(!1);
function M3(r) {
  var n;
  const e = () => {
    var i, a;
    const o = typeof window < "u" ? (i = window.localStorage) == null ? void 0 : i.getItem("isDark") : null;
    return typeof o == "string" ? !!JSON.parse(o) : !!(typeof window < "u" && ((a = window == null ? void 0 : window.matchMedia("(prefers-color-scheme: dark)")) != null && a.matches));
  }, t = () => {
    var o;
    vs.value = !vs.value, typeof window < "u" && ((o = window == null ? void 0 : window.localStorage) == null || o.setItem("isDark", JSON.stringify(vs.value)));
  };
  function s(o) {
    var i;
    vs.value = o, typeof window < "u" && ((i = window == null ? void 0 : window.localStorage) == null || i.setItem("isDark", JSON.stringify(vs.value)));
  }
  return vs.value = (typeof window > "u" ? null : JSON.parse(((n = window.localStorage) == null ? void 0 : n.getItem("isDark")) || "null")) ?? r ?? e(), Le(
    vs,
    (o) => {
      typeof document > "u" || (document.body.classList.toggle("dark-mode", o), document.body.classList.toggle("light-mode", !o));
    },
    { immediate: !0 }
  ), {
    isDark: vs,
    toggleDarkMode: t,
    setDarkMode: s
  };
}
const x0 = "https://api.scalar.com/request-proxy", gl = "https://proxy.scalar.com", D3 = "http://localhost:5051";
function R3(r) {
  Le(
    () => r,
    () => {
      var e;
      r.proxy === x0 ? (console.warn(
        `[DEPRECATED] Warning: configuration.proxy points to our old proxy (${x0}).`
      ), console.warn(
        `[DEPRECATED] We are overwriting the value and use the new proxy URL (${gl}) instead.`
      ), r.proxy = gl, console.warn(
        `[DEPRECATED] Action Required: You should manually update your configuration to use the new URL (${gl}). Read more: https://github.com/scalar/scalar`
      )) : (e = r.proxy) != null && e.length && r.proxy !== gl && r.proxy !== D3 && (console.warn(
        `[DEPRECATED] Warning: configuration.proxy points to a custom proxy (${r == null ? void 0 : r.proxy}).`
      ), console.warn(
        "[DEPRECATED] Action Required: You need to use our new proxy (written in Go). Read more: https://github.com/scalar/scalar/tree/main/examples/proxy-server"
      ));
    },
    {
      immediate: !0
    }
  );
}
const _p = ie(Eo.hash ?? ""), fc = ie(), j3 = ie(!1), L3 = (r) => r.slug ? `description/${r.slug}` : "", sw = (r) => {
  var t;
  if (!fc.value)
    return "";
  const e = new RegExp("^" + ((t = fc.value) == null ? void 0 : t.basePath) + "/?");
  return decodeURIComponent(r.replace(e, ""));
}, B3 = (r, e) => {
  if (!r)
    return "webhooks";
  const t = Ph(r), s = encodeURIComponent(t);
  return `webhook/${e}/${s}`;
}, F3 = (r) => {
  if (!r)
    return "models";
  const e = Ph(r);
  return `model/${encodeURIComponent(e)}`;
}, V3 = (r, e) => `${nw(e)}/${r.httpVerb}${r.path}`, nw = ({ name: r }) => {
  const e = Ph(r);
  return `tag/${encodeURIComponent(e)}`;
}, U3 = (r = _p.value) => {
  var n;
  const e = (n = r.match(/(tag\/[^/]+)/)) == null ? void 0 : n[0], t = r.startsWith("model") ? "models" : "", s = r.startsWith("webhook") ? "webhooks" : "";
  return e || t || s;
}, z3 = () => {
  _p.value = fc.value ? sw(window.location.pathname) : decodeURIComponent(window.location.hash.replace(/^#/, ""));
}, Ct = () => ({
  hash: _p,
  getWebhookId: B3,
  getModelId: F3,
  getHeadingId: L3,
  getOperationId: V3,
  getPathRoutingId: sw,
  getSectionId: U3,
  getTagId: nw,
  isIntersectionEnabled: j3,
  pathRouting: fc,
  updateHash: z3
});
function xp(r) {
  return {
    parameterMap: oe(() => {
      var n;
      const t = ((n = r.operation.information) == null ? void 0 : n.parameters) ?? [], s = {
        path: [],
        query: [],
        header: [],
        body: [],
        formData: []
      };
      return r.operation.pathParameters && r.operation.pathParameters.forEach((o) => {
        o.in === "path" ? s.path.push(o) : o.in === "query" ? s.query.push(o) : o.in === "header" ? s.header.push(o) : o.in === "body" ? s.body.push(o) : o.in === "formData" && s.formData.push(o);
      }), t && t.forEach((o) => {
        o.in === "path" ? s.path.push(o) : o.in === "query" ? s.query.push(o) : o.in === "header" ? s.header.push(o) : o.in === "body" ? s.body.push(o) : o.in === "formData" && s.formData.push(o);
      }), s;
    })
  };
}
const q3 = async ({ url: r, content: e }, t) => {
  if (r)
    return pO(r) ? await Xp(r, t) : await Xp(r);
  const s = typeof e == "function" ? e() : e;
  if (typeof s == "string")
    return s;
  if (typeof s == "object")
    return qi(s);
};
function H3({
  specConfig: r,
  proxy: e
}) {
  const t = ie(""), s = $r(lo()), n = ie(null);
  function o(i) {
    return i ? T3(i).then((a) => {
      n.value = null, Object.assign(s, {
        servers: [],
        ...a
      });
    }).catch((a) => {
      n.value = a.toString();
    }) : Object.assign(s, lo());
  }
  return Le(
    () => Hp(r),
    async (i) => {
      var a;
      if (i) {
        const l = (a = await q3(i, Hp(e))) == null ? void 0 : a.trim();
        typeof l == "string" && (t.value = l);
      }
    },
    { immediate: !0, deep: !0 }
  ), Le(t, () => {
    o(t.value);
  }), {
    rawSpec: t,
    parsedSpec: s,
    specErrors: n
  };
}
function Cp(r) {
  return { responses: oe(() => {
    if (!r.information)
      return [];
    const { responses: t } = r.information, s = [];
    return t && Object.keys(t).forEach((n) => {
      s.push({
        name: n,
        description: t[n].description
      });
    }), s;
  }) };
}
const {
  getHeadingId: C0,
  getModelId: A0,
  getOperationId: E0,
  getSectionId: K3,
  getTagId: ow,
  getWebhookId: Qu,
  hash: wh
} = Ct(), ht = ie(void 0);
function W3(r) {
  return ht.value = r;
}
const iw = ie(!1), pc = $r(
  Eo["useSidebarContent-collapsedSidebarItems"] ?? {}
);
function G3(r) {
  pc[r] = !pc[r];
}
function Zu(r, e) {
  pc[r] = e;
}
const mc = ie([]), J3 = async (r) => {
  const e = await rc(r), t = ff(e);
  return e.filter((s) => (
    // highest level, eg. # Introduction
    s.depth === t || // second highest level, eg. ## Authentication
    s.depth === t + 1
  ));
}, aw = oe(() => {
  var d, h, f, m, g, p, y, b, v, k;
  const { state: r } = Ih(), e = {}, {
    openApi: { globalSecurity: t }
  } = ty(), s = [];
  let n = null;
  mc.value.forEach((_) => {
    var w;
    _.depth === ff(mc.value) ? (n = {
      id: C0(_),
      title: _.value,
      show: !r.showApiClient,
      children: []
    }, s.push(n)) : n && ((w = n.children) == null || w.push({
      id: C0(_),
      title: _.value,
      show: !r.showApiClient
    }));
  });
  const o = (h = (d = ht.value) == null ? void 0 : d.tags) == null ? void 0 : h[0], a = o && ((_) => (_ == null ? void 0 : _.length) !== 1 || _[0].name !== "default" || _[0].description !== "")((f = ht.value) == null ? void 0 : f.tags) ? (g = (m = ht.value) == null ? void 0 : m.tags) == null ? void 0 : g.filter((_) => {
    var w;
    return ((w = _.operations) == null ? void 0 : w.length) > 0;
  }).map((_) => {
    var w;
    return {
      id: ow(_),
      title: _.name,
      displayTitle: _["x-displayName"] ?? _.name,
      show: !0,
      children: (w = _.operations) == null ? void 0 : w.map(
        (x) => {
          var B;
          const T = E0(x, _), j = x.name ?? x.path;
          return e[T] = j, {
            id: T,
            title: j,
            httpVerb: x.httpVerb,
            deprecated: ((B = x.information) == null ? void 0 : B.deprecated) ?? !1,
            show: !0,
            select: () => {
              r.showApiClient && Qd(x, t);
            }
          };
        }
      )
    };
  }) : (p = o == null ? void 0 : o.operations) == null ? void 0 : p.map((_) => {
    var T;
    const w = E0(_, o), x = _.name ?? _.path;
    return e[w] = x, {
      id: w,
      title: x,
      httpVerb: _.httpVerb,
      deprecated: ((T = _.information) == null ? void 0 : T.deprecated) ?? !1,
      show: !0,
      select: () => {
        r.showApiClient && Qd(_, t);
      }
    };
  }), l = av(ht.value) && !iw.value ? [
    {
      id: A0(),
      title: "Models",
      show: !r.showApiClient,
      children: Object.keys(Fr(ht.value) ?? {}).map(
        (_) => {
          var x;
          const w = A0(_);
          return e[w] = _, {
            id: w,
            title: ((x = Fr(ht.value)) == null ? void 0 : x[_]).title ?? _,
            show: !r.showApiClient
          };
        }
      )
    }
  ] : [], c = (y = ht.value) != null && y["x-tagGroups"] ? (v = (b = ht.value) == null ? void 0 : b["x-tagGroups"]) == null ? void 0 : v.map((_) => {
    const w = [];
    return _.tags.map((T) => {
      if (T === "models" && l.length > 0)
        w.push(l[0]);
      else {
        const j = a == null ? void 0 : a.find(
          (B) => B.title === T
        );
        j && w.push(j);
      }
    }), {
      id: _.name,
      title: _.name,
      children: w,
      show: !0,
      isGroup: !0
    };
  }) : void 0, u = fO(ht.value) ? [
    {
      id: Qu(),
      title: "Webhook",
      show: !r.showApiClient,
      children: Object.keys(((k = ht.value) == null ? void 0 : k.webhooks) ?? {}).map((_) => {
        var x, T;
        const w = Qu(_);
        return e[w] = _, Object.keys(
          ((T = (x = ht.value) == null ? void 0 : x.webhooks) == null ? void 0 : T[_]) ?? {}
        ).map((j) => {
          var B, W, L;
          return {
            id: Qu(_, j),
            title: (L = (W = (B = ht.value) == null ? void 0 : B.webhooks) == null ? void 0 : W[_][j]) == null ? void 0 : L.name,
            httpVerb: j,
            show: !r.showApiClient
          };
        });
      }).flat()
    }
  ] : [];
  return {
    entries: [
      ...s,
      ...c ?? a ?? [],
      ...c ? [] : u,
      ...c ? [] : l
    ],
    titles: e
  };
}), Y3 = ie(!1), X3 = oe(() => {
  var r, e;
  return ((e = (r = aw.value) == null ? void 0 : r.titles) == null ? void 0 : e[wh.value]) ?? "";
});
function xr(r) {
  return r != null && r.parsedSpec && (ht.value = r.parsedSpec, Le(
    () => {
      var e, t;
      return (t = (e = ht.value) == null ? void 0 : e.tags) == null ? void 0 : t.length;
    },
    () => {
      var e, t;
      if (wh.value) {
        const s = K3(wh.value);
        s && Zu(s, !0);
      } else {
        const s = (t = (e = ht.value) == null ? void 0 : e.tags) == null ? void 0 : t[0];
        s && Zu(ow(s), !0);
      }
    }
  ), Le(
    () => {
      var e, t;
      return (t = (e = ht.value) == null ? void 0 : e.info) == null ? void 0 : t.description;
    },
    async () => {
      var t, s;
      const e = (s = (t = ht.value) == null ? void 0 : t.info) == null ? void 0 : s.description;
      return e ? mc.value = await J3(e) : mc.value = [];
    }
  )), {
    breadcrumb: X3,
    items: aw,
    isSidebarOpen: Y3,
    collapsedSidebarItems: pc,
    toggleCollapsedSidebarItem: G3,
    setCollapsedSidebarItem: Zu,
    hideModels: iw,
    setParsedSpec: W3
  };
}
const Q3 = /* @__PURE__ */ Q({
  __name: "SidebarHttpBadge",
  props: {
    active: { type: Boolean },
    method: {}
  },
  setup(r) {
    return (e, t) => (S(), U($(Po), {
      class: xe(["sidebar-heading-type", { "sidebar-heading-type-active": e.active }]),
      method: e.method,
      property: "--method-color",
      short: ""
    }, null, 8, ["class", "method"]));
  }
}), lw = /* @__PURE__ */ ne(Q3, [["__scopeId", "data-v-9e6d2bc7"]]), Z3 = ["id"], ej = {
  key: 0,
  class: "sidebar-heading-chevron"
}, tj = ["href"], rj = { class: "sidebar-heading-link-title" }, sj = {
  key: 1,
  class: "sidebar-heading-link-method"
}, nj = {
  key: 1,
  class: "action-menu"
}, oj = /* @__PURE__ */ Q({
  __name: "SidebarElement",
  props: {
    id: {},
    item: {},
    isActive: { type: Boolean },
    hasChildren: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["toggleOpen"],
  setup(r, { emit: e }) {
    const t = r, s = e, { hash: n, isIntersectionEnabled: o, pathRouting: i } = Ct(), a = async () => {
      var u, d;
      t.hasChildren && s("toggleOpen"), (d = (u = t.item) == null ? void 0 : u.select) == null || d.call(u), t.open && (o.value = !1, await hs(100), o.value = !0);
    }, l = () => {
      if (i.value)
        return i.value.basePath + "/" + t.item.id;
      {
        const u = new URL(window.location.href);
        return u.hash = t.item.id, `${u.pathname}${u.search}${u.hash}`;
      }
    }, c = async (u) => {
      var d, h;
      if (i.value) {
        u.preventDefault(), t.hasChildren && s("toggleOpen"), (h = (d = t.item) == null ? void 0 : d.select) == null || h.call(d), s("toggleOpen"), o.value = !1, n.value = t.item.id;
        const f = new URL(window.location.href);
        f.pathname = i.value.basePath + "/" + t.item.id, window.history.pushState({}, "", f), hc(t.item.id), await hs(100), o.value = !0;
      }
    };
    return (u, d) => {
      var h, f;
      return S(), E("li", {
        id: u.id,
        class: "sidebar-group-item"
      }, [
        V("div", {
          class: xe(["sidebar-heading", {
            "sidebar-group-item__folder": u.hasChildren,
            active_page: u.isActive,
            deprecated: u.item.deprecated ?? !1
          }]),
          onClick: a
        }, [
          u.hasChildren ? (S(), E("p", ej, [
            R($(va), {
              class: "toggle-nested-icon",
              icon: u.open ? "ChevronDown" : "ChevronRight",
              label: "Toggle group",
              size: "xs",
              onClick: ca(a, ["stop"])
            }, null, 8, ["icon"]),
            J("   ")
          ])) : z("", !0),
          V("a", {
            class: "sidebar-heading-link",
            href: l(),
            onClick: c
          }, [
            (f = (h = u.item) == null ? void 0 : h.icon) != null && f.src ? (S(), U($(Ze), {
              key: 0,
              class: "sidebar-icon",
              icon: u.item.icon.src
            }, null, 8, ["icon"])) : z("", !0),
            V("p", rj, ee(u.item.title), 1),
            u.item.httpVerb && !u.hasChildren ? (S(), E("p", sj, [
              J("   "),
              R(lw, {
                active: u.isActive,
                method: u.item.httpVerb
              }, null, 8, ["active", "method"])
            ])) : z("", !0)
          ], 8, tj)
        ], 2),
        u.open ? te(u.$slots, "default", { key: 0 }, void 0, !0) : z("", !0),
        u.$slots["action-menu"] ? (S(), E("div", nj, [
          te(u.$slots, "action-menu", {}, void 0, !0)
        ])) : z("", !0)
      ], 8, Z3);
    };
  }
}), yl = /* @__PURE__ */ ne(oj, [["__scopeId", "data-v-4ed1078c"]]), ij = /* @__PURE__ */ Q({
  __name: "SidebarGroup",
  props: {
    level: {}
  },
  setup(r) {
    return (e, t) => (S(), E("ul", {
      class: "sidebar-group sidebar-indent-nested",
      style: os({ "--scalar-sidebar-level": e.level })
    }, [
      te(e.$slots, "default", {}, void 0, !0)
    ], 4));
  }
}), ed = /* @__PURE__ */ ne(ij, [["__scopeId", "data-v-39c84840"]]), aj = { class: "sidebar" }, lj = { class: "sidebar-group-title" }, cj = -160, uj = /* @__PURE__ */ Q({
  __name: "Sidebar",
  props: {
    parsedSpec: {}
  },
  setup(r) {
    const e = r, { hash: t, isIntersectionEnabled: s } = Ct(), { items: n, toggleCollapsedSidebarItem: o, collapsedSidebarItems: i } = xr(
      {
        parsedSpec: e.parsedSpec
      }
    ), a = ie(null), l = ie(!0);
    Le(t, (u) => {
      !s.value || l.value || typeof window > "u" || c(u);
    });
    const c = (u) => {
      var f, m, g, p;
      const d = document.getElementById(`sidebar-${u}`);
      if (!d || !a.value)
        return;
      let h = cj;
      d.getAttribute("data-sidebar-type") === "heading" ? h += d.offsetTop + ((f = d.getElementsByClassName("sidebar-heading")) == null ? void 0 : f[0]).offsetHeight : h += d.offsetTop + (((m = d.parentElement) == null ? void 0 : m.offsetTop) ?? 0) + (((p = (g = d.parentElement) == null ? void 0 : g.parentElement) == null ? void 0 : p.offsetTop) ?? 0), a.value.scrollTo({ top: h, behavior: "smooth" });
    };
    return vr(() => {
      setTimeout(() => c(t.value), 500), l.value = !1;
    }), (u, d) => (S(), E("div", aj, [
      te(u.$slots, "sidebar-start", {}, void 0, !0),
      V("div", {
        ref_key: "scrollerEl",
        ref: a,
        class: "sidebar-pages custom-scroll custom-scroll-self-contain-overflow"
      }, [
        R(ed, { level: 0 }, {
          default: P(() => [
            (S(!0), E(Z, null, we($(n).entries, (h) => (S(), E(Z, {
              key: h.id
            }, [
              h.isGroup ? (S(), E(Z, { key: 0 }, [
                V("li", lj, ee(h.displayTitle ?? h.title), 1),
                (S(!0), E(Z, null, we(h.children, (f) => (S(), U(yl, {
                  key: f.id,
                  id: `sidebar-${f.id}`,
                  "data-sidebar-type": "heading",
                  hasChildren: f.children && f.children.length > 0,
                  isActive: $(t) === f.id,
                  item: {
                    id: f.id,
                    title: f.displayTitle ?? f.title,
                    select: f.select,
                    httpVerb: f.httpVerb,
                    deprecated: f.deprecated ?? !1
                  },
                  open: $(i)[f.id] ?? !1,
                  onToggleOpen: async () => {
                    l.value = !0, $(o)(f.id), await $(hs)(100), l.value = !1;
                  }
                }, {
                  default: P(() => {
                    var m;
                    return [
                      f.children && ((m = f.children) == null ? void 0 : m.length) > 0 ? (S(), U(ed, {
                        key: 0,
                        level: 1
                      }, {
                        default: P(() => [
                          (S(!0), E(Z, null, we(f.children, (g) => (S(), E(Z, {
                            key: g.id
                          }, [
                            h.show ? (S(), U(yl, {
                              key: 0,
                              id: `sidebar-${g.id}`,
                              isActive: $(t) === g.id,
                              item: {
                                id: g.id,
                                title: g.displayTitle ?? g.title,
                                select: g.select,
                                httpVerb: g.httpVerb,
                                deprecated: g.deprecated ?? !1
                              }
                            }, null, 8, ["id", "isActive", "item"])) : z("", !0)
                          ], 64))), 128))
                        ]),
                        _: 2
                      }, 1024)) : z("", !0)
                    ];
                  }),
                  _: 2
                }, 1032, ["id", "hasChildren", "isActive", "item", "open", "onToggleOpen"]))), 128))
              ], 64)) : (S(), E(Z, { key: 1 }, [
                h.show ? (S(), U(yl, {
                  key: 0,
                  id: `sidebar-${h.id}`,
                  "data-sidebar-type": "heading",
                  hasChildren: h.children && h.children.length > 0,
                  isActive: $(t) === h.id,
                  item: {
                    id: h.id,
                    title: h.displayTitle ?? h.title,
                    select: h.select,
                    httpVerb: h.httpVerb,
                    deprecated: h.deprecated ?? !1
                  },
                  open: $(i)[h.id] ?? !1,
                  onToggleOpen: async () => {
                    l.value = !0, $(o)(h.id), await $(hs)(100), l.value = !1;
                  }
                }, {
                  default: P(() => {
                    var f;
                    return [
                      h.children && ((f = h.children) == null ? void 0 : f.length) > 0 ? (S(), U(ed, {
                        key: 0,
                        level: 1
                      }, {
                        default: P(() => [
                          (S(!0), E(Z, null, we(h.children, (m) => (S(), E(Z, {
                            key: m.id
                          }, [
                            h.show ? (S(), U(yl, {
                              key: 0,
                              id: `sidebar-${m.id}`,
                              isActive: $(t) === m.id,
                              item: {
                                id: m.id,
                                title: m.displayTitle ?? m.title,
                                select: m.select,
                                httpVerb: m.httpVerb,
                                deprecated: m.deprecated ?? !1
                              }
                            }, null, 8, ["id", "isActive", "item"])) : z("", !0)
                          ], 64))), 128))
                        ]),
                        _: 2
                      }, 1024)) : z("", !0)
                    ];
                  }),
                  _: 2
                }, 1032, ["id", "hasChildren", "isActive", "item", "open", "onToggleOpen"])) : z("", !0)
              ], 64))
            ], 64))), 128))
          ]),
          _: 1
        })
      ], 512),
      te(u.$slots, "sidebar-end", {}, void 0, !0)
    ]));
  }
}), cw = /* @__PURE__ */ ne(uj, [["__scopeId", "data-v-e68ba74a"]]), dj = {
  key: 0,
  class: "api-client-drawer"
}, hj = { class: "api-client-container" }, fj = { class: "scalar-api-client-height" }, pj = { class: "scalar-api-client-states" }, mj = { class: "t-doc__sidebar" }, gj = /* @__PURE__ */ Q({
  __name: "ApiClientModal",
  props: {
    parsedSpec: {},
    overloadShow: { type: Boolean },
    proxyUrl: {},
    theme: {}
  },
  emits: ["toggleDarkMode"],
  setup(r) {
    const e = M0(
      () => import("./index-CKiQQBFv.js").then((i) => i.ApiClient)
    ), { hideApiClient: t, state: s } = Ih(), n = Th("(max-width: 1000px)"), o = ie(!1);
    return (i, a) => (S(), E(Z, null, [
      $(s).showApiClient || i.overloadShow ? (S(), E("div", dj, [
        V("div", hj, [
          te(i.$slots, "header", {}, void 0, !0),
          V("div", fj, [
            R($(e), {
              proxyUrl: i.proxyUrl,
              showSideBar: o.value,
              theme: i.theme ?? "none",
              withDefaultFonts: !1,
              onEscapeKeyPress: $(t),
              onToggleSidebar: a[2] || (a[2] = (l) => o.value = !o.value)
            }, {
              "address-bar-controls": P(() => [
                V("div", pj, [
                  V("button", {
                    class: "scalar-api-client-states-button scalar-api-client-states-button__endpoints",
                    type: "button",
                    onClick: a[0] || (a[0] = (l) => o.value = !o.value)
                  }, [
                    R($(Ze), {
                      icon: o.value ? "SideBarClosed" : "SideBarOpen",
                      size: "sm"
                    }, null, 8, ["icon"])
                  ]),
                  V("button", {
                    class: "scalar-api-client-states-button",
                    type: "button",
                    onClick: a[1] || (a[1] = //@ts-ignore
                    (...l) => $(t) && $(t)(...l))
                  }, [
                    R($(Ze), {
                      icon: "Close",
                      size: "sm"
                    })
                  ])
                ])
              ]),
              sidebar: P(() => [
                V("div", mj, [
                  Ao(R($(cw), { parsedSpec: i.parsedSpec }, {
                    "sidebar-start": P(() => [
                      te(i.$slots, "sidebar-start", {}, void 0, !0)
                    ]),
                    _: 3
                  }, 8, ["parsedSpec"]), [
                    [yc, !$(n)]
                  ])
                ])
              ]),
              _: 3
            }, 8, ["proxyUrl", "showSideBar", "theme", "onEscapeKeyPress"])
          ])
        ])
      ])) : z("", !0),
      $(s).showApiClient ? (S(), E("div", {
        key: 1,
        class: "api-client-drawer-exit",
        onClick: a[3] || (a[3] = //@ts-ignore
        (...l) => $(t) && $(t)(...l))
      })) : z("", !0)
    ], 64));
  }
}), yj = /* @__PURE__ */ ne(gj, [["__scopeId", "data-v-206ad1a1"]]);
function uw(r) {
  var e;
  return ((e = fo.value.find((t) => t.key === r.targetKey)) == null ? void 0 : e.title) ?? r.targetKey;
}
function dw(r) {
  var e, t;
  return ((t = (e = fo.value.find((s) => s.key === r.targetKey)) == null ? void 0 : e.clients.find((s) => s.key === r.clientKey)) == null ? void 0 : t.title) ?? r.clientKey;
}
const bj = oe(() => uw(An)), vj = oe(() => dw(An));
function wj(r, e) {
  return e.value === !0 ? [] : r.flatMap((t) => {
    var s;
    return typeof e.value != "object" ? [] : Array.isArray(e.value) ? (t.clients = t.clients.filter(
      // @ts-expect-error Typescript, chill. It’s all good. It has to be an array.
      (n) => !e.value.includes(n.key)
    ), [t]) : e.value[t.key] === !0 ? [] : (Array.isArray(e.value[t.key]) && (t.clients = t.clients.filter((n) => !// @ts-expect-error We checked whether it’s an Array already.
    e.value[t.key].includes(n.key))), (s = t == null ? void 0 : t.clients) != null && s.length ? [t] : []);
  });
}
const fo = oe(() => {
  var e;
  const r = bk();
  return (e = r.find((t) => t.key === "node")) == null || e.clients.unshift({
    description: "An HTTP/1.1 client, written from scratch for Node.js.",
    key: "undici",
    link: "https://github.com/nodejs/undici",
    title: "undici"
  }), wj(r, kh);
}), O0 = {
  node: ["unirest"]
}, kh = ie({
  ...O0 === !0 ? {} : O0
}), Ap = () => {
  var e, t, s, n;
  return fo.value.find(
    (o) => o.key === "shell" && o.clients.find((i) => i.key === "curl")
  ) ? {
    targetKey: "shell",
    clientKey: "curl"
  } : {
    targetKey: (e = fo.value[0]) == null ? void 0 : e.key,
    clientKey: (n = (s = (t = fo.value[0]) == null ? void 0 : t.clients) == null ? void 0 : s[0]) == null ? void 0 : n.key
  };
}, An = $r(Ap());
function kj() {
  pf(An, Ap());
}
const Sj = (r) => {
  Object.assign(An, {
    ...An,
    ...r
  });
}, Ia = () => ({
  httpClient: td(An),
  resetState: kj,
  setHttpClient: Sj,
  excludedClients: td(kh),
  setExcludedClients: (r) => {
    kh.value = r, pf(An, Ap());
  },
  availableTargets: fo,
  getClientTitle: dw,
  getTargetTitle: uw,
  httpTargetTitle: bj,
  httpClientTitle: vj
}), $j = { key: 0 }, _j = { class: "authentication-header" }, xj = { class: "selector" }, Cj = {
  key: 0,
  class: "authentication-content"
}, Aj = /* @__PURE__ */ Q({
  __name: "Authentication",
  props: {
    parsedSpec: {},
    proxy: {}
  },
  setup(r) {
    const e = r, { authentication: t, setAuthentication: s } = ha(), n = oe(() => {
      var i, a, l;
      if (!t.preferredSecurityScheme)
        return !1;
      const o = (l = (a = (i = e.parsedSpec) == null ? void 0 : i.components) == null ? void 0 : a.securitySchemes) == null ? void 0 : l[t.preferredSecurityScheme];
      return !!o && "type" in o && !!o.type;
    });
    return Le(
      () => {
        var o, i;
        return (i = (o = e.parsedSpec) == null ? void 0 : o.components) == null ? void 0 : i.securitySchemes;
      },
      () => {
        var o, i;
        s({
          securitySchemes: (i = (o = e.parsedSpec) == null ? void 0 : o.components) == null ? void 0 : i.securitySchemes
        });
      },
      { deep: !0, immediate: !0 }
    ), On(async () => {
      const o = aa();
      await hs(1), o.payload.data["useGlobalStore-authentication"] = t;
    }), (o, i) => {
      var a, l, c, u, d;
      return $(hO)(o.parsedSpec) ? (S(), E("div", $j, [
        V("div", _j, [
          V("div", xj, [
            R($(lO), {
              value: (l = (a = o.parsedSpec) == null ? void 0 : a.components) == null ? void 0 : l.securitySchemes
            }, null, 8, ["value"])
          ])
        ]),
        n.value ? (S(), E("div", Cj, [
          $(t).preferredSecurityScheme ? (S(), U($(ZE), {
            key: 0,
            proxy: o.proxy,
            value: (d = (u = (c = o.parsedSpec) == null ? void 0 : c.components) == null ? void 0 : u.securitySchemes) == null ? void 0 : d[$(t).preferredSecurityScheme]
          }, null, 8, ["proxy", "value"])) : z("", !0)
        ])) : z("", !0)
      ])) : z("", !0);
    };
  }
}), Ej = /* @__PURE__ */ ne(Aj, [["__scopeId", "data-v-adb00e96"]]), Oj = ["innerHTML"], Tj = /* @__PURE__ */ Q({
  __name: "MarkdownRenderer",
  props: {
    value: {},
    withImages: { type: Boolean, default: !1 }
  },
  setup(r) {
    const e = r, t = ie(""), s = e.withImages ? [] : ["img", "picture"], n = {
      ...fu,
      tagNames: [
        ...(fu.tagNames || []).filter(
          // Removes disallowed tags
          (o) => !s.includes(o)
        ),
        // Adds support for <abbr>
        "abbr"
      ],
      attributes: {
        ...fu.attributes,
        abbr: ["title"]
      }
    };
    return Le(
      () => e.value,
      async () => {
        const o = await L0().use(j0).use(Ck).use(Ak, { allowDangerousHtml: !0 }).use($k).use(_k, n).use(Sk, {
          detect: !0
        }).use(wk, { target: "_blank" }).use(kk).use(xk).process(e.value);
        t.value = String(o.value);
      },
      { immediate: !0 }
    ), On(async () => await hs(1)), (o, i) => (S(), E("div", {
      class: "markdown",
      innerHTML: t.value
    }, null, 8, Oj));
  }
}), Lt = /* @__PURE__ */ ne(Tj, [["__scopeId", "data-v-5a5f5321"]]), Pj = ["title", "innerHTML"], Ij = /* @__PURE__ */ Q({
  __name: "ServerItem",
  props: {
    value: {},
    variables: {}
  },
  setup(r) {
    const e = r, { copyToClipboard: t } = Go(), s = oe(() => {
      var a;
      const i = (((a = e.value) == null ? void 0 : a.url) ?? "").replace(/(<([^>]+)>)/gi, "");
      return jb(i, (l) => {
        var u;
        const c = (u = e.variables) == null ? void 0 : u.find(
          (d) => d.name === l
        );
        return `<span class="base-url-variable">${((c == null ? void 0 : c.value) ?? "") !== "" ? c == null ? void 0 : c.value : `{${l}}`}</span>`;
      });
    }), n = oe(
      () => s.value.replace(/(<([^>]+)>)/gi, "")
    );
    return (o, i) => o.value ? (S(), E("a", {
      key: 0,
      class: "base-url",
      title: o.value.description,
      onClick: i[0] || (i[0] = (a) => $(t)(n.value)),
      innerHTML: s.value
    }, null, 8, Pj)) : z("", !0);
  }
}), Nj = /* @__PURE__ */ ne(Ij, [["__scopeId", "data-v-41c016dc"]]), Mj = { key: 0 }, Dj = ["for"], Rj = ["id", "value", "onInput"], jj = ["value"], Lj = { class: "input-value" }, Bj = ["id", "value", "onInput"], Fj = /* @__PURE__ */ Q({
  __name: "ServerVariables",
  props: {
    value: {}
  },
  setup(r) {
    const { server: e, setServer: t } = To(), s = (o, i) => {
      const a = i.target.value, l = [...e.variables], c = l.findIndex((u) => u.name === o);
      l[c].value = a, t({
        variables: l
      });
    }, n = (o) => {
      const i = e.variables.findIndex((a) => a.name === o);
      return e.variables[i].value ?? "";
    };
    return (o, i) => o.value ? (S(), E("div", Mj, [
      (S(!0), E(Z, null, we(o.value, (a) => (S(), E("div", {
        key: a.name,
        class: "input"
      }, [
        V("label", {
          for: `variable-${a.name}`
        }, [
          V("code", null, ee(a.name), 1)
        ], 8, Dj),
        a.enum ? (S(), E(Z, { key: 0 }, [
          V("select", {
            id: `variable-${a.name}`,
            value: n(a.name),
            onInput: (l) => s(a.name, l)
          }, [
            (S(!0), E(Z, null, we(a.enum, (l) => (S(), E("option", {
              key: l,
              value: l
            }, ee(l), 9, jj))), 128))
          ], 40, Rj),
          V("div", Lj, ee(a.default), 1)
        ], 64)) : (S(), E("input", {
          key: 1,
          id: `variable-${a.name}`,
          autocomplete: "off",
          placeholder: "value",
          spellcheck: "false",
          type: "text",
          value: n(a.name),
          onInput: (l) => s(a.name, l)
        }, null, 40, Bj))
      ]))), 128))
    ])) : z("", !0);
  }
}), Vj = /* @__PURE__ */ ne(Fj, [["__scopeId", "data-v-2e5f4fe1"]]), Uj = (r) => (It("data-v-1634f7d3"), r = r(), Nt(), r), zj = { key: 0 }, qj = /* @__PURE__ */ Uj(() => /* @__PURE__ */ V("span", { class: "scalar-card-serverlist-title" }, "Base URL", -1)), Hj = { class: "scalar-card-serverlist" }, Kj = { class: "scalar-card-serverlist-container" }, Wj = { class: "server-item" }, Gj = { class: "server-selector" }, Jj = ["value"], Yj = ["value"], Xj = {
  key: 0,
  muted: ""
}, Qj = { class: "description" }, Zj = /* @__PURE__ */ Q({
  __name: "BaseUrl",
  setup(r) {
    const { server: e, setServer: t } = To(), s = ie(0);
    return Le(
      [s, () => e.servers],
      () => {
        var a, l, c;
        if (!e.servers.length)
          return;
        const n = ((a = e.servers[s.value]) == null ? void 0 : a.variables) ?? {}, o = n ? Object.keys(n).map((u) => {
          var d;
          return {
            name: u,
            value: ((d = n[u].default) == null ? void 0 : d.toString()) ?? ""
          };
        }) : [];
        Px(
          (l = e.servers[s.value]) == null ? void 0 : l.url
        ).filter((u) => !n[u]).forEach((u) => {
          o.push({
            name: u,
            value: ""
          });
        }), t({
          selectedServer: s.value,
          description: (c = e.servers[s.value]) == null ? void 0 : c.description,
          variables: o
        });
      },
      {
        immediate: !0,
        deep: !0
      }
    ), (n, o) => $(e).servers.length > 0 ? (S(), E("div", zj, [
      qj,
      V("div", Hj, [
        V("div", Kj, [
          V("div", Wj, [
            V("div", Gj, [
              $(e).servers.length > 1 ? (S(), E("select", {
                key: 0,
                value: s.value,
                onInput: o[0] || (o[0] = (i) => s.value = parseInt(
                  i.target.value,
                  10
                ))
              }, [
                (S(!0), E(Z, null, we($(e).servers, (i, a) => (S(), E("option", {
                  key: a,
                  value: a
                }, ee(i.url), 9, Yj))), 128))
              ], 40, Jj)) : z("", !0),
              R(Nj, {
                value: $(e).servers[s.value],
                variables: $(e).variables
              }, null, 8, ["value", "variables"]),
              $(e).servers.length > 1 ? (S(), U($(Ze), {
                key: 1,
                icon: "ChevronDown"
              })) : z("", !0)
            ])
          ]),
          R(Vj, {
            value: $(e).variables
          }, null, 8, ["value"])
        ])
      ]),
      $(e).description ? (S(), E("div", Xj, [
        V("div", Qj, [
          R($(Lt), {
            value: $(e).description
          }, null, 8, ["value"])
        ])
      ])) : z("", !0)
    ])) : z("", !0);
  }
}), eL = /* @__PURE__ */ ne(Zj, [["__scopeId", "data-v-1634f7d3"]]), tL = (r) => (It("data-v-09827b05"), r = r(), Nt(), r), rL = ["onClick"], sL = ["value"], nL = ["label"], oL = ["value"], iL = { class: "client-libraries-icon__more" }, aL = {
  key: 1,
  class: "client-libraries-icon",
  height: "50",
  viewBox: "0 0 50 50",
  width: "50",
  xmlns: "http://www.w3.org/2000/svg"
}, lL = /* @__PURE__ */ tL(() => /* @__PURE__ */ V("g", {
  fill: "currentColor",
  "fill-rule": "nonzero"
}, [
  /* @__PURE__ */ V("path", { d: "M10.71 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M21.13 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M31.55 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0" })
], -1)), cL = [
  lL
], uL = { key: 0 }, dL = /* @__PURE__ */ Q({
  __name: "ClientSelector",
  setup(r) {
    const {
      httpClient: e,
      setHttpClient: t,
      availableTargets: s,
      getClientTitle: n,
      getTargetTitle: o
    } = Ia(), i = ie(), a = [
      {
        targetKey: "shell",
        clientKey: "curl"
      },
      {
        targetKey: "ruby",
        clientKey: "native"
      },
      {
        targetKey: "node",
        clientKey: "undici"
      },
      {
        targetKey: "php",
        clientKey: "guzzle"
      },
      {
        targetKey: "python",
        clientKey: "python3"
      }
    ].filter(
      (d) => s.value.find((h) => h.key === d.targetKey && h.clients.find(
        (f) => f.key === d.clientKey
      ))
    ), l = (d) => `programming-language-${d}`, c = (d) => d.targetKey === e.targetKey && d.clientKey === e.clientKey, u = (d) => a.some(
      (h) => h.targetKey === d.targetKey && h.clientKey === d.clientKey
    );
    return (d, h) => (S(), E("div", {
      ref_key: "containerRef",
      ref: i,
      class: "client-libraries-content"
    }, [
      (S(!0), E(Z, null, we($(a), (f) => (S(), E("div", {
        key: f.clientKey,
        class: xe(["client-libraries rendered-code-sdks", {
          "client-libraries__active": c(f)
        }]),
        onClick: () => $(t)(f)
      }, [
        V("div", {
          class: xe(`client-libraries-icon__${f.targetKey}`)
        }, [
          R($(Ze), {
            class: "client-libraries-icon",
            icon: l(f.targetKey)
          }, null, 8, ["icon"])
        ], 2),
        V("span", null, ee($(o)(f)), 1)
      ], 10, rL))), 128)),
      V("div", {
        class: xe(["client-libraries client-libraries__select", {
          "client-libraries__active": $(e) && !u($(e))
        }])
      }, [
        V("select", {
          class: "language-select",
          value: JSON.stringify($(e)),
          onInput: h[0] || (h[0] = (f) => $(t)(JSON.parse(f.target.value)))
        }, [
          (S(!0), E(Z, null, we($(s), (f) => (S(), E("optgroup", {
            key: f.key,
            label: f.title
          }, [
            (S(!0), E(Z, null, we(f.clients, (m) => (S(), E("option", {
              key: m.key,
              value: JSON.stringify({
                targetKey: f.key,
                clientKey: m.key
              })
            }, ee($(n)({
              targetKey: f.key,
              clientKey: m.key
            })), 9, oL))), 128))
          ], 8, nL))), 128))
        ], 40, sL),
        V("div", iL, [
          $(e) && !u($(e)) ? (S(), E("div", {
            key: 0,
            class: xe(`client-libraries-icon__${$(e).targetKey}`)
          }, [
            R($(Ze), {
              class: "client-libraries-icon",
              icon: l($(e).targetKey)
            }, null, 8, ["icon"])
          ], 2)) : (S(), E("svg", aL, cL))
        ]),
        $(s).length ? (S(), E("span", uL, "More")) : z("", !0)
      ], 2)
    ], 512));
  }
}), hL = /* @__PURE__ */ ne(dL, [["__scopeId", "data-v-09827b05"]]), fL = (r) => (It("data-v-301043da"), r = r(), Nt(), r), pL = /* @__PURE__ */ fL(() => /* @__PURE__ */ V("div", { class: "client-libraries-heading" }, "Client Libraries", -1)), mL = {
  class: "selected-client card-footer",
  muted: ""
}, gL = /* @__PURE__ */ Q({
  __name: "ClientLibraries",
  setup(r) {
    const { availableTargets: e, httpTargetTitle: t, httpClientTitle: s } = Ia();
    return (n, o) => (S(), E("div", null, [
      $(e).length ? (S(), E(Z, { key: 0 }, [
        pL,
        V("div", null, [
          R(hL)
        ]),
        V("div", mL, ee($(s)) + " " + ee($(t)), 1)
      ], 64)) : z("", !0)
    ]));
  }
}), yL = /* @__PURE__ */ ne(gL, [["__scopeId", "data-v-301043da"]]), bL = {}, vL = { class: "badge" };
function wL(r, e) {
  return S(), E("div", vL, [
    te(r.$slots, "default", {}, void 0, !0)
  ]);
}
const ia = /* @__PURE__ */ ne(bL, [["render", wL], ["__scopeId", "data-v-190574ac"]]), Ep = /* @__PURE__ */ Q({
  __name: "IntersectionObserver",
  props: {
    id: {},
    is: {}
  },
  emits: ["intersecting"],
  setup(r, { emit: e }) {
    const t = r, s = e, n = ie(), o = (a) => {
      const l = a.offsetHeight;
      return `${l / 2}px 0px ${l / 2}px 0px`;
    }, i = (a) => a.offsetHeight < window.innerHeight ? 0.8 : 0.5;
    return vr(() => {
      if (n.value) {
        const a = {
          rootMargin: o(n.value),
          threshold: i(n.value)
        };
        ak(
          n,
          ([{ isIntersecting: l }]) => {
            l && t.id && s("intersecting");
          },
          a
        );
      }
    }), (a, l) => (S(), U(br(a.is ?? "div"), {
      id: a.id,
      ref_key: "intersectionObserverRef",
      ref: n
    }, {
      default: P(() => [
        te(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["id"]));
  }
}), kL = /* @__PURE__ */ Q({
  __name: "Section",
  props: {
    id: {},
    label: {}
  },
  setup(r) {
    const e = r, { getSectionId: t, hash: s, isIntersectionEnabled: n, pathRouting: o } = Ct(), { setCollapsedSidebarItem: i } = xr();
    function a() {
      var u, d;
      if (!e.label || !n.value)
        return;
      const l = new URL(window.location.href), c = e.id ?? "";
      o.value ? l.pathname = o.value.basePath + "/" + c : l.hash = c, s.value = c, window.history.replaceState({}, "", l), ((u = e.id) != null && u.startsWith("model") || (d = e.id) != null && d.startsWith("webhook")) && i(t(e.id), !0);
    }
    return (l, c) => (S(), U(Ep, {
      is: "section",
      id: l.id,
      class: "section",
      onIntersecting: a
    }, {
      default: P(() => [
        te(l.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }, 8, ["id"]));
  }
}), Jo = /* @__PURE__ */ ne(kL, [["__scopeId", "data-v-a09c928d"]]), SL = { class: "section-accordion-button-content" }, $L = {
  key: 0,
  class: "section-accordion-button-actions"
}, _L = {
  key: 0,
  class: "section-accordion-description"
}, xL = { class: "section-accordion-content-card" }, CL = /* @__PURE__ */ Q({
  __name: "SectionAccordion",
  props: {
    id: {},
    transparent: { type: Boolean }
  },
  setup(r) {
    const e = ie(), t = lk(e);
    return (s, n) => (S(), U(Ep, {
      id: s.id,
      class: "section-wrapper"
    }, {
      default: P(() => [
        R($(Ch), {
          as: "section",
          class: xe(["section-accordion", { "section-accordion-transparent": s.transparent }])
        }, {
          default: P(({ open: o }) => [
            R($(Ah), {
              ref_key: "button",
              ref: e,
              class: "section-accordion-button"
            }, {
              default: P(() => [
                V("div", SL, [
                  te(s.$slots, "title", {}, void 0, !0)
                ]),
                s.$slots.actions ? (S(), E("div", $L, [
                  te(s.$slots, "actions", {
                    active: $(t) || o
                  }, void 0, !0)
                ])) : z("", !0),
                R($(Ze), {
                  class: "section-accordion-chevron",
                  icon: o ? "ChevronDown" : "ChevronRight"
                }, null, 8, ["icon"])
              ]),
              _: 2
            }, 1536),
            R($(Eh), { class: "section-accordion-content" }, {
              default: P(() => [
                s.$slots.description ? (S(), E("div", _L, [
                  te(s.$slots, "description", {}, void 0, !0)
                ])) : z("", !0),
                V("div", xL, [
                  te(s.$slots, "default", {}, void 0, !0)
                ])
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 8, ["id"]));
  }
}), hw = /* @__PURE__ */ ne(CL, [["__scopeId", "data-v-07cabcb0"]]), AL = {}, EL = { class: "section-column" };
function OL(r, e) {
  return S(), E("div", EL, [
    te(r.$slots, "default", {}, void 0, !0)
  ]);
}
const xo = /* @__PURE__ */ ne(AL, [["render", OL], ["__scopeId", "data-v-d64e7382"]]), TL = {}, PL = { class: "section-columns" };
function IL(r, e) {
  return S(), E("div", PL, [
    te(r.$slots, "default", {}, void 0, !0)
  ]);
}
const Op = /* @__PURE__ */ ne(TL, [["render", IL], ["__scopeId", "data-v-8b9602bf"]]), NL = {}, ML = { class: "section-container" };
function DL(r, e) {
  return S(), E("div", ML, [
    te(r.$slots, "default", {}, void 0, !0)
  ]);
}
const Na = /* @__PURE__ */ ne(NL, [["render", DL], ["__scopeId", "data-v-34b26958"]]), RL = { class: "section-accordion-wrapper" }, jL = { class: "section-accordion-title" }, LL = /* @__PURE__ */ Q({
  __name: "SectionContainerAccordion",
  setup(r) {
    return (e, t) => (S(), E("div", RL, [
      R($(Ch), {
        as: "div",
        class: "section-accordion",
        defaultOpen: ""
      }, {
        default: P(({ open: s }) => [
          R($(Ah), { class: "section-accordion-button" }, {
            default: P(() => [
              R($(Ze), {
                class: "section-accordion-chevron",
                icon: s ? "ChevronDown" : "ChevronRight"
              }, null, 8, ["icon"]),
              V("div", jL, [
                te(e.$slots, "title", {}, void 0, !0)
              ])
            ]),
            _: 2
          }, 1024),
          R($(Eh), { class: "section-accordion-content" }, {
            default: P(() => [
              te(e.$slots, "default", {}, void 0, !0)
            ]),
            _: 3
          })
        ]),
        _: 3
      })
    ]));
  }
}), fw = /* @__PURE__ */ ne(LL, [["__scopeId", "data-v-2049975e"]]), BL = /* @__PURE__ */ Q({
  __name: "LoadingSkeleton",
  props: {
    lines: { default: 1 }
  },
  setup(r) {
    return (e, t) => (S(!0), E(Z, null, we([...Array(e.lines).keys()], (s) => (S(), E("div", {
      key: s,
      class: xe(["loading", { "single-line": e.lines === 1 }])
    }, null, 2))), 128));
  }
}), pw = /* @__PURE__ */ ne(BL, [["__scopeId", "data-v-c90b2c46"]]), FL = { class: "section-content" }, VL = /* @__PURE__ */ Q({
  __name: "SectionContent",
  props: {
    loading: { type: Boolean, default: !1 }
  },
  setup(r) {
    return (e, t) => (S(), E("div", FL, [
      e.loading ? (S(), U(pw, {
        key: 1,
        lines: 8
      })) : te(e.$slots, "default", { key: 0 }, void 0, !0)
    ]));
  }
}), Yo = /* @__PURE__ */ ne(VL, [["__scopeId", "data-v-9735459e"]]), UL = /* @__PURE__ */ Q({
  __name: "SectionHeader",
  props: {
    loading: { type: Boolean, default: !1 },
    tight: { type: Boolean, default: !1 },
    level: { default: 1 }
  },
  setup(r) {
    return (e, t) => e.loading ? (S(), U(pw, { key: 0 })) : (S(), U(br(`h${e.level}`), {
      key: 1,
      class: xe(["section-header", { tight: e.tight }])
    }, {
      default: P(() => [
        te(e.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), qs = /* @__PURE__ */ ne(UL, [["__scopeId", "data-v-3bd1b9f0"]]), zL = {
  key: 0,
  class: "introduction-description"
}, qL = /* @__PURE__ */ Q({
  __name: "Description",
  props: {
    value: {}
  },
  setup(r) {
    const e = r, s = `components-Content-Introduction-Description-sections${Nh(e.value)}`, n = ck(
      async () => {
        if (!e.value)
          return [];
        const u = await rc(e.value), d = ff(u);
        return await Promise.all(
          N3(e.value, d).map(
            async (h) => ({
              heading: (await rc(h))[0],
              content: h
            })
          )
        );
      },
      Eo[s] ?? []
      // initial state
    ), { getHeadingId: o, hash: i, isIntersectionEnabled: a, pathRouting: l } = Ct();
    function c(u = "") {
      if (!a.value)
        return;
      const d = new URL(window.location.href);
      l.value ? d.pathname = l.value.basePath + "/" + u : d.hash = u, i.value = u, window.history.replaceState({}, "", d);
    }
    return On(async () => {
      const u = aa();
      await hs(1), u.payload.data[s] = n.value;
    }), (u, d) => u.value ? (S(), E("div", zL, [
      (S(!0), E(Z, null, we($(n), (h, f) => (S(), E(Z, { key: f }, [
        h.heading ? (S(), U(Ep, {
          key: 0,
          id: $(o)(h.heading),
          class: "introduction-description-heading",
          onIntersecting: () => c($(o)(h.heading))
        }, {
          default: P(() => [
            R($(Lt), {
              value: h.content,
              withImages: ""
            }, null, 8, ["value"])
          ]),
          _: 2
        }, 1032, ["id", "onIntersecting"])) : (S(), U($(Lt), {
          key: 1,
          value: h.content,
          withImages: ""
        }, null, 8, ["value"]))
      ], 64))), 128))
    ])) : z("", !0);
  }
}), HL = /* @__PURE__ */ ne(qL, [["__scopeId", "data-v-5e475391"]]), KL = { class: "download" }, WL = { class: "download-cta" }, GL = /* @__PURE__ */ Q({
  __name: "DownloadSpec",
  props: {
    specTitle: {}
  },
  setup(r) {
    const e = r, t = xh(tw), s = () => {
      rw.emit({ id: "", specTitle: e.specTitle });
    };
    return (n, o) => {
      var i;
      return S(), E("div", KL, [
        V("div", WL, [
          (i = $(t)) != null && i() ? z("", !0) : (S(), E("button", {
            key: 0,
            class: "download-button",
            type: "button",
            onClick: s
          }, " Download OpenAPI Spec "))
        ])
      ]);
    };
  }
}), JL = /* @__PURE__ */ ne(GL, [["__scopeId", "data-v-810904a4"]]), YL = { class: "badges" }, XL = { class: "sticky-cards" }, QL = /* @__PURE__ */ Q({
  __name: "Introduction",
  props: {
    info: {},
    parsedSpec: {}
  },
  setup(r) {
    const e = r, t = new R0(), s = oe(() => e.parsedSpec.openapi ?? e.parsedSpec.swagger ?? ""), n = oe(() => t.slug(e.info.title ?? ""));
    return (o, i) => (S(), U($(Na), null, {
      default: P(() => [
        R($(Jo), { class: "introduction-section" }, {
          default: P(() => [
            R($(Yo), {
              loading: !o.info.description && !o.info.title
            }, {
              default: P(() => [
                R($(Op), null, {
                  default: P(() => [
                    R($(xo), null, {
                      default: P(() => [
                        V("div", YL, [
                          o.info.version ? (S(), U($(ia), { key: 0 }, {
                            default: P(() => [
                              J(ee(o.info.version), 1)
                            ]),
                            _: 1
                          })) : z("", !0),
                          s.value ? (S(), U($(ia), { key: 1 }, {
                            default: P(() => [
                              J(" OAS " + ee(s.value), 1)
                            ]),
                            _: 1
                          })) : z("", !0)
                        ]),
                        R($(qs), {
                          level: 1,
                          loading: !o.info.title,
                          tight: ""
                        }, {
                          default: P(() => [
                            J(ee(o.info.title), 1)
                          ]),
                          _: 1
                        }, 8, ["loading"]),
                        R(JL, { specTitle: n.value }, null, 8, ["specTitle"]),
                        R(HL, {
                          value: o.info.description
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    o.$slots.aside ? (S(), U($(xo), { key: 0 }, {
                      default: P(() => [
                        V("div", XL, [
                          te(o.$slots, "aside", {}, void 0, !0)
                        ])
                      ]),
                      _: 3
                    })) : z("", !0)
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["loading"]),
            te(o.$slots, "after", {}, void 0, !0)
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), ZL = /* @__PURE__ */ ne(QL, [["__scopeId", "data-v-30c2e131"]]), e4 = Symbol(), Sh = Oh(e4), gc = /* @__PURE__ */ Q({
  __name: "Lazy",
  props: {
    id: {},
    isLazy: { type: Boolean, default: !0 },
    lazyTimeout: { default: 0 }
  },
  setup(r) {
    const e = r, t = (n = () => {
    }) => {
      typeof window > "u" || ("requestIdleCallback" in window ? setTimeout(() => window.requestIdleCallback(n), e.lazyTimeout) : setTimeout(() => Ai(n), e.lazyTimeout ?? 300));
    }, s = ie(!e.isLazy);
    return e.isLazy ? t(() => {
      s.value = !0, e.id && Ai(() => Sh.emit({ id: e.id }));
    }) : e.id && Ai(() => Sh.emit({ id: e.id })), (n, o) => s.value ? te(n.$slots, "default", { key: 0 }) : z("", !0);
  }
}), t4 = {
  key: 0,
  class: "screenreader-only"
}, r4 = /* @__PURE__ */ Q({
  __name: "ScreenReader",
  props: {
    if: { type: Boolean, default: !0 }
  },
  setup(r) {
    return (e, t) => e.$props.if ? (S(), E("span", t4, [
      te(e.$slots, "default", {}, void 0, !0)
    ])) : te(e.$slots, "default", { key: 1 }, void 0, !0);
  }
}), mw = /* @__PURE__ */ ne(r4, [["__scopeId", "data-v-681ebf2c"]]), s4 = (r) => (It("data-v-d9801d4e"), r = r(), Nt(), r), n4 = { class: "label" }, o4 = { class: "anchor" }, i4 = /* @__PURE__ */ s4(() => /* @__PURE__ */ V("span", null, "​", -1)), a4 = /* @__PURE__ */ Q({
  __name: "Anchor",
  props: {
    id: {}
  },
  setup(r) {
    const { copyToClipboard: e } = Go(), t = (s) => {
      const n = new URL(window.location.href);
      return n.hash = s, n.toString();
    };
    return (s, n) => (S(), E("span", n4, [
      te(s.$slots, "default", {}, void 0, !0),
      V("span", o4, [
        i4,
        V("button", {
          class: "anchor-copy",
          type: "button",
          onClick: n[0] || (n[0] = ca((o) => $(e)(t(s.id)), ["stop"]))
        }, [
          J(" # "),
          R(mw, null, {
            default: P(() => [
              J('Copy link to "'),
              te(s.$slots, "default", {}, void 0, !0),
              J('"')
            ]),
            _: 3
          })
        ])
      ])
    ]));
  }
}), Hs = /* @__PURE__ */ ne(a4, [["__scopeId", "data-v-d9801d4e"]]), l4 = {}, c4 = { class: "scalar-card" };
function u4(r, e) {
  return S(), E("div", c4, [
    te(r.$slots, "default", {}, void 0, !0)
  ]);
}
const uu = /* @__PURE__ */ ne(l4, [["render", u4], ["__scopeId", "data-v-dcabb131"]]), d4 = /* @__PURE__ */ Q({
  __name: "CardContent",
  props: {
    muted: { type: Boolean },
    contrast: { type: Boolean },
    frameless: { type: Boolean },
    transparent: { type: Boolean },
    borderless: { type: Boolean }
  },
  setup(r) {
    return (e, t) => (S(), E("div", {
      class: xe(["scalar-card-content", {
        "scalar-card--muted": e.muted,
        "scalar-card--contrast": e.contrast,
        "scalar-card--frameless": e.frameless,
        "scalar-card--transparent": e.transparent,
        "scalar-card--borderless": e.borderless
      }])
    }, [
      te(e.$slots, "default", {}, void 0, !0)
    ], 2));
  }
}), Xo = /* @__PURE__ */ ne(d4, [["__scopeId", "data-v-5312c2e0"]]), h4 = { class: "scalar-card-header-slots" }, f4 = { class: "scalar-card-header-slot scalar-card-header-title" }, p4 = { class: "scalar-card-header-slot scalar-card-header-actions" }, m4 = /* @__PURE__ */ Q({
  __name: "CardHeader",
  props: {
    muted: { type: Boolean },
    contrast: { type: Boolean },
    frameless: { type: Boolean },
    transparent: { type: Boolean },
    borderless: { type: Boolean }
  },
  setup(r) {
    const e = r;
    return (t, s) => (S(), U(Xo, En(e, { class: "scalar-card-header" }), {
      default: P(() => [
        V("div", h4, [
          V("div", f4, [
            te(t.$slots, "default", {}, void 0, !0)
          ]),
          V("div", p4, [
            te(t.$slots, "actions", {}, void 0, !0)
          ])
        ])
      ]),
      _: 3
    }, 16));
  }
}), du = /* @__PURE__ */ ne(m4, [["__scopeId", "data-v-bbd0c20a"]]), g4 = /* @__PURE__ */ Q({
  __name: "CardFooter",
  props: {
    muted: { type: Boolean },
    contrast: { type: Boolean },
    frameless: { type: Boolean },
    transparent: { type: Boolean },
    borderless: { type: Boolean }
  },
  setup(r) {
    const e = r;
    return (t, s) => (S(), U(Xo, cr(ur(e)), {
      default: P(() => [
        te(t.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }, 16));
  }
}), Tp = /* @__PURE__ */ ne(g4, [["__scopeId", "data-v-918ab8d6"]]), y4 = /* @__PURE__ */ Q({
  __name: "CardTabHeader",
  emits: ["change"],
  setup(r, { emit: e }) {
    const t = e, s = (n) => {
      t("change", n);
    };
    return (n, o) => (S(), U(du, { class: "scalar-card-header-tabs" }, {
      actions: P(() => [
        te(n.$slots, "actions", {}, void 0, !0)
      ]),
      default: P(() => [
        R($(sk), { onChange: s }, {
          default: P(() => [
            R($(nk), { class: "tab-list custom-scroll" }, {
              default: P(() => [
                te(n.$slots, "default", {}, void 0, !0)
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), b4 = /* @__PURE__ */ ne(y4, [["__scopeId", "data-v-6a91b57c"]]), v4 = /* @__PURE__ */ Q({
  __name: "CardTab",
  setup(r) {
    return (e, t) => (S(), U($(ok), { as: "template" }, {
      default: P(({ selected: s }) => [
        V("button", {
          class: xe({ tab: !0, "tab-selected": s }),
          type: "button"
        }, [
          V("span", null, [
            te(e.$slots, "default", {}, void 0, !0)
          ])
        ], 2)
      ]),
      _: 3
    }));
  }
}), w4 = /* @__PURE__ */ ne(v4, [["__scopeId", "data-v-f373ecc2"]]), k4 = ["value"], S4 = ["label"], $4 = ["value"], _4 = ["value"], Pp = /* @__PURE__ */ Q({
  __name: "TextSelect",
  props: {
    modelValue: {},
    options: {}
  },
  emits: ["update:modelValue"],
  setup(r) {
    return (e, t) => (S(), E("div", {
      class: xe(["text-select", e.options.length === 1 ? "text-select--single-option" : ""])
    }, [
      V("span", null, [
        te(e.$slots, "default")
      ]),
      V("select", {
        value: e.modelValue,
        onInput: t[0] || (t[0] = (s) => e.$emit("update:modelValue", s.target.value))
      }, [
        (S(!0), E(Z, null, we(e.options, (s) => (S(), E(Z, {
          key: s.value
        }, [
          s.options ? (S(), E("optgroup", {
            key: 0,
            label: s.label
          }, [
            (S(!0), E(Z, null, we(s.options, (n) => (S(), E("option", {
              key: n.value,
              value: n.value
            }, ee(n.label), 9, $4))), 128))
          ], 8, S4)) : (S(), E("option", {
            key: s.value,
            value: s.value
          }, ee(s.label), 9, _4))
        ], 64))), 128))
      ], 40, k4)
    ], 2));
  }
}), x4 = { class: "request-header" }, C4 = /* @__PURE__ */ Q({
  __name: "CustomRequestExamples",
  props: {
    operation: {},
    examples: {}
  },
  setup(r) {
    const e = r, t = ie(0), s = oe(() => (
      // @ts-ignore
      {
        C: "c",
        "C#": "csharp",
        // 'C++': '',
        // 'CoffeeScript': '',
        // 'CSS': '',
        // 'Dart': '',
        // 'DM': '',
        // 'Elixir': '',
        Go: "go",
        // 'Groovy': '',
        HTML: "html",
        Java: "java",
        JavaScript: "javascript",
        Kotlin: "kotlin",
        "Objective-C": "objc",
        // 'Perl': '',
        // 'PHP': '',
        PowerShell: "powershell",
        Python: "python",
        Ruby: "ruby",
        // 'Rust': '',
        // 'Scala': '',
        Shell: "shell",
        Swift: "swift",
        TypeScript: "javascript",
        cURL: "shell"
      }[e.examples[t.value].lang] ?? e.examples[t.value].lang
    )), n = oe(() => e.examples[t.value]);
    Le(e.examples, () => {
      e.examples[t.value] === "undefined" && (t.value = 0);
    });
    const { copyToClipboard: o } = Go();
    return (i, a) => (S(), U($(uu), { class: "dark-mode" }, {
      default: P(() => [
        R($(du), { muted: "" }, {
          actions: P(() => [
            R(Pp, {
              class: "request-client-picker",
              modelValue: t.value,
              options: i.examples.map((l, c) => ({
                value: c.toString(),
                label: l.label
              })),
              "onUpdate:modelValue": a[0] || (a[0] = (l) => (t.value = parseInt(l), 10))
            }, {
              default: P(() => [
                J(ee(n.value.label), 1)
              ]),
              _: 1
            }, 8, ["modelValue", "options"]),
            V("button", {
              class: "copy-button",
              type: "button",
              onClick: a[1] || (a[1] = (l) => $(o)(n.value.source.trim()))
            }, [
              R($(Ze), {
                icon: "Clipboard",
                width: "10px"
              })
            ])
          ]),
          default: P(() => [
            V("div", x4, [
              R($(Po), {
                class: "request-method",
                method: i.operation.httpVerb
              }, null, 8, ["method"]),
              te(i.$slots, "header", {}, void 0, !0)
            ])
          ]),
          _: 3
        }),
        R($(Xo), {
          borderless: "",
          class: "request-editor-section custom-scroll",
          frameless: ""
        }, {
          default: P(() => [
            R($(As), {
              content: n.value.source.trim(),
              lang: s.value,
              lineNumbers: ""
            }, null, 8, ["content", "lang"])
          ]),
          _: 1
        }),
        i.$slots.footer ? (S(), U($(Tp), {
          key: 0,
          class: "scalar-card-footer",
          contrast: ""
        }, {
          default: P(() => [
            te(i.$slots, "footer", {}, void 0, !0)
          ]),
          _: 3
        })) : z("", !0)
      ]),
      _: 3
    }));
  }
}), A4 = /* @__PURE__ */ ne(C4, [["__scopeId", "data-v-18ba624d"]]), E4 = { class: "schema-type" }, O4 = ["title"], T4 = /* @__PURE__ */ Q({
  __name: "SchemaHeading",
  props: {
    value: {},
    name: {}
  },
  setup(r) {
    return (e, t) => {
      var s, n, o, i, a, l;
      return S(), E("span", E4, [
        V("span", {
          class: "schema-type-icon",
          title: typeof e.value.type == "string" ? e.value.type : Array.isArray(e.value.type) ? e.value.type.join(" | ") : "unkown type"
        }, [
          e.value.type === "object" ? (S(), E(Z, { key: 0 }, [
            J(" {} ")
          ], 64)) : z("", !0),
          e.value.type === "array" ? (S(), E(Z, { key: 1 }, [
            J(" [] ")
          ], 64)) : z("", !0),
          e.value.enum ? (S(), E(Z, { key: 2 }, [
            J(" enum ")
          ], 64)) : z("", !0)
        ], 8, O4),
        (n = (s = e.value) == null ? void 0 : s.xml) != null && n.name && ((i = (o = e.value) == null ? void 0 : o.xml) == null ? void 0 : i.name) !== "##default" ? (S(), E(Z, { key: 0 }, [
          J(" <" + ee((l = (a = e.value) == null ? void 0 : a.xml) == null ? void 0 : l.name) + " /> ", 1)
        ], 64)) : e.name ? (S(), E(Z, { key: 1 }, [
          J(ee(e.name), 1)
        ], 64)) : (S(), E(Z, { key: 2 }, [
          J(ee(e.value.type), 1)
        ], 64))
      ]);
    };
  }
}), gw = /* @__PURE__ */ ne(T4, [["__scopeId", "data-v-6c5c3c96"]]), P4 = {
  key: 0,
  class: "property-detail-prefix"
}, I4 = {
  key: 1,
  class: "property-detail-value"
}, N4 = {
  key: 2,
  class: "property-detail-value"
}, M4 = /* @__PURE__ */ Q({
  __name: "SchemaPropertyDetail",
  props: {
    truncate: { type: Boolean },
    code: { type: Boolean }
  },
  setup(r) {
    return (e, t) => (S(), E("span", {
      class: xe(["property-detail", { "property-detail-truncate": e.truncate }])
    }, [
      e.$slots.prefix ? (S(), E("div", P4, [
        te(e.$slots, "prefix", {}, void 0, !0),
        J("  ")
      ])) : z("", !0),
      e.code ? (S(), E("code", I4, [
        te(e.$slots, "default", {}, void 0, !0)
      ])) : (S(), E("span", N4, [
        te(e.$slots, "default", {}, void 0, !0)
      ]))
    ], 2));
  }
}), Qt = /* @__PURE__ */ ne(M4, [["__scopeId", "data-v-16d94ef5"]]), D4 = { class: "property-heading" }, R4 = {
  key: 0,
  class: "property-name"
}, j4 = {
  key: 1,
  class: "property-additional"
}, L4 = {
  key: 2,
  class: "property-deprecated"
}, B4 = {
  key: 3,
  class: "property-required"
}, F4 = {
  key: 4,
  class: "property-const"
}, V4 = {
  key: 5,
  class: "property-details"
}, U4 = {
  key: 6,
  class: "property-write-only"
}, z4 = {
  key: 7,
  class: "property-read-only"
}, q4 = /* @__PURE__ */ Q({
  __name: "SchemaPropertyHeading",
  props: {
    value: {},
    enum: { type: Boolean },
    required: { type: Boolean, default: !1 },
    additional: { type: Boolean }
  },
  setup(r) {
    const e = ["oneOf", "anyOf", "allOf", "not"];
    return (t, s) => {
      var n, o, i, a, l, c, u;
      return S(), E("div", D4, [
        t.$slots.name ? (S(), E("div", R4, [
          te(t.$slots, "name", {}, void 0, !0)
        ])) : z("", !0),
        t.additional ? (S(), E("div", j4, [
          (n = t.value) != null && n["x-additionalPropertiesName"] ? (S(), E(Z, { key: 0 }, [
            J(ee(t.value["x-additionalPropertiesName"]), 1)
          ], 64)) : (S(), E(Z, { key: 1 }, [
            J(" additional properties ")
          ], 64))
        ])) : z("", !0),
        (o = t.value) != null && o.deprecated ? (S(), E("div", L4, [
          R($(ia), null, {
            default: P(() => [
              J("deprecated")
            ]),
            _: 1
          })
        ])) : z("", !0),
        t.required ? (S(), E("div", B4, " required ")) : z("", !0),
        (i = t.value) != null && i.const || (a = t.value) != null && a.enum && t.value.enum.length === 1 ? (S(), E("div", F4, [
          R(Qt, { truncate: "" }, {
            prefix: P(() => [
              J("const:")
            ]),
            default: P(() => [
              J(" " + ee(t.value.const ?? t.value.enum[0]), 1)
            ]),
            _: 1
          })
        ])) : (l = t.value) != null && l.type ? (S(), E("div", V4, [
          t.additional ? (S(), U(Qt, { key: 0 }, {
            prefix: P(() => [
              J("key:")
            ]),
            default: P(() => [
              J(" string ")
            ]),
            _: 1
          })) : z("", !0),
          R(Qt, null, ua({
            default: P(() => {
              var d, h, f;
              return [
                (h = (d = t.value) == null ? void 0 : d.items) != null && h.type ? (S(), E(Z, { key: 0 }, [
                  J(ee(t.value.type) + " " + ee(t.value.items.type) + "[] ", 1)
                ], 64)) : (S(), E(Z, { key: 1 }, [
                  J(ee(Array.isArray(t.value.type) ? t.value.type.join(" | ") : t.value.type) + " " + ee((f = t.value) != null && f.nullable ? " | nullable" : ""), 1)
                ], 64)),
                t.value.minItems || t.value.maxItems ? (S(), E(Z, { key: 2 }, [
                  J(ee(t.value.minItems) + "…" + ee(t.value.maxItems), 1)
                ], 64)) : z("", !0)
              ];
            }),
            _: 2
          }, [
            t.additional ? {
              name: "prefix",
              fn: P(() => [
                J("value:")
              ]),
              key: "0"
            } : void 0
          ]), 1024),
          t.value.minLength ? (S(), U(Qt, { key: 1 }, {
            prefix: P(() => [
              J("min:")
            ]),
            default: P(() => [
              J(" " + ee(t.value.minLength), 1)
            ]),
            _: 1
          })) : z("", !0),
          t.value.maxLength ? (S(), U(Qt, { key: 2 }, {
            prefix: P(() => [
              J("max:")
            ]),
            default: P(() => [
              J(" " + ee(t.value.maxLength), 1)
            ]),
            _: 1
          })) : z("", !0),
          t.value.uniqueItems ? (S(), U(Qt, { key: 3 }, {
            default: P(() => [
              J(" unique! ")
            ]),
            _: 1
          })) : z("", !0),
          t.value.format ? (S(), U(Qt, { key: 4 }, {
            default: P(() => [
              J(ee(t.value.format), 1)
            ]),
            _: 1
          })) : z("", !0),
          t.value.minimum ? (S(), U(Qt, { key: 5 }, {
            prefix: P(() => [
              J("min:")
            ]),
            default: P(() => [
              J(" " + ee(t.value.minimum), 1)
            ]),
            _: 1
          })) : z("", !0),
          t.value.maximum ? (S(), U(Qt, { key: 6 }, {
            prefix: P(() => [
              J("max:")
            ]),
            default: P(() => [
              J(" " + ee(t.value.maximum), 1)
            ]),
            _: 1
          })) : z("", !0),
          t.value.pattern ? (S(), U(Qt, {
            key: 7,
            code: "",
            truncate: ""
          }, {
            default: P(() => [
              J(ee(t.value.pattern), 1)
            ]),
            _: 1
          })) : z("", !0),
          t.$props.enum ? (S(), U(Qt, { key: 8 }, {
            default: P(() => [
              J("enum")
            ]),
            _: 1
          })) : z("", !0),
          t.value.default ? (S(), U(Qt, {
            key: 9,
            truncate: ""
          }, {
            prefix: P(() => [
              J("default:")
            ]),
            default: P(() => [
              J(" " + ee(t.value.default), 1)
            ]),
            _: 1
          })) : z("", !0)
        ])) : z("", !0),
        (c = t.value) != null && c.writeOnly ? (S(), E("div", U4, " write-only ")) : (u = t.value) != null && u.readOnly ? (S(), E("div", z4, " read-only ")) : z("", !0),
        (S(!0), E(Z, null, we(e.filter((d) => {
          var h, f, m;
          return ((h = t.value) == null ? void 0 : h[d]) || ((m = (f = t.value) == null ? void 0 : f.items) == null ? void 0 : m[d]);
        }), (d) => (S(), U($(ia), { key: d }, {
          default: P(() => [
            J(ee(d), 1)
          ]),
          _: 2
        }, 1024))), 128))
      ]);
    };
  }
}), H4 = /* @__PURE__ */ ne(q4, [["__scopeId", "data-v-c1c21610"]]), K4 = (r) => (It("data-v-9c7a15fe"), r = r(), Nt(), r), W4 = {
  key: 0,
  class: "property-description"
}, G4 = {
  key: 1,
  class: "property-description"
}, J4 = {
  key: 2,
  class: "property-example custom-scroll"
}, Y4 = /* @__PURE__ */ K4(() => /* @__PURE__ */ V("span", { class: "property-example-label" }, "Example", -1)), X4 = { class: "property-example-value" }, Q4 = {
  key: 3,
  class: "property-enum"
}, Z4 = {
  key: 0,
  class: "property-list"
}, eB = { class: "property-heading" }, tB = { class: "property-name" }, rB = { class: "property-description" }, sB = {
  key: 1,
  class: "property-enum-values"
}, nB = {
  key: 4,
  class: "children"
}, oB = {
  key: 0,
  class: "children"
}, iB = {
  key: 0,
  class: "property-rule"
}, aB = {
  key: 1,
  class: "property-rule"
}, lB = /* @__PURE__ */ Q({
  __name: "SchemaProperty",
  props: {
    value: {},
    level: { default: 0 },
    name: {},
    required: { type: Boolean, default: !1 },
    compact: { type: Boolean, default: !1 },
    description: {},
    additional: { type: Boolean }
  },
  setup(r) {
    const e = {
      integer: {
        _default: "Integer numbers.",
        int32: "Signed 32-bit integers (commonly used integer type).",
        int64: "Signed 64-bit integers (long type)."
      },
      string: {
        date: "full-date notation as defined by RFC 3339, section 5.6, for example, 2017-07-21",
        "date-time": "the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z",
        password: "a hint to UIs to mask the input",
        byte: "base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==",
        binary: "binary data, used to describe files"
      }
    }, t = function(i, a) {
      return a != null && a.properties || a != null && a.additionalProperties ? null : i || (a == null ? void 0 : a.description) || null;
    }, s = function(i) {
      return !i || !e[i.type] ? null : e[i.type][i.format || "_default"];
    }, n = function(i) {
      var a;
      return (i == null ? void 0 : i.enum) || ((a = i == null ? void 0 : i.items) == null ? void 0 : a.enum) || [];
    }, o = ["oneOf", "anyOf", "allOf", "not"];
    return (i, a) => {
      var l, c, u, d, h, f, m, g, p, y, b;
      return S(), E("div", {
        class: xe(["property", [
          `property--level-${i.level}`,
          {
            "property--compact": i.compact,
            "property--deprecated": (l = i.value) == null ? void 0 : l.deprecated
          }
        ]])
      }, [
        R(H4, {
          additional: i.additional,
          enum: n(i.value).length > 1,
          required: i.required,
          value: i.value
        }, ua({ _: 2 }, [
          i.name ? {
            name: "name",
            fn: P(() => [
              J(ee(i.name), 1)
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["additional", "enum", "required", "value"]),
        t(i.description, i.value) ? (S(), E("div", W4, [
          R($(Lt), {
            value: t(i.description, i.value)
          }, null, 8, ["value"])
        ])) : s(i.value) ? (S(), E("div", G4, [
          R($(Lt), {
            value: s(i.value) || ""
          }, null, 8, ["value"])
        ])) : z("", !0),
        (c = i.value) != null && c.example || (d = (u = i.value) == null ? void 0 : u.items) != null && d.example ? (S(), E("div", J4, [
          Y4,
          V("code", X4, ee(i.value.example || ((h = i.value) == null ? void 0 : h.items.example)), 1)
        ])) : z("", !0),
        ((f = n(i.value)) == null ? void 0 : f.length) > 1 ? (S(), E("div", Q4, [
          (m = i.value) != null && m["x-enumDescriptions"] ? (S(), E("div", Z4, [
            (S(!0), E(Z, null, we(n(i.value), (v) => (S(), E("div", {
              key: v,
              class: "property"
            }, [
              V("div", eB, [
                V("div", tB, ee(v), 1)
              ]),
              V("div", rB, [
                R($(Lt), {
                  value: i.value["x-enumDescriptions"][v]
                }, null, 8, ["value"])
              ])
            ]))), 128))
          ])) : (S(), E("ul", sB, [
            (S(!0), E(Z, null, we(n(i.value), (v) => (S(), E("li", {
              key: v,
              class: "property-enum-value"
            }, ee(v), 1))), 128))
          ]))
        ])) : z("", !0),
        ((g = i.value) == null ? void 0 : g.type) === "object" && ((p = i.value) != null && p.properties || (y = i.value) != null && y.additionalProperties) ? (S(), E("div", nB, [
          R(pn, {
            compact: i.compact,
            level: i.level + 1,
            value: i.value
          }, null, 8, ["compact", "level", "value"])
        ])) : z("", !0),
        (b = i.value) != null && b.items ? (S(), E(Z, { key: 5 }, [
          ["object"].includes(i.value.items.type) ? (S(), E("div", oB, [
            R(pn, {
              compact: i.compact,
              level: i.level + 1,
              value: i.value.items
            }, null, 8, ["compact", "level", "value"])
          ])) : z("", !0)
        ], 64)) : z("", !0),
        (S(), E(Z, null, we(o, (v) => {
          var k, _, w;
          return S(), E(Z, { key: v }, [
            (k = i.value) != null && k[v] ? (S(), E("div", iB, [
              (S(!0), E(Z, null, we(i.value[v], (x, T) => (S(), U(pn, {
                key: T,
                compact: i.compact,
                level: i.level + 1,
                value: x
              }, null, 8, ["compact", "level", "value"]))), 128))
            ])) : z("", !0),
            (w = (_ = i.value) == null ? void 0 : _.items) != null && w[v] && i.level < 3 ? (S(), E("div", aB, [
              (S(!0), E(Z, null, we(i.value.items[v], (x, T) => (S(), U(pn, {
                key: T,
                compact: i.compact,
                level: i.level + 1,
                value: x
              }, null, 8, ["compact", "level", "value"]))), 128))
            ])) : z("", !0)
          ], 64);
        }), 64))
      ], 2);
    };
  }
}), fn = /* @__PURE__ */ ne(lB, [["__scopeId", "data-v-9c7a15fe"]]), cB = (r) => (It("data-v-44c40736"), r = r(), Nt(), r), uB = {
  key: 0,
  class: "schema-card-description"
}, dB = /* @__PURE__ */ cB(() => /* @__PURE__ */ V("polygon", {
  "fill-rule": "nonzero",
  points: "14 8 8 8 8 14 6 14 6 8 0 8 0 6 6 6 6 0 8 0 8 6 14 6"
}, null, -1)), hB = [
  dB
], fB = /* @__PURE__ */ Q({
  __name: "Schema",
  props: {
    value: {},
    level: { default: 0 },
    name: {},
    compact: { type: Boolean },
    noncollapsible: { type: Boolean }
  },
  setup(r) {
    const e = r, t = oe(() => !(e.noncollapsible || e.level === 0)), s = (n) => e.noncollapsible && n.stopPropagation();
    return (n, o) => typeof n.value == "object" && Object.keys(n.value).length ? (S(), U($(Ch), {
      key: 0,
      defaultOpen: n.noncollapsible
    }, {
      default: P(({ open: i }) => {
        var a;
        return [
          V("div", {
            class: xe(["schema-card", [
              `schema-card--level-${n.level}`,
              { "schema-card--compact": n.compact, "schema-card--open": i }
            ]])
          }, [
            (a = n.value) != null && a.description ? (S(), E("div", uB, [
              R($(Lt), {
                value: n.value.description
              }, null, 8, ["value"])
            ])) : z("", !0),
            V("div", {
              class: xe(["schema-properties", { "schema-properties-open": i }])
            }, [
              Ao(R($(Ah), {
                as: n.noncollapsible ? "div" : "button",
                class: xe(["schema-card-title", { "schema-card-title--compact": n.compact }]),
                style: os({
                  top: `calc(var(--refs-header-height) +  calc(var(--schema-title-height) * ${n.level}))`
                }),
                onClickCapture: s
              }, {
                default: P(() => {
                  var l, c, u;
                  return [
                    n.compact ? (S(), E(Z, { key: 0 }, [
                      t.value ? (S(), E("svg", {
                        key: 0,
                        class: xe(["schema-card-title-icon", { "schema-card-title-icon--open": i }]),
                        fill: "currentColor",
                        height: "14",
                        viewBox: "0 0 14 14",
                        width: "14",
                        xmlns: "http://www.w3.org/2000/svg"
                      }, hB, 2)) : z("", !0),
                      i ? (S(), E(Z, { key: 1 }, [
                        J(" Hide " + ee(((l = n.value) == null ? void 0 : l.title) ?? "Child Attributes"), 1)
                      ], 64)) : (S(), E(Z, { key: 2 }, [
                        J(" Show " + ee(((c = n.value) == null ? void 0 : c.title) ?? "Child Attributes"), 1)
                      ], 64))
                    ], 64)) : (S(), E(Z, { key: 1 }, [
                      t.value ? (S(), U($(Ze), {
                        key: 0,
                        class: xe(["schema-card-title-icon", { "schema-card-title-icon--open": i }]),
                        icon: "ChevronRight",
                        size: "md"
                      }, null, 8, ["class"])) : z("", !0),
                      R(gw, {
                        name: ((u = n.value) == null ? void 0 : u.title) ?? n.name,
                        value: n.value
                      }, null, 8, ["name", "value"])
                    ], 64))
                  ];
                }),
                _: 2
              }, 1032, ["as", "class", "style"]), [
                [yc, !(n.noncollapsible && n.compact)]
              ]),
              R($(Eh), { static: n.noncollapsible }, {
                default: P(() => {
                  var l;
                  return [
                    n.value.properties || n.value.additionalProperties ? (S(), E(Z, { key: 0 }, [
                      n.value.properties ? (S(!0), E(Z, { key: 0 }, we(Object.keys((l = n.value) == null ? void 0 : l.properties), (c) => {
                        var u, d, h, f;
                        return S(), U(fn, {
                          key: c,
                          compact: n.compact,
                          level: n.level,
                          name: c,
                          required: ((u = n.value.required) == null ? void 0 : u.includes(c)) || ((h = (d = n.value.properties) == null ? void 0 : d[c]) == null ? void 0 : h.required) === !0,
                          value: (f = n.value.properties) == null ? void 0 : f[c]
                        }, null, 8, ["compact", "level", "name", "required", "value"]);
                      }), 128)) : z("", !0),
                      n.value.additionalProperties ? (S(), E(Z, { key: 1 }, [
                        n.value.additionalProperties === !0 || Object.keys(n.value.additionalProperties).length === 0 || !n.value.additionalProperties.type ? (S(), U(fn, {
                          key: 0,
                          additional: "",
                          compact: n.compact,
                          level: n.level,
                          noncollapsible: "",
                          value: { type: "any", ...n.value.additionalProperties }
                        }, null, 8, ["compact", "level", "value"])) : (S(), U(fn, {
                          key: 1,
                          additional: "",
                          compact: n.compact,
                          level: n.level,
                          noncollapsible: "",
                          value: n.value.additionalProperties
                        }, null, 8, ["compact", "level", "value"]))
                      ], 64)) : z("", !0)
                    ], 64)) : (S(), U(fn, {
                      key: 1,
                      compact: n.compact,
                      level: n.level,
                      name: n.value.name,
                      value: n.value
                    }, null, 8, ["compact", "level", "name", "value"]))
                  ];
                }),
                _: 1
              }, 8, ["static"])
            ], 2)
          ], 2)
        ];
      }),
      _: 1
    }, 8, ["defaultOpen"])) : z("", !0);
  }
}), pn = /* @__PURE__ */ ne(fB, [["__scopeId", "data-v-44c40736"]]), pB = { class: "parameter-item" }, mB = { class: "parameter-item-container" }, gB = /* @__PURE__ */ Q({
  __name: "ParameterItem",
  props: {
    parameter: {},
    showChildren: { type: Boolean, default: !1 }
  },
  setup(r) {
    return (e, t) => (S(), E("li", pB, [
      V("div", mB, [
        R($(fn), {
          compact: "",
          description: e.parameter.description,
          level: 0,
          name: e.parameter.name,
          noncollapsible: e.showChildren,
          required: e.parameter.required,
          value: e.parameter.schema
        }, null, 8, ["description", "name", "noncollapsible", "required", "value"])
      ])
    ]));
  }
}), yB = /* @__PURE__ */ ne(gB, [["__scopeId", "data-v-f70ee55c"]]), bB = {
  key: 0,
  class: "parameters"
}, vB = { class: "parameters-title" }, wB = { class: "parameter-list" }, kB = /* @__PURE__ */ Q({
  __name: "Parameters",
  props: {
    parameters: {},
    showChildren: { type: Boolean, default: !1 }
  },
  setup(r) {
    return (e, t) => {
      var s;
      return (s = e.parameters) != null && s.length ? (S(), E("div", bB, [
        V("div", vB, [
          te(e.$slots, "title", {}, void 0, !0)
        ]),
        V("ul", wB, [
          (S(!0), E(Z, null, we(e.parameters, (n) => (S(), U(yB, {
            key: n.name,
            parameter: n,
            showChildren: e.showChildren
          }, null, 8, ["parameter", "showChildren"]))), 128))
        ])
      ])) : z("", !0);
    };
  }
}), fr = /* @__PURE__ */ ne(kB, [["__scopeId", "data-v-45fca787"]]), SB = { key: 0 }, $B = { class: "request-body-title" }, _B = ["value"], xB = {
  key: 0,
  class: "request-body-description"
}, CB = {
  key: 0,
  class: "request-body-schema"
}, AB = /* @__PURE__ */ Q({
  __name: "RequestBody",
  props: {
    requestBody: {}
  },
  setup(r) {
    var n;
    const e = r, t = oe(() => {
      var o;
      return (o = e.requestBody) != null && o.content ? Object.keys(e.requestBody.content) : [];
    }), s = ie("application/json");
    return (n = e.requestBody) != null && n.content && t.value.length > 0 && (s.value = t.value[0]), (o, i) => {
      var a, l, c, u;
      return e != null && e.requestBody ? (S(), E("div", SB, [
        V("div", $B, [
          te(o.$slots, "title", {}, void 0, !0),
          V("div", {
            class: xe(["request-body-title-select", { "request-body-title-no-select": t.value.length <= 1 }])
          }, [
            V("span", null, ee(s.value), 1),
            e != null && e.requestBody && t.value.length > 1 ? Ao((S(), E("select", {
              key: 0,
              "onUpdate:modelValue": i[0] || (i[0] = (d) => s.value = d)
            }, [
              (S(!0), E(Z, null, we((a = e.requestBody) == null ? void 0 : a.content, (d, h) => (S(), E("option", {
                key: h,
                value: h
              }, ee(h), 9, _B))), 128))
            ], 512)), [
              [zw, s.value]
            ]) : z("", !0)
          ], 2),
          e != null && e.requestBody.description ? (S(), E("div", xB, [
            R($(Lt), {
              value: e.requestBody.description
            }, null, 8, ["value"])
          ])) : z("", !0)
        ]),
        (l = e == null ? void 0 : e.requestBody.content) != null && l[s.value] ? (S(), E("div", CB, [
          R($(pn), {
            compact: "",
            noncollapsible: "",
            value: (u = (c = e == null ? void 0 : e.requestBody.content) == null ? void 0 : c[s.value]) == null ? void 0 : u.schema
          }, null, 8, ["value"])
        ])) : z("", !0)
      ])) : z("", !0);
    };
  }
}), Ip = /* @__PURE__ */ ne(AB, [["__scopeId", "data-v-e095eb63"]]), EB = { class: "endpoint-details" }, OB = { class: "endpoint-description" }, TB = /* @__PURE__ */ Q({
  __name: "EndpointDetails",
  props: {
    operation: {}
  },
  setup(r) {
    const e = r, { parameterMap: t } = xp(e), { responses: s } = Cp(e.operation);
    return (n, o) => {
      var i, a;
      return S(), E("div", EB, [
        V("div", OB, [
          R($(Lt), {
            value: n.operation.description,
            withImages: ""
          }, null, 8, ["value"])
        ]),
        R(fr, {
          parameters: $(t).path
        }, {
          title: P(() => [
            J("Path Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        R(fr, {
          parameters: $(t).query
        }, {
          title: P(() => [
            J("Query Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        R(fr, {
          parameters: $(t).header
        }, {
          title: P(() => [
            J("Headers")
          ]),
          _: 1
        }, 8, ["parameters"]),
        R(fr, {
          parameters: $(t).body,
          showChildren: ""
        }, {
          title: P(() => [
            J("Body Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        R(fr, {
          parameters: $(t).formData
        }, {
          title: P(() => [
            J("Form Data")
          ]),
          _: 1
        }, 8, ["parameters"]),
        (i = n.operation.information) != null && i.requestBody ? (S(), U(Ip, {
          key: 0,
          requestBody: (a = n.operation.information) == null ? void 0 : a.requestBody
        }, {
          title: P(() => [
            J("Body")
          ]),
          _: 1
        }, 8, ["requestBody"])) : z("", !0),
        R(fr, { parameters: $(s) }, {
          title: P(() => [
            J("Responses")
          ]),
          _: 1
        }, 8, ["parameters"])
      ]);
    };
  }
}), PB = { key: 0 }, IB = /* @__PURE__ */ Q({
  __name: "EndpointPath",
  props: {
    path: {},
    deprecated: { type: Boolean }
  },
  setup(r) {
    const e = r, t = (n) => n.startsWith("{") && n.endsWith("}"), s = oe(() => e.path.split(/({[^}]+})/));
    return (n, o) => (S(), E("span", {
      class: xe(["endpoint-path", { deprecated: n.deprecated }])
    }, [
      (S(!0), E(Z, null, we(s.value, (i, a) => (S(), E(Z, { key: a }, [
        t(i) ? (S(), E("em", PB, ee(i), 1)) : (S(), E(Z, { key: 1 }, [
          J(ee(i), 1)
        ], 64))
      ], 64))), 128))
    ], 2));
  }
}), $h = /* @__PURE__ */ ne(IB, [["__scopeId", "data-v-a4eadd9b"]]);
function Ma(r) {
  return r.reduce((e, t) => (e[t.name] = t.value, e), {});
}
function NB(r) {
  return /\s|-/.test(r);
}
function Hr(r, e = 0) {
  let t = [], s = " ".repeat(e), n = " ".repeat(e + 2);
  for (const [o, i] of Object.entries(r)) {
    let a = NB(o) ? `'${o}'` : o;
    if (Array.isArray(i)) {
      const l = i.map((c) => typeof c == "string" ? `'${c}'` : c && typeof c == "object" ? Hr(c, e + 2) : c).join(`, ${n}`);
      t.push(`${n}${a}: [${l}]`);
    } else if (i && typeof i == "object")
      t.push(
        `${n}${a}: ${Hr(
          i,
          e + 2
        )}`
      );
    else if (typeof i == "string") {
      let l = `${i}`;
      if (i.startsWith("JSON.stringify")) {
        const c = i.split(`
`);
        c.length > 1 && (l = c.map((u, d) => d === 0 ? u : `${n}${u}`).join(`
`));
      } else
        l = `'${i}'`;
      t.push(`${n}${a}: ${l}`);
    } else
      t.push(`${n}${a}: ${i}`);
  }
  return `{
${t.join(`,
`)}
${s}}`;
}
function MB(r) {
  var e, t;
  const s = {
    method: "GET",
    ...r
  };
  s.method = s.method.toUpperCase();
  const n = {
    method: s.method === "GET" ? void 0 : s.method
  }, o = new URLSearchParams(
    s.queryString ? Ma(s.queryString) : void 0
  ), i = o.size ? `?${o.toString()}` : "";
  (e = s.headers) != null && e.length && (n.headers = {}, s.headers.forEach((l) => {
    n.headers[l.name] = l.value;
  })), (t = s.cookies) != null && t.length && (n.headers = n.headers || {}, s.cookies.forEach((l) => {
    n.headers["Set-Cookie"] = n.headers["Set-Cookie"] ? `${n.headers["Set-Cookie"]}; ${l.name}=${l.value}` : `${l.name}=${l.value}`;
  })), Object.keys(n).forEach((l) => {
    n[l] === void 0 && delete n[l];
  }), s.postData && (n.body = s.postData.text, s.postData.mimeType === "application/json" && (n.body = `JSON.stringify(${Hr(JSON.parse(n.body))})`));
  const a = Object.keys(n).length ? `, ${Hr(n)}` : "";
  return {
    target: "node",
    client: "undici",
    code: `import { request } from 'undici'

const { statusCode, body } = await request('${s.url}${i}'${a})`
  };
}
function DB(r) {
  var e, t;
  const s = {
    method: "GET",
    ...r
  };
  s.method = s.method.toUpperCase();
  const n = {
    method: s.method === "GET" ? void 0 : s.method
  }, o = new URLSearchParams(
    s.queryString ? Ma(s.queryString) : void 0
  ), i = o.size ? `?${o.toString()}` : "";
  (e = s.headers) != null && e.length && (n.headers = {}, s.headers.forEach((l) => {
    n.headers[l.name] = l.value;
  })), (t = s.cookies) != null && t.length && (n.headers = n.headers || {}, s.cookies.forEach((l) => {
    n.headers["Set-Cookie"] = n.headers["Set-Cookie"] ? `${n.headers["Set-Cookie"]}; ${l.name}=${l.value}` : `${l.name}=${l.value}`;
  })), Object.keys(n).forEach((l) => {
    n[l] === void 0 && delete n[l];
  }), s.postData && (n.body = s.postData.text, s.postData.mimeType === "application/json" && (n.body = `JSON.stringify(${Hr(
    JSON.parse(n.body)
  )})`));
  const a = Object.keys(n).length ? `, ${Hr(n)}` : "";
  return {
    target: "node",
    client: "fetch",
    code: `fetch('${s.url}${i}'${a})`
  };
}
function RB(r) {
  var e, t;
  const s = {
    method: "GET",
    ...r
  };
  s.method = s.method.toUpperCase();
  const n = {
    method: s.method === "GET" ? void 0 : s.method
  }, o = new URLSearchParams(
    s.queryString ? Ma(s.queryString) : void 0
  ), i = o.size ? `?${o.toString()}` : "";
  (e = s.headers) != null && e.length && (n.headers = {}, s.headers.forEach((l) => {
    n.headers[l.name] = l.value;
  })), (t = s.cookies) != null && t.length && (n.headers = n.headers || {}, s.cookies.forEach((l) => {
    n.headers["Set-Cookie"] = n.headers["Set-Cookie"] ? `${n.headers["Set-Cookie"]}; ${l.name}=${l.value}` : `${l.name}=${l.value}`;
  })), Object.keys(n).forEach((l) => {
    n[l] === void 0 && delete n[l];
  }), s.postData && (n.body = s.postData.text, s.postData.mimeType === "application/json" && (n.body = `JSON.stringify(${Hr(
    JSON.parse(n.body)
  )})`));
  const a = Object.keys(n).length ? `, ${Hr(n)}` : "";
  return {
    target: "js",
    client: "fetch",
    code: `fetch('${s.url}${i}'${a})`
  };
}
function jB(r) {
  var e, t;
  const s = {
    method: "GET",
    ...r
  };
  s.method = s.method.toUpperCase();
  const n = {
    method: s.method === "GET" ? void 0 : s.method
  }, o = new URLSearchParams(
    s.queryString ? Ma(s.queryString) : void 0
  );
  o.size && (n.query = {}, o.forEach((a, l) => {
    n.query[l] = a;
  })), (e = s.headers) != null && e.length && (n.headers = {}, s.headers.forEach((a) => {
    n.headers[a.name] = a.value;
  })), (t = s.cookies) != null && t.length && (n.headers = n.headers || {}, s.cookies.forEach((a) => {
    n.headers["Set-Cookie"] = n.headers["Set-Cookie"] ? `${n.headers["Set-Cookie"]}; ${a.name}=${a.value}` : `${a.name}=${a.value}`;
  })), Object.keys(n).forEach((a) => {
    n[a] === void 0 && delete n[a];
  }), s.postData && (n.body = s.postData.text, s.postData.mimeType === "application/json" && (n.body = JSON.parse(n.body)));
  const i = Object.keys(n).length ? `, ${Hr(n)}` : "";
  return {
    target: "js",
    client: "ofetch",
    code: `ofetch('${s.url}'${i})`
  };
}
function LB(r) {
  var e, t;
  const s = {
    method: "GET",
    ...r
  };
  s.method = s.method.toUpperCase();
  const n = {
    method: s.method === "GET" ? void 0 : s.method
  }, o = new URLSearchParams(
    s.queryString ? Ma(s.queryString) : void 0
  );
  o.size && (n.query = {}, o.forEach((a, l) => {
    n.query[l] = a;
  })), (e = s.headers) != null && e.length && (n.headers = {}, s.headers.forEach((a) => {
    n.headers[a.name] = a.value;
  })), (t = s.cookies) != null && t.length && (n.headers = n.headers || {}, s.cookies.forEach((a) => {
    n.headers["Set-Cookie"] = n.headers["Set-Cookie"] ? `${n.headers["Set-Cookie"]}; ${a.name}=${a.value}` : `${a.name}=${a.value}`;
  })), Object.keys(n).forEach((a) => {
    n[a] === void 0 && delete n[a];
  }), s.postData && (n.body = s.postData.text, s.postData.mimeType === "application/json" && (n.body = JSON.parse(n.body)));
  const i = Object.keys(n).length ? `, ${Hr(n)}` : "";
  return {
    target: "node",
    client: "ofetch",
    code: `ofetch('${s.url}'${i})`
  };
}
function T0() {
  const r = [MB, DB, RB, jB, LB];
  return {
    get(e, t, s) {
      const n = this.findPlugin(e, t);
      if (n)
        return n(s);
    },
    print(e, t, s) {
      var n;
      return (n = this.get(e, t, s)) == null ? void 0 : n.code;
    },
    targets() {
      return r.map((e) => e().target).filter((e, t, s) => s.indexOf(e) === t);
    },
    clients() {
      return r.map((e) => e().client);
    },
    plugins() {
      return r.map((e) => {
        const t = e();
        return {
          target: t.target,
          client: t.client
        };
      });
    },
    findPlugin(e, t) {
      return r.find((s) => {
        const n = s();
        return n.target === e && n.client === t;
      });
    },
    hasPlugin(e, t) {
      return !!this.findPlugin(e, t);
    }
  };
}
const BB = /* @__PURE__ */ Q({
  __name: "ExamplePicker",
  props: {
    examples: {}
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const t = r, s = e, n = ie(Object.keys(t.examples)[0]);
    function o(a) {
      a && (n.value = a);
    }
    Le(
      () => t.examples,
      () => {
        o(Object.keys(t.examples)[0]);
      },
      { immediate: !0 }
    ), Le(
      n,
      () => {
        n.value && s("update:modelValue", n.value);
      },
      { immediate: !0 }
    );
    function i(a) {
      if (!a)
        return "Select an example";
      const l = t.examples[a];
      return (l == null ? void 0 : l.summary) ?? a;
    }
    return (a, l) => (S(), U(Pp, {
      modelValue: n.value,
      "onUpdate:modelValue": l[0] || (l[0] = (c) => n.value = c),
      class: "example-selector",
      options: Object.keys(a.examples).map((c) => ({
        label: i(c),
        value: c
      }))
    }, {
      default: P(() => [
        J(ee(i(n.value)), 1)
      ]),
      _: 1
    }, 8, ["modelValue", "options"]));
  }
}), yw = /* @__PURE__ */ ne(BB, [["__scopeId", "data-v-652a7e14"]]), FB = { class: "request-header" }, VB = { class: "code-snippet" }, UB = {
  key: 0,
  class: "request-card-footer-addon"
}, zB = /* @__PURE__ */ Q({
  __name: "ExampleRequest",
  props: {
    operation: {}
  },
  setup(r) {
    const e = r, s = `components-Content-Operation-Example-Request${Nh(
      e.operation.path + e.operation.httpVerb + e.operation.operationId
    )}`, n = ie(Eo[s] ?? ""), o = ie(), { copyToClipboard: i } = Go(), {
      httpClient: a,
      setHttpClient: l,
      availableTargets: c,
      httpTargetTitle: u,
      httpClientTitle: d
    } = Ia(), { server: h } = To(), { authentication: f } = ha(), m = oe(
      () => {
        var y, b, v, k, _, w, x;
        return ((k = (v = (b = (y = e.operation.information) == null ? void 0 : y.requestBody) == null ? void 0 : b.content) == null ? void 0 : v["application/json"]) == null ? void 0 : k.examples) && Object.keys(
          (x = (w = (_ = e.operation.information) == null ? void 0 : _.requestBody) == null ? void 0 : w.content) == null ? void 0 : x["application/json"].examples
        ).length > 1;
      }
    ), g = xh($p), p = async () => {
      var b;
      const y = Q0(
        {
          url: Xl(h)
        },
        ad(
          e.operation,
          {
            replaceVariables: !0
          },
          o.value
        ),
        Db(
          f,
          ((b = e.operation.information) == null ? void 0 : b.security) ?? (g == null ? void 0 : g())
        )
      );
      try {
        return T0().hasPlugin(
          a.targetKey.replace("javascript", "js"),
          // @ts-ignore
          a.clientKey
        ) ? T0().print(
          // @ts-ignore
          a.targetKey.replace("javascript", "js"),
          a.clientKey,
          y
        ) ?? "" : await new vk(y).convert(
          a.targetKey,
          a.clientKey
        );
      } catch (v) {
        return console.error("[ExampleRequest]", v), "";
      }
    };
    return Le(
      [
        // Update snippet when a different client is selected
        () => a,
        // … or the global server state changed
        () => h,
        // … or the global authentication state changed
        () => f,
        // … or the selected example key
        () => o
      ],
      async () => {
        n.value = await p();
      },
      {
        deep: !0,
        immediate: !0
      }
    ), On(async () => {
      const y = aa();
      await hs(1), y.payload.data[s] = n.value;
    }), oe(() => iv({
      serverState: h,
      authenticationState: f,
      operation: e.operation,
      globalSecurity: g == null ? void 0 : g()
    })), (y, b) => (S(), U($(uu), { class: "dark-mode" }, {
      default: P(() => [
        R($(du), { muted: "" }, {
          actions: P(() => [
            R(Pp, {
              class: "request-client-picker",
              modelValue: JSON.stringify($(a)),
              options: $(c).map((v) => ({
                value: v.key,
                label: v.title,
                options: v.clients.map((k) => ({
                  value: JSON.stringify({
                    targetKey: v.key,
                    clientKey: k.key
                  }),
                  label: k.title
                }))
              })),
              "onUpdate:modelValue": b[0] || (b[0] = (v) => $(l)(JSON.parse(v)))
            }, {
              default: P(() => [
                J(ee($(u)) + " " + ee($(d)), 1)
              ]),
              _: 1
            }, 8, ["modelValue", "options"]),
            V("button", {
              class: "copy-button",
              type: "button",
              onClick: b[1] || (b[1] = (v) => $(i)(n.value))
            }, [
              R($(Ze), {
                icon: "Clipboard",
                width: "10px"
              })
            ])
          ]),
          default: P(() => [
            V("div", FB, [
              R($(Po), {
                as: "span",
                class: "request-method",
                method: y.operation.httpVerb
              }, null, 8, ["method"]),
              te(y.$slots, "header", {}, void 0, !0)
            ])
          ]),
          _: 3
        }),
        R($(Xo), {
          borderless: "",
          class: "request-editor-section custom-scroll",
          frameless: ""
        }, {
          default: P(() => [
            V("div", VB, [
              R($(As), {
                content: n.value,
                hideCredentials: $(Nx)($(f)),
                lang: $(a).targetKey,
                lineNumbers: ""
              }, null, 8, ["content", "hideCredentials", "lang"])
            ])
          ]),
          _: 1
        }),
        m.value || y.$slots.footer ? (S(), U($(Tp), {
          key: 0,
          class: "request-card-footer",
          contrast: ""
        }, {
          default: P(() => {
            var v, k, _, w;
            return [
              m.value ? (S(), E("div", UB, [
                R(yw, {
                  class: "request-example-selector",
                  examples: ((w = (_ = (k = (v = y.operation.information) == null ? void 0 : v.requestBody) == null ? void 0 : k.content) == null ? void 0 : _["application/json"]) == null ? void 0 : w.examples) ?? [],
                  "onUpdate:modelValue": b[2] || (b[2] = (x) => o.value = x)
                }, null, 8, ["examples"])
              ])) : z("", !0),
              te(y.$slots, "footer", {}, void 0, !0)
            ];
          }),
          _: 3
        })) : z("", !0)
      ]),
      _: 3
    }));
  }
}), bw = /* @__PURE__ */ ne(zB, [["__scopeId", "data-v-23a139ed"]]), qB = { key: 0 }, HB = { key: 1 }, KB = {
  key: 0,
  class: "rule"
}, WB = { class: "rule-title" }, GB = { class: "rule-items" }, JB = {
  key: 2,
  class: "empty-state"
}, YB = /* @__PURE__ */ Q({
  __name: "ExampleResponse",
  props: {
    response: {}
  },
  setup(r) {
    const e = ["oneOf", "anyOf", "not"], t = (s) => s.reduce((n, o) => ({
      ...n,
      ...o
    }), {});
    return (s, n) => {
      var o, i, a, l, c, u, d;
      return (o = s.response) != null && o.example ? (S(), E("div", qB, [
        R($(As), {
          content: $(qi)((i = s.response) == null ? void 0 : i.example),
          lang: "json"
        }, null, 8, ["content"])
      ])) : (a = s.response) != null && a.schema ? (S(), E("div", HB, [
        (l = s.response) != null && l.schema.type ? (S(), U($(As), {
          key: 0,
          content: $(qi)(
            $(at)((c = s.response) == null ? void 0 : c.schema, {
              emptyString: "…",
              mode: "read"
            })
          ),
          lang: "json"
        }, null, 8, ["content"])) : z("", !0),
        (S(), E(Z, null, we(e, (h) => {
          var f, m, g, p, y, b;
          return S(), E(Z, { key: h }, [
            (f = s.response) != null && f.schema[h] && (((m = s.response) == null ? void 0 : m.schema[h].length) > 1 || h === "not") ? (S(), E("div", KB, [
              V("div", WB, ee(h), 1),
              V("ol", GB, [
                (S(!0), E(Z, null, we((g = s.response) == null ? void 0 : g.schema[h], (v, k) => (S(), E("li", {
                  key: k,
                  class: "rule-item"
                }, [
                  R($(As), {
                    content: $(at)(v, {
                      emptyString: "…",
                      mode: "read"
                    }),
                    lang: "json"
                  }, null, 8, ["content"])
                ]))), 128))
              ])
            ])) : (p = s.response) != null && p.schema[h] && ((y = s.response) == null ? void 0 : y.schema[h].length) === 1 ? (S(), U($(As), {
              key: 1,
              content: $(at)((b = s.response) == null ? void 0 : b.schema[h][0], {
                emptyString: "…",
                mode: "read"
              }),
              lang: "json"
            }, null, 8, ["content"])) : z("", !0)
          ], 64);
        }), 64)),
        (u = s.response) != null && u.schema.allOf ? (S(), U($(As), {
          key: 1,
          content: t(
            (d = s.response) == null ? void 0 : d.schema.allOf.map(
              (h) => $(at)(h, {
                emptyString: "…",
                mode: "read"
              })
            )
          ),
          lang: "json"
        }, null, 8, ["content"])) : z("", !0)
      ])) : (S(), E("div", JB, " No Body "));
    };
  }
}), P0 = /* @__PURE__ */ ne(YB, [["__scopeId", "data-v-800e8c7d"]]), XB = (r) => (It("data-v-314905de"), r = r(), Nt(), r), QB = {
  key: 1,
  class: "scalar-card-checkbox"
}, ZB = /* @__PURE__ */ XB(() => /* @__PURE__ */ V("span", { class: "scalar-card-checkbox-checkmark" }, null, -1)), e8 = { class: "scalar-card-container custom-scroll" }, t8 = {
  key: 1,
  class: "response-description"
}, r8 = /* @__PURE__ */ Q({
  __name: "PathResponses",
  props: {
    operation: {}
  },
  setup(r) {
    const e = r, { copyToClipboard: t } = Go(), s = ie(), n = oe(() => {
      var h, f;
      return Object.keys(((f = (h = e == null ? void 0 : e.operation) == null ? void 0 : h.information) == null ? void 0 : f.responses) ?? {}).sort(
        (m) => m === "default" ? -1 : 0
      );
    }), o = oe(
      () => !!l.value.examples
    ), i = ie(0), a = oe(() => {
      var f, m;
      const h = n.value[i.value];
      return (m = (f = e.operation.information) == null ? void 0 : f.responses) == null ? void 0 : m[h];
    }), l = oe(() => {
      var f;
      const h = Z0(
        (f = a.value) == null ? void 0 : f.content
      );
      return (
        // OpenAPI 3.x
        (h == null ? void 0 : h["application/json"]) ?? (h == null ? void 0 : h["text/plain"]) ?? // Swagger 2.0
        a.value
      );
    }), c = oe(() => ({
      ...l.value,
      example: o.value && s.value ? l.value.examples[s.value].value ?? l.value.examples[s.value] : l.value.example
    })), u = (h) => {
      i.value = h;
    }, d = ie(!1);
    return (h, f) => n.value.length ? (S(), U($(uu), { key: 0 }, {
      default: P(() => {
        var m;
        return [
          R($(b4), {
            muted: "",
            x: "as",
            onChange: u
          }, {
            actions: P(() => {
              var g, p;
              return [
                (g = l.value) != null && g.example ? (S(), E("button", {
                  key: 0,
                  class: "code-copy",
                  type: "button",
                  onClick: f[0] || (f[0] = () => {
                    var y;
                    return $(t)((y = l.value) == null ? void 0 : y.example);
                  })
                }, [
                  R($(Ze), {
                    icon: "Clipboard",
                    width: "10px",
                    x: "asd"
                  })
                ])) : z("", !0),
                (p = l.value) != null && p.schema ? (S(), E("label", QB, [
                  J(" Show Schema "),
                  Ao(V("input", {
                    "onUpdate:modelValue": f[1] || (f[1] = (y) => d.value = y),
                    class: "scalar-card-checkbox-input",
                    type: "checkbox"
                  }, null, 512), [
                    [qw, d.value]
                  ]),
                  ZB
                ])) : z("", !0)
              ];
            }),
            default: P(() => [
              (S(!0), E(Z, null, we(n.value, (g) => (S(), U($(w4), { key: g }, {
                default: P(() => [
                  J(ee(g), 1)
                ]),
                _: 2
              }, 1024))), 128))
            ]),
            _: 1
          }),
          V("div", e8, [
            R($(Xo), { muted: "" }, {
              default: P(() => {
                var g;
                return [
                  (g = l.value) != null && g.schema ? (S(), E(Z, { key: 0 }, [
                    d.value && c.value ? (S(), U($(As), {
                      key: 0,
                      content: c.value,
                      lang: "json"
                    }, null, 8, ["content"])) : (S(), U(P0, {
                      key: 1,
                      response: c.value
                    }, null, 8, ["response"]))
                  ], 64)) : (S(), U(P0, {
                    key: 1,
                    response: c.value
                  }, null, 8, ["response"]))
                ];
              }),
              _: 1
            })
          ]),
          (m = a.value) != null && m.description || o.value ? (S(), U($(Tp), {
            key: 0,
            class: "response-card-footer",
            muted: ""
          }, {
            default: P(() => {
              var g, p;
              return [
                o.value ? (S(), U(yw, {
                  key: 0,
                  class: "response-example-selector",
                  examples: (g = l.value) == null ? void 0 : g.examples,
                  "onUpdate:modelValue": f[2] || (f[2] = (y) => s.value = y)
                }, null, 8, ["examples"])) : (p = a.value) != null && p.description ? (S(), E("div", t8, [
                  R($(Lt), {
                    class: "markdown",
                    value: a.value.description
                  }, null, 8, ["value"])
                ])) : z("", !0)
              ];
            }),
            _: 1
          })) : z("", !0)
        ];
      }),
      _: 1
    })) : z("", !0);
  }
}), vw = /* @__PURE__ */ ne(r8, [["__scopeId", "data-v-314905de"]]), s8 = (r) => (It("data-v-f44e2b65"), r = r(), Nt(), r), n8 = /* @__PURE__ */ s8(() => /* @__PURE__ */ V("span", null, "Test Request", -1)), o8 = /* @__PURE__ */ Q({
  __name: "TryRequestButton",
  props: {
    operation: {}
  },
  setup(r) {
    const e = xh($p);
    return (t, s) => (S(), U($(Po), {
      as: "button",
      class: "show-api-client-button",
      method: t.operation.httpVerb,
      type: "button",
      onClick: s[0] || (s[0] = ca((n) => {
        var o;
        return $(Qd)(t.operation, (o = $(e)) == null ? void 0 : o());
      }, ["stop"]))
    }, {
      default: P(() => [
        R($(Ze), { icon: "PaperAirplane" }),
        n8
      ]),
      _: 1
    }, 8, ["method"]));
  }
}), _h = /* @__PURE__ */ ne(o8, [["__scopeId", "data-v-f44e2b65"]]), i8 = { class: "examples" }, a8 = /* @__PURE__ */ Q({
  __name: "Operation",
  props: {
    id: {},
    operation: {}
  },
  setup(r) {
    const e = r, { availableTargets: t } = Ia(), s = oe(() => {
      var o;
      const n = ["x-custom-examples", "x-codeSamples", "x-code-samples"];
      for (const i of n)
        if ((o = e.operation.information) != null && o[i])
          return e.operation.information[i];
      return null;
    });
    return (n, o) => (S(), U($(Jo), {
      id: n.id,
      label: n.operation.name
    }, {
      default: P(() => [
        R($(Yo), null, {
          default: P(() => [
            R($(Op), null, {
              default: P(() => [
                R($(xo), null, {
                  default: P(() => {
                    var i, a;
                    return [
                      (i = n.operation.information) != null && i.deprecated ? (S(), U($(ia), { key: 0 }, {
                        default: P(() => [
                          J(" Deprecated ")
                        ]),
                        _: 1
                      })) : z("", !0),
                      V("div", {
                        class: xe((a = n.operation.information) != null && a.deprecated ? "deprecated" : "")
                      }, [
                        R($(qs), { level: 3 }, {
                          default: P(() => [
                            R($(Hs), {
                              id: n.id ?? ""
                            }, {
                              default: P(() => [
                                J(ee(n.operation.name), 1)
                              ]),
                              _: 1
                            }, 8, ["id"])
                          ]),
                          _: 1
                        })
                      ], 2),
                      R(TB, { operation: n.operation }, null, 8, ["operation"])
                    ];
                  }),
                  _: 1
                }),
                R($(xo), null, {
                  default: P(() => [
                    V("div", i8, [
                      s.value ? (S(), U(A4, {
                        key: 0,
                        examples: s.value,
                        operation: n.operation
                      }, {
                        header: P(() => {
                          var i;
                          return [
                            R($h, {
                              class: "example-path",
                              deprecated: (i = n.operation.information) == null ? void 0 : i.deprecated,
                              path: n.operation.path
                            }, null, 8, ["deprecated", "path"])
                          ];
                        }),
                        footer: P(() => [
                          R(_h, { operation: n.operation }, null, 8, ["operation"])
                        ]),
                        _: 1
                      }, 8, ["examples", "operation"])) : $(t).length ? (S(), U(bw, {
                        key: 1,
                        operation: n.operation
                      }, {
                        header: P(() => {
                          var i;
                          return [
                            R($h, {
                              class: "example-path",
                              deprecated: (i = n.operation.information) == null ? void 0 : i.deprecated,
                              path: n.operation.path
                            }, null, 8, ["deprecated", "path"])
                          ];
                        }),
                        footer: P(() => [
                          R(_h, { operation: n.operation }, null, 8, ["operation"])
                        ]),
                        _: 1
                      }, 8, ["operation"])) : z("", !0),
                      R($(vw), {
                        operation: n.operation,
                        style: { "margin-top": "12px" }
                      }, null, 8, ["operation"])
                    ])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["id", "label"]));
  }
}), ww = /* @__PURE__ */ ne(a8, [["__scopeId", "data-v-c4d55ce0"]]), l8 = { class: "endpoint-details-card" }, c8 = /* @__PURE__ */ Q({
  __name: "EndpointDetailsCard",
  props: {
    operation: {}
  },
  setup(r) {
    const e = r, { parameterMap: t } = xp(e), { responses: s } = Cp(e.operation);
    return (n, o) => {
      var i;
      return S(), E("div", l8, [
        R(fr, {
          class: "endpoint-details-card-item",
          parameters: $(t).path
        }, {
          title: P(() => [
            J("Path Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        R(fr, {
          class: "endpoint-details-card-item",
          parameters: $(t).query
        }, {
          title: P(() => [
            J("Query Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        R(fr, {
          class: "endpoint-details-card-item",
          parameters: $(t).header
        }, {
          title: P(() => [
            J("Headers")
          ]),
          _: 1
        }, 8, ["parameters"]),
        R(Ip, {
          class: "endpoint-details-card-item",
          requestBody: (i = n.operation.information) == null ? void 0 : i.requestBody
        }, {
          title: P(() => [
            J("Body")
          ]),
          _: 1
        }, 8, ["requestBody"]),
        R(fr, {
          class: "endpoint-details-card-item",
          parameters: $(s)
        }, {
          title: P(() => [
            J("Responses")
          ]),
          _: 1
        }, 8, ["parameters"])
      ]);
    };
  }
}), u8 = /* @__PURE__ */ ne(c8, [["__scopeId", "data-v-f94bee14"]]), d8 = { class: "endpoint-header" }, h8 = { class: "endpoint-details" }, f8 = { class: "endpoint-label" }, p8 = { class: "endpoint-label-path" }, m8 = { class: "endpoint-label-name" }, g8 = { class: "endpoint-content" }, y8 = /* @__PURE__ */ Q({
  __name: "OperationAccordion",
  props: {
    id: {},
    operation: {}
  },
  setup(r) {
    const { copyToClipboard: e } = Go();
    return (t, s) => (S(), U($(hw), {
      id: t.id,
      class: "reference-endpoint",
      transparent: ""
    }, ua({
      title: P(() => [
        V("h3", d8, [
          V("div", h8, [
            R($(Po), {
              class: "endpoint-type",
              method: t.operation.httpVerb,
              short: ""
            }, null, 8, ["method"]),
            R($(Hs), {
              id: t.id ?? "",
              class: "endpoint-anchor"
            }, {
              default: P(() => {
                var n;
                return [
                  V("div", f8, [
                    V("div", p8, [
                      R($h, {
                        deprecated: (n = t.operation.information) == null ? void 0 : n.deprecated,
                        path: t.operation.path
                      }, null, 8, ["deprecated", "path"])
                    ]),
                    V("div", m8, ee(t.operation.name), 1)
                  ])
                ];
              }),
              _: 1
            }, 8, ["id"])
          ])
        ])
      ]),
      actions: P(({ active: n }) => [
        n ? (S(), U(_h, {
          key: 0,
          operation: t.operation
        }, null, 8, ["operation"])) : (S(), U($(Ze), {
          key: 1,
          class: "endpoint-try-hint",
          icon: "PaperAirplane"
        })),
        R($(va), {
          class: "endpoint-copy",
          icon: "Clipboard",
          label: "Copy endpoint URL",
          size: "xs",
          variant: "ghost",
          onClick: s[0] || (s[0] = ca((o) => $(e)(t.operation.path), ["stop"]))
        })
      ]),
      default: P(() => [
        V("div", g8, [
          R(u8, { operation: t.operation }, null, 8, ["operation"]),
          R($(vw), { operation: t.operation }, null, 8, ["operation"]),
          R(bw, { operation: t.operation }, null, 8, ["operation"])
        ])
      ]),
      _: 2
    }, [
      t.operation.description ? {
        name: "description",
        fn: P(() => [
          R($(Lt), {
            value: t.operation.description,
            withImages: ""
          }, null, 8, ["value"])
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["id"]));
  }
}), b8 = /* @__PURE__ */ ne(y8, [["__scopeId", "data-v-f61893df"]]), v8 = /* @__PURE__ */ Q({
  __name: "ShowMoreButton",
  props: {
    id: {}
  },
  setup(r) {
    const { setCollapsedSidebarItem: e } = xr();
    return (t, s) => (S(), E("button", {
      class: "show-more",
      type: "button",
      onClick: s[0] || (s[0] = (n) => $(e)(t.id, !0))
    }, [
      J(" Show More "),
      R($(Ze), {
        class: "show-more-icon",
        icon: "ChevronDown"
      })
    ]));
  }
}), kw = /* @__PURE__ */ ne(v8, [["__scopeId", "data-v-60a9fbab"]]), w8 = { class: "endpoints" }, k8 = ["onClick"], S8 = /* @__PURE__ */ Q({
  __name: "Endpoints",
  props: {
    id: {},
    tag: {}
  },
  emits: ["observeAndNavigate"],
  setup(r, { emit: e }) {
    const t = r, s = e, { getOperationId: n, getTagId: o } = Ct(), { setCollapsedSidebarItem: i } = xr(), a = (c) => {
      s("observeAndNavigate", c);
    };
    async function l(c) {
      a(n(c, t.tag)), i(o(t.tag), !0);
    }
    return (c, u) => (S(), U($(Jo), {
      id: c.id,
      label: c.tag.name.toUpperCase()
    }, {
      default: P(() => [
        R($(Yo), null, {
          default: P(() => [
            R($(Op), null, {
              default: P(() => [
                R($(xo), null, {
                  default: P(() => [
                    R($(qs), { level: 2 }, {
                      default: P(() => [
                        R($(Hs), {
                          id: $(o)(c.tag)
                        }, {
                          default: P(() => [
                            J(ee(c.tag["x-displayName"] ?? c.tag.name), 1)
                          ]),
                          _: 1
                        }, 8, ["id"])
                      ]),
                      _: 1
                    }),
                    R($(Lt), {
                      value: c.tag.description,
                      withImages: ""
                    }, null, 8, ["value"])
                  ]),
                  _: 1
                }),
                R($(xo), null, {
                  default: P(() => {
                    var d;
                    return [
                      ((d = c.tag.operations) == null ? void 0 : d.length) > 0 ? (S(), U($(uu), {
                        key: 0,
                        class: "scalar-card-sticky"
                      }, {
                        default: P(() => [
                          R($(du), { muted: "" }, {
                            default: P(() => [
                              J("Endpoints")
                            ]),
                            _: 1
                          }),
                          R($(Xo), {
                            class: "custom-scroll",
                            muted: ""
                          }, {
                            default: P(() => [
                              V("div", w8, [
                                (S(!0), E(Z, null, we(c.tag.operations, (h) => (S(), E("a", {
                                  key: $(n)(h, c.tag),
                                  class: "endpoint",
                                  onClick: (f) => l(h)
                                }, [
                                  R($(Po), {
                                    method: h.httpVerb
                                  }, null, 8, ["method"]),
                                  V("span", null, ee(h.path), 1)
                                ], 8, k8))), 128))
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })) : z("", !0)
                    ];
                  }),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["id", "label"]));
  }
}), $8 = /* @__PURE__ */ ne(S8, [["__scopeId", "data-v-b209ef2d"]]), _8 = (r, e) => {
  uk(r, e, { childList: !0, subtree: !0 });
}, x8 = /* @__PURE__ */ Q({
  __name: "Tag",
  props: {
    id: {},
    tag: {},
    spec: {}
  },
  setup(r) {
    const e = r, t = ie(null), { collapsedSidebarItems: s } = xr(), { getTagId: n } = Ct(), o = (c) => {
      var u;
      return ((u = e.spec.tags) == null ? void 0 : u.length) !== 1 || (c == null ? void 0 : c.name) !== "default" || (c == null ? void 0 : c.description) !== "";
    }, i = (c) => {
      window.location.href = `#${c}`;
    }, a = (c) => {
      _8(t, (u, d) => {
        u.forEach((h) => {
          Array.from(h.addedNodes).some((m) => m instanceof HTMLElement && m.id === c) && (i(c), d.disconnect());
        });
      });
    }, l = (c) => {
      document.getElementById(c) ? i(c) : a(c);
    };
    return (c, u) => (S(), U($(Na), {
      ref_key: "sectionContainerRef",
      ref: t,
      class: "tag-section-container"
    }, {
      default: P(() => {
        var d;
        return [
          o(c.tag) ? (S(), U($8, {
            key: 0,
            id: c.id,
            tag: c.tag,
            onObserveAndNavigate: l
          }, null, 8, ["id", "tag"])) : z("", !0),
          !$(s)[$(n)(c.tag)] && ((d = c.tag.operations) == null ? void 0 : d.length) > 1 ? (S(), U(kw, {
            key: 1,
            id: c.id ?? ""
          }, null, 8, ["id"])) : te(c.$slots, "default", { key: 2 }, void 0, !0)
        ];
      }),
      _: 3
    }, 512));
  }
}), Sw = /* @__PURE__ */ ne(x8, [["__scopeId", "data-v-7fef7ce7"]]), C8 = /* @__PURE__ */ Q({
  __name: "TagAccordion",
  props: {
    tag: {},
    spec: {}
  },
  setup(r) {
    const { getTagId: e } = Ct();
    return (t, s) => (S(), U($(fw), { class: "tag-section" }, {
      title: P(() => [
        R($(qs), {
          class: "tag-name",
          level: 2
        }, {
          default: P(() => [
            R($(Hs), {
              id: $(e)(t.tag)
            }, {
              default: P(() => [
                J(ee(t.tag.name), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 1
        }),
        R($(Lt), {
          class: "tag-description",
          value: t.tag.description,
          withImages: ""
        }, null, 8, ["value"])
      ]),
      default: P(() => [
        te(t.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }));
  }
}), A8 = /* @__PURE__ */ ne(C8, [["__scopeId", "data-v-f11e3b56"]]), E8 = /* @__PURE__ */ Q({
  __name: "Loading",
  props: {
    layout: { default: "default" },
    parsedSpec: {}
  },
  setup(r) {
    const e = r, t = ie(!1), s = ie([]), n = ie([]), { getModelId: o, getSectionId: i, getTagId: a, hash: l, isIntersectionEnabled: c } = Ct(), u = ie(e.layout !== "accordion" && l.value);
    Le(
      () => {
        var h;
        return (h = e.parsedSpec.tags) == null ? void 0 : h.length;
      },
      (h) => {
        var m, g;
        if (!l.value || typeof h != "number" || !e.parsedSpec.tags)
          return;
        const f = i();
        if (f.startsWith("tag")) {
          let p = 0;
          const y = ((m = e.parsedSpec.tags) == null ? void 0 : m.findIndex(
            (k) => a(k) === f
          )) ?? 0, b = l.value.match(/tag\/([^/]+)\/([^/]+)\/(.+)/);
          if ((b == null ? void 0 : b.length) === 4) {
            const k = b[2], _ = "/" + b[3];
            p = (g = e.parsedSpec.tags[y]) == null ? void 0 : g.operations.findIndex(
              ({ httpVerb: w, path: x }) => k === w && _ === x
            );
          }
          const v = e.parsedSpec.tags[y];
          if (!v)
            return;
          v.name !== "default" && (t.value = f !== l.value && f.startsWith("tag")), s.value.push({
            ...v,
            lazyOperations: v.operations.slice(
              p,
              p + 2
            )
          });
        } else if (l.value.startsWith("model")) {
          const p = Object.keys(Fr(e.parsedSpec) ?? {}), [, y] = l.value.toLowerCase().split("/"), b = l.value === "models" ? 0 : p.findIndex((v) => v.toLowerCase() === y);
          if (b === -1)
            return;
          n.value = p.slice(b, b + 3);
        } else
          hc(l.value), setTimeout(() => c.value = !0, 1e3);
      },
      { immediate: !0 }
    );
    const d = Sh.on(({ id: h }) => {
      const f = l.value;
      !f || h !== f || (d(), setTimeout(() => {
        typeof window < "u" && hc(f), u.value = !1, setTimeout(() => c.value = !0, 1e3);
      }, 300));
    });
    return vr(() => {
      l.value || setTimeout(() => c.value = !0, 1e3);
    }), (h, f) => Ao((S(), E("div", {
      class: xe(["references-loading", {
        "references-loading-hidden-tag": t.value,
        "references-loading-top-spacer": s.value.length
      }])
    }, [
      (S(!0), E(Z, null, we(s.value, (m) => (S(), E(Z, {
        key: m.id
      }, [
        m.operations && m.operations.length > 0 ? (S(), U($(Sw), {
          key: 0,
          spec: h.parsedSpec,
          tag: m
        }, {
          default: P(() => [
            (S(!0), E(Z, null, we(m.lazyOperations, (g) => (S(), U($(ww), {
              key: `${g.httpVerb}-${g.operationId}`,
              operation: g,
              tag: m
            }, null, 8, ["operation", "tag"]))), 128))
          ]),
          _: 2
        }, 1032, ["spec", "tag"])) : z("", !0)
      ], 64))), 128)),
      n.value.length ? (S(), U($(Na), { key: 0 }, {
        default: P(() => [
          (S(!0), E(Z, null, we(n.value, (m) => (S(), U($(Jo), {
            key: m,
            label: m
          }, {
            default: P(() => {
              var g;
              return [
                (g = $(Fr)(h.parsedSpec)) != null && g[m] ? (S(), U($(Yo), { key: 0 }, {
                  default: P(() => {
                    var p;
                    return [
                      R($(qs), { level: 2 }, {
                        default: P(() => [
                          R($(Hs), {
                            id: $(o)(m)
                          }, {
                            default: P(() => {
                              var y;
                              return [
                                J(ee(((y = $(Fr)(h.parsedSpec)) == null ? void 0 : y[m]).title ?? m), 1)
                              ];
                            }),
                            _: 2
                          }, 1032, ["id"])
                        ]),
                        _: 2
                      }, 1024),
                      R($(pn), {
                        name: m,
                        noncollapsible: "",
                        value: (p = $(Fr)(h.parsedSpec)) == null ? void 0 : p[m]
                      }, null, 8, ["name", "value"])
                    ];
                  }),
                  _: 2
                }, 1024)) : z("", !0)
              ];
            }),
            _: 2
          }, 1032, ["label"]))), 128))
        ]),
        _: 1
      })) : z("", !0)
    ], 2)), [
      [yc, u.value]
    ]);
  }
}), O8 = (r) => (It("data-v-f19478dd"), r = r(), Nt(), r), T8 = /* @__PURE__ */ O8(() => /* @__PURE__ */ V("div", { id: "models" }, null, -1)), P8 = /* @__PURE__ */ Q({
  __name: "Models",
  props: {
    schemas: {}
  },
  setup(r) {
    const e = r, { collapsedSidebarItems: t } = xr(), { getModelId: s } = Ct(), n = oe(
      () => Object.keys(e.schemas ?? {}).length <= 3 || t[s()]
    ), o = oe(() => {
      const i = Object.keys(e.schemas ?? {});
      return n.value ? i : i.slice(0, 3);
    });
    return (i, a) => i.schemas ? (S(), U($(Na), { key: 0 }, {
      default: P(() => [
        R($(gc), {
          id: "models",
          isLazy: !1
        }, {
          default: P(() => [
            T8
          ]),
          _: 1
        }),
        (S(!0), E(Z, null, we(o.value, (l, c) => (S(), U($(gc), {
          id: $(s)(l),
          key: l,
          isLazy: ""
        }, {
          default: P(() => [
            R($(Jo), {
              id: $(s)(l),
              label: l
            }, {
              default: P(() => [
                i.schemas[l] ? (S(), U($(Yo), { key: 0 }, {
                  default: P(() => [
                    R($(qs), { level: 2 }, {
                      default: P(() => [
                        R($(Hs), {
                          id: $(s)(l)
                        }, {
                          default: P(() => [
                            J(ee(i.schemas[l].title ?? l), 1)
                          ]),
                          _: 2
                        }, 1032, ["id"])
                      ]),
                      _: 2
                    }, 1024),
                    R($(pn), {
                      name: l,
                      noncollapsible: "",
                      value: i.schemas[l]
                    }, null, 8, ["name", "value"]),
                    !n.value && c === o.value.length - 1 ? (S(), U(kw, {
                      key: 0,
                      id: $(s)(),
                      class: "something-special"
                    }, null, 8, ["id"])) : z("", !0)
                  ]),
                  _: 2
                }, 1024)) : z("", !0)
              ]),
              _: 2
            }, 1032, ["id", "label"])
          ]),
          _: 2
        }, 1032, ["id"]))), 128))
      ]),
      _: 1
    })) : z("", !0);
  }
}), I8 = /* @__PURE__ */ ne(P8, [["__scopeId", "data-v-f19478dd"]]), N8 = {
  key: 0,
  class: "properties"
}, M8 = { key: 1 }, D8 = /* @__PURE__ */ Q({
  __name: "ModelsAccordion",
  props: {
    schemas: {}
  },
  setup(r) {
    const e = r, t = oe(() => e.schemas ? Object.entries(e.schemas).map(([n, o]) => ({
      name: n,
      schema: o
    })) : []), { getModelId: s } = Ct();
    return (n, o) => e.schemas ? (S(), U($(fw), {
      key: 0,
      class: "reference-models"
    }, {
      title: P(() => [
        R($(qs), { level: 2 }, {
          default: P(() => [
            J("Models")
          ]),
          _: 1
        })
      ]),
      default: P(() => [
        (S(!0), E(Z, null, we(t.value, ({ name: i, schema: a }) => (S(), U($(hw), {
          id: $(s)(i),
          key: i,
          label: i
        }, {
          title: P(() => [
            R($(Hs), {
              id: $(s)(i),
              class: "reference-models-anchor"
            }, {
              default: P(() => [
                R($(gw), {
                  class: "reference-models-label",
                  name: i,
                  value: a
                }, null, 8, ["name", "value"])
              ]),
              _: 2
            }, 1032, ["id"])
          ]),
          default: P(() => [
            a != null && a.properties ? (S(), E("div", N8, [
              (S(!0), E(Z, null, we(Object.entries(a.properties), ([l, c]) => {
                var u, d, h;
                return S(), U($(fn), {
                  key: l,
                  name: l,
                  required: ((u = a.required) == null ? void 0 : u.includes(l)) || ((h = (d = a.properties) == null ? void 0 : d[l]) == null ? void 0 : h.required) === !0,
                  value: c
                }, null, 8, ["name", "required", "value"]);
              }), 128))
            ])) : (S(), E("div", M8, [
              R($(fn), { value: a }, null, 8, ["value"])
            ]))
          ]),
          _: 2
        }, 1032, ["id", "label"]))), 128))
      ]),
      _: 1
    })) : z("", !0);
  }
}), R8 = /* @__PURE__ */ ne(D8, [["__scopeId", "data-v-a6175929"]]), j8 = /* @__PURE__ */ Q({
  __name: "Webhook",
  props: {
    webhook: {}
  },
  setup(r) {
    const e = r, { responses: t } = Cp(e.webhook);
    return (s, n) => {
      var o;
      return s.webhook ? (S(), E(Z, { key: 0 }, [
        R(Ip, {
          requestBody: (o = s.webhook.information) == null ? void 0 : o.requestBody
        }, {
          title: P(() => [
            J("Payload")
          ]),
          _: 1
        }, 8, ["requestBody"]),
        R(fr, { parameters: $(t) }, {
          title: P(() => [
            J("Responses")
          ]),
          _: 1
        }, 8, ["parameters"])
      ], 64)) : z("", !0);
    };
  }
}), L8 = /* @__PURE__ */ Q({
  __name: "Webhooks",
  props: {
    webhooks: {}
  },
  setup(r) {
    const e = r, t = oe(() => Object.keys(e.webhooks ?? {})), { getWebhookId: s } = Ct();
    return (n, o) => t.value.length ? (S(), U($(Na), { key: 0 }, {
      default: P(() => [
        (S(!0), E(Z, null, we(t.value, (i) => {
          var a;
          return S(), E(Z, { key: i }, [
            (S(!0), E(Z, null, we(Object.keys(
              (a = n.webhooks) == null ? void 0 : a[i]
            ), (l) => (S(), U($(Jo), {
              id: $(s)(i, l),
              key: l,
              label: i
            }, {
              default: P(() => {
                var c;
                return [
                  (c = n.webhooks) != null && c[i] ? (S(), U($(Yo), { key: 0 }, {
                    default: P(() => {
                      var u, d;
                      return [
                        R($(qs), { level: 2 }, {
                          default: P(() => [
                            R($(Hs), {
                              id: $(s)(i, l)
                            }, {
                              default: P(() => {
                                var h;
                                return [
                                  J(ee((h = n.webhooks[i][l]) == null ? void 0 : h.name), 1)
                                ];
                              }),
                              _: 2
                            }, 1032, ["id"])
                          ]),
                          _: 2
                        }, 1024),
                        (u = n.webhooks[i][l]) != null && u.description ? (S(), U($(Lt), {
                          key: 0,
                          value: (d = n.webhooks[i][l]) == null ? void 0 : d.description,
                          withImages: ""
                        }, null, 8, ["value"])) : z("", !0),
                        R(j8, {
                          webhook: n.webhooks[i][l]
                        }, null, 8, ["webhook"])
                      ];
                    }),
                    _: 2
                  }, 1024)) : z("", !0)
                ];
              }),
              _: 2
            }, 1032, ["id", "label"]))), 128))
          ], 64);
        }), 128))
      ]),
      _: 1
    })) : z("", !0);
  }
}), B8 = /* @__PURE__ */ la('<div class="section-flare" data-v-055e26bb><div class="section-flare-item" data-v-055e26bb></div><div class="section-flare-item" data-v-055e26bb></div><div class="section-flare-item" data-v-055e26bb></div><div class="section-flare-item" data-v-055e26bb></div><div class="section-flare-item" data-v-055e26bb></div><div class="section-flare-item" data-v-055e26bb></div><div class="section-flare-item" data-v-055e26bb></div><div class="section-flare-item" data-v-055e26bb></div></div>', 1), F8 = { class: "narrow-references-container" }, V8 = /* @__PURE__ */ Q({
  __name: "Content",
  props: {
    parsedSpec: {},
    layout: {},
    baseServerURL: {},
    proxy: {}
  },
  setup(r) {
    const e = r, { getOperationId: t, getTagId: s, hash: n } = Ct(), { setServer: o } = To(), { hideModels: i, collapsedSidebarItems: a } = xr(), l = (f) => {
      if (f.url.match(/^(?!(https?|file):\/\/|{).+/)) {
        let m = e.baseServerURL ?? window.location.origin;
        m = m.replace(/\/$/, "");
        const g = f.url.startsWith("/") ? f.url : `/${f.url}`;
        f.url = `${m}${g}`.replace(/\/$/, "");
      }
      return f;
    };
    Le(
      () => e.parsedSpec,
      (f) => {
        var g, p;
        let m = [
          { url: typeof window < "u" ? window.location.origin : "/" }
        ];
        f.servers && f.servers.length > 0 ? m = f.servers : e.parsedSpec.host && (m = [
          {
            url: `${((g = e.parsedSpec.schemes) == null ? void 0 : g[0]) ?? "http"}://${e.parsedSpec.host}${((p = e.parsedSpec) == null ? void 0 : p.basePath) ?? ""}`
          }
        ]), (e.baseServerURL || typeof window < "u") && (m = m.map(l)), o({ servers: m });
      },
      { deep: !0, immediate: !0 }
    );
    const c = oe(
      () => e.layout === "accordion" ? A8 : Sw
    ), u = oe(
      () => e.layout === "accordion" ? b8 : ww
    ), d = oe(
      () => e.layout === "accordion" ? "after" : "aside"
    ), h = e.layout !== "accordion" && !n.value.startsWith("model");
    return (f, m) => (S(), E(Z, null, [
      B8,
      V("div", F8, [
        te(f.$slots, "start", {}, void 0, !0),
        R($(E8), {
          layout: f.layout,
          parsedSpec: f.parsedSpec
        }, null, 8, ["layout", "parsedSpec"]),
        f.parsedSpec.info.title || f.parsedSpec.info.description ? (S(), U($(ZL), {
          key: 0,
          info: f.parsedSpec.info,
          parsedSpec: f.parsedSpec
        }, {
          [d.value]: P(() => [
            V("div", {
              class: xe(["introduction-card", { "introduction-card-row": f.layout === "accordion" }])
            }, [
              R($(eL)),
              R($(Ej), {
                parsedSpec: f.parsedSpec,
                proxy: f.proxy
              }, null, 8, ["parsedSpec", "proxy"]),
              R($(yL))
            ], 2)
          ]),
          _: 2
        }, 1032, ["info", "parsedSpec"])) : te(f.$slots, "empty-state", { key: 1 }, void 0, !0),
        (S(!0), E(Z, null, we(f.parsedSpec.tags, (g) => (S(), U($(gc), {
          id: $(s)(g),
          key: $(s)(g),
          isLazy: $(h) && !$(a)[$(s)(g)]
        }, {
          default: P(() => [
            (S(), U(br(c.value), {
              id: $(s)(g),
              spec: f.parsedSpec,
              tag: g
            }, {
              default: P(() => [
                (S(!0), E(Z, null, we(g.operations, (p, y) => (S(), U($(gc), {
                  id: $(t)(p, g),
                  key: `${p.httpVerb}-${p.operationId}`,
                  isLazy: y > 0
                }, {
                  default: P(() => [
                    (S(), U(br(u.value), {
                      id: $(t)(p, g),
                      operation: p,
                      tag: g
                    }, null, 8, ["id", "operation", "tag"]))
                  ]),
                  _: 2
                }, 1032, ["id", "isLazy"]))), 128))
              ]),
              _: 2
            }, 1032, ["id", "spec", "tag"]))
          ]),
          _: 2
        }, 1032, ["id", "isLazy"]))), 128)),
        f.parsedSpec.webhooks ? (S(), U($(L8), {
          key: 2,
          webhooks: f.parsedSpec.webhooks
        }, null, 8, ["webhooks"])) : z("", !0),
        $(av)(f.parsedSpec) && !$(i) ? (S(), E(Z, { key: 3 }, [
          f.layout === "accordion" ? (S(), U($(R8), {
            key: 0,
            schemas: $(Fr)(f.parsedSpec)
          }, null, 8, ["schemas"])) : (S(), U($(I8), {
            key: 1,
            schemas: $(Fr)(f.parsedSpec)
          }, null, 8, ["schemas"]))
        ], 64)) : z("", !0),
        te(f.$slots, "end", {}, void 0, !0)
      ])
    ], 64));
  }
}), U8 = /* @__PURE__ */ ne(V8, [["__scopeId", "data-v-055e26bb"]]), z8 = (r) => (It("data-v-391b4e37"), r = r(), Nt(), r), q8 = { class: "start custom-scroll" }, H8 = { class: "start-copy" }, K8 = /* @__PURE__ */ la('<div class="start-logo" data-v-391b4e37><svg height="36" viewBox="0 0 36 36" width="36" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><path d="M18 0a18 18 0 1 1 0 36 18 18 0 0 1 0-36Zm11.2 6.5c-3.3-3.3-11.1-1-17.4 5.3-6.2 6.3-8.6 14-5.3 17.4 3.3 3.3 11 .9 17.3-5.4 6.3-6.2 8.7-14 5.4-17.3ZM17.6 12a6.3 6.3 0 1 1 0 12.7 6.3 6.3 0 0 1 0-12.7Z" fill="currentColor" fill-rule="evenodd" data-v-391b4e37></path></svg></div><h1 class="start-h1" data-v-391b4e37>Swagger Editor</h1><p class="start-p" data-v-391b4e37> Welcome to the Scalar API References + Swagger Editor, a Free &amp; Open-Source tool that takes your Swagger/OAS file and generates Beautiful API references. </p>', 3), W8 = { class: "start-cta" }, G8 = { class: "start-row" }, J8 = /* @__PURE__ */ la('<div class="start-section start-section-integrations" data-v-391b4e37><div class="start-h2" data-v-391b4e37>INTEGRATIONS</div><a class="start-item" href="https://github.com/scalar/scalar/tree/main/packages/fastify-api-reference#readme" target="_blank" data-v-391b4e37><svg fill="currentColor" height="16" viewBox="0 0 19 16" width="19" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><path d="m18.2 3.1.8-2V.9l-4.7 1.3C15.2 1 15 0 15 0s-2.5 1.6-4.3 1.5c-2 0-3.6.8-4 1-1.8 1.2-2.5 3.3-3.2 3.8L0 8.9 2.3 8l-2 2.5c.2.3 1.2 1.6 2.1 1.3l.4-.1 1.6.5-.7-1 .2-.2.9.3-.1-.8.9.3-.1-.8.3-.1 1-3.5 3.7-2.6-.3.7A4 4 0 0 1 8 7l-.6.2c-.5.5-.7.7-.8 2.5a2 2 0 0 1 1 0c1.6.4 2.2 2.3 1.7 2.9l-.7.6H8v.6h-.7v.5l-.2.2c-.7 0-1.4-.6-1.4-.6 0 .5.4 1.3.4 1.3s1.7 1.1 2.7.7c1-.4.7-2.3 2.8-3.2l3.3-.9.8-2.2-1.7.5v-2l2.5-.6.9-2.2-3.4.9v-2l4.2-1.1Z" fill="currentColor" fill-rule="nonzero" data-v-391b4e37></path></svg><span data-v-391b4e37>Fastify</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#from-a-cdn" target="_blank" data-v-391b4e37><svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g data-v-391b4e37><path d="M22.5 1.5h-21A1.5 1.5 0 0 0 0 3v3a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 6V3a1.5 1.5 0 0 0-1.5-1.5Zm-19.25 3A1.25 1.25 0 1 1 4.5 5.75 1.25 1.25 0 0 1 3.25 4.5ZM8.5 5.75A1.25 1.25 0 1 1 9.75 4.5 1.25 1.25 0 0 1 8.5 5.75Z" fill="currentColor" data-v-391b4e37></path><path d="M22.5 9h-21A1.5 1.5 0 0 0 0 10.5v3A1.5 1.5 0 0 0 1.5 15h21a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 22.5 9ZM3.25 12a1.25 1.25 0 1 1 1.25 1.25A1.25 1.25 0 0 1 3.25 12Zm5.25 1.25A1.25 1.25 0 1 1 9.75 12a1.25 1.25 0 0 1-1.25 1.25Z" fill="currentColor" data-v-391b4e37></path><path d="M22.5 16.5h-21A1.5 1.5 0 0 0 0 18v3a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 21v-3a1.5 1.5 0 0 0-1.5-1.5Zm-19.25 3a1.25 1.25 0 1 1 1.25 1.25 1.25 1.25 0 0 1-1.25-1.25Zm5.25 1.25a1.25 1.25 0 1 1 1.25-1.25 1.25 1.25 0 0 1-1.25 1.25Z" fill="currentColor" data-v-391b4e37></path></g></svg><span data-v-391b4e37>CDN</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#with-vuejs" target="_blank" data-v-391b4e37><svg height="170" viewBox="0 0 196.3 170" width="196.3" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g fill="currentColor" fill-rule="nonzero" data-v-391b4e37><polygon points="39.23 0 0 0 2.9450761 5.1010782 98.16 170.02 196.32 0 157.06 0 98.16 102.01 42.175701 5.0991171" data-v-391b4e37></polygon><polygon points="75.5 2.009956e-14 0 2.009956e-14 2.94 5.1 78.44871 5.1 98.16 39.26 117.87937 5.1 193.38 5.1 196.325 0 120.82 7.8065636e-15 114.97322 2.009956e-14 98.16 29.037153 81.35 2.009956e-14" data-v-391b4e37></polygon></g></svg><span data-v-391b4e37>Vue</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#with-react" target="_blank" data-v-391b4e37><svg height="23.3" viewBox="0 0 22 23.3" width="22" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g fill="none" fill-rule="evenodd" data-v-391b4e37><circle cx="11" cy="11.6" fill="currentColor" fill-rule="nonzero" r="2" data-v-391b4e37></circle><g stroke="currentColor" data-v-391b4e37><ellipse cx="11" cy="11.6" rx="11" ry="4.2" data-v-391b4e37></ellipse><ellipse cx="11" cy="11.6" rx="11" ry="4.2" transform="rotate(60 11 11.6)" data-v-391b4e37></ellipse><ellipse cx="11" cy="11.6" rx="11" ry="4.2" transform="rotate(120 11 11.6)" data-v-391b4e37></ellipse></g></g></svg><span data-v-391b4e37>React</span></a></div>', 1), Y8 = { class: "start-section start-section-colors" }, X8 = /* @__PURE__ */ z8(() => /* @__PURE__ */ V("p", { class: "start-h2" }, "THEMING", -1)), Q8 = ["onClick"], Z8 = /* @__PURE__ */ la('<p class="start-h1" data-v-391b4e37>Features</p><ul class="start-ul" data-v-391b4e37><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Customize</p> Bring your typography &amp; color palettes, or use our themes! </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Testing</p> A deeply integrated Rest API Client (Also Free &amp; Open-Source) </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Search</p> Fully integrated Search (Using fuse.js) </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Hosting</p> Free subdomain hosting on https://apidocumentation.com </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>OpenAPI &amp; Swagger</p> Support for OpenAPI 3.1, OpenAPI 3.0, and Swagger 2.0 </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Code Samples</p> Code samples to show off your API in most popular languages </li></ul>', 2), e9 = /* @__PURE__ */ Q({
  __name: "GettingStarted",
  props: {
    theme: {}
  },
  emits: ["changeTheme", "loadSwaggerFile", "linkSwaggerFile", "updateContent"],
  setup(r, { emit: e }) {
    const t = e, s = [
      "default",
      "alternate",
      "moon",
      "purple",
      "solarized",
      "bluePlanet",
      "saturn",
      "kepler",
      "mars",
      "deepSpace"
    ];
    async function n() {
      const o = await fetch(
        "https://cdn.jsdelivr.net/npm/@scalar/galaxy/dist/latest.yaml"
      );
      t("updateContent", await o.text());
    }
    return (o, i) => (S(), E("div", q8, [
      V("div", H8, [
        K8,
        V("div", W8, [
          R($(Tg), {
            fullWidth: "",
            onClick: n
          }, {
            default: P(() => [
              J(" Show Example ")
            ]),
            _: 1
          }),
          R($(Tg), {
            fullWidth: "",
            variant: "outlined",
            onClick: i[0] || (i[0] = (a) => o.$emit("loadSwaggerFile"))
          }, {
            default: P(() => [
              J(" Upload File ")
            ]),
            _: 1
          })
        ])
      ]),
      V("div", G8, [
        J8,
        V("div", Y8, [
          X8,
          (S(), E(Z, null, we(s, (a) => V("div", {
            key: a,
            class: xe(["start-item", { "start-item-active": a === o.theme }]),
            onClick: (l) => o.$emit("changeTheme", { id: a, label: $(Wp)[a] })
          }, ee($(Wp)[a]), 11, Q8)), 64))
        ])
      ]),
      Z8
    ]));
  }
}), t9 = /* @__PURE__ */ ne(e9, [["__scopeId", "data-v-391b4e37"]]), r9 = { class: "references-header" }, s9 = {
  key: 0,
  class: "references-navigation t-doc__sidebar"
}, n9 = { class: "references-navigation-list" }, o9 = { class: "references-editor" }, i9 = { class: "references-editor-textarea" }, a9 = { class: "references-rendered" }, l9 = {
  key: 0,
  class: "references-footer"
}, c9 = /* @__PURE__ */ Q({
  inheritAttrs: !1,
  __name: "ApiReferenceLayout",
  props: {
    configuration: {},
    parsedSpec: {},
    rawSpec: {}
  },
  emits: ["changeTheme", "updateContent", "loadSwaggerFile", "linkSwaggerFile", "toggleDarkMode"],
  setup(r) {
    const e = r, t = Th("(min-width: 1150px)"), s = ie("100dvh"), n = ie(null);
    dk(n, (w) => {
      s.value = w[0].contentRect.height + "px";
    });
    const {
      breadcrumb: o,
      collapsedSidebarItems: i,
      isSidebarOpen: a,
      setCollapsedSidebarItem: l,
      hideModels: c,
      setParsedSpec: u
    } = xr(), {
      getPathRoutingId: d,
      getSectionId: h,
      getTagId: f,
      hash: m,
      isIntersectionEnabled: g,
      pathRouting: p,
      updateHash: y
    } = Ct();
    p.value = e.configuration.pathRouting, Hw(() => y());
    const b = async (w) => {
      var x;
      g.value = !1, y(), w ? hc(w) : (x = n.value) == null || x.scrollTo(0, 0), await hs(100), g.value = !0;
    };
    vr(() => {
      rw.on(({ specTitle: w }) => {
        I3(e.rawSpec, w);
      }), window.onhashchange = () => b(decodeURIComponent(window.location.hash.replace(/^#/, ""))), window.onpopstate = () => p.value && b(d(window.location.pathname));
    });
    const v = oe(
      () => t.value || !e.configuration.isEditable
    ), k = hk((w) => {
      if ((w.target.scrollTop ?? 0) < 50) {
        const T = e.configuration.pathRouting ? e.configuration.pathRouting.basePath : window.location.pathname;
        window.history.replaceState({}, "", T + window.location.search), m.value = "";
      }
    }), _ = oe(() => ({
      breadcrumb: o.value,
      spec: e.parsedSpec
    }));
    return Le(() => e.parsedSpec, u, { deep: !0 }), On(() => {
      var x, T;
      const w = aa();
      if (w && ((x = w.payload).data || (x.data = sd()), e.configuration.pathRouting)) {
        const j = d(w.url);
        m.value = j, w.payload.data.hash = j;
        for (const B in i)
          Object.hasOwn(i, B) && delete i[B];
        if (j)
          l(h(j), !0);
        else {
          const B = (T = e.parsedSpec.tags) == null ? void 0 : T[0];
          B && l(f(B), !0);
        }
        w.payload.data["useSidebarContent-collapsedSidebarItems"] = i;
      }
    }), ik(() => {
      var j;
      const w = Kw(), x = "scalar-instance-id";
      if (!w)
        return x;
      let T = w.uid;
      return typeof window > "u" ? (w.attrs || (w.attrs = {}), w.attrs[x] = T) : (j = w.vnode.el) != null && j.getAttribute && (T = w.vnode.el.getAttribute(x)), `${x}-${T}`;
    }), Kp($p, () => e.parsedSpec.security), Kp(
      tw,
      () => e.configuration.hideDownloadButton
    ), c.value = e.configuration.hideModels ?? !1, R3(e.configuration), (w, x) => {
      var T, j;
      return S(), E(Z, null, [
        R($(Fk), {
          id: (T = w.configuration) == null ? void 0 : T.theme,
          withDefaultFonts: (j = w.configuration) == null ? void 0 : j.withDefaultFonts
        }, null, 8, ["id", "withDefaultFonts"]),
        R($(V0), null, {
          default: P(({ styles: B }) => [
            R($(Jk), null, {
              default: P(({ styles: W }) => {
                var L, ue;
                return [
                  V("div", {
                    ref_key: "documentEl",
                    ref: n,
                    class: xe(["scalar-api-reference references-layout", [
                      {
                        "references-editable": w.configuration.isEditable,
                        "references-sidebar": w.configuration.showSidebar,
                        "references-sidebar-mobile-open": $(a),
                        "references-classic": w.configuration.layout === "classic"
                      },
                      B,
                      W,
                      w.$attrs.class
                    ]]),
                    style: os({ "--full-height": s.value }),
                    onScrollPassive: x[4] || (x[4] = //@ts-ignore
                    (...ae) => $(k) && $(k)(...ae))
                  }, [
                    V("div", r9, [
                      te(w.$slots, "header", cr(ur(_.value)), void 0, !0)
                    ]),
                    w.configuration.showSidebar ? (S(), E("aside", s9, [
                      V("div", n9, [
                        R($(cw), { parsedSpec: w.parsedSpec }, {
                          "sidebar-start": P(() => [
                            te(w.$slots, "sidebar-start", cr(ur(_.value)), void 0, !0)
                          ]),
                          "sidebar-end": P(() => [
                            te(w.$slots, "sidebar-end", cr(ur(_.value)), void 0, !0)
                          ]),
                          _: 3
                        }, 8, ["parsedSpec"])
                      ])
                    ])) : z("", !0),
                    Ao(V("div", o9, [
                      V("div", i9, [
                        te(w.$slots, "editor", cr(ur(_.value)), void 0, !0)
                      ])
                    ], 512), [
                      [yc, w.configuration.isEditable]
                    ]),
                    v.value ? (S(), E(Z, { key: 1 }, [
                      V("div", a9, [
                        R($(U8), {
                          baseServerURL: w.configuration.baseServerURL,
                          layout: w.configuration.layout === "classic" ? "accordion" : "default",
                          parsedSpec: w.parsedSpec,
                          proxy: w.configuration.proxy
                        }, ua({
                          start: P(() => [
                            te(w.$slots, "content-start", cr(ur(_.value)), void 0, !0)
                          ]),
                          end: P(() => [
                            te(w.$slots, "content-end", cr(ur(_.value)), void 0, !0)
                          ]),
                          _: 2
                        }, [
                          (L = w.configuration) != null && L.isEditable ? {
                            name: "empty-state",
                            fn: P(() => {
                              var ae;
                              return [
                                R(t9, {
                                  theme: ((ae = w.configuration) == null ? void 0 : ae.theme) || "default",
                                  onChangeTheme: x[0] || (x[0] = (me) => w.$emit("changeTheme", me)),
                                  onLinkSwaggerFile: x[1] || (x[1] = (me) => w.$emit("linkSwaggerFile")),
                                  onLoadSwaggerFile: x[2] || (x[2] = (me) => w.$emit("loadSwaggerFile")),
                                  onUpdateContent: x[3] || (x[3] = (me) => w.$emit("updateContent", me))
                                }, null, 8, ["theme"])
                              ];
                            }),
                            key: "0"
                          } : void 0
                        ]), 1032, ["baseServerURL", "layout", "parsedSpec", "proxy"])
                      ]),
                      w.$slots.footer ? (S(), E("div", l9, [
                        te(w.$slots, "footer", cr(ur(_.value)), void 0, !0)
                      ])) : z("", !0)
                    ], 64)) : z("", !0),
                    R(yj, {
                      parsedSpec: w.parsedSpec,
                      proxyUrl: (ue = w.configuration) == null ? void 0 : ue.proxy
                    }, {
                      "sidebar-start": P(() => [
                        te(w.$slots, "sidebar-start", cr(ur(_.value)), void 0, !0)
                      ]),
                      "sidebar-end": P(() => [
                        te(w.$slots, "sidebar-end", cr(ur(_.value)), void 0, !0)
                      ]),
                      _: 3
                    }, 8, ["parsedSpec", "proxyUrl"])
                  ], 38)
                ];
              }),
              _: 2
            }, 1024)
          ]),
          _: 3
        }),
        R($(BC))
      ], 64);
    };
  }
}), $w = /* @__PURE__ */ ne(c9, [["__scopeId", "data-v-34f73cf2"]]), u9 = {}, d9 = { class: "references-classic-header-container" }, h9 = { class: "references-classic-header" };
function f9(r, e) {
  return S(), E("div", d9, [
    V("div", h9, [
      te(r.$slots, "default", {}, void 0, !0),
      te(r.$slots, "dark-mode-toggle", {}, void 0, !0)
    ])
  ]);
}
const p9 = /* @__PURE__ */ ne(u9, [["render", f9], ["__scopeId", "data-v-a860f78f"]]), m9 = (r) => (It("data-v-559a0a79"), r = r(), Nt(), r), g9 = { class: "darklight-reference" }, y9 = { key: 0 }, b9 = { key: 1 }, v9 = /* @__PURE__ */ m9(() => /* @__PURE__ */ V("a", {
  class: "darklight-reference-promo",
  href: "https://www.scalar.com",
  target: "_blank"
}, " Powered by scalar.com ", -1)), w9 = /* @__PURE__ */ Q({
  __name: "DarkModeToggle",
  props: {
    isDarkMode: { type: Boolean }
  },
  emits: ["toggleDarkMode"],
  setup(r) {
    return (e, t) => (S(), E("div", g9, [
      V("button", {
        class: "darklight",
        type: "button",
        onClick: t[0] || (t[0] = (s) => e.$emit("toggleDarkMode"))
      }, [
        R($(Ze), { icon: "LightDarkModeToggle" }),
        e.isDarkMode ? (S(), E("span", y9, "Light Mode")) : (S(), E("span", b9, "Dark Mode"))
      ]),
      v9
    ]));
  }
}), k9 = /* @__PURE__ */ ne(w9, [["__scopeId", "data-v-559a0a79"]]), S9 = /* @__PURE__ */ Q({
  __name: "DarkModeIconToggle",
  props: {
    isDarkMode: { type: Boolean }
  },
  emits: ["toggleDarkMode"],
  setup(r) {
    return (e, t) => (S(), E("button", {
      class: "darklight",
      type: "button",
      onClick: t[0] || (t[0] = (s) => e.$emit("toggleDarkMode"))
    }, [
      R($(Ze), {
        icon: e.isDarkMode ? "DarkMode" : "LightMode"
      }, null, 8, ["icon"]),
      R(mw, null, {
        default: P(() => [
          J(" Switch to " + ee(e.isDarkMode ? "Light" : "Dark") + " Mode ", 1)
        ]),
        _: 1
      })
    ]));
  }
}), $9 = /* @__PURE__ */ ne(S9, [["__scopeId", "data-v-8f61ca56"]]);
function _9(r, e) {
  let t = r;
  const s = e.required && e.required.includes(r);
  return t += s ? " REQUIRED " : " optional ", e.properties[r] && (t += e.properties[r].type, e.properties[r].description && (t += " " + e.properties[r].description)), t;
}
function x9(r) {
  var s;
  const e = ["Body"], t = (s = r == null ? void 0 : r.schema) == null ? void 0 : s.properties;
  return t && Object.keys(t).forEach((n) => {
    if (!r.schema)
      return;
    e.push(_9(n, r.schema));
    const o = t[n];
    o.type === "object" && !!o.properties && o.properties && Object.keys(o.properties).forEach((a) => {
      var l, c;
      e.push(`${a} ${(c = (l = o.properties) == null ? void 0 : l[a]) == null ? void 0 : c.type}`);
    });
  }), e;
}
function C9(r) {
  var e, t, s;
  try {
    const n = (s = (t = (e = r == null ? void 0 : r.information) == null ? void 0 : e.requestBody) == null ? void 0 : t.content) == null ? void 0 : s["application/json"];
    if (!n)
      throw new Error("Body not found");
    return x9(n);
  } catch {
    return !1;
  }
}
const A9 = (r) => (It("data-v-3445e6c6"), r = r(), Nt(), r), E9 = /* @__PURE__ */ A9(() => /* @__PURE__ */ V("div", { class: "ref-search-meta" }, [
  /* @__PURE__ */ V("span", null, "↑↓ Navigate"),
  /* @__PURE__ */ V("span", null, "⏎ Select")
], -1)), O9 = /* @__PURE__ */ Q({
  __name: "SearchModal",
  props: {
    parsedSpec: {},
    modalState: {}
  },
  setup(r) {
    const e = r, t = rd(e, "parsedSpec"), s = {
      heading: "DocsPage",
      model: "JsonObject",
      req: "Terminal",
      tag: "CodeFolder",
      webhook: "Terminal"
    }, n = D0(), o = ie([]), i = ie([]), a = ie(0), l = ie(""), c = ie(null), u = new Ek(o.value, {
      keys: ["title", "description", "body"]
    }), d = () => {
      a.value = 0, i.value = u.search(l.value);
    }, h = oe(
      () => k.value[a.value]
    ), { getHeadingId: f, getWebhookId: m, getModelId: g, getOperationId: p, getTagId: y } = Ct();
    Le(
      () => e.modalState.open,
      (T) => {
        T && (l.value = "", a.value = 0, i.value = []);
      }
    );
    const { setCollapsedSidebarItem: b, hideModels: v } = xr();
    Le(
      t.value,
      async () => {
        var ae, me, Pe, De, Be;
        if (o.value = [], !((me = (ae = e.parsedSpec) == null ? void 0 : ae.tags) != null && me.length) && !((Pe = e.parsedSpec) != null && Pe.webhooks)) {
          u.setCollection([]);
          return;
        }
        const T = [], j = await rc(
          ((De = e.parsedSpec.info) == null ? void 0 : De.description) ?? ""
        );
        j.length && (j.forEach((ve) => {
          T.push({
            type: "heading",
            title: `Info > ${ve.value}`,
            description: "",
            href: `#${f(ve)}`,
            tag: ve.slug,
            body: ""
          });
        }), o.value = o.value.concat(T)), (Be = e.parsedSpec.tags) == null || Be.forEach((ve) => {
          const Y = {
            title: ve["x-displayName"] ?? ve.name,
            href: `#${y(ve)}`,
            description: ve.description,
            type: "tag",
            tag: ve.name,
            body: ""
          };
          o.value.push(Y), ve.operations && ve.operations.forEach((M) => {
            const { parameterMap: q } = xp({ operation: M }), F = C9(M) || q.value;
            let C = null;
            typeof F != "boolean" && (C = F);
            const I = {
              type: "req",
              title: M.name ?? M.path,
              href: `#${p(M, ve)}`,
              operationId: M.operationId,
              description: M.description ?? "",
              httpVerb: M.httpVerb,
              path: M.path,
              tag: ve.name,
              operation: M
            };
            C && (I.body = C), o.value.push(I);
          });
        });
        const B = e.parsedSpec.webhooks, W = [];
        B && Object.keys(B).forEach((ve) => {
          Object.keys(
            B[ve]
          ).forEach((M) => {
            var q;
            W.push({
              type: "webhook",
              title: `Webhook: ${(q = B[ve][M]) == null ? void 0 : q.name}`,
              href: `#${m(ve, M)}`,
              description: ve,
              httpVerb: M,
              tag: ve,
              body: ""
            });
          }), o.value = o.value.concat(W);
        });
        const L = v.value ? {} : Fr(e.parsedSpec), ue = [];
        L && (Object.keys(L).forEach((ve) => {
          ue.push({
            type: "model",
            title: "Model",
            href: `#${g(ve)}`,
            description: L[ve].title ?? ve,
            tag: ve,
            body: ""
          });
        }), o.value = o.value.concat(ue)), u.setCollection(o.value);
      },
      { immediate: !0 }
    ), bl(n.enter, () => {
      e.modalState.open && window && (w(h.value), window.location.hash = h.value.item.href, e.modalState.hide());
    }), bl(n.ArrowDown, () => {
      var T;
      e.modalState.open && window && (a.value < k.value.length - 1 ? a.value++ : a.value = 0, (T = document.getElementById(h.value.item.href)) == null || T.scrollIntoView({
        behavior: "smooth",
        block: "center"
      }));
    }), bl(n.ArrowUp, () => {
      var T;
      e.modalState.open && window && (a.value > 0 ? a.value-- : a.value = k.value.length - 1, (T = document.getElementById(h.value.item.href)) == null || T.scrollIntoView({
        behavior: "smooth",
        block: "center"
      }));
    });
    const k = oe(
      () => l.value.length === 0 ? o.value.map((T) => ({
        item: T
      })) : i.value
    ), _ = /#(tag\/[^/]*)/, w = (T) => {
      let j = "models";
      const B = T.item.href.match(_);
      B != null && B.length && B.length > 1 && (j = B[1]), b(j, !0), e.modalState.hide();
    };
    function x(T) {
      const j = new URL(window.location.href);
      return j.hash = T, j.toString();
    }
    return (T, j) => (S(), U($(Ax), {
      state: T.modalState,
      variant: "search"
    }, {
      default: P(() => [
        V("div", {
          ref_key: "searchModalRef",
          ref: c,
          class: "ref-search-container"
        }, [
          R($(TE), {
            modelValue: l.value,
            "onUpdate:modelValue": j[0] || (j[0] = (B) => l.value = B),
            onInput: d
          }, null, 8, ["modelValue"])
        ], 512),
        R($(IE), {
          class: "ref-search-results custom-scroll",
          noResults: !k.value.length
        }, {
          query: P(() => [
            J(ee(l.value), 1)
          ]),
          default: P(() => [
            (S(!0), E(Z, null, we(k.value, (B, W) => (S(), U($(FE), {
              id: B.item.href,
              key: B.refIndex,
              active: a.value === W,
              href: x(B.item.href),
              icon: s[B.item.type],
              onClick: (L) => w(B),
              onFocus: (L) => a.value = W
            }, ua({
              default: P(() => [
                J(ee(B.item.title) + " ", 1)
              ]),
              _: 2
            }, [
              (B.item.httpVerb || B.item.path) && B.item.path !== B.item.title ? {
                name: "description",
                fn: P(() => [
                  J(ee(B.item.path), 1)
                ]),
                key: "0"
              } : B.item.description ? {
                name: "description",
                fn: P(() => [
                  J(ee(B.item.description), 1)
                ]),
                key: "1"
              } : void 0,
              B.item.type === "req" ? {
                name: "addon",
                fn: P(() => [
                  R(lw, {
                    method: B.item.httpVerb ?? "get"
                  }, null, 8, ["method"])
                ]),
                key: "2"
              } : void 0
            ]), 1032, ["id", "active", "href", "icon", "onClick", "onFocus"]))), 128))
          ]),
          _: 1
        }, 8, ["noResults"]),
        E9
      ]),
      _: 1
    }, 8, ["state"]));
  }
}), T9 = /* @__PURE__ */ ne(O9, [["__scopeId", "data-v-3445e6c6"]]), P9 = (r) => (It("data-v-edb0a931"), r = r(), Nt(), r), I9 = { class: "sidebar-search-input" }, N9 = /* @__PURE__ */ P9(() => /* @__PURE__ */ V("span", { class: "sidebar-search-placeholder" }, "Search", -1)), M9 = { class: "sidebar-search-shortcut" }, D9 = { class: "sidebar-search-key" }, R9 = /* @__PURE__ */ Q({
  __name: "SearchButton",
  props: {
    spec: {},
    searchHotKey: { default: "k" }
  },
  setup(r) {
    const e = r, t = Ex(), s = D0({
      passive: !1,
      onEventFired(n) {
        !Nu() && n.ctrlKey && n.key === e.searchHotKey && (n.preventDefault(), n.stopPropagation());
      }
    });
    return bl(
      s[`${Nu() ? "meta" : "control"}_${e.searchHotKey}`],
      () => t.open ? t.hide() : t.show()
    ), (n, o) => (S(), E(Z, null, [
      V("button", {
        class: xe(["sidebar-search", n.$attrs.class]),
        type: "button",
        onClick: o[0] || (o[0] = //@ts-ignore
        (...i) => $(t).show && $(t).show(...i))
      }, [
        R($(Ze), {
          class: "search-icon",
          icon: "Search",
          size: "sm"
        }),
        V("div", I9, [
          N9,
          V("span", M9, [
            V("span", D9, ee($(Nu)() ? "⌘" : "⌃") + ee(n.searchHotKey), 1)
          ])
        ])
      ], 2),
      R(T9, {
        modalState: $(t),
        parsedSpec: n.spec
      }, null, 8, ["modalState", "parsedSpec"])
    ], 64));
  }
}), _w = /* @__PURE__ */ ne(R9, [["__scopeId", "data-v-edb0a931"]]), j9 = /* @__PURE__ */ Q({
  __name: "ClassicLayout",
  props: {
    configuration: {},
    parsedSpec: {},
    rawSpec: {},
    isDark: { type: Boolean }
  },
  emits: ["toggleDarkMode"],
  setup(r) {
    const e = r, t = oe(() => ({ ...e.configuration, showSidebar: !1 }));
    return (s, n) => (S(), U($w, {
      configuration: t.value,
      parsedSpec: s.parsedSpec,
      rawSpec: s.rawSpec
    }, {
      "content-start": P(({ spec: o }) => [
        R(p9, null, {
          "dark-mode-toggle": P(() => [
            R($($9), {
              isDarkMode: s.isDark,
              onToggleDarkMode: n[0] || (n[0] = (i) => s.$emit("toggleDarkMode"))
            }, null, 8, ["isDarkMode"])
          ]),
          default: P(() => [
            R(_w, {
              class: "t-doc__sidebar",
              searchHotKey: t.value.searchHotKey,
              spec: o
            }, null, 8, ["searchHotKey", "spec"])
          ]),
          _: 2
        }, 1024)
      ]),
      "content-end": P(() => [
        te(s.$slots, "footer")
      ]),
      _: 3
    }, 8, ["configuration", "parsedSpec", "rawSpec"]));
  }
}), L9 = { class: "references-mobile-header t-doc__header" }, B9 = { class: "references-mobile-breadcrumbs" }, F9 = { class: "references-mobile-header-actions" }, V9 = /* @__PURE__ */ Q({
  __name: "MobileHeader",
  props: {
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(r) {
    const { breadcrumb: e } = xr();
    return (t, s) => (S(), E("div", L9, [
      R($(va), {
        icon: t.open ? "Close" : "Menu",
        label: t.open ? "Close Menu" : "Open Menu",
        size: "md",
        onClick: s[0] || (s[0] = (n) => t.$emit("update:open", !t.open))
      }, null, 8, ["icon", "label"]),
      V("span", B9, ee($(e)), 1),
      V("div", F9, [
        te(t.$slots, "actions", {}, void 0, !0)
      ])
    ]));
  }
}), U9 = /* @__PURE__ */ ne(V9, [["__scopeId", "data-v-0242e3de"]]), z9 = { class: "scalar-api-references-standalone-search" }, q9 = /* @__PURE__ */ Q({
  __name: "ModernLayout",
  props: {
    configuration: {},
    parsedSpec: {},
    rawSpec: {},
    isDark: { type: Boolean }
  },
  emits: ["toggleDarkMode"],
  setup(r) {
    const e = r, t = Th("(max-width: 1000px)"), { isSidebarOpen: s } = xr();
    Le(t, (o, i) => {
      o && !i && (s.value = !1);
    });
    const { hash: n } = Ct();
    return Le(n, (o, i) => {
      o && o !== i && (s.value = !1);
    }), (o, i) => (S(), U($w, {
      class: xe({
        "scalar-api-references-standalone-mobile": o.configuration.showSidebar
      }),
      configuration: o.configuration,
      parsedSpec: o.parsedSpec,
      rawSpec: o.rawSpec
    }, {
      header: P(() => [
        e.configuration.showSidebar ? (S(), U(U9, {
          key: 0,
          open: $(s),
          "onUpdate:open": i[0] || (i[0] = (a) => Ww(s) ? s.value = a : null)
        }, null, 8, ["open"])) : z("", !0)
      ]),
      "sidebar-start": P(({ spec: a }) => {
        var l;
        return [
          V("div", z9, [
            R(_w, {
              searchHotKey: (l = e.configuration) == null ? void 0 : l.searchHotKey,
              spec: a
            }, null, 8, ["searchHotKey", "spec"])
          ])
        ];
      }),
      "sidebar-end": P(() => [
        R($(k9), {
          isDarkMode: o.isDark,
          onToggleDarkMode: i[1] || (i[1] = (a) => o.$emit("toggleDarkMode"))
        }, null, 8, ["isDarkMode"])
      ]),
      "content-end": P(() => [
        te(o.$slots, "footer", {}, void 0, !0)
      ]),
      _: 3
    }, 8, ["class", "configuration", "parsedSpec", "rawSpec"]));
  }
}), H9 = /* @__PURE__ */ ne(q9, [["__scopeId", "data-v-333fecad"]]), K9 = {
  modern: H9,
  classic: j9
}, W9 = /* @__PURE__ */ Q({
  __name: "ApiReference",
  props: {
    configuration: {}
  },
  emits: ["updateContent"],
  setup(r) {
    var d, h;
    const e = r, { toggleDarkMode: t, isDark: s } = M3(
      (d = e.configuration) == null ? void 0 : d.darkMode
    );
    Le(
      () => {
        var f;
        return (f = e.configuration) == null ? void 0 : f.darkMode;
      },
      (f) => {
        f !== s.value && t();
      }
    );
    const n = oe(() => {
      var f, m;
      if ((f = e.configuration) != null && f.customCss)
        return Xk((m = e.configuration) == null ? void 0 : m.customCss);
    });
    Le(n, () => console.log(n.value));
    const o = oe(() => {
      var f;
      return {
        spec: {
          content: void 0,
          url: void 0,
          ...(f = e.configuration) == null ? void 0 : f.spec
        },
        proxy: void 0,
        theme: "default",
        showSidebar: !0,
        isEditable: !1,
        ...e.configuration,
        customCss: n.value
      };
    });
    (h = o.value) != null && h.metaData && (gk(), yk(o.value.metaData));
    function i(f, m) {
      Le(
        () => {
          var g;
          return (g = o.value) == null ? void 0 : g[f];
        },
        (g) => {
          typeof g < "u" && m(g);
        },
        { immediate: !0 }
      );
    }
    const { setAuthentication: a } = ha();
    i("authentication", a);
    const { setExcludedClients: l } = Ia();
    i("hiddenClients", l);
    const { parsedSpec: c, rawSpec: u } = H3({
      proxy: rd(() => {
        var f;
        return ((f = e.configuration) == null ? void 0 : f.proxy) || "";
      }),
      specConfig: rd(() => {
        var f;
        return ((f = e.configuration) == null ? void 0 : f.spec) || {};
      })
    });
    return (f, m) => {
      var g, p;
      return S(), E(Z, null, [
        (g = o.value) != null && g.customCss ? (S(), U(br("style"), { key: 0 }, {
          default: P(() => [
            J(ee(o.value.customCss), 1)
          ]),
          _: 1
        })) : z("", !0),
        (S(), U(br($(K9)[((p = o.value) == null ? void 0 : p.layout) || "modern"]), {
          configuration: o.value,
          isDark: $(s),
          parsedSpec: $(c),
          rawSpec: $(u),
          onToggleDarkMode: m[0] || (m[0] = () => $(t)()),
          onUpdateContent: m[1] || (m[1] = (y) => f.$emit("updateContent", y))
        }, {
          footer: P(() => [
            te(f.$slots, "footer")
          ]),
          _: 3
        }, 40, ["configuration", "isDark", "parsedSpec", "rawSpec"]))
      ], 64);
    };
  }
});
function FF(r, e, t = !0) {
  const s = $r(e), n = Gw(W9, { configuration: s });
  function o(i = r) {
    if (!i) {
      console.warn(
        "Invalid HTML element provided. Cannot mount Scalar References"
      );
      return;
    }
    n.mount(i);
  }
  return t && o(), {
    /** Update the configuration for a mounted reference */
    updateConfig(i, a = !0) {
      a ? Object.assign(s, i) : pf(s, i);
    },
    updateSpec(i) {
      s.spec = i;
    },
    /** Mount the references to a given element */
    mount: o,
    /** Unmount the app from an element */
    unmount: () => n.unmount()
  };
}
export {
  cx as $,
  Io as A,
  tx as B,
  Qr as C,
  ct as D,
  Ee as E,
  pe as F,
  AF as G,
  OF as H,
  Xe as I,
  TF as J,
  kF as K,
  _F as L,
  zt as M,
  vb as N,
  SF as O,
  Hh as P,
  CF as Q,
  go as R,
  zs as S,
  je as T,
  xF as U,
  wr as V,
  fa as W,
  G_ as X,
  W_ as Y,
  bx as Z,
  bF as _,
  Ii as a,
  lo as a$,
  NF as a0,
  EF as a1,
  IF as a2,
  wF as a3,
  MF as a4,
  PF as a5,
  ne as a6,
  Qp as a7,
  Db as a8,
  OS as a9,
  FS as aA,
  XS as aB,
  To as aC,
  sy as aD,
  ZS as aE,
  e2 as aF,
  yj as aG,
  W9 as aH,
  $w as aI,
  H9 as aJ,
  U8 as aK,
  T9 as aL,
  _w as aM,
  t9 as aN,
  FF as aO,
  H3 as aP,
  k9 as aQ,
  $9 as aR,
  cw as aS,
  uu as aT,
  du as aU,
  Xo as aV,
  Tp as aW,
  b4 as aX,
  w4 as aY,
  wj as aZ,
  Ia as a_,
  ha as aa,
  ty as ab,
  Ox as ac,
  jb as ad,
  Mx as ae,
  YS as af,
  Nu as ag,
  Ex as ah,
  Ax as ai,
  DF as aj,
  lO as ak,
  ZE as al,
  Tg as am,
  Ze as an,
  RS as ao,
  As as ap,
  Fk as aq,
  Po as ar,
  zS as as,
  Tx as at,
  Px as au,
  Rb as av,
  Nx as aw,
  Xl as ax,
  Ih as ay,
  LS as az,
  de as b,
  cO as b0,
  iv as b1,
  rc as b2,
  ff as b3,
  Fr as b4,
  jF as b5,
  av as b6,
  hO as b7,
  fO as b8,
  pO as b9,
  LF as ba,
  BF as bb,
  pf as bc,
  Qd as bd,
  T3 as be,
  $p as bf,
  tw as bg,
  hc as bh,
  hs as bi,
  rw as bj,
  I3 as bk,
  N3 as bl,
  cd as c,
  Kh as d,
  g_ as e,
  pt as f,
  vF as g,
  Re as h,
  gF as i,
  $t as j,
  X$ as k,
  Ns as l,
  Ab as m,
  Je as n,
  Sy as o,
  Z_ as p,
  Q_ as q,
  T_ as r,
  kn as s,
  Bt as t,
  $_ as u,
  Te as v,
  ut as w,
  U_ as x,
  G as y,
  Hd as z
};
