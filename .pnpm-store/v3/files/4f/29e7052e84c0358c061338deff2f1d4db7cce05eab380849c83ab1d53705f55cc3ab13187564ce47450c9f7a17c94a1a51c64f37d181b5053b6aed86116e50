import { parse, stringify } from 'yaml';
import { AxiosHeaders } from 'axios';

const createHash = (input) => {
  let chr = 0;
  let hash = 0;
  let i = 0;
  if (!input?.length)
    return hash;
  for (i = 0; i < input.length; i++) {
    chr = input.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash;
};

const defaultStateFactory = () => ({});
const ssrState = typeof window !== "undefined" ? window.__SCALAR__ ?? defaultStateFactory() : defaultStateFactory();

const yaml = {
  /** Parse and throw if the return value is not an object */
  parse: (val) => {
    const yamlObject = parse(val);
    if (typeof yamlObject !== "object")
      throw Error("Invalid YAML object");
    return yamlObject;
  },
  /** Parse and return a fallback on failure */
  parseSafe(val, fallback) {
    try {
      return yaml.parse(val);
    } catch (err) {
      return typeof fallback === "function" ? fallback(err) : fallback;
    }
  },
  stringify
};
const json = {
  /** Parse and throw if the return value is not an object */
  parse: (val) => {
    const jsonObject = JSON.parse(val);
    if (typeof jsonObject !== "object")
      throw Error("Invalid JSON object");
    return jsonObject;
  },
  /** Parse and return a fallback on failure */
  parseSafe(val, fallback) {
    try {
      return json.parse(val);
    } catch (err) {
      return typeof fallback === "function" ? fallback(err) : fallback;
    }
  },
  stringify: (val) => JSON.stringify(val)
};
const isJsonString = (value) => {
  if (typeof value !== "string")
    return false;
  return !!json.parseSafe(value, false);
};
const transformToJson = (value) => {
  return JSON.stringify(json.parseSafe(value, yaml.parseSafe(value, value)));
};
function formatJsonOrYamlString(value) {
  const trimmed = value.trim();
  if (trimmed[0] !== "{")
    return value;
  try {
    return JSON.stringify(JSON.parse(value), null, 2);
  } catch {
    return value;
  }
}
const parseJsonOrYaml = (value) => {
  if (typeof value !== "string")
    return value;
  const jsonObject = json.parseSafe(value, null);
  if (jsonObject)
    return jsonObject;
  if (value.length > 0 && ["{", "["].includes(value[0])) {
    throw Error("Invalid JSON or YAML");
  }
  return yaml.parseSafe(value, (err) => {
    throw Error(err);
  });
};

const OLD_PROXY_URL = "https://api.scalar.com/request-proxy";
const NEW_PROXY_URL = "https://proxy.scalar.com";
function redirectToProxy(proxy, url) {
  return `${proxy}?scalar_url=${encodeURI(url)}`;
}
async function fetchSpecFromUrl(url, proxy) {
  if (proxy === OLD_PROXY_URL) {
    proxy = NEW_PROXY_URL;
  }
  const response = await fetch(proxy ? redirectToProxy(proxy, url) : url);
  if (response.status !== 200) {
    console.error(
      `[fetchSpecFromUrl] Failed to fetch the specification at ${url} (Status: ${response.status})`
    );
    if (!proxy) {
      console.warn(
        `[fetchSpecFromUrl] Tried to fetch the specification (url: ${url}) without a proxy. Are the CORS headers configured to allow cross-domain requests? https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS`
      );
    }
  }
  return formatJsonOrYamlString(await response.text());
}

function guessFromFormat(schema, fallback = "") {
  const exampleValues = {
    // 'date-time': '1970-01-01T00:00:00Z',
    "date-time": (/* @__PURE__ */ new Date()).toISOString(),
    // 'date': '1970-01-01',
    "date": (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
    "email": "hello@example.com",
    "hostname": "example.com",
    // https://tools.ietf.org/html/rfc6531#section-3.3
    "idn-email": "jane.doe@example.com",
    // https://tools.ietf.org/html/rfc5890#section-2.3.2.3
    "idn-hostname": "example.com",
    "ipv4": "127.0.0.1",
    "ipv6": "51d4:7fab:bfbf:b7d7:b2cb:d4b4:3dad:d998",
    "iri-reference": "/entitiy/1",
    // https://tools.ietf.org/html/rfc3987
    "iri": "https://example.com/entity/123",
    "json-pointer": "/nested/objects",
    "password": "super-secret",
    "regex": "/[a-z]/",
    // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01
    "relative-json-pointer": "1/nested/objects",
    // full-time in https://tools.ietf.org/html/rfc3339#section-5.6
    // 'time': '00:00:00Z',
    "time": (/* @__PURE__ */ new Date()).toISOString().split("T")[1].split(".")[0],
    // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1
    "uri-reference": "../folder",
    "uri-template": "https://example.com/{id}",
    "uri": "https://example.com",
    "uuid": "123e4567-e89b-12d3-a456-426614174000"
  };
  return exampleValues[schema.format] ?? fallback;
}
const getExampleFromSchema = (schema, options, level = 0, parentSchema, name) => {
  if (level > 5) {
    return null;
  }
  const makeUpRandomData = !!options?.emptyString;
  if (options?.mode === "write" && schema.readOnly) {
    return void 0;
  }
  if (options?.mode === "read" && schema.writeOnly) {
    return void 0;
  }
  if (schema["x-variable"]) {
    const value = options?.variables?.[schema["x-variable"]];
    if (value !== void 0) {
      if (schema.type === "number" || schema.type === "integer") {
        return parseInt(value, 10);
      }
      return value;
    }
  }
  if (Array.isArray(schema.examples) && schema.examples.length > 0) {
    return schema.examples[0];
  }
  if (schema.example !== void 0) {
    return schema.example;
  }
  if (schema.default !== void 0) {
    return schema.default;
  }
  if (schema.enum !== void 0) {
    return schema.enum[0];
  }
  const isObjectOrArray = schema.type === "object" || schema.type === "array";
  if (!isObjectOrArray && options?.omitEmptyAndOptionalProperties === true) {
    const isRequired = schema.required === true || parentSchema?.required === true || parentSchema?.required?.includes(name ?? schema.name);
    if (!isRequired) {
      return void 0;
    }
  }
  if (schema.type === "object" || schema.properties !== void 0) {
    const response = {};
    if (schema.properties !== void 0) {
      Object.keys(schema.properties).forEach((propertyName) => {
        const property = schema.properties[propertyName];
        const propertyXmlTagName = options?.xml ? property.xml?.name : void 0;
        response[propertyXmlTagName ?? propertyName] = getExampleFromSchema(
          property,
          options,
          level + 1,
          schema,
          propertyName
        );
        if (typeof response[propertyXmlTagName ?? propertyName] === "undefined") {
          delete response[propertyXmlTagName ?? propertyName];
        }
      });
    }
    if (schema.anyOf !== void 0) {
      Object.assign(
        response,
        getExampleFromSchema(schema.anyOf[0]),
        options,
        level + 1
      );
    } else if (schema.oneOf !== void 0) {
      Object.assign(
        response,
        getExampleFromSchema(schema.oneOf[0]),
        options,
        level + 1
      );
    } else if (schema.allOf !== void 0) {
      Object.assign(
        response,
        ...schema.allOf.map(
          (item) => getExampleFromSchema(item, options, level + 1, schema)
        ).filter((item) => item !== void 0)
      );
    }
    if (schema.additionalProperties !== void 0 && schema.additionalProperties !== false) {
      const additionalSchema = getExampleFromSchema(
        schema.additionalProperties,
        options,
        level + 1
      );
      if (additionalSchema && typeof additionalSchema === "object" && !Array.isArray(additionalSchema)) {
        return {
          ...response,
          ...getExampleFromSchema(
            schema.additionalProperties,
            options,
            level + 1
          )
        };
      }
      if (additionalSchema === null) {
        return null;
      }
      const additionalProperties = getExampleFromSchema(
        schema.additionalProperties,
        {
          ...options,
          // Letâ€™s just add the additionalProperties, even if they are optional.
          omitEmptyAndOptionalProperties: false
        },
        level + 1
      );
      return {
        ...response,
        ...additionalProperties === void 0 ? {} : { "{{key}}": additionalProperties }
      };
    }
    return response;
  }
  if (schema.type === "array" || schema.items !== void 0) {
    const itemsXmlTagName = schema?.items?.xml?.name;
    const wrapItems = !!(options?.xml && schema.xml?.wrapped && itemsXmlTagName);
    if (schema.example !== void 0) {
      return wrapItems ? { [itemsXmlTagName]: schema.example } : schema.example;
    }
    if (schema.items) {
      const rules = ["anyOf", "oneOf", "allOf"];
      for (const rule of rules) {
        if (!schema.items[rule]) {
          continue;
        }
        const schemas = ["anyOf", "oneOf"].includes(rule) ? (
          // Use the first item only
          schema.items[rule].slice(0, 1)
        ) : (
          // Use all items
          schema.items[rule]
        );
        const exampleFromRule = schemas.map(
          (item) => getExampleFromSchema(item, options, level + 1, schema)
        ).filter((item) => item !== void 0);
        return wrapItems ? [{ [itemsXmlTagName]: exampleFromRule }] : exampleFromRule;
      }
    }
    if (schema.items?.type) {
      const exampleFromSchema = getExampleFromSchema(
        schema.items,
        options,
        level + 1
      );
      return wrapItems ? [{ [itemsXmlTagName]: exampleFromSchema }] : [exampleFromSchema];
    }
    return [];
  }
  const exampleValues = {
    string: makeUpRandomData ? guessFromFormat(schema, options?.emptyString) : "",
    boolean: true,
    integer: schema.min ?? 1,
    number: schema.min ?? 1,
    array: []
  };
  if (schema.type !== void 0 && exampleValues[schema.type] !== void 0) {
    return exampleValues[schema.type];
  }
  if (Array.isArray(schema.oneOf) && schema.oneOf.length > 0) {
    const firstOneOfItem = schema.oneOf[0];
    return getExampleFromSchema(firstOneOfItem, options, level + 1);
  }
  if (Array.isArray(schema.allOf)) {
    let example = null;
    schema.allOf.forEach((allOfItem) => {
      const newExample = getExampleFromSchema(allOfItem, options, level + 1);
      example = typeof newExample === "object" && typeof example === "object" ? {
        ...example ?? {},
        ...newExample
      } : Array.isArray(newExample) && Array.isArray(example) ? [...example ?? {}, ...newExample] : newExample;
    });
    return example;
  }
  if (Array.isArray(schema.type)) {
    if (schema.type.includes("null")) {
      return null;
    }
    const exampleValue = exampleValues[schema.type[0]];
    if (exampleValue !== void 0) {
      return exampleValue;
    }
  }
  console.warn(`[getExampleFromSchema] Unknown property type "${schema.type}".`);
  return null;
};

const getHarRequest = (...requests) => {
  let mergedRequests = {
    httpVersion: "1.1",
    method: "GET",
    url: "",
    path: "",
    headers: [],
    headersSize: -1,
    queryString: [],
    cookies: [],
    bodySize: -1
  };
  requests.forEach((request) => {
    mergedRequests = {
      ...mergedRequests,
      ...request,
      headers: [...mergedRequests.headers, ...request.headers ?? []],
      queryString: [
        ...mergedRequests.queryString,
        ...request.queryString ?? []
      ],
      cookies: [...mergedRequests.cookies, ...request.cookies ?? []]
    };
  });
  const headersObj = mergedRequests.headers.reduce(
    (obj, { name, value }) => {
      obj[name] = value;
      return obj;
    },
    {}
  );
  const normalizedAxiosHeaders = AxiosHeaders.from(headersObj).normalize(true);
  mergedRequests.headers = Object.entries(normalizedAxiosHeaders).map(
    ([name, value]) => ({ name, value })
  );
  const { path, ...result } = mergedRequests;
  if (path) {
    return {
      ...result,
      url: `${mergedRequests.url}${path}`
    };
  }
  return result;
};

function getParametersFromOperation(operation, where, requiredOnly = true) {
  const parameters = [
    ...operation.pathParameters || [],
    ...operation.information?.parameters || []
  ];
  const params = parameters.filter((parameter) => parameter.in === where).filter(
    (parameter) => requiredOnly && parameter.required || !requiredOnly
  ).map((parameter) => ({
    name: parameter.name,
    description: parameter.description ?? null,
    value: parameter.example ? parameter.example : parameter.schema ? getExampleFromSchema(parameter.schema, { mode: "write" }) : "",
    required: parameter.required ?? false,
    enabled: parameter.required ?? false
  }));
  return params.sort((a, b) => {
    if (a.required && !b.required) {
      return -1;
    } else if (!a.required && b.required) {
      return 1;
    }
    return 0;
  });
}

function json2xml(data, tab) {
  const toXml = function(value, key, indentation) {
    let xml2 = "";
    if (value instanceof Array) {
      for (let i = 0, n = value.length; i < n; i++) {
        xml2 += indentation + toXml(value[i], key, indentation + "	") + "\n";
      }
    } else if (typeof value == "object") {
      let hasChild = false;
      xml2 += indentation + "<" + key;
      for (const m in value) {
        if (m.charAt(0) == "@")
          xml2 += " " + m.substr(1) + '="' + value[m].toString() + '"';
        else
          hasChild = true;
      }
      xml2 += hasChild ? ">" : "/>";
      if (hasChild) {
        for (const m in value) {
          if (m == "#text")
            xml2 += value[m];
          else if (m == "#cdata")
            xml2 += "<![CDATA[" + value[m] + "]]>";
          else if (m.charAt(0) != "@")
            xml2 += toXml(value[m], m, indentation + "	");
        }
        xml2 += (xml2.charAt(xml2.length - 1) == "\n" ? indentation : "") + "</" + key + ">";
      }
    } else {
      xml2 += indentation + "<" + key + ">" + value.toString() + "</" + key + ">";
    }
    return xml2;
  };
  let xml = "";
  for (const key in data) {
    xml += toXml(data[key], key, "");
  }
  return tab ? xml.replace(/\t/g, tab) : xml.replace(/\t|\n/g, "");
}

function normalizeMimeType(contentType) {
  if (typeof contentType !== "string") {
    return void 0;
  }
  return contentType.replace(/;.*$/, "").replace(/\/.+\+/, "/").trim();
}

function normalizeMimeTypeObject(content) {
  if (!content) {
    return content;
  }
  const newContent = {
    ...content
  };
  Object.keys(newContent).forEach((key) => {
    const newKey = normalizeMimeType(key);
    if (newKey === void 0) {
      return;
    }
    newContent[newKey] = newContent[key];
    if (key !== newKey) {
      delete newContent[key];
    }
  });
  return newContent;
}

const prettyPrintJson = (value) => {
  try {
    if (typeof value === "string") {
      return JSON.stringify(JSON.parse(value), null, 2);
    } else {
      return JSON.stringify(value, null, 2);
    }
  } catch {
    console.log("[prettyPrintJson] Error parsing JSON", value);
    return value;
  }
};

function getRequestBodyFromOperation(operation, selectedExampleKey) {
  const mimeTypes = [
    "application/json",
    "application/octet-stream",
    "application/x-www-form-urlencoded",
    "application/xml",
    "multipart/form-data",
    "text/plain"
  ];
  const originalContent = operation.information?.requestBody?.content;
  const content = normalizeMimeTypeObject(originalContent);
  const mimeType = mimeTypes.find(
    (currentMimeType) => !!content?.[currentMimeType]
  );
  const examples = content?.["application/json"]?.examples;
  const selectedExample = (examples ?? {})?.[selectedExampleKey ?? Object.keys(examples ?? {})[0]];
  if (selectedExample) {
    return {
      postData: {
        mimeType: "application/json",
        text: prettyPrintJson(selectedExample?.value)
      }
    };
  }
  const bodyParameters = getParametersFromOperation(operation, "body", false);
  if (bodyParameters.length > 0) {
    return {
      postData: {
        mimeType: "application/json",
        text: prettyPrintJson(bodyParameters[0].value)
      }
    };
  }
  const formDataParameters = getParametersFromOperation(
    operation,
    "formData",
    false
  );
  if (formDataParameters.length > 0) {
    return {
      postData: {
        mimeType: "application/x-www-form-urlencoded",
        params: formDataParameters.map((parameter) => ({
          name: parameter.name,
          value: parameter.value
        }))
      }
    };
  }
  if (!mimeType) {
    return {
      postData: void 0
    };
  }
  const requestBodyObject = content?.[mimeType];
  const headers = [
    {
      name: "Content-Type",
      value: mimeType
    }
  ];
  const example = requestBodyObject?.example ? requestBodyObject?.example : void 0;
  if (mimeType === "application/json") {
    const exampleFromSchema = requestBodyObject?.schema ? getExampleFromSchema(requestBodyObject?.schema, {
      mode: "write",
      omitEmptyAndOptionalProperties: true
    }) : null;
    const body = example ?? exampleFromSchema;
    return {
      headers,
      postData: {
        mimeType,
        text: typeof body === "string" ? body : JSON.stringify(body, null, 2)
      }
    };
  }
  if (mimeType === "application/xml") {
    const exampleFromSchema = requestBodyObject?.schema ? getExampleFromSchema(requestBodyObject?.schema, {
      xml: true,
      mode: "write",
      omitEmptyAndOptionalProperties: true
    }) : null;
    return {
      headers,
      postData: {
        mimeType,
        text: example ?? json2xml(exampleFromSchema, "  ")
      }
    };
  }
  if (mimeType === "application/octet-stream") {
    return {
      headers,
      postData: {
        mimeType,
        text: "BINARY"
      }
    };
  }
  if (mimeType === "text/plain") {
    const exampleFromSchema = requestBodyObject?.schema ? getExampleFromSchema(requestBodyObject?.schema, {
      xml: true,
      mode: "write",
      omitEmptyAndOptionalProperties: true
    }) : null;
    return {
      headers,
      postData: {
        mimeType,
        text: example ?? exampleFromSchema ?? ""
      }
    };
  }
  if (mimeType === "application/x-www-form-urlencoded") {
    return {
      headers,
      postData: {
        mimeType
        // TODO: We have an object, but how do we get that kind of array from the object?
        // Donâ€™t forget to include nested properties â€¦ :|
        // params: [
        //   {
        //     name: 'foo',
        //     value: 'bar',
        //   },
        // ],
      }
    };
  }
  if (mimeType === "multipart/form-data") {
    return {
      headers,
      postData: {
        mimeType
        // TODO: We have an object, but how do we get that kind of array from the object?
        // Donâ€™t forget to include nested properties â€¦ :|
        // params: [
        //   {
        //     name: 'foo',
        //     value: 'bar',
        //   },
        // ],
      }
    };
  }
  return void 0;
}

const getRequestFromOperation = (operation, options, selectedExampleKey) => {
  let path = operation.path;
  if (options?.replaceVariables === true) {
    const pathVariables = path.match(/{(.*?)}/g);
    if (pathVariables) {
      pathVariables.forEach((variable) => {
        const variableName = variable.replace(/{|}/g, "");
        path = path.replace(variable, `__${variableName.toUpperCase()}__`);
      });
    }
  }
  const requestBody = getRequestBodyFromOperation(operation, selectedExampleKey);
  return {
    method: operation.httpVerb.toUpperCase(),
    path,
    headers: [
      ...getParametersFromOperation(operation, "header", options?.requiredOnly),
      ...requestBody?.headers ?? []
    ],
    // TODO: Sorry, something is off here and I donâ€™t get it.
    // @ts-ignore
    postData: requestBody?.postData,
    queryString: getParametersFromOperation(
      operation,
      "query",
      options?.requiredOnly
    ),
    cookies: getParametersFromOperation(
      operation,
      "cookie",
      options?.requiredOnly
    )
  };
};

const httpStatusCodes = {
  100: {
    name: "Continue",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100"
  },
  101: {
    name: "Switching Protocols",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101"
  },
  102: {
    name: "Processing",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/102"
  },
  103: {
    name: "Early Hints",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103"
  },
  200: {
    name: "OK",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200"
  },
  201: {
    name: "Created",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201"
  },
  202: {
    name: "Accepted",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202"
  },
  203: {
    name: "Non-Authoritative Information",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/203"
  },
  204: {
    name: "No Content",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204"
  },
  205: {
    name: "Reset Content",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/205"
  },
  206: {
    name: "Partial Content",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"
  },
  207: {
    name: "Multi-Status",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/207"
  },
  208: {
    name: "Already Reported",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/208"
  },
  226: {
    name: "IM Used",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/226"
  },
  300: {
    name: "Multiple Choices",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300"
  },
  301: {
    name: "Moved Permanently",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301"
  },
  302: {
    name: "Found",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302"
  },
  303: {
    name: "See Other",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303"
  },
  304: {
    name: "Not Modified",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304"
  },
  305: {
    name: "Use Proxy",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/305"
  },
  306: {
    name: "(Unused)",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/306"
  },
  307: {
    name: "Temporary Redirect",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307"
  },
  308: {
    name: "Permanent Redirect",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308"
  },
  400: {
    name: "Bad Request",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400"
  },
  401: {
    name: "Unauthorized",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401"
  },
  402: {
    name: "Payment Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402"
  },
  403: {
    name: "Forbidden",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403"
  },
  404: {
    name: "Not Found",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404"
  },
  405: {
    name: "Method Not Allowed",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405"
  },
  406: {
    name: "Not Acceptable",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/406"
  },
  407: {
    name: "Proxy Authentication Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/407"
  },
  408: {
    name: "Request Timeout",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"
  },
  409: {
    name: "Conflict",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409"
  },
  410: {
    name: "Gone",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410"
  },
  411: {
    name: "Length Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/411"
  },
  412: {
    name: "Precondition Failed",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412"
  },
  413: {
    name: "Content Too Large",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"
  },
  414: {
    name: "URI Too Long",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414"
  },
  415: {
    name: "Unsupported Media Type",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415"
  },
  416: {
    name: "Range Not Satisfiable",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416"
  },
  417: {
    name: "Expectation Failed",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/417"
  },
  421: {
    name: "Misdirected Request",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/421"
  },
  422: {
    name: "Unprocessable Content",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422"
  },
  423: {
    name: "Locked",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/423"
  },
  424: {
    name: "Failed Dependency",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/424"
  },
  425: {
    name: "Too Early",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/425"
  },
  426: {
    name: "Upgrade Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/426"
  },
  428: {
    name: "Precondition Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/428"
  },
  429: {
    name: "Too Many Requests",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"
  },
  431: {
    name: "Request Header Fields Too Large",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431"
  },
  451: {
    name: "Unavailable For Legal Reasons",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/451"
  },
  500: {
    name: "Internal Server Error",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"
  },
  501: {
    name: "Not Implemented",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501"
  },
  502: {
    name: "Bad Gateway",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"
  },
  503: {
    name: "Service Unavailable",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"
  },
  504: {
    name: "Gateway Timeout",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"
  },
  505: {
    name: "HTTP Version Not Supported",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/505"
  },
  506: {
    name: "Variant Also Negotiates",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506"
  },
  507: {
    name: "Insufficient Storage",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/507"
  },
  508: {
    name: "Loop Detected",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508"
  },
  510: {
    name: "Not Extended",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510"
  },
  511: {
    name: "Network Authentication Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/511"
  }
};

export { createHash, defaultStateFactory, fetchSpecFromUrl, formatJsonOrYamlString, getExampleFromSchema, getHarRequest, getParametersFromOperation, getRequestBodyFromOperation, getRequestFromOperation, httpStatusCodes, isJsonString, json, json2xml, normalizeMimeType, normalizeMimeTypeObject, parseJsonOrYaml, prettyPrintJson, ssrState, transformToJson, yaml };
