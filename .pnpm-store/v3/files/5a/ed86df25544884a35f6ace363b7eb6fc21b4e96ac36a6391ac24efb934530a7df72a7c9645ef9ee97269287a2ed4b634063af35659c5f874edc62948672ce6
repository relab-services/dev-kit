var $l = Object.defineProperty;
var vl = (t, e, n) => e in t ? $l(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var nt = (t, e, n) => (vl(t, typeof e != "symbol" ? e + "" : e, n), n);
const bl = (t, e) => {
  const n = t[e];
  return n ? typeof n == "function" ? n() : Promise.resolve(n) : new Promise((r, s) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(s.bind(null, new Error("Unknown variable dynamic import: " + e)));
  });
};
var _l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ri(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Ds = { exports: {} }, po = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.formatNames = t.fastFormats = t.fullFormats = void 0;
  function e(D, V) {
    return { validate: D, compare: V };
  }
  t.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: e(i, a),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: e(c, l),
    "date-time": e(d, g),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: y,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: R,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: u,
    // signed 32 bit integer
    int32: { type: "number", validate: E },
    // signed 64 bit integer
    int64: { type: "number", validate: C },
    // C-type float
    float: { type: "number", validate: _ },
    // C-type double
    double: { type: "number", validate: _ },
    // hint to the UI to hide input strings
    password: !0,
    // unchecked string payload
    binary: !0
  }, t.fastFormats = {
    ...t.fullFormats,
    date: e(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, a),
    time: e(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, l),
    "date-time": e(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, g),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, t.formatNames = Object.keys(t.fullFormats);
  function n(D) {
    return D % 4 === 0 && (D % 100 !== 0 || D % 400 === 0);
  }
  const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, s = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function i(D) {
    const V = r.exec(D);
    if (!V)
      return !1;
    const G = +V[1], U = +V[2], ye = +V[3];
    return U >= 1 && U <= 12 && ye >= 1 && ye <= (U === 2 && n(G) ? 29 : s[U]);
  }
  function a(D, V) {
    if (D && V)
      return D > V ? 1 : D < V ? -1 : 0;
  }
  const o = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function c(D, V) {
    const G = o.exec(D);
    if (!G)
      return !1;
    const U = +G[1], ye = +G[2], se = +G[3], Ie = G[5];
    return (U <= 23 && ye <= 59 && se <= 59 || U === 23 && ye === 59 && se === 60) && (!V || Ie !== "");
  }
  function l(D, V) {
    if (!(D && V))
      return;
    const G = o.exec(D), U = o.exec(V);
    if (G && U)
      return D = G[1] + G[2] + G[3] + (G[4] || ""), V = U[1] + U[2] + U[3] + (U[4] || ""), D > V ? 1 : D < V ? -1 : 0;
  }
  const f = /t|\s/i;
  function d(D) {
    const V = D.split(f);
    return V.length === 2 && i(V[0]) && c(V[1], !0);
  }
  function g(D, V) {
    if (!(D && V))
      return;
    const [G, U] = D.split(f), [ye, se] = V.split(f), Ie = a(G, ye);
    if (Ie !== void 0)
      return Ie || l(U, se);
  }
  const v = /\/|:/, w = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function y(D) {
    return v.test(D) && w.test(D);
  }
  const h = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function u(D) {
    return h.lastIndex = 0, h.test(D);
  }
  const p = -(2 ** 31), b = 2 ** 31 - 1;
  function E(D) {
    return Number.isInteger(D) && D <= b && D >= p;
  }
  function C(D) {
    return Number.isInteger(D);
  }
  function _() {
    return !0;
  }
  const P = /[^\\]\\Z/;
  function R(D) {
    if (P.test(D))
      return !1;
    try {
      return new RegExp(D), !0;
    } catch {
      return !1;
    }
  }
})(po);
var yo = {}, Ms = { exports: {} }, Ct = {}, Me = {}, an = {}, Xn = {}, H = {}, Jn = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.regexpCode = t.getEsmExportName = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0;
  class e {
  }
  t._CodeOrName = e, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class n extends e {
    constructor(p) {
      if (super(), !t.IDENTIFIER.test(p))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = p;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  t.Name = n;
  class r extends e {
    constructor(p) {
      super(), this._items = typeof p == "string" ? [p] : p;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const p = this._items[0];
      return p === "" || p === '""';
    }
    get str() {
      var p;
      return (p = this._str) !== null && p !== void 0 ? p : this._str = this._items.reduce((b, E) => `${b}${E}`, "");
    }
    get names() {
      var p;
      return (p = this._names) !== null && p !== void 0 ? p : this._names = this._items.reduce((b, E) => (E instanceof n && (b[E.str] = (b[E.str] || 0) + 1), b), {});
    }
  }
  t._Code = r, t.nil = new r("");
  function s(u, ...p) {
    const b = [u[0]];
    let E = 0;
    for (; E < p.length; )
      o(b, p[E]), b.push(u[++E]);
    return new r(b);
  }
  t._ = s;
  const i = new r("+");
  function a(u, ...p) {
    const b = [v(u[0])];
    let E = 0;
    for (; E < p.length; )
      b.push(i), o(b, p[E]), b.push(i, v(u[++E]));
    return c(b), new r(b);
  }
  t.str = a;
  function o(u, p) {
    p instanceof r ? u.push(...p._items) : p instanceof n ? u.push(p) : u.push(d(p));
  }
  t.addCodeArg = o;
  function c(u) {
    let p = 1;
    for (; p < u.length - 1; ) {
      if (u[p] === i) {
        const b = l(u[p - 1], u[p + 1]);
        if (b !== void 0) {
          u.splice(p - 1, 3, b);
          continue;
        }
        u[p++] = "+";
      }
      p++;
    }
  }
  function l(u, p) {
    if (p === '""')
      return u;
    if (u === '""')
      return p;
    if (typeof u == "string")
      return p instanceof n || u[u.length - 1] !== '"' ? void 0 : typeof p != "string" ? `${u.slice(0, -1)}${p}"` : p[0] === '"' ? u.slice(0, -1) + p.slice(1) : void 0;
    if (typeof p == "string" && p[0] === '"' && !(u instanceof n))
      return `"${u}${p.slice(1)}`;
  }
  function f(u, p) {
    return p.emptyStr() ? u : u.emptyStr() ? p : a`${u}${p}`;
  }
  t.strConcat = f;
  function d(u) {
    return typeof u == "number" || typeof u == "boolean" || u === null ? u : v(Array.isArray(u) ? u.join(",") : u);
  }
  function g(u) {
    return new r(v(u));
  }
  t.stringify = g;
  function v(u) {
    return JSON.stringify(u).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  t.safeStringify = v;
  function w(u) {
    return typeof u == "string" && t.IDENTIFIER.test(u) ? new r(`.${u}`) : s`[${u}]`;
  }
  t.getProperty = w;
  function y(u) {
    if (typeof u == "string" && t.IDENTIFIER.test(u))
      return new r(`${u}`);
    throw new Error(`CodeGen: invalid export name: ${u}, use explicit $id name mapping`);
  }
  t.getEsmExportName = y;
  function h(u) {
    return new r(u.toString());
  }
  t.regexpCode = h;
})(Jn);
var Ls = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0;
  const e = Jn;
  class n extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), this.value = l.value;
    }
  }
  var r;
  (function(c) {
    c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
  })(r = t.UsedValueState || (t.UsedValueState = {})), t.varKinds = {
    const: new e.Name("const"),
    let: new e.Name("let"),
    var: new e.Name("var")
  };
  class s {
    constructor({ prefixes: l, parent: f } = {}) {
      this._names = {}, this._prefixes = l, this._parent = f;
    }
    toName(l) {
      return l instanceof e.Name ? l : this.name(l);
    }
    name(l) {
      return new e.Name(this._newName(l));
    }
    _newName(l) {
      const f = this._names[l] || this._nameGroup(l);
      return `${l}${f.index++}`;
    }
    _nameGroup(l) {
      var f, d;
      if (!((d = (f = this._parent) === null || f === void 0 ? void 0 : f._prefixes) === null || d === void 0) && d.has(l) || this._prefixes && !this._prefixes.has(l))
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return this._names[l] = { prefix: l, index: 0 };
    }
  }
  t.Scope = s;
  class i extends e.Name {
    constructor(l, f) {
      super(f), this.prefix = l;
    }
    setValue(l, { property: f, itemIndex: d }) {
      this.value = l, this.scopePath = (0, e._)`.${new e.Name(f)}[${d}]`;
    }
  }
  t.ValueScopeName = i;
  const a = (0, e._)`\n`;
  class o extends s {
    constructor(l) {
      super(l), this._values = {}, this._scope = l.scope, this.opts = { ...l, _n: l.lines ? a : e.nil };
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new i(l, this._newName(l));
    }
    value(l, f) {
      var d;
      if (f.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const g = this.toName(l), { prefix: v } = g, w = (d = f.key) !== null && d !== void 0 ? d : f.ref;
      let y = this._values[v];
      if (y) {
        const p = y.get(w);
        if (p)
          return p;
      } else
        y = this._values[v] = /* @__PURE__ */ new Map();
      y.set(w, g);
      const h = this._scope[v] || (this._scope[v] = []), u = h.length;
      return h[u] = f.ref, g.setValue(f, { property: v, itemIndex: u }), g;
    }
    getValue(l, f) {
      const d = this._values[l];
      if (d)
        return d.get(f);
    }
    scopeRefs(l, f = this._values) {
      return this._reduceValues(f, (d) => {
        if (d.scopePath === void 0)
          throw new Error(`CodeGen: name "${d}" has no value`);
        return (0, e._)`${l}${d.scopePath}`;
      });
    }
    scopeCode(l = this._values, f, d) {
      return this._reduceValues(l, (g) => {
        if (g.value === void 0)
          throw new Error(`CodeGen: name "${g}" has no value`);
        return g.value.code;
      }, f, d);
    }
    _reduceValues(l, f, d = {}, g) {
      let v = e.nil;
      for (const w in l) {
        const y = l[w];
        if (!y)
          continue;
        const h = d[w] = d[w] || /* @__PURE__ */ new Map();
        y.forEach((u) => {
          if (h.has(u))
            return;
          h.set(u, r.Started);
          let p = f(u);
          if (p) {
            const b = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
            v = (0, e._)`${v}${b} ${u} = ${p};${this.opts._n}`;
          } else if (p = g == null ? void 0 : g(u))
            v = (0, e._)`${v}${p}${this.opts._n}`;
          else
            throw new n(u);
          h.set(u, r.Completed);
        });
      }
      return v;
    }
  }
  t.ValueScope = o;
})(Ls);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0;
  const e = Jn, n = Ls;
  var r = Jn;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(t, "strConcat", { enumerable: !0, get: function() {
    return r.strConcat;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(t, "getProperty", { enumerable: !0, get: function() {
    return r.getProperty;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(t, "regexpCode", { enumerable: !0, get: function() {
    return r.regexpCode;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } });
  var s = Ls;
  Object.defineProperty(t, "Scope", { enumerable: !0, get: function() {
    return s.Scope;
  } }), Object.defineProperty(t, "ValueScope", { enumerable: !0, get: function() {
    return s.ValueScope;
  } }), Object.defineProperty(t, "ValueScopeName", { enumerable: !0, get: function() {
    return s.ValueScopeName;
  } }), Object.defineProperty(t, "varKinds", { enumerable: !0, get: function() {
    return s.varKinds;
  } }), t.operators = {
    GT: new e._Code(">"),
    GTE: new e._Code(">="),
    LT: new e._Code("<"),
    LTE: new e._Code("<="),
    EQ: new e._Code("==="),
    NEQ: new e._Code("!=="),
    NOT: new e._Code("!"),
    OR: new e._Code("||"),
    AND: new e._Code("&&"),
    ADD: new e._Code("+")
  };
  class i {
    optimizeNodes() {
      return this;
    }
    optimizeNames(m, O) {
      return this;
    }
  }
  class a extends i {
    constructor(m, O, j) {
      super(), this.varKind = m, this.name = O, this.rhs = j;
    }
    render({ es5: m, _n: O }) {
      const j = m ? n.varKinds.var : this.varKind, F = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${j} ${this.name}${F};` + O;
    }
    optimizeNames(m, O) {
      if (m[this.name.str])
        return this.rhs && (this.rhs = se(this.rhs, m, O)), this;
    }
    get names() {
      return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends i {
    constructor(m, O, j) {
      super(), this.lhs = m, this.rhs = O, this.sideEffects = j;
    }
    render({ _n: m }) {
      return `${this.lhs} = ${this.rhs};` + m;
    }
    optimizeNames(m, O) {
      if (!(this.lhs instanceof e.Name && !m[this.lhs.str] && !this.sideEffects))
        return this.rhs = se(this.rhs, m, O), this;
    }
    get names() {
      const m = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
      return ye(m, this.rhs);
    }
  }
  class c extends o {
    constructor(m, O, j, F) {
      super(m, j, F), this.op = O;
    }
    render({ _n: m }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + m;
    }
  }
  class l extends i {
    constructor(m) {
      super(), this.label = m, this.names = {};
    }
    render({ _n: m }) {
      return `${this.label}:` + m;
    }
  }
  class f extends i {
    constructor(m) {
      super(), this.label = m, this.names = {};
    }
    render({ _n: m }) {
      return `break${this.label ? ` ${this.label}` : ""};` + m;
    }
  }
  class d extends i {
    constructor(m) {
      super(), this.error = m;
    }
    render({ _n: m }) {
      return `throw ${this.error};` + m;
    }
    get names() {
      return this.error.names;
    }
  }
  class g extends i {
    constructor(m) {
      super(), this.code = m;
    }
    render({ _n: m }) {
      return `${this.code};` + m;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(m, O) {
      return this.code = se(this.code, m, O), this;
    }
    get names() {
      return this.code instanceof e._CodeOrName ? this.code.names : {};
    }
  }
  class v extends i {
    constructor(m = []) {
      super(), this.nodes = m;
    }
    render(m) {
      return this.nodes.reduce((O, j) => O + j.render(m), "");
    }
    optimizeNodes() {
      const { nodes: m } = this;
      let O = m.length;
      for (; O--; ) {
        const j = m[O].optimizeNodes();
        Array.isArray(j) ? m.splice(O, 1, ...j) : j ? m[O] = j : m.splice(O, 1);
      }
      return m.length > 0 ? this : void 0;
    }
    optimizeNames(m, O) {
      const { nodes: j } = this;
      let F = j.length;
      for (; F--; ) {
        const q = j[F];
        q.optimizeNames(m, O) || (Ie(m, q.names), j.splice(F, 1));
      }
      return j.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((m, O) => U(m, O.names), {});
    }
  }
  class w extends v {
    render(m) {
      return "{" + m._n + super.render(m) + "}" + m._n;
    }
  }
  class y extends v {
  }
  class h extends w {
  }
  h.kind = "else";
  class u extends w {
    constructor(m, O) {
      super(O), this.condition = m;
    }
    render(m) {
      let O = `if(${this.condition})` + super.render(m);
      return this.else && (O += "else " + this.else.render(m)), O;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const m = this.condition;
      if (m === !0)
        return this.nodes;
      let O = this.else;
      if (O) {
        const j = O.optimizeNodes();
        O = this.else = Array.isArray(j) ? new h(j) : j;
      }
      if (O)
        return m === !1 ? O instanceof u ? O : O.nodes : this.nodes.length ? this : new u(vt(m), O instanceof u ? [O] : O.nodes);
      if (!(m === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(m, O) {
      var j;
      if (this.else = (j = this.else) === null || j === void 0 ? void 0 : j.optimizeNames(m, O), !!(super.optimizeNames(m, O) || this.else))
        return this.condition = se(this.condition, m, O), this;
    }
    get names() {
      const m = super.names;
      return ye(m, this.condition), this.else && U(m, this.else.names), m;
    }
  }
  u.kind = "if";
  class p extends w {
  }
  p.kind = "for";
  class b extends p {
    constructor(m) {
      super(), this.iteration = m;
    }
    render(m) {
      return `for(${this.iteration})` + super.render(m);
    }
    optimizeNames(m, O) {
      if (super.optimizeNames(m, O))
        return this.iteration = se(this.iteration, m, O), this;
    }
    get names() {
      return U(super.names, this.iteration.names);
    }
  }
  class E extends p {
    constructor(m, O, j, F) {
      super(), this.varKind = m, this.name = O, this.from = j, this.to = F;
    }
    render(m) {
      const O = m.es5 ? n.varKinds.var : this.varKind, { name: j, from: F, to: q } = this;
      return `for(${O} ${j}=${F}; ${j}<${q}; ${j}++)` + super.render(m);
    }
    get names() {
      const m = ye(super.names, this.from);
      return ye(m, this.to);
    }
  }
  class C extends p {
    constructor(m, O, j, F) {
      super(), this.loop = m, this.varKind = O, this.name = j, this.iterable = F;
    }
    render(m) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(m);
    }
    optimizeNames(m, O) {
      if (super.optimizeNames(m, O))
        return this.iterable = se(this.iterable, m, O), this;
    }
    get names() {
      return U(super.names, this.iterable.names);
    }
  }
  class _ extends w {
    constructor(m, O, j) {
      super(), this.name = m, this.args = O, this.async = j;
    }
    render(m) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(m);
    }
  }
  _.kind = "func";
  class P extends v {
    render(m) {
      return "return " + super.render(m);
    }
  }
  P.kind = "return";
  class R extends w {
    render(m) {
      let O = "try" + super.render(m);
      return this.catch && (O += this.catch.render(m)), this.finally && (O += this.finally.render(m)), O;
    }
    optimizeNodes() {
      var m, O;
      return super.optimizeNodes(), (m = this.catch) === null || m === void 0 || m.optimizeNodes(), (O = this.finally) === null || O === void 0 || O.optimizeNodes(), this;
    }
    optimizeNames(m, O) {
      var j, F;
      return super.optimizeNames(m, O), (j = this.catch) === null || j === void 0 || j.optimizeNames(m, O), (F = this.finally) === null || F === void 0 || F.optimizeNames(m, O), this;
    }
    get names() {
      const m = super.names;
      return this.catch && U(m, this.catch.names), this.finally && U(m, this.finally.names), m;
    }
  }
  class D extends w {
    constructor(m) {
      super(), this.error = m;
    }
    render(m) {
      return `catch(${this.error})` + super.render(m);
    }
  }
  D.kind = "catch";
  class V extends w {
    render(m) {
      return "finally" + super.render(m);
    }
  }
  V.kind = "finally";
  class G {
    constructor(m, O = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...O, _n: O.lines ? `
` : "" }, this._extScope = m, this._scope = new n.Scope({ parent: m }), this._nodes = [new y()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(m) {
      return this._scope.name(m);
    }
    // reserves unique name in the external scope
    scopeName(m) {
      return this._extScope.name(m);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(m, O) {
      const j = this._extScope.value(m, O);
      return (this._values[j.prefix] || (this._values[j.prefix] = /* @__PURE__ */ new Set())).add(j), j;
    }
    getScopeValue(m, O) {
      return this._extScope.getValue(m, O);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(m) {
      return this._extScope.scopeRefs(m, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(m, O, j, F) {
      const q = this._scope.toName(O);
      return j !== void 0 && F && (this._constants[q.str] = j), this._leafNode(new a(m, q, j)), q;
    }
    // `const` declaration (`var` in es5 mode)
    const(m, O, j) {
      return this._def(n.varKinds.const, m, O, j);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(m, O, j) {
      return this._def(n.varKinds.let, m, O, j);
    }
    // `var` declaration with optional assignment
    var(m, O, j) {
      return this._def(n.varKinds.var, m, O, j);
    }
    // assignment code
    assign(m, O, j) {
      return this._leafNode(new o(m, O, j));
    }
    // `+=` code
    add(m, O) {
      return this._leafNode(new c(m, t.operators.ADD, O));
    }
    // appends passed SafeExpr to code or executes Block
    code(m) {
      return typeof m == "function" ? m() : m !== e.nil && this._leafNode(new g(m)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...m) {
      const O = ["{"];
      for (const [j, F] of m)
        O.length > 1 && O.push(","), O.push(j), (j !== F || this.opts.es5) && (O.push(":"), (0, e.addCodeArg)(O, F));
      return O.push("}"), new e._Code(O);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(m, O, j) {
      if (this._blockNode(new u(m)), O && j)
        this.code(O).else().code(j).endIf();
      else if (O)
        this.code(O).endIf();
      else if (j)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(m) {
      return this._elseNode(new u(m));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new h());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(u, h);
    }
    _for(m, O) {
      return this._blockNode(m), O && this.code(O).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(m, O) {
      return this._for(new b(m), O);
    }
    // `for` statement for a range of values
    forRange(m, O, j, F, q = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
      const Z = this._scope.toName(m);
      return this._for(new E(q, Z, O, j), () => F(Z));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(m, O, j, F = n.varKinds.const) {
      const q = this._scope.toName(m);
      if (this.opts.es5) {
        const Z = O instanceof e.Name ? O : this.var("_arr", O);
        return this.forRange("_i", 0, (0, e._)`${Z}.length`, (ee) => {
          this.var(q, (0, e._)`${Z}[${ee}]`), j(q);
        });
      }
      return this._for(new C("of", F, q, O), () => j(q));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(m, O, j, F = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(m, (0, e._)`Object.keys(${O})`, j);
      const q = this._scope.toName(m);
      return this._for(new C("in", F, q, O), () => j(q));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(p);
    }
    // `label` statement
    label(m) {
      return this._leafNode(new l(m));
    }
    // `break` statement
    break(m) {
      return this._leafNode(new f(m));
    }
    // `return` statement
    return(m) {
      const O = new P();
      if (this._blockNode(O), this.code(m), O.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(P);
    }
    // `try` statement
    try(m, O, j) {
      if (!O && !j)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const F = new R();
      if (this._blockNode(F), this.code(m), O) {
        const q = this.name("e");
        this._currNode = F.catch = new D(q), O(q);
      }
      return j && (this._currNode = F.finally = new V(), this.code(j)), this._endBlockNode(D, V);
    }
    // `throw` statement
    throw(m) {
      return this._leafNode(new d(m));
    }
    // start self-balancing block
    block(m, O) {
      return this._blockStarts.push(this._nodes.length), m && this.code(m).endBlock(O), this;
    }
    // end the current self-balancing block
    endBlock(m) {
      const O = this._blockStarts.pop();
      if (O === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const j = this._nodes.length - O;
      if (j < 0 || m !== void 0 && j !== m)
        throw new Error(`CodeGen: wrong number of nodes: ${j} vs ${m} expected`);
      return this._nodes.length = O, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(m, O = e.nil, j, F) {
      return this._blockNode(new _(m, O, j)), F && this.code(F).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(_);
    }
    optimize(m = 1) {
      for (; m-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(m) {
      return this._currNode.nodes.push(m), this;
    }
    _blockNode(m) {
      this._currNode.nodes.push(m), this._nodes.push(m);
    }
    _endBlockNode(m, O) {
      const j = this._currNode;
      if (j instanceof m || O && j instanceof O)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${O ? `${m.kind}/${O.kind}` : m.kind}"`);
    }
    _elseNode(m) {
      const O = this._currNode;
      if (!(O instanceof u))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = O.else = m, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const m = this._nodes;
      return m[m.length - 1];
    }
    set _currNode(m) {
      const O = this._nodes;
      O[O.length - 1] = m;
    }
  }
  t.CodeGen = G;
  function U(A, m) {
    for (const O in m)
      A[O] = (A[O] || 0) + (m[O] || 0);
    return A;
  }
  function ye(A, m) {
    return m instanceof e._CodeOrName ? U(A, m.names) : A;
  }
  function se(A, m, O) {
    if (A instanceof e.Name)
      return j(A);
    if (!F(A))
      return A;
    return new e._Code(A._items.reduce((q, Z) => (Z instanceof e.Name && (Z = j(Z)), Z instanceof e._Code ? q.push(...Z._items) : q.push(Z), q), []));
    function j(q) {
      const Z = O[q.str];
      return Z === void 0 || m[q.str] !== 1 ? q : (delete m[q.str], Z);
    }
    function F(q) {
      return q instanceof e._Code && q._items.some((Z) => Z instanceof e.Name && m[Z.str] === 1 && O[Z.str] !== void 0);
    }
  }
  function Ie(A, m) {
    for (const O in m)
      A[O] = (A[O] || 0) - (m[O] || 0);
  }
  function vt(A) {
    return typeof A == "boolean" || typeof A == "number" || A === null ? !A : (0, e._)`!${M(A)}`;
  }
  t.not = vt;
  const Lt = k(t.operators.AND);
  function Sn(...A) {
    return A.reduce(Lt);
  }
  t.and = Sn;
  const Vt = k(t.operators.OR);
  function L(...A) {
    return A.reduce(Vt);
  }
  t.or = L;
  function k(A) {
    return (m, O) => m === e.nil ? O : O === e.nil ? m : (0, e._)`${M(m)} ${A} ${M(O)}`;
  }
  function M(A) {
    return A instanceof e.Name ? A : (0, e._)`(${A})`;
  }
})(H);
var X = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.checkStrictMode = t.getErrorPath = t.Type = t.useFunc = t.setEvaluated = t.evaluatedPropsToName = t.mergeEvaluated = t.eachItem = t.unescapeJsonPointer = t.escapeJsonPointer = t.escapeFragment = t.unescapeFragment = t.schemaRefOrVal = t.schemaHasRulesButRef = t.schemaHasRules = t.checkUnknownRules = t.alwaysValidSchema = t.toHash = void 0;
  const e = H, n = Jn;
  function r(_) {
    const P = {};
    for (const R of _)
      P[R] = !0;
    return P;
  }
  t.toHash = r;
  function s(_, P) {
    return typeof P == "boolean" ? P : Object.keys(P).length === 0 ? !0 : (i(_, P), !a(P, _.self.RULES.all));
  }
  t.alwaysValidSchema = s;
  function i(_, P = _.schema) {
    const { opts: R, self: D } = _;
    if (!R.strictSchema || typeof P == "boolean")
      return;
    const V = D.RULES.keywords;
    for (const G in P)
      V[G] || C(_, `unknown keyword: "${G}"`);
  }
  t.checkUnknownRules = i;
  function a(_, P) {
    if (typeof _ == "boolean")
      return !_;
    for (const R in _)
      if (P[R])
        return !0;
    return !1;
  }
  t.schemaHasRules = a;
  function o(_, P) {
    if (typeof _ == "boolean")
      return !_;
    for (const R in _)
      if (R !== "$ref" && P.all[R])
        return !0;
    return !1;
  }
  t.schemaHasRulesButRef = o;
  function c({ topSchemaRef: _, schemaPath: P }, R, D, V) {
    if (!V) {
      if (typeof R == "number" || typeof R == "boolean")
        return R;
      if (typeof R == "string")
        return (0, e._)`${R}`;
    }
    return (0, e._)`${_}${P}${(0, e.getProperty)(D)}`;
  }
  t.schemaRefOrVal = c;
  function l(_) {
    return g(decodeURIComponent(_));
  }
  t.unescapeFragment = l;
  function f(_) {
    return encodeURIComponent(d(_));
  }
  t.escapeFragment = f;
  function d(_) {
    return typeof _ == "number" ? `${_}` : _.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  t.escapeJsonPointer = d;
  function g(_) {
    return _.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  t.unescapeJsonPointer = g;
  function v(_, P) {
    if (Array.isArray(_))
      for (const R of _)
        P(R);
    else
      P(_);
  }
  t.eachItem = v;
  function w({ mergeNames: _, mergeToName: P, mergeValues: R, resultToName: D }) {
    return (V, G, U, ye) => {
      const se = U === void 0 ? G : U instanceof e.Name ? (G instanceof e.Name ? _(V, G, U) : P(V, G, U), U) : G instanceof e.Name ? (P(V, U, G), G) : R(G, U);
      return ye === e.Name && !(se instanceof e.Name) ? D(V, se) : se;
    };
  }
  t.mergeEvaluated = {
    props: w({
      mergeNames: (_, P, R) => _.if((0, e._)`${R} !== true && ${P} !== undefined`, () => {
        _.if((0, e._)`${P} === true`, () => _.assign(R, !0), () => _.assign(R, (0, e._)`${R} || {}`).code((0, e._)`Object.assign(${R}, ${P})`));
      }),
      mergeToName: (_, P, R) => _.if((0, e._)`${R} !== true`, () => {
        P === !0 ? _.assign(R, !0) : (_.assign(R, (0, e._)`${R} || {}`), h(_, R, P));
      }),
      mergeValues: (_, P) => _ === !0 ? !0 : { ..._, ...P },
      resultToName: y
    }),
    items: w({
      mergeNames: (_, P, R) => _.if((0, e._)`${R} !== true && ${P} !== undefined`, () => _.assign(R, (0, e._)`${P} === true ? true : ${R} > ${P} ? ${R} : ${P}`)),
      mergeToName: (_, P, R) => _.if((0, e._)`${R} !== true`, () => _.assign(R, P === !0 ? !0 : (0, e._)`${R} > ${P} ? ${R} : ${P}`)),
      mergeValues: (_, P) => _ === !0 ? !0 : Math.max(_, P),
      resultToName: (_, P) => _.var("items", P)
    })
  };
  function y(_, P) {
    if (P === !0)
      return _.var("props", !0);
    const R = _.var("props", (0, e._)`{}`);
    return P !== void 0 && h(_, R, P), R;
  }
  t.evaluatedPropsToName = y;
  function h(_, P, R) {
    Object.keys(R).forEach((D) => _.assign((0, e._)`${P}${(0, e.getProperty)(D)}`, !0));
  }
  t.setEvaluated = h;
  const u = {};
  function p(_, P) {
    return _.scopeValue("func", {
      ref: P,
      code: u[P.code] || (u[P.code] = new n._Code(P.code))
    });
  }
  t.useFunc = p;
  var b;
  (function(_) {
    _[_.Num = 0] = "Num", _[_.Str = 1] = "Str";
  })(b = t.Type || (t.Type = {}));
  function E(_, P, R) {
    if (_ instanceof e.Name) {
      const D = P === b.Num;
      return R ? D ? (0, e._)`"[" + ${_} + "]"` : (0, e._)`"['" + ${_} + "']"` : D ? (0, e._)`"/" + ${_}` : (0, e._)`"/" + ${_}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return R ? (0, e.getProperty)(_).toString() : "/" + d(_);
  }
  t.getErrorPath = E;
  function C(_, P, R = _.opts.strictSchema) {
    if (R) {
      if (P = `strict mode: ${P}`, R === !0)
        throw new Error(P);
      _.self.logger.warn(P);
    }
  }
  t.checkStrictMode = C;
})(X);
var Te = {};
Object.defineProperty(Te, "__esModule", { value: !0 });
const be = H, wl = {
  // validation function arguments
  data: new be.Name("data"),
  // args passed from referencing schema
  valCxt: new be.Name("valCxt"),
  instancePath: new be.Name("instancePath"),
  parentData: new be.Name("parentData"),
  parentDataProperty: new be.Name("parentDataProperty"),
  rootData: new be.Name("rootData"),
  dynamicAnchors: new be.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new be.Name("vErrors"),
  errors: new be.Name("errors"),
  this: new be.Name("this"),
  // "globals"
  self: new be.Name("self"),
  scope: new be.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new be.Name("json"),
  jsonPos: new be.Name("jsonPos"),
  jsonLen: new be.Name("jsonLen"),
  jsonPart: new be.Name("jsonPart")
};
Te.default = wl;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0;
  const e = H, n = X, r = Te;
  t.keywordError = {
    message: ({ keyword: h }) => (0, e.str)`must pass "${h}" keyword validation`
  }, t.keyword$DataError = {
    message: ({ keyword: h, schemaType: u }) => u ? (0, e.str)`"${h}" keyword must be ${u} ($data)` : (0, e.str)`"${h}" keyword is invalid ($data)`
  };
  function s(h, u = t.keywordError, p, b) {
    const { it: E } = h, { gen: C, compositeRule: _, allErrors: P } = E, R = d(h, u, p);
    b ?? (_ || P) ? c(C, R) : l(E, (0, e._)`[${R}]`);
  }
  t.reportError = s;
  function i(h, u = t.keywordError, p) {
    const { it: b } = h, { gen: E, compositeRule: C, allErrors: _ } = b, P = d(h, u, p);
    c(E, P), C || _ || l(b, r.default.vErrors);
  }
  t.reportExtraError = i;
  function a(h, u) {
    h.assign(r.default.errors, u), h.if((0, e._)`${r.default.vErrors} !== null`, () => h.if(u, () => h.assign((0, e._)`${r.default.vErrors}.length`, u), () => h.assign(r.default.vErrors, null)));
  }
  t.resetErrorsCount = a;
  function o({ gen: h, keyword: u, schemaValue: p, data: b, errsCount: E, it: C }) {
    if (E === void 0)
      throw new Error("ajv implementation error");
    const _ = h.name("err");
    h.forRange("i", E, r.default.errors, (P) => {
      h.const(_, (0, e._)`${r.default.vErrors}[${P}]`), h.if((0, e._)`${_}.instancePath === undefined`, () => h.assign((0, e._)`${_}.instancePath`, (0, e.strConcat)(r.default.instancePath, C.errorPath))), h.assign((0, e._)`${_}.schemaPath`, (0, e.str)`${C.errSchemaPath}/${u}`), C.opts.verbose && (h.assign((0, e._)`${_}.schema`, p), h.assign((0, e._)`${_}.data`, b));
    });
  }
  t.extendErrors = o;
  function c(h, u) {
    const p = h.const("err", u);
    h.if((0, e._)`${r.default.vErrors} === null`, () => h.assign(r.default.vErrors, (0, e._)`[${p}]`), (0, e._)`${r.default.vErrors}.push(${p})`), h.code((0, e._)`${r.default.errors}++`);
  }
  function l(h, u) {
    const { gen: p, validateName: b, schemaEnv: E } = h;
    E.$async ? p.throw((0, e._)`new ${h.ValidationError}(${u})`) : (p.assign((0, e._)`${b}.errors`, u), p.return(!1));
  }
  const f = {
    keyword: new e.Name("keyword"),
    schemaPath: new e.Name("schemaPath"),
    params: new e.Name("params"),
    propertyName: new e.Name("propertyName"),
    message: new e.Name("message"),
    schema: new e.Name("schema"),
    parentSchema: new e.Name("parentSchema")
  };
  function d(h, u, p) {
    const { createErrors: b } = h.it;
    return b === !1 ? (0, e._)`{}` : g(h, u, p);
  }
  function g(h, u, p = {}) {
    const { gen: b, it: E } = h, C = [
      v(E, p),
      w(h, p)
    ];
    return y(h, u, C), b.object(...C);
  }
  function v({ errorPath: h }, { instancePath: u }) {
    const p = u ? (0, e.str)`${h}${(0, n.getErrorPath)(u, n.Type.Str)}` : h;
    return [r.default.instancePath, (0, e.strConcat)(r.default.instancePath, p)];
  }
  function w({ keyword: h, it: { errSchemaPath: u } }, { schemaPath: p, parentSchema: b }) {
    let E = b ? u : (0, e.str)`${u}/${h}`;
    return p && (E = (0, e.str)`${E}${(0, n.getErrorPath)(p, n.Type.Str)}`), [f.schemaPath, E];
  }
  function y(h, { params: u, message: p }, b) {
    const { keyword: E, data: C, schemaValue: _, it: P } = h, { opts: R, propertyName: D, topSchemaRef: V, schemaPath: G } = P;
    b.push([f.keyword, E], [f.params, typeof u == "function" ? u(h) : u || (0, e._)`{}`]), R.messages && b.push([f.message, typeof p == "function" ? p(h) : p]), R.verbose && b.push([f.schema, _], [f.parentSchema, (0, e._)`${V}${G}`], [r.default.data, C]), D && b.push([f.propertyName, D]);
  }
})(Xn);
Object.defineProperty(an, "__esModule", { value: !0 });
an.boolOrEmptySchema = an.topBoolOrEmptySchema = void 0;
const Sl = Xn, El = H, Ol = Te, Nl = {
  message: "boolean schema is false"
};
function Pl(t) {
  const { gen: e, schema: n, validateName: r } = t;
  n === !1 ? go(t, !1) : typeof n == "object" && n.$async === !0 ? e.return(Ol.default.data) : (e.assign((0, El._)`${r}.errors`, null), e.return(!0));
}
an.topBoolOrEmptySchema = Pl;
function kl(t, e) {
  const { gen: n, schema: r } = t;
  r === !1 ? (n.var(e, !1), go(t)) : n.var(e, !0);
}
an.boolOrEmptySchema = kl;
function go(t, e) {
  const { gen: n, data: r } = t, s = {
    gen: n,
    keyword: "false schema",
    data: r,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: t
  };
  (0, Sl.reportError)(s, Nl, void 0, e);
}
var Zn = {}, jt = {};
Object.defineProperty(jt, "__esModule", { value: !0 });
jt.getRules = jt.isJSONType = void 0;
const Al = ["string", "number", "integer", "boolean", "null", "object", "array"], Tl = new Set(Al);
function Il(t) {
  return typeof t == "string" && Tl.has(t);
}
jt.isJSONType = Il;
function Cl() {
  const t = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...t, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, t.number, t.string, t.array, t.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
jt.getRules = Cl;
var it = {};
Object.defineProperty(it, "__esModule", { value: !0 });
it.shouldUseRule = it.shouldUseGroup = it.schemaHasRulesForType = void 0;
function jl({ schema: t, self: e }, n) {
  const r = e.RULES.types[n];
  return r && r !== !0 && $o(t, r);
}
it.schemaHasRulesForType = jl;
function $o(t, e) {
  return e.rules.some((n) => vo(t, n));
}
it.shouldUseGroup = $o;
function vo(t, e) {
  var n;
  return t[e.keyword] !== void 0 || ((n = e.definition.implements) === null || n === void 0 ? void 0 : n.some((r) => t[r] !== void 0));
}
it.shouldUseRule = vo;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.reportTypeError = t.checkDataTypes = t.checkDataType = t.coerceAndCheckDataType = t.getJSONTypes = t.getSchemaTypes = t.DataType = void 0;
  const e = jt, n = it, r = Xn, s = H, i = X;
  var a;
  (function(b) {
    b[b.Correct = 0] = "Correct", b[b.Wrong = 1] = "Wrong";
  })(a = t.DataType || (t.DataType = {}));
  function o(b) {
    const E = c(b.type);
    if (E.includes("null")) {
      if (b.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!E.length && b.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      b.nullable === !0 && E.push("null");
    }
    return E;
  }
  t.getSchemaTypes = o;
  function c(b) {
    const E = Array.isArray(b) ? b : b ? [b] : [];
    if (E.every(e.isJSONType))
      return E;
    throw new Error("type must be JSONType or JSONType[]: " + E.join(","));
  }
  t.getJSONTypes = c;
  function l(b, E) {
    const { gen: C, data: _, opts: P } = b, R = d(E, P.coerceTypes), D = E.length > 0 && !(R.length === 0 && E.length === 1 && (0, n.schemaHasRulesForType)(b, E[0]));
    if (D) {
      const V = y(E, _, P.strictNumbers, a.Wrong);
      C.if(V, () => {
        R.length ? g(b, E, R) : u(b);
      });
    }
    return D;
  }
  t.coerceAndCheckDataType = l;
  const f = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function d(b, E) {
    return E ? b.filter((C) => f.has(C) || E === "array" && C === "array") : [];
  }
  function g(b, E, C) {
    const { gen: _, data: P, opts: R } = b, D = _.let("dataType", (0, s._)`typeof ${P}`), V = _.let("coerced", (0, s._)`undefined`);
    R.coerceTypes === "array" && _.if((0, s._)`${D} == 'object' && Array.isArray(${P}) && ${P}.length == 1`, () => _.assign(P, (0, s._)`${P}[0]`).assign(D, (0, s._)`typeof ${P}`).if(y(E, P, R.strictNumbers), () => _.assign(V, P))), _.if((0, s._)`${V} !== undefined`);
    for (const U of C)
      (f.has(U) || U === "array" && R.coerceTypes === "array") && G(U);
    _.else(), u(b), _.endIf(), _.if((0, s._)`${V} !== undefined`, () => {
      _.assign(P, V), v(b, V);
    });
    function G(U) {
      switch (U) {
        case "string":
          _.elseIf((0, s._)`${D} == "number" || ${D} == "boolean"`).assign(V, (0, s._)`"" + ${P}`).elseIf((0, s._)`${P} === null`).assign(V, (0, s._)`""`);
          return;
        case "number":
          _.elseIf((0, s._)`${D} == "boolean" || ${P} === null
              || (${D} == "string" && ${P} && ${P} == +${P})`).assign(V, (0, s._)`+${P}`);
          return;
        case "integer":
          _.elseIf((0, s._)`${D} === "boolean" || ${P} === null
              || (${D} === "string" && ${P} && ${P} == +${P} && !(${P} % 1))`).assign(V, (0, s._)`+${P}`);
          return;
        case "boolean":
          _.elseIf((0, s._)`${P} === "false" || ${P} === 0 || ${P} === null`).assign(V, !1).elseIf((0, s._)`${P} === "true" || ${P} === 1`).assign(V, !0);
          return;
        case "null":
          _.elseIf((0, s._)`${P} === "" || ${P} === 0 || ${P} === false`), _.assign(V, null);
          return;
        case "array":
          _.elseIf((0, s._)`${D} === "string" || ${D} === "number"
              || ${D} === "boolean" || ${P} === null`).assign(V, (0, s._)`[${P}]`);
      }
    }
  }
  function v({ gen: b, parentData: E, parentDataProperty: C }, _) {
    b.if((0, s._)`${E} !== undefined`, () => b.assign((0, s._)`${E}[${C}]`, _));
  }
  function w(b, E, C, _ = a.Correct) {
    const P = _ === a.Correct ? s.operators.EQ : s.operators.NEQ;
    let R;
    switch (b) {
      case "null":
        return (0, s._)`${E} ${P} null`;
      case "array":
        R = (0, s._)`Array.isArray(${E})`;
        break;
      case "object":
        R = (0, s._)`${E} && typeof ${E} == "object" && !Array.isArray(${E})`;
        break;
      case "integer":
        R = D((0, s._)`!(${E} % 1) && !isNaN(${E})`);
        break;
      case "number":
        R = D();
        break;
      default:
        return (0, s._)`typeof ${E} ${P} ${b}`;
    }
    return _ === a.Correct ? R : (0, s.not)(R);
    function D(V = s.nil) {
      return (0, s.and)((0, s._)`typeof ${E} == "number"`, V, C ? (0, s._)`isFinite(${E})` : s.nil);
    }
  }
  t.checkDataType = w;
  function y(b, E, C, _) {
    if (b.length === 1)
      return w(b[0], E, C, _);
    let P;
    const R = (0, i.toHash)(b);
    if (R.array && R.object) {
      const D = (0, s._)`typeof ${E} != "object"`;
      P = R.null ? D : (0, s._)`!${E} || ${D}`, delete R.null, delete R.array, delete R.object;
    } else
      P = s.nil;
    R.number && delete R.integer;
    for (const D in R)
      P = (0, s.and)(P, w(D, E, C, _));
    return P;
  }
  t.checkDataTypes = y;
  const h = {
    message: ({ schema: b }) => `must be ${b}`,
    params: ({ schema: b, schemaValue: E }) => typeof b == "string" ? (0, s._)`{type: ${b}}` : (0, s._)`{type: ${E}}`
  };
  function u(b) {
    const E = p(b);
    (0, r.reportError)(E, h);
  }
  t.reportTypeError = u;
  function p(b) {
    const { gen: E, data: C, schema: _ } = b, P = (0, i.schemaRefOrVal)(b, _, "type");
    return {
      gen: E,
      keyword: "type",
      data: C,
      schema: _.type,
      schemaCode: P,
      schemaValue: P,
      parentSchema: _,
      params: {},
      it: b
    };
  }
})(Zn);
var Vr = {};
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.assignDefaults = void 0;
const Jt = H, Rl = X;
function Dl(t, e) {
  const { properties: n, items: r } = t.schema;
  if (e === "object" && n)
    for (const s in n)
      Ea(t, s, n[s].default);
  else
    e === "array" && Array.isArray(r) && r.forEach((s, i) => Ea(t, i, s.default));
}
Vr.assignDefaults = Dl;
function Ea(t, e, n) {
  const { gen: r, compositeRule: s, data: i, opts: a } = t;
  if (n === void 0)
    return;
  const o = (0, Jt._)`${i}${(0, Jt.getProperty)(e)}`;
  if (s) {
    (0, Rl.checkStrictMode)(t, `default is ignored for: ${o}`);
    return;
  }
  let c = (0, Jt._)`${o} === undefined`;
  a.useDefaults === "empty" && (c = (0, Jt._)`${c} || ${o} === null || ${o} === ""`), r.if(c, (0, Jt._)`${o} = ${(0, Jt.stringify)(n)}`);
}
var Ze = {}, Q = {};
Object.defineProperty(Q, "__esModule", { value: !0 });
Q.validateUnion = Q.validateArray = Q.usePattern = Q.callValidateCode = Q.schemaProperties = Q.allSchemaProperties = Q.noPropertyInData = Q.propertyInData = Q.isOwnProperty = Q.hasPropFunc = Q.reportMissingProp = Q.checkMissingProp = Q.checkReportMissingProp = void 0;
const ae = H, si = X, lt = Te, Ml = X;
function Ll(t, e) {
  const { gen: n, data: r, it: s } = t;
  n.if(ai(n, r, e, s.opts.ownProperties), () => {
    t.setParams({ missingProperty: (0, ae._)`${e}` }, !0), t.error();
  });
}
Q.checkReportMissingProp = Ll;
function Vl({ gen: t, data: e, it: { opts: n } }, r, s) {
  return (0, ae.or)(...r.map((i) => (0, ae.and)(ai(t, e, i, n.ownProperties), (0, ae._)`${s} = ${i}`)));
}
Q.checkMissingProp = Vl;
function Fl(t, e) {
  t.setParams({ missingProperty: e }, !0), t.error();
}
Q.reportMissingProp = Fl;
function bo(t) {
  return t.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, ae._)`Object.prototype.hasOwnProperty`
  });
}
Q.hasPropFunc = bo;
function ii(t, e, n) {
  return (0, ae._)`${bo(t)}.call(${e}, ${n})`;
}
Q.isOwnProperty = ii;
function Ul(t, e, n, r) {
  const s = (0, ae._)`${e}${(0, ae.getProperty)(n)} !== undefined`;
  return r ? (0, ae._)`${s} && ${ii(t, e, n)}` : s;
}
Q.propertyInData = Ul;
function ai(t, e, n, r) {
  const s = (0, ae._)`${e}${(0, ae.getProperty)(n)} === undefined`;
  return r ? (0, ae.or)(s, (0, ae.not)(ii(t, e, n))) : s;
}
Q.noPropertyInData = ai;
function _o(t) {
  return t ? Object.keys(t).filter((e) => e !== "__proto__") : [];
}
Q.allSchemaProperties = _o;
function ql(t, e) {
  return _o(e).filter((n) => !(0, si.alwaysValidSchema)(t, e[n]));
}
Q.schemaProperties = ql;
function Kl({ schemaCode: t, data: e, it: { gen: n, topSchemaRef: r, schemaPath: s, errorPath: i }, it: a }, o, c, l) {
  const f = l ? (0, ae._)`${t}, ${e}, ${r}${s}` : e, d = [
    [lt.default.instancePath, (0, ae.strConcat)(lt.default.instancePath, i)],
    [lt.default.parentData, a.parentData],
    [lt.default.parentDataProperty, a.parentDataProperty],
    [lt.default.rootData, lt.default.rootData]
  ];
  a.opts.dynamicRef && d.push([lt.default.dynamicAnchors, lt.default.dynamicAnchors]);
  const g = (0, ae._)`${f}, ${n.object(...d)}`;
  return c !== ae.nil ? (0, ae._)`${o}.call(${c}, ${g})` : (0, ae._)`${o}(${g})`;
}
Q.callValidateCode = Kl;
const Bl = (0, ae._)`new RegExp`;
function zl({ gen: t, it: { opts: e } }, n) {
  const r = e.unicodeRegExp ? "u" : "", { regExp: s } = e.code, i = s(n, r);
  return t.scopeValue("pattern", {
    key: i.toString(),
    ref: i,
    code: (0, ae._)`${s.code === "new RegExp" ? Bl : (0, Ml.useFunc)(t, s)}(${n}, ${r})`
  });
}
Q.usePattern = zl;
function Gl(t) {
  const { gen: e, data: n, keyword: r, it: s } = t, i = e.name("valid");
  if (s.allErrors) {
    const o = e.let("valid", !0);
    return a(() => e.assign(o, !1)), o;
  }
  return e.var(i, !0), a(() => e.break()), i;
  function a(o) {
    const c = e.const("len", (0, ae._)`${n}.length`);
    e.forRange("i", 0, c, (l) => {
      t.subschema({
        keyword: r,
        dataProp: l,
        dataPropType: si.Type.Num
      }, i), e.if((0, ae.not)(i), o);
    });
  }
}
Q.validateArray = Gl;
function Jl(t) {
  const { gen: e, schema: n, keyword: r, it: s } = t;
  if (!Array.isArray(n))
    throw new Error("ajv implementation error");
  if (n.some((c) => (0, si.alwaysValidSchema)(s, c)) && !s.opts.unevaluated)
    return;
  const a = e.let("valid", !1), o = e.name("_valid");
  e.block(() => n.forEach((c, l) => {
    const f = t.subschema({
      keyword: r,
      schemaProp: l,
      compositeRule: !0
    }, o);
    e.assign(a, (0, ae._)`${a} || ${o}`), t.mergeValidEvaluated(f, o) || e.if((0, ae.not)(a));
  })), t.result(a, () => t.reset(), () => t.error(!0));
}
Q.validateUnion = Jl;
Object.defineProperty(Ze, "__esModule", { value: !0 });
Ze.validateKeywordUsage = Ze.validSchemaType = Ze.funcKeywordCode = Ze.macroKeywordCode = void 0;
const we = H, Ot = Te, Hl = Q, Yl = Xn;
function Wl(t, e) {
  const { gen: n, keyword: r, schema: s, parentSchema: i, it: a } = t, o = e.macro.call(a.self, s, i, a), c = wo(n, r, o);
  a.opts.validateSchema !== !1 && a.self.validateSchema(o, !0);
  const l = n.name("valid");
  t.subschema({
    schema: o,
    schemaPath: we.nil,
    errSchemaPath: `${a.errSchemaPath}/${r}`,
    topSchemaRef: c,
    compositeRule: !0
  }, l), t.pass(l, () => t.error(!0));
}
Ze.macroKeywordCode = Wl;
function Ql(t, e) {
  var n;
  const { gen: r, keyword: s, schema: i, parentSchema: a, $data: o, it: c } = t;
  Zl(c, e);
  const l = !o && e.compile ? e.compile.call(c.self, i, a, c) : e.validate, f = wo(r, s, l), d = r.let("valid");
  t.block$data(d, g), t.ok((n = e.valid) !== null && n !== void 0 ? n : d);
  function g() {
    if (e.errors === !1)
      y(), e.modifying && Oa(t), h(() => t.error());
    else {
      const u = e.async ? v() : w();
      e.modifying && Oa(t), h(() => Xl(t, u));
    }
  }
  function v() {
    const u = r.let("ruleErrs", null);
    return r.try(() => y((0, we._)`await `), (p) => r.assign(d, !1).if((0, we._)`${p} instanceof ${c.ValidationError}`, () => r.assign(u, (0, we._)`${p}.errors`), () => r.throw(p))), u;
  }
  function w() {
    const u = (0, we._)`${f}.errors`;
    return r.assign(u, null), y(we.nil), u;
  }
  function y(u = e.async ? (0, we._)`await ` : we.nil) {
    const p = c.opts.passContext ? Ot.default.this : Ot.default.self, b = !("compile" in e && !o || e.schema === !1);
    r.assign(d, (0, we._)`${u}${(0, Hl.callValidateCode)(t, f, p, b)}`, e.modifying);
  }
  function h(u) {
    var p;
    r.if((0, we.not)((p = e.valid) !== null && p !== void 0 ? p : d), u);
  }
}
Ze.funcKeywordCode = Ql;
function Oa(t) {
  const { gen: e, data: n, it: r } = t;
  e.if(r.parentData, () => e.assign(n, (0, we._)`${r.parentData}[${r.parentDataProperty}]`));
}
function Xl(t, e) {
  const { gen: n } = t;
  n.if((0, we._)`Array.isArray(${e})`, () => {
    n.assign(Ot.default.vErrors, (0, we._)`${Ot.default.vErrors} === null ? ${e} : ${Ot.default.vErrors}.concat(${e})`).assign(Ot.default.errors, (0, we._)`${Ot.default.vErrors}.length`), (0, Yl.extendErrors)(t);
  }, () => t.error());
}
function Zl({ schemaEnv: t }, e) {
  if (e.async && !t.$async)
    throw new Error("async keyword in sync schema");
}
function wo(t, e, n) {
  if (n === void 0)
    throw new Error(`keyword "${e}" failed to compile`);
  return t.scopeValue("keyword", typeof n == "function" ? { ref: n } : { ref: n, code: (0, we.stringify)(n) });
}
function xl(t, e, n = !1) {
  return !e.length || e.some((r) => r === "array" ? Array.isArray(t) : r === "object" ? t && typeof t == "object" && !Array.isArray(t) : typeof t == r || n && typeof t > "u");
}
Ze.validSchemaType = xl;
function eu({ schema: t, opts: e, self: n, errSchemaPath: r }, s, i) {
  if (Array.isArray(s.keyword) ? !s.keyword.includes(i) : s.keyword !== i)
    throw new Error("ajv implementation error");
  const a = s.dependencies;
  if (a != null && a.some((o) => !Object.prototype.hasOwnProperty.call(t, o)))
    throw new Error(`parent schema must have dependencies of ${i}: ${a.join(",")}`);
  if (s.validateSchema && !s.validateSchema(t[i])) {
    const c = `keyword "${i}" value is invalid at path "${r}": ` + n.errorsText(s.validateSchema.errors);
    if (e.validateSchema === "log")
      n.logger.error(c);
    else
      throw new Error(c);
  }
}
Ze.validateKeywordUsage = eu;
var pt = {};
Object.defineProperty(pt, "__esModule", { value: !0 });
pt.extendSubschemaMode = pt.extendSubschemaData = pt.getSubschema = void 0;
const Xe = H, So = X;
function tu(t, { keyword: e, schemaProp: n, schema: r, schemaPath: s, errSchemaPath: i, topSchemaRef: a }) {
  if (e !== void 0 && r !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (e !== void 0) {
    const o = t.schema[e];
    return n === void 0 ? {
      schema: o,
      schemaPath: (0, Xe._)`${t.schemaPath}${(0, Xe.getProperty)(e)}`,
      errSchemaPath: `${t.errSchemaPath}/${e}`
    } : {
      schema: o[n],
      schemaPath: (0, Xe._)`${t.schemaPath}${(0, Xe.getProperty)(e)}${(0, Xe.getProperty)(n)}`,
      errSchemaPath: `${t.errSchemaPath}/${e}/${(0, So.escapeFragment)(n)}`
    };
  }
  if (r !== void 0) {
    if (s === void 0 || i === void 0 || a === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: r,
      schemaPath: s,
      topSchemaRef: a,
      errSchemaPath: i
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
pt.getSubschema = tu;
function nu(t, e, { dataProp: n, dataPropType: r, data: s, dataTypes: i, propertyName: a }) {
  if (s !== void 0 && n !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: o } = e;
  if (n !== void 0) {
    const { errorPath: l, dataPathArr: f, opts: d } = e, g = o.let("data", (0, Xe._)`${e.data}${(0, Xe.getProperty)(n)}`, !0);
    c(g), t.errorPath = (0, Xe.str)`${l}${(0, So.getErrorPath)(n, r, d.jsPropertySyntax)}`, t.parentDataProperty = (0, Xe._)`${n}`, t.dataPathArr = [...f, t.parentDataProperty];
  }
  if (s !== void 0) {
    const l = s instanceof Xe.Name ? s : o.let("data", s, !0);
    c(l), a !== void 0 && (t.propertyName = a);
  }
  i && (t.dataTypes = i);
  function c(l) {
    t.data = l, t.dataLevel = e.dataLevel + 1, t.dataTypes = [], e.definedProperties = /* @__PURE__ */ new Set(), t.parentData = e.data, t.dataNames = [...e.dataNames, l];
  }
}
pt.extendSubschemaData = nu;
function ru(t, { jtdDiscriminator: e, jtdMetadata: n, compositeRule: r, createErrors: s, allErrors: i }) {
  r !== void 0 && (t.compositeRule = r), s !== void 0 && (t.createErrors = s), i !== void 0 && (t.allErrors = i), t.jtdDiscriminator = e, t.jtdMetadata = n;
}
pt.extendSubschemaMode = ru;
var ve = {}, Eo = function t(e, n) {
  if (e === n)
    return !0;
  if (e && n && typeof e == "object" && typeof n == "object") {
    if (e.constructor !== n.constructor)
      return !1;
    var r, s, i;
    if (Array.isArray(e)) {
      if (r = e.length, r != n.length)
        return !1;
      for (s = r; s-- !== 0; )
        if (!t(e[s], n[s]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === n.source && e.flags === n.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === n.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === n.toString();
    if (i = Object.keys(e), r = i.length, r !== Object.keys(n).length)
      return !1;
    for (s = r; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[s]))
        return !1;
    for (s = r; s-- !== 0; ) {
      var a = i[s];
      if (!t(e[a], n[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && n !== n;
}, Oo = { exports: {} }, mt = Oo.exports = function(t, e, n) {
  typeof e == "function" && (n = e, e = {}), n = e.cb || n;
  var r = typeof n == "function" ? n : n.pre || function() {
  }, s = n.post || function() {
  };
  _r(e, r, s, t, "", t);
};
mt.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
mt.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
mt.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
mt.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function _r(t, e, n, r, s, i, a, o, c, l) {
  if (r && typeof r == "object" && !Array.isArray(r)) {
    e(r, s, i, a, o, c, l);
    for (var f in r) {
      var d = r[f];
      if (Array.isArray(d)) {
        if (f in mt.arrayKeywords)
          for (var g = 0; g < d.length; g++)
            _r(t, e, n, d[g], s + "/" + f + "/" + g, i, s, f, r, g);
      } else if (f in mt.propsKeywords) {
        if (d && typeof d == "object")
          for (var v in d)
            _r(t, e, n, d[v], s + "/" + f + "/" + su(v), i, s, f, r, v);
      } else
        (f in mt.keywords || t.allKeys && !(f in mt.skipKeywords)) && _r(t, e, n, d, s + "/" + f, i, s, f, r);
    }
    n(r, s, i, a, o, c, l);
  }
}
function su(t) {
  return t.replace(/~/g, "~0").replace(/\//g, "~1");
}
var iu = Oo.exports;
Object.defineProperty(ve, "__esModule", { value: !0 });
ve.getSchemaRefs = ve.resolveUrl = ve.normalizeId = ve._getFullPath = ve.getFullPath = ve.inlineRef = void 0;
const au = X, ou = Eo, cu = iu, lu = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function uu(t, e = !0) {
  return typeof t == "boolean" ? !0 : e === !0 ? !Vs(t) : e ? No(t) <= e : !1;
}
ve.inlineRef = uu;
const fu = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function Vs(t) {
  for (const e in t) {
    if (fu.has(e))
      return !0;
    const n = t[e];
    if (Array.isArray(n) && n.some(Vs) || typeof n == "object" && Vs(n))
      return !0;
  }
  return !1;
}
function No(t) {
  let e = 0;
  for (const n in t) {
    if (n === "$ref")
      return 1 / 0;
    if (e++, !lu.has(n) && (typeof t[n] == "object" && (0, au.eachItem)(t[n], (r) => e += No(r)), e === 1 / 0))
      return 1 / 0;
  }
  return e;
}
function Po(t, e = "", n) {
  n !== !1 && (e = nn(e));
  const r = t.parse(e);
  return ko(t, r);
}
ve.getFullPath = Po;
function ko(t, e) {
  return t.serialize(e).split("#")[0] + "#";
}
ve._getFullPath = ko;
const du = /#\/?$/;
function nn(t) {
  return t ? t.replace(du, "") : "";
}
ve.normalizeId = nn;
function hu(t, e, n) {
  return n = nn(n), t.resolve(e, n);
}
ve.resolveUrl = hu;
const mu = /^[a-z_][-a-z0-9._]*$/i;
function pu(t, e) {
  if (typeof t == "boolean")
    return {};
  const { schemaId: n, uriResolver: r } = this.opts, s = nn(t[n] || e), i = { "": s }, a = Po(r, s, !1), o = {}, c = /* @__PURE__ */ new Set();
  return cu(t, { allKeys: !0 }, (d, g, v, w) => {
    if (w === void 0)
      return;
    const y = a + g;
    let h = i[w];
    typeof d[n] == "string" && (h = u.call(this, d[n])), p.call(this, d.$anchor), p.call(this, d.$dynamicAnchor), i[g] = h;
    function u(b) {
      const E = this.opts.uriResolver.resolve;
      if (b = nn(h ? E(h, b) : b), c.has(b))
        throw f(b);
      c.add(b);
      let C = this.refs[b];
      return typeof C == "string" && (C = this.refs[C]), typeof C == "object" ? l(d, C.schema, b) : b !== nn(y) && (b[0] === "#" ? (l(d, o[b], b), o[b] = d) : this.refs[b] = y), b;
    }
    function p(b) {
      if (typeof b == "string") {
        if (!mu.test(b))
          throw new Error(`invalid anchor "${b}"`);
        u.call(this, `#${b}`);
      }
    }
  }), o;
  function l(d, g, v) {
    if (g !== void 0 && !ou(d, g))
      throw f(v);
  }
  function f(d) {
    return new Error(`reference "${d}" resolves to more than one schema`);
  }
}
ve.getSchemaRefs = pu;
Object.defineProperty(Me, "__esModule", { value: !0 });
Me.getData = Me.KeywordCxt = Me.validateFunctionCode = void 0;
const Ao = an, Na = Zn, oi = it, Ar = Zn, yu = Vr, Un = Ze, $s = pt, K = H, J = Te, gu = ve, at = X, jn = Xn;
function $u(t) {
  if (Co(t) && (jo(t), Io(t))) {
    _u(t);
    return;
  }
  To(t, () => (0, Ao.topBoolOrEmptySchema)(t));
}
Me.validateFunctionCode = $u;
function To({ gen: t, validateName: e, schema: n, schemaEnv: r, opts: s }, i) {
  s.code.es5 ? t.func(e, (0, K._)`${J.default.data}, ${J.default.valCxt}`, r.$async, () => {
    t.code((0, K._)`"use strict"; ${Pa(n, s)}`), bu(t, s), t.code(i);
  }) : t.func(e, (0, K._)`${J.default.data}, ${vu(s)}`, r.$async, () => t.code(Pa(n, s)).code(i));
}
function vu(t) {
  return (0, K._)`{${J.default.instancePath}="", ${J.default.parentData}, ${J.default.parentDataProperty}, ${J.default.rootData}=${J.default.data}${t.dynamicRef ? (0, K._)`, ${J.default.dynamicAnchors}={}` : K.nil}}={}`;
}
function bu(t, e) {
  t.if(J.default.valCxt, () => {
    t.var(J.default.instancePath, (0, K._)`${J.default.valCxt}.${J.default.instancePath}`), t.var(J.default.parentData, (0, K._)`${J.default.valCxt}.${J.default.parentData}`), t.var(J.default.parentDataProperty, (0, K._)`${J.default.valCxt}.${J.default.parentDataProperty}`), t.var(J.default.rootData, (0, K._)`${J.default.valCxt}.${J.default.rootData}`), e.dynamicRef && t.var(J.default.dynamicAnchors, (0, K._)`${J.default.valCxt}.${J.default.dynamicAnchors}`);
  }, () => {
    t.var(J.default.instancePath, (0, K._)`""`), t.var(J.default.parentData, (0, K._)`undefined`), t.var(J.default.parentDataProperty, (0, K._)`undefined`), t.var(J.default.rootData, J.default.data), e.dynamicRef && t.var(J.default.dynamicAnchors, (0, K._)`{}`);
  });
}
function _u(t) {
  const { schema: e, opts: n, gen: r } = t;
  To(t, () => {
    n.$comment && e.$comment && Do(t), Nu(t), r.let(J.default.vErrors, null), r.let(J.default.errors, 0), n.unevaluated && wu(t), Ro(t), Au(t);
  });
}
function wu(t) {
  const { gen: e, validateName: n } = t;
  t.evaluated = e.const("evaluated", (0, K._)`${n}.evaluated`), e.if((0, K._)`${t.evaluated}.dynamicProps`, () => e.assign((0, K._)`${t.evaluated}.props`, (0, K._)`undefined`)), e.if((0, K._)`${t.evaluated}.dynamicItems`, () => e.assign((0, K._)`${t.evaluated}.items`, (0, K._)`undefined`));
}
function Pa(t, e) {
  const n = typeof t == "object" && t[e.schemaId];
  return n && (e.code.source || e.code.process) ? (0, K._)`/*# sourceURL=${n} */` : K.nil;
}
function Su(t, e) {
  if (Co(t) && (jo(t), Io(t))) {
    Eu(t, e);
    return;
  }
  (0, Ao.boolOrEmptySchema)(t, e);
}
function Io({ schema: t, self: e }) {
  if (typeof t == "boolean")
    return !t;
  for (const n in t)
    if (e.RULES.all[n])
      return !0;
  return !1;
}
function Co(t) {
  return typeof t.schema != "boolean";
}
function Eu(t, e) {
  const { schema: n, gen: r, opts: s } = t;
  s.$comment && n.$comment && Do(t), Pu(t), ku(t);
  const i = r.const("_errs", J.default.errors);
  Ro(t, i), r.var(e, (0, K._)`${i} === ${J.default.errors}`);
}
function jo(t) {
  (0, at.checkUnknownRules)(t), Ou(t);
}
function Ro(t, e) {
  if (t.opts.jtd)
    return ka(t, [], !1, e);
  const n = (0, Na.getSchemaTypes)(t.schema), r = (0, Na.coerceAndCheckDataType)(t, n);
  ka(t, n, !r, e);
}
function Ou(t) {
  const { schema: e, errSchemaPath: n, opts: r, self: s } = t;
  e.$ref && r.ignoreKeywordsWithRef && (0, at.schemaHasRulesButRef)(e, s.RULES) && s.logger.warn(`$ref: keywords ignored in schema at path "${n}"`);
}
function Nu(t) {
  const { schema: e, opts: n } = t;
  e.default !== void 0 && n.useDefaults && n.strictSchema && (0, at.checkStrictMode)(t, "default is ignored in the schema root");
}
function Pu(t) {
  const e = t.schema[t.opts.schemaId];
  e && (t.baseId = (0, gu.resolveUrl)(t.opts.uriResolver, t.baseId, e));
}
function ku(t) {
  if (t.schema.$async && !t.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function Do({ gen: t, schemaEnv: e, schema: n, errSchemaPath: r, opts: s }) {
  const i = n.$comment;
  if (s.$comment === !0)
    t.code((0, K._)`${J.default.self}.logger.log(${i})`);
  else if (typeof s.$comment == "function") {
    const a = (0, K.str)`${r}/$comment`, o = t.scopeValue("root", { ref: e.root });
    t.code((0, K._)`${J.default.self}.opts.$comment(${i}, ${a}, ${o}.schema)`);
  }
}
function Au(t) {
  const { gen: e, schemaEnv: n, validateName: r, ValidationError: s, opts: i } = t;
  n.$async ? e.if((0, K._)`${J.default.errors} === 0`, () => e.return(J.default.data), () => e.throw((0, K._)`new ${s}(${J.default.vErrors})`)) : (e.assign((0, K._)`${r}.errors`, J.default.vErrors), i.unevaluated && Tu(t), e.return((0, K._)`${J.default.errors} === 0`));
}
function Tu({ gen: t, evaluated: e, props: n, items: r }) {
  n instanceof K.Name && t.assign((0, K._)`${e}.props`, n), r instanceof K.Name && t.assign((0, K._)`${e}.items`, r);
}
function ka(t, e, n, r) {
  const { gen: s, schema: i, data: a, allErrors: o, opts: c, self: l } = t, { RULES: f } = l;
  if (i.$ref && (c.ignoreKeywordsWithRef || !(0, at.schemaHasRulesButRef)(i, f))) {
    s.block(() => Vo(t, "$ref", f.all.$ref.definition));
    return;
  }
  c.jtd || Iu(t, e), s.block(() => {
    for (const g of f.rules)
      d(g);
    d(f.post);
  });
  function d(g) {
    (0, oi.shouldUseGroup)(i, g) && (g.type ? (s.if((0, Ar.checkDataType)(g.type, a, c.strictNumbers)), Aa(t, g), e.length === 1 && e[0] === g.type && n && (s.else(), (0, Ar.reportTypeError)(t)), s.endIf()) : Aa(t, g), o || s.if((0, K._)`${J.default.errors} === ${r || 0}`));
  }
}
function Aa(t, e) {
  const { gen: n, schema: r, opts: { useDefaults: s } } = t;
  s && (0, yu.assignDefaults)(t, e.type), n.block(() => {
    for (const i of e.rules)
      (0, oi.shouldUseRule)(r, i) && Vo(t, i.keyword, i.definition, e.type);
  });
}
function Iu(t, e) {
  t.schemaEnv.meta || !t.opts.strictTypes || (Cu(t, e), t.opts.allowUnionTypes || ju(t, e), Ru(t, t.dataTypes));
}
function Cu(t, e) {
  if (e.length) {
    if (!t.dataTypes.length) {
      t.dataTypes = e;
      return;
    }
    e.forEach((n) => {
      Mo(t.dataTypes, n) || ci(t, `type "${n}" not allowed by context "${t.dataTypes.join(",")}"`);
    }), Mu(t, e);
  }
}
function ju(t, e) {
  e.length > 1 && !(e.length === 2 && e.includes("null")) && ci(t, "use allowUnionTypes to allow union type keyword");
}
function Ru(t, e) {
  const n = t.self.RULES.all;
  for (const r in n) {
    const s = n[r];
    if (typeof s == "object" && (0, oi.shouldUseRule)(t.schema, s)) {
      const { type: i } = s.definition;
      i.length && !i.some((a) => Du(e, a)) && ci(t, `missing type "${i.join(",")}" for keyword "${r}"`);
    }
  }
}
function Du(t, e) {
  return t.includes(e) || e === "number" && t.includes("integer");
}
function Mo(t, e) {
  return t.includes(e) || e === "integer" && t.includes("number");
}
function Mu(t, e) {
  const n = [];
  for (const r of t.dataTypes)
    Mo(e, r) ? n.push(r) : e.includes("integer") && r === "number" && n.push("integer");
  t.dataTypes = n;
}
function ci(t, e) {
  const n = t.schemaEnv.baseId + t.errSchemaPath;
  e += ` at "${n}" (strictTypes)`, (0, at.checkStrictMode)(t, e, t.opts.strictTypes);
}
class Lo {
  constructor(e, n, r) {
    if ((0, Un.validateKeywordUsage)(e, n, r), this.gen = e.gen, this.allErrors = e.allErrors, this.keyword = r, this.data = e.data, this.schema = e.schema[r], this.$data = n.$data && e.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, at.schemaRefOrVal)(e, this.schema, r, this.$data), this.schemaType = n.schemaType, this.parentSchema = e.schema, this.params = {}, this.it = e, this.def = n, this.$data)
      this.schemaCode = e.gen.const("vSchema", Fo(this.$data, e));
    else if (this.schemaCode = this.schemaValue, !(0, Un.validSchemaType)(this.schema, n.schemaType, n.allowUndefined))
      throw new Error(`${r} value must be ${JSON.stringify(n.schemaType)}`);
    ("code" in n ? n.trackErrors : n.errors !== !1) && (this.errsCount = e.gen.const("_errs", J.default.errors));
  }
  result(e, n, r) {
    this.failResult((0, K.not)(e), n, r);
  }
  failResult(e, n, r) {
    this.gen.if(e), r ? r() : this.error(), n ? (this.gen.else(), n(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(e, n) {
    this.failResult((0, K.not)(e), void 0, n);
  }
  fail(e) {
    if (e === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(e), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(e) {
    if (!this.$data)
      return this.fail(e);
    const { schemaCode: n } = this;
    this.fail((0, K._)`${n} !== undefined && (${(0, K.or)(this.invalid$data(), e)})`);
  }
  error(e, n, r) {
    if (n) {
      this.setParams(n), this._error(e, r), this.setParams({});
      return;
    }
    this._error(e, r);
  }
  _error(e, n) {
    (e ? jn.reportExtraError : jn.reportError)(this, this.def.error, n);
  }
  $dataError() {
    (0, jn.reportError)(this, this.def.$dataError || jn.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, jn.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(e) {
    this.allErrors || this.gen.if(e);
  }
  setParams(e, n) {
    n ? Object.assign(this.params, e) : this.params = e;
  }
  block$data(e, n, r = K.nil) {
    this.gen.block(() => {
      this.check$data(e, r), n();
    });
  }
  check$data(e = K.nil, n = K.nil) {
    if (!this.$data)
      return;
    const { gen: r, schemaCode: s, schemaType: i, def: a } = this;
    r.if((0, K.or)((0, K._)`${s} === undefined`, n)), e !== K.nil && r.assign(e, !0), (i.length || a.validateSchema) && (r.elseIf(this.invalid$data()), this.$dataError(), e !== K.nil && r.assign(e, !1)), r.else();
  }
  invalid$data() {
    const { gen: e, schemaCode: n, schemaType: r, def: s, it: i } = this;
    return (0, K.or)(a(), o());
    function a() {
      if (r.length) {
        if (!(n instanceof K.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(r) ? r : [r];
        return (0, K._)`${(0, Ar.checkDataTypes)(c, n, i.opts.strictNumbers, Ar.DataType.Wrong)}`;
      }
      return K.nil;
    }
    function o() {
      if (s.validateSchema) {
        const c = e.scopeValue("validate$data", { ref: s.validateSchema });
        return (0, K._)`!${c}(${n})`;
      }
      return K.nil;
    }
  }
  subschema(e, n) {
    const r = (0, $s.getSubschema)(this.it, e);
    (0, $s.extendSubschemaData)(r, this.it, e), (0, $s.extendSubschemaMode)(r, e);
    const s = { ...this.it, ...r, items: void 0, props: void 0 };
    return Su(s, n), s;
  }
  mergeEvaluated(e, n) {
    const { it: r, gen: s } = this;
    r.opts.unevaluated && (r.props !== !0 && e.props !== void 0 && (r.props = at.mergeEvaluated.props(s, e.props, r.props, n)), r.items !== !0 && e.items !== void 0 && (r.items = at.mergeEvaluated.items(s, e.items, r.items, n)));
  }
  mergeValidEvaluated(e, n) {
    const { it: r, gen: s } = this;
    if (r.opts.unevaluated && (r.props !== !0 || r.items !== !0))
      return s.if(n, () => this.mergeEvaluated(e, K.Name)), !0;
  }
}
Me.KeywordCxt = Lo;
function Vo(t, e, n, r) {
  const s = new Lo(t, n, e);
  "code" in n ? n.code(s, r) : s.$data && n.validate ? (0, Un.funcKeywordCode)(s, n) : "macro" in n ? (0, Un.macroKeywordCode)(s, n) : (n.compile || n.validate) && (0, Un.funcKeywordCode)(s, n);
}
const Lu = /^\/(?:[^~]|~0|~1)*$/, Vu = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function Fo(t, { dataLevel: e, dataNames: n, dataPathArr: r }) {
  let s, i;
  if (t === "")
    return J.default.rootData;
  if (t[0] === "/") {
    if (!Lu.test(t))
      throw new Error(`Invalid JSON-pointer: ${t}`);
    s = t, i = J.default.rootData;
  } else {
    const l = Vu.exec(t);
    if (!l)
      throw new Error(`Invalid JSON-pointer: ${t}`);
    const f = +l[1];
    if (s = l[2], s === "#") {
      if (f >= e)
        throw new Error(c("property/index", f));
      return r[e - f];
    }
    if (f > e)
      throw new Error(c("data", f));
    if (i = n[e - f], !s)
      return i;
  }
  let a = i;
  const o = s.split("/");
  for (const l of o)
    l && (i = (0, K._)`${i}${(0, K.getProperty)((0, at.unescapeJsonPointer)(l))}`, a = (0, K._)`${a} && ${i}`);
  return a;
  function c(l, f) {
    return `Cannot access ${l} ${f} levels up, current level is ${e}`;
  }
}
Me.getData = Fo;
var ln = {};
Object.defineProperty(ln, "__esModule", { value: !0 });
class Fu extends Error {
  constructor(e) {
    super("validation failed"), this.errors = e, this.ajv = this.validation = !0;
  }
}
ln.default = Fu;
var un = {};
Object.defineProperty(un, "__esModule", { value: !0 });
const vs = ve;
class Uu extends Error {
  constructor(e, n, r, s) {
    super(s || `can't resolve reference ${r} from id ${n}`), this.missingRef = (0, vs.resolveUrl)(e, n, r), this.missingSchema = (0, vs.normalizeId)((0, vs.getFullPath)(e, this.missingRef));
  }
}
un.default = Uu;
var Ee = {};
Object.defineProperty(Ee, "__esModule", { value: !0 });
Ee.resolveSchema = Ee.getCompilingSchema = Ee.resolveRef = Ee.compileSchema = Ee.SchemaEnv = void 0;
const Fe = H, qu = ln, Et = Te, Ke = ve, Ta = X, Ku = Me;
class Fr {
  constructor(e) {
    var n;
    this.refs = {}, this.dynamicAnchors = {};
    let r;
    typeof e.schema == "object" && (r = e.schema), this.schema = e.schema, this.schemaId = e.schemaId, this.root = e.root || this, this.baseId = (n = e.baseId) !== null && n !== void 0 ? n : (0, Ke.normalizeId)(r == null ? void 0 : r[e.schemaId || "$id"]), this.schemaPath = e.schemaPath, this.localRefs = e.localRefs, this.meta = e.meta, this.$async = r == null ? void 0 : r.$async, this.refs = {};
  }
}
Ee.SchemaEnv = Fr;
function li(t) {
  const e = Uo.call(this, t);
  if (e)
    return e;
  const n = (0, Ke.getFullPath)(this.opts.uriResolver, t.root.baseId), { es5: r, lines: s } = this.opts.code, { ownProperties: i } = this.opts, a = new Fe.CodeGen(this.scope, { es5: r, lines: s, ownProperties: i });
  let o;
  t.$async && (o = a.scopeValue("Error", {
    ref: qu.default,
    code: (0, Fe._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = a.scopeName("validate");
  t.validateName = c;
  const l = {
    gen: a,
    allErrors: this.opts.allErrors,
    data: Et.default.data,
    parentData: Et.default.parentData,
    parentDataProperty: Et.default.parentDataProperty,
    dataNames: [Et.default.data],
    dataPathArr: [Fe.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: a.scopeValue("schema", this.opts.code.source === !0 ? { ref: t.schema, code: (0, Fe.stringify)(t.schema) } : { ref: t.schema }),
    validateName: c,
    ValidationError: o,
    schema: t.schema,
    schemaEnv: t,
    rootId: n,
    baseId: t.baseId || n,
    schemaPath: Fe.nil,
    errSchemaPath: t.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Fe._)`""`,
    opts: this.opts,
    self: this
  };
  let f;
  try {
    this._compilations.add(t), (0, Ku.validateFunctionCode)(l), a.optimize(this.opts.code.optimize);
    const d = a.toString();
    f = `${a.scopeRefs(Et.default.scope)}return ${d}`, this.opts.code.process && (f = this.opts.code.process(f, t));
    const v = new Function(`${Et.default.self}`, `${Et.default.scope}`, f)(this, this.scope.get());
    if (this.scope.value(c, { ref: v }), v.errors = null, v.schema = t.schema, v.schemaEnv = t, t.$async && (v.$async = !0), this.opts.code.source === !0 && (v.source = { validateName: c, validateCode: d, scopeValues: a._values }), this.opts.unevaluated) {
      const { props: w, items: y } = l;
      v.evaluated = {
        props: w instanceof Fe.Name ? void 0 : w,
        items: y instanceof Fe.Name ? void 0 : y,
        dynamicProps: w instanceof Fe.Name,
        dynamicItems: y instanceof Fe.Name
      }, v.source && (v.source.evaluated = (0, Fe.stringify)(v.evaluated));
    }
    return t.validate = v, t;
  } catch (d) {
    throw delete t.validate, delete t.validateName, f && this.logger.error("Error compiling schema, function code:", f), d;
  } finally {
    this._compilations.delete(t);
  }
}
Ee.compileSchema = li;
function Bu(t, e, n) {
  var r;
  n = (0, Ke.resolveUrl)(this.opts.uriResolver, e, n);
  const s = t.refs[n];
  if (s)
    return s;
  let i = Ju.call(this, t, n);
  if (i === void 0) {
    const a = (r = t.localRefs) === null || r === void 0 ? void 0 : r[n], { schemaId: o } = this.opts;
    a && (i = new Fr({ schema: a, schemaId: o, root: t, baseId: e }));
  }
  if (i !== void 0)
    return t.refs[n] = zu.call(this, i);
}
Ee.resolveRef = Bu;
function zu(t) {
  return (0, Ke.inlineRef)(t.schema, this.opts.inlineRefs) ? t.schema : t.validate ? t : li.call(this, t);
}
function Uo(t) {
  for (const e of this._compilations)
    if (Gu(e, t))
      return e;
}
Ee.getCompilingSchema = Uo;
function Gu(t, e) {
  return t.schema === e.schema && t.root === e.root && t.baseId === e.baseId;
}
function Ju(t, e) {
  let n;
  for (; typeof (n = this.refs[e]) == "string"; )
    e = n;
  return n || this.schemas[e] || Ur.call(this, t, e);
}
function Ur(t, e) {
  const n = this.opts.uriResolver.parse(e), r = (0, Ke._getFullPath)(this.opts.uriResolver, n);
  let s = (0, Ke.getFullPath)(this.opts.uriResolver, t.baseId, void 0);
  if (Object.keys(t.schema).length > 0 && r === s)
    return bs.call(this, n, t);
  const i = (0, Ke.normalizeId)(r), a = this.refs[i] || this.schemas[i];
  if (typeof a == "string") {
    const o = Ur.call(this, t, a);
    return typeof (o == null ? void 0 : o.schema) != "object" ? void 0 : bs.call(this, n, o);
  }
  if (typeof (a == null ? void 0 : a.schema) == "object") {
    if (a.validate || li.call(this, a), i === (0, Ke.normalizeId)(e)) {
      const { schema: o } = a, { schemaId: c } = this.opts, l = o[c];
      return l && (s = (0, Ke.resolveUrl)(this.opts.uriResolver, s, l)), new Fr({ schema: o, schemaId: c, root: t, baseId: s });
    }
    return bs.call(this, n, a);
  }
}
Ee.resolveSchema = Ur;
const Hu = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function bs(t, { baseId: e, schema: n, root: r }) {
  var s;
  if (((s = t.fragment) === null || s === void 0 ? void 0 : s[0]) !== "/")
    return;
  for (const o of t.fragment.slice(1).split("/")) {
    if (typeof n == "boolean")
      return;
    const c = n[(0, Ta.unescapeFragment)(o)];
    if (c === void 0)
      return;
    n = c;
    const l = typeof n == "object" && n[this.opts.schemaId];
    !Hu.has(o) && l && (e = (0, Ke.resolveUrl)(this.opts.uriResolver, e, l));
  }
  let i;
  if (typeof n != "boolean" && n.$ref && !(0, Ta.schemaHasRulesButRef)(n, this.RULES)) {
    const o = (0, Ke.resolveUrl)(this.opts.uriResolver, e, n.$ref);
    i = Ur.call(this, r, o);
  }
  const { schemaId: a } = this.opts;
  if (i = i || new Fr({ schema: n, schemaId: a, root: r, baseId: e }), i.schema !== i.root.schema)
    return i;
}
const Yu = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", Wu = "Meta-schema for $data reference (JSON AnySchema extension proposal)", Qu = "object", Xu = [
  "$data"
], Zu = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, xu = !1, ef = {
  $id: Yu,
  description: Wu,
  type: Qu,
  required: Xu,
  properties: Zu,
  additionalProperties: xu
};
var ui = {}, Fs = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(t, e) {
  (function(n, r) {
    r(e);
  })(_l, function(n) {
    function r() {
      for (var S = arguments.length, $ = Array(S), N = 0; N < S; N++)
        $[N] = arguments[N];
      if ($.length > 1) {
        $[0] = $[0].slice(0, -1);
        for (var I = $.length - 1, T = 1; T < I; ++T)
          $[T] = $[T].slice(1, -1);
        return $[I] = $[I].slice(1), $.join("");
      } else
        return $[0];
    }
    function s(S) {
      return "(?:" + S + ")";
    }
    function i(S) {
      return S === void 0 ? "undefined" : S === null ? "null" : Object.prototype.toString.call(S).split(" ").pop().split("]").shift().toLowerCase();
    }
    function a(S) {
      return S.toUpperCase();
    }
    function o(S) {
      return S != null ? S instanceof Array ? S : typeof S.length != "number" || S.split || S.setInterval || S.call ? [S] : Array.prototype.slice.call(S) : [];
    }
    function c(S, $) {
      var N = S;
      if ($)
        for (var I in $)
          N[I] = $[I];
      return N;
    }
    function l(S) {
      var $ = "[A-Za-z]", N = "[0-9]", I = r(N, "[A-Fa-f]"), T = s(s("%[EFef]" + I + "%" + I + I + "%" + I + I) + "|" + s("%[89A-Fa-f]" + I + "%" + I + I) + "|" + s("%" + I + I)), B = "[\\:\\/\\?\\#\\[\\]\\@]", z = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", te = r(B, z), ie = S ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", de = S ? "[\\uE000-\\uF8FF]" : "[]", x = r($, N, "[\\-\\.\\_\\~]", ie);
      s($ + r($, N, "[\\+\\-\\.]") + "*"), s(s(T + "|" + r(x, z, "[\\:]")) + "*");
      var ne = s(s("25[0-5]") + "|" + s("2[0-4]" + N) + "|" + s("1" + N + N) + "|" + s("0?[1-9]" + N) + "|0?0?" + N), he = s(ne + "\\." + ne + "\\." + ne + "\\." + ne), Y = s(I + "{1,4}"), oe = s(s(Y + "\\:" + Y) + "|" + he), ge = s(s(Y + "\\:") + "{6}" + oe), ce = s("\\:\\:" + s(Y + "\\:") + "{5}" + oe), ct = s(s(Y) + "?\\:\\:" + s(Y + "\\:") + "{4}" + oe), He = s(s(s(Y + "\\:") + "{0,1}" + Y) + "?\\:\\:" + s(Y + "\\:") + "{3}" + oe), Ye = s(s(s(Y + "\\:") + "{0,2}" + Y) + "?\\:\\:" + s(Y + "\\:") + "{2}" + oe), Gt = s(s(s(Y + "\\:") + "{0,3}" + Y) + "?\\:\\:" + Y + "\\:" + oe), wt = s(s(s(Y + "\\:") + "{0,4}" + Y) + "?\\:\\:" + oe), je = s(s(s(Y + "\\:") + "{0,5}" + Y) + "?\\:\\:" + Y), We = s(s(s(Y + "\\:") + "{0,6}" + Y) + "?\\:\\:"), St = s([ge, ce, ct, He, Ye, Gt, wt, je, We].join("|")), tt = s(s(x + "|" + T) + "+");
      s("[vV]" + I + "+\\." + r(x, z, "[\\:]") + "+"), s(s(T + "|" + r(x, z)) + "*");
      var In = s(T + "|" + r(x, z, "[\\:\\@]"));
      return s(s(T + "|" + r(x, z, "[\\@]")) + "+"), s(s(In + "|" + r("[\\/\\?]", de)) + "*"), {
        NOT_SCHEME: new RegExp(r("[^]", $, N, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(r("[^\\%\\:]", x, z), "g"),
        NOT_HOST: new RegExp(r("[^\\%\\[\\]\\:]", x, z), "g"),
        NOT_PATH: new RegExp(r("[^\\%\\/\\:\\@]", x, z), "g"),
        NOT_PATH_NOSCHEME: new RegExp(r("[^\\%\\/\\@]", x, z), "g"),
        NOT_QUERY: new RegExp(r("[^\\%]", x, z, "[\\:\\@\\/\\?]", de), "g"),
        NOT_FRAGMENT: new RegExp(r("[^\\%]", x, z, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(r("[^]", x, z), "g"),
        UNRESERVED: new RegExp(x, "g"),
        OTHER_CHARS: new RegExp(r("[^\\%]", x, te), "g"),
        PCT_ENCODED: new RegExp(T, "g"),
        IPV4ADDRESS: new RegExp("^(" + he + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + St + ")" + s(s("\\%25|\\%(?!" + I + "{2})") + "(" + tt + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var f = l(!1), d = l(!0), g = /* @__PURE__ */ function() {
      function S($, N) {
        var I = [], T = !0, B = !1, z = void 0;
        try {
          for (var te = $[Symbol.iterator](), ie; !(T = (ie = te.next()).done) && (I.push(ie.value), !(N && I.length === N)); T = !0)
            ;
        } catch (de) {
          B = !0, z = de;
        } finally {
          try {
            !T && te.return && te.return();
          } finally {
            if (B)
              throw z;
          }
        }
        return I;
      }
      return function($, N) {
        if (Array.isArray($))
          return $;
        if (Symbol.iterator in Object($))
          return S($, N);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), v = function(S) {
      if (Array.isArray(S)) {
        for (var $ = 0, N = Array(S.length); $ < S.length; $++)
          N[$] = S[$];
        return N;
      } else
        return Array.from(S);
    }, w = 2147483647, y = 36, h = 1, u = 26, p = 38, b = 700, E = 72, C = 128, _ = "-", P = /^xn--/, R = /[^\0-\x7E]/, D = /[\x2E\u3002\uFF0E\uFF61]/g, V = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, G = y - h, U = Math.floor, ye = String.fromCharCode;
    function se(S) {
      throw new RangeError(V[S]);
    }
    function Ie(S, $) {
      for (var N = [], I = S.length; I--; )
        N[I] = $(S[I]);
      return N;
    }
    function vt(S, $) {
      var N = S.split("@"), I = "";
      N.length > 1 && (I = N[0] + "@", S = N[1]), S = S.replace(D, ".");
      var T = S.split("."), B = Ie(T, $).join(".");
      return I + B;
    }
    function Lt(S) {
      for (var $ = [], N = 0, I = S.length; N < I; ) {
        var T = S.charCodeAt(N++);
        if (T >= 55296 && T <= 56319 && N < I) {
          var B = S.charCodeAt(N++);
          (B & 64512) == 56320 ? $.push(((T & 1023) << 10) + (B & 1023) + 65536) : ($.push(T), N--);
        } else
          $.push(T);
      }
      return $;
    }
    var Sn = function($) {
      return String.fromCodePoint.apply(String, v($));
    }, Vt = function($) {
      return $ - 48 < 10 ? $ - 22 : $ - 65 < 26 ? $ - 65 : $ - 97 < 26 ? $ - 97 : y;
    }, L = function($, N) {
      return $ + 22 + 75 * ($ < 26) - ((N != 0) << 5);
    }, k = function($, N, I) {
      var T = 0;
      for (
        $ = I ? U($ / b) : $ >> 1, $ += U($ / N);
        /* no initialization */
        $ > G * u >> 1;
        T += y
      )
        $ = U($ / G);
      return U(T + (G + 1) * $ / ($ + p));
    }, M = function($) {
      var N = [], I = $.length, T = 0, B = C, z = E, te = $.lastIndexOf(_);
      te < 0 && (te = 0);
      for (var ie = 0; ie < te; ++ie)
        $.charCodeAt(ie) >= 128 && se("not-basic"), N.push($.charCodeAt(ie));
      for (var de = te > 0 ? te + 1 : 0; de < I; ) {
        for (
          var x = T, ne = 1, he = y;
          ;
          /* no condition */
          he += y
        ) {
          de >= I && se("invalid-input");
          var Y = Vt($.charCodeAt(de++));
          (Y >= y || Y > U((w - T) / ne)) && se("overflow"), T += Y * ne;
          var oe = he <= z ? h : he >= z + u ? u : he - z;
          if (Y < oe)
            break;
          var ge = y - oe;
          ne > U(w / ge) && se("overflow"), ne *= ge;
        }
        var ce = N.length + 1;
        z = k(T - x, ce, x == 0), U(T / ce) > w - B && se("overflow"), B += U(T / ce), T %= ce, N.splice(T++, 0, B);
      }
      return String.fromCodePoint.apply(String, N);
    }, A = function($) {
      var N = [];
      $ = Lt($);
      var I = $.length, T = C, B = 0, z = E, te = !0, ie = !1, de = void 0;
      try {
        for (var x = $[Symbol.iterator](), ne; !(te = (ne = x.next()).done); te = !0) {
          var he = ne.value;
          he < 128 && N.push(ye(he));
        }
      } catch (Cn) {
        ie = !0, de = Cn;
      } finally {
        try {
          !te && x.return && x.return();
        } finally {
          if (ie)
            throw de;
        }
      }
      var Y = N.length, oe = Y;
      for (Y && N.push(_); oe < I; ) {
        var ge = w, ce = !0, ct = !1, He = void 0;
        try {
          for (var Ye = $[Symbol.iterator](), Gt; !(ce = (Gt = Ye.next()).done); ce = !0) {
            var wt = Gt.value;
            wt >= T && wt < ge && (ge = wt);
          }
        } catch (Cn) {
          ct = !0, He = Cn;
        } finally {
          try {
            !ce && Ye.return && Ye.return();
          } finally {
            if (ct)
              throw He;
          }
        }
        var je = oe + 1;
        ge - T > U((w - B) / je) && se("overflow"), B += (ge - T) * je, T = ge;
        var We = !0, St = !1, tt = void 0;
        try {
          for (var In = $[Symbol.iterator](), ba; !(We = (ba = In.next()).done); We = !0) {
            var _a = ba.value;
            if (_a < T && ++B > w && se("overflow"), _a == T) {
              for (
                var ur = B, fr = y;
                ;
                /* no condition */
                fr += y
              ) {
                var dr = fr <= z ? h : fr >= z + u ? u : fr - z;
                if (ur < dr)
                  break;
                var wa = ur - dr, Sa = y - dr;
                N.push(ye(L(dr + wa % Sa, 0))), ur = U(wa / Sa);
              }
              N.push(ye(L(ur, 0))), z = k(B, je, oe == Y), B = 0, ++oe;
            }
          }
        } catch (Cn) {
          St = !0, tt = Cn;
        } finally {
          try {
            !We && In.return && In.return();
          } finally {
            if (St)
              throw tt;
          }
        }
        ++B, ++T;
      }
      return N.join("");
    }, m = function($) {
      return vt($, function(N) {
        return P.test(N) ? M(N.slice(4).toLowerCase()) : N;
      });
    }, O = function($) {
      return vt($, function(N) {
        return R.test(N) ? "xn--" + A(N) : N;
      });
    }, j = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: Lt,
        encode: Sn
      },
      decode: M,
      encode: A,
      toASCII: O,
      toUnicode: m
    }, F = {};
    function q(S) {
      var $ = S.charCodeAt(0), N = void 0;
      return $ < 16 ? N = "%0" + $.toString(16).toUpperCase() : $ < 128 ? N = "%" + $.toString(16).toUpperCase() : $ < 2048 ? N = "%" + ($ >> 6 | 192).toString(16).toUpperCase() + "%" + ($ & 63 | 128).toString(16).toUpperCase() : N = "%" + ($ >> 12 | 224).toString(16).toUpperCase() + "%" + ($ >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + ($ & 63 | 128).toString(16).toUpperCase(), N;
    }
    function Z(S) {
      for (var $ = "", N = 0, I = S.length; N < I; ) {
        var T = parseInt(S.substr(N + 1, 2), 16);
        if (T < 128)
          $ += String.fromCharCode(T), N += 3;
        else if (T >= 194 && T < 224) {
          if (I - N >= 6) {
            var B = parseInt(S.substr(N + 4, 2), 16);
            $ += String.fromCharCode((T & 31) << 6 | B & 63);
          } else
            $ += S.substr(N, 6);
          N += 6;
        } else if (T >= 224) {
          if (I - N >= 9) {
            var z = parseInt(S.substr(N + 4, 2), 16), te = parseInt(S.substr(N + 7, 2), 16);
            $ += String.fromCharCode((T & 15) << 12 | (z & 63) << 6 | te & 63);
          } else
            $ += S.substr(N, 9);
          N += 9;
        } else
          $ += S.substr(N, 3), N += 3;
      }
      return $;
    }
    function ee(S, $) {
      function N(I) {
        var T = Z(I);
        return T.match($.UNRESERVED) ? T : I;
      }
      return S.scheme && (S.scheme = String(S.scheme).replace($.PCT_ENCODED, N).toLowerCase().replace($.NOT_SCHEME, "")), S.userinfo !== void 0 && (S.userinfo = String(S.userinfo).replace($.PCT_ENCODED, N).replace($.NOT_USERINFO, q).replace($.PCT_ENCODED, a)), S.host !== void 0 && (S.host = String(S.host).replace($.PCT_ENCODED, N).toLowerCase().replace($.NOT_HOST, q).replace($.PCT_ENCODED, a)), S.path !== void 0 && (S.path = String(S.path).replace($.PCT_ENCODED, N).replace(S.scheme ? $.NOT_PATH : $.NOT_PATH_NOSCHEME, q).replace($.PCT_ENCODED, a)), S.query !== void 0 && (S.query = String(S.query).replace($.PCT_ENCODED, N).replace($.NOT_QUERY, q).replace($.PCT_ENCODED, a)), S.fragment !== void 0 && (S.fragment = String(S.fragment).replace($.PCT_ENCODED, N).replace($.NOT_FRAGMENT, q).replace($.PCT_ENCODED, a)), S;
    }
    function fe(S) {
      return S.replace(/^0*(.*)/, "$1") || "0";
    }
    function ze(S, $) {
      var N = S.match($.IPV4ADDRESS) || [], I = g(N, 2), T = I[1];
      return T ? T.split(".").map(fe).join(".") : S;
    }
    function Ft(S, $) {
      var N = S.match($.IPV6ADDRESS) || [], I = g(N, 3), T = I[1], B = I[2];
      if (T) {
        for (var z = T.toLowerCase().split("::").reverse(), te = g(z, 2), ie = te[0], de = te[1], x = de ? de.split(":").map(fe) : [], ne = ie.split(":").map(fe), he = $.IPV4ADDRESS.test(ne[ne.length - 1]), Y = he ? 7 : 8, oe = ne.length - Y, ge = Array(Y), ce = 0; ce < Y; ++ce)
          ge[ce] = x[ce] || ne[oe + ce] || "";
        he && (ge[Y - 1] = ze(ge[Y - 1], $));
        var ct = ge.reduce(function(je, We, St) {
          if (!We || We === "0") {
            var tt = je[je.length - 1];
            tt && tt.index + tt.length === St ? tt.length++ : je.push({ index: St, length: 1 });
          }
          return je;
        }, []), He = ct.sort(function(je, We) {
          return We.length - je.length;
        })[0], Ye = void 0;
        if (He && He.length > 1) {
          var Gt = ge.slice(0, He.index), wt = ge.slice(He.index + He.length);
          Ye = Gt.join(":") + "::" + wt.join(":");
        } else
          Ye = ge.join(":");
        return B && (Ye += "%" + B), Ye;
      } else
        return S;
    }
    var En = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, On = "".match(/(){0}/)[1] === void 0;
    function ke(S) {
      var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, N = {}, I = $.iri !== !1 ? d : f;
      $.reference === "suffix" && (S = ($.scheme ? $.scheme + ":" : "") + "//" + S);
      var T = S.match(En);
      if (T) {
        On ? (N.scheme = T[1], N.userinfo = T[3], N.host = T[4], N.port = parseInt(T[5], 10), N.path = T[6] || "", N.query = T[7], N.fragment = T[8], isNaN(N.port) && (N.port = T[5])) : (N.scheme = T[1] || void 0, N.userinfo = S.indexOf("@") !== -1 ? T[3] : void 0, N.host = S.indexOf("//") !== -1 ? T[4] : void 0, N.port = parseInt(T[5], 10), N.path = T[6] || "", N.query = S.indexOf("?") !== -1 ? T[7] : void 0, N.fragment = S.indexOf("#") !== -1 ? T[8] : void 0, isNaN(N.port) && (N.port = S.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? T[4] : void 0)), N.host && (N.host = Ft(ze(N.host, I), I)), N.scheme === void 0 && N.userinfo === void 0 && N.host === void 0 && N.port === void 0 && !N.path && N.query === void 0 ? N.reference = "same-document" : N.scheme === void 0 ? N.reference = "relative" : N.fragment === void 0 ? N.reference = "absolute" : N.reference = "uri", $.reference && $.reference !== "suffix" && $.reference !== N.reference && (N.error = N.error || "URI is not a " + $.reference + " reference.");
        var B = F[($.scheme || N.scheme || "").toLowerCase()];
        if (!$.unicodeSupport && (!B || !B.unicodeSupport)) {
          if (N.host && ($.domainHost || B && B.domainHost))
            try {
              N.host = j.toASCII(N.host.replace(I.PCT_ENCODED, Z).toLowerCase());
            } catch (z) {
              N.error = N.error || "Host's domain name can not be converted to ASCII via punycode: " + z;
            }
          ee(N, f);
        } else
          ee(N, I);
        B && B.parse && B.parse(N, $);
      } else
        N.error = N.error || "URI can not be parsed.";
      return N;
    }
    function Nn(S, $) {
      var N = $.iri !== !1 ? d : f, I = [];
      return S.userinfo !== void 0 && (I.push(S.userinfo), I.push("@")), S.host !== void 0 && I.push(Ft(ze(String(S.host), N), N).replace(N.IPV6ADDRESS, function(T, B, z) {
        return "[" + B + (z ? "%25" + z : "") + "]";
      })), (typeof S.port == "number" || typeof S.port == "string") && (I.push(":"), I.push(String(S.port))), I.length ? I.join("") : void 0;
    }
    var Ut = /^\.\.?\//, qt = /^\/\.(\/|$)/, Kt = /^\/\.\.(\/|$)/, Pn = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Ge(S) {
      for (var $ = []; S.length; )
        if (S.match(Ut))
          S = S.replace(Ut, "");
        else if (S.match(qt))
          S = S.replace(qt, "/");
        else if (S.match(Kt))
          S = S.replace(Kt, "/"), $.pop();
        else if (S === "." || S === "..")
          S = "";
        else {
          var N = S.match(Pn);
          if (N) {
            var I = N[0];
            S = S.slice(I.length), $.push(I);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return $.join("");
    }
    function Oe(S) {
      var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, N = $.iri ? d : f, I = [], T = F[($.scheme || S.scheme || "").toLowerCase()];
      if (T && T.serialize && T.serialize(S, $), S.host && !N.IPV6ADDRESS.test(S.host)) {
        if ($.domainHost || T && T.domainHost)
          try {
            S.host = $.iri ? j.toUnicode(S.host) : j.toASCII(S.host.replace(N.PCT_ENCODED, Z).toLowerCase());
          } catch (te) {
            S.error = S.error || "Host's domain name can not be converted to " + ($.iri ? "Unicode" : "ASCII") + " via punycode: " + te;
          }
      }
      ee(S, N), $.reference !== "suffix" && S.scheme && (I.push(S.scheme), I.push(":"));
      var B = Nn(S, $);
      if (B !== void 0 && ($.reference !== "suffix" && I.push("//"), I.push(B), S.path && S.path.charAt(0) !== "/" && I.push("/")), S.path !== void 0) {
        var z = S.path;
        !$.absolutePath && (!T || !T.absolutePath) && (z = Ge(z)), B === void 0 && (z = z.replace(/^\/\//, "/%2F")), I.push(z);
      }
      return S.query !== void 0 && (I.push("?"), I.push(S.query)), S.fragment !== void 0 && (I.push("#"), I.push(S.fragment)), I.join("");
    }
    function Bt(S, $) {
      var N = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, I = arguments[3], T = {};
      return I || (S = ke(Oe(S, N), N), $ = ke(Oe($, N), N)), N = N || {}, !N.tolerant && $.scheme ? (T.scheme = $.scheme, T.userinfo = $.userinfo, T.host = $.host, T.port = $.port, T.path = Ge($.path || ""), T.query = $.query) : ($.userinfo !== void 0 || $.host !== void 0 || $.port !== void 0 ? (T.userinfo = $.userinfo, T.host = $.host, T.port = $.port, T.path = Ge($.path || ""), T.query = $.query) : ($.path ? ($.path.charAt(0) === "/" ? T.path = Ge($.path) : ((S.userinfo !== void 0 || S.host !== void 0 || S.port !== void 0) && !S.path ? T.path = "/" + $.path : S.path ? T.path = S.path.slice(0, S.path.lastIndexOf("/") + 1) + $.path : T.path = $.path, T.path = Ge(T.path)), T.query = $.query) : (T.path = S.path, $.query !== void 0 ? T.query = $.query : T.query = S.query), T.userinfo = S.userinfo, T.host = S.host, T.port = S.port), T.scheme = S.scheme), T.fragment = $.fragment, T;
    }
    function kn(S, $, N) {
      var I = c({ scheme: "null" }, N);
      return Oe(Bt(ke(S, I), ke($, I), I, !0), I);
    }
    function bt(S, $) {
      return typeof S == "string" ? S = Oe(ke(S, $), $) : i(S) === "object" && (S = ke(Oe(S, $), $)), S;
    }
    function An(S, $, N) {
      return typeof S == "string" ? S = Oe(ke(S, N), N) : i(S) === "object" && (S = Oe(S, N)), typeof $ == "string" ? $ = Oe(ke($, N), N) : i($) === "object" && ($ = Oe($, N)), S === $;
    }
    function lr(S, $) {
      return S && S.toString().replace(!$ || !$.iri ? f.ESCAPE : d.ESCAPE, q);
    }
    function Ce(S, $) {
      return S && S.toString().replace(!$ || !$.iri ? f.PCT_ENCODED : d.PCT_ENCODED, Z);
    }
    var _t = {
      scheme: "http",
      domainHost: !0,
      parse: function($, N) {
        return $.host || ($.error = $.error || "HTTP URIs must have a host."), $;
      },
      serialize: function($, N) {
        var I = String($.scheme).toLowerCase() === "https";
        return ($.port === (I ? 443 : 80) || $.port === "") && ($.port = void 0), $.path || ($.path = "/"), $;
      }
    }, da = {
      scheme: "https",
      domainHost: _t.domainHost,
      parse: _t.parse,
      serialize: _t.serialize
    };
    function ha(S) {
      return typeof S.secure == "boolean" ? S.secure : String(S.scheme).toLowerCase() === "wss";
    }
    var Tn = {
      scheme: "ws",
      domainHost: !0,
      parse: function($, N) {
        var I = $;
        return I.secure = ha(I), I.resourceName = (I.path || "/") + (I.query ? "?" + I.query : ""), I.path = void 0, I.query = void 0, I;
      },
      serialize: function($, N) {
        if (($.port === (ha($) ? 443 : 80) || $.port === "") && ($.port = void 0), typeof $.secure == "boolean" && ($.scheme = $.secure ? "wss" : "ws", $.secure = void 0), $.resourceName) {
          var I = $.resourceName.split("?"), T = g(I, 2), B = T[0], z = T[1];
          $.path = B && B !== "/" ? B : void 0, $.query = z, $.resourceName = void 0;
        }
        return $.fragment = void 0, $;
      }
    }, ma = {
      scheme: "wss",
      domainHost: Tn.domainHost,
      parse: Tn.parse,
      serialize: Tn.serialize
    }, ol = {}, pa = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", Je = "[0-9A-Fa-f]", cl = s(s("%[EFef]" + Je + "%" + Je + Je + "%" + Je + Je) + "|" + s("%[89A-Fa-f]" + Je + "%" + Je + Je) + "|" + s("%" + Je + Je)), ll = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", ul = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", fl = r(ul, '[\\"\\\\]'), dl = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", hl = new RegExp(pa, "g"), zt = new RegExp(cl, "g"), ml = new RegExp(r("[^]", ll, "[\\.]", '[\\"]', fl), "g"), ya = new RegExp(r("[^]", pa, dl), "g"), pl = ya;
    function gs(S) {
      var $ = Z(S);
      return $.match(hl) ? $ : S;
    }
    var ga = {
      scheme: "mailto",
      parse: function($, N) {
        var I = $, T = I.to = I.path ? I.path.split(",") : [];
        if (I.path = void 0, I.query) {
          for (var B = !1, z = {}, te = I.query.split("&"), ie = 0, de = te.length; ie < de; ++ie) {
            var x = te[ie].split("=");
            switch (x[0]) {
              case "to":
                for (var ne = x[1].split(","), he = 0, Y = ne.length; he < Y; ++he)
                  T.push(ne[he]);
                break;
              case "subject":
                I.subject = Ce(x[1], N);
                break;
              case "body":
                I.body = Ce(x[1], N);
                break;
              default:
                B = !0, z[Ce(x[0], N)] = Ce(x[1], N);
                break;
            }
          }
          B && (I.headers = z);
        }
        I.query = void 0;
        for (var oe = 0, ge = T.length; oe < ge; ++oe) {
          var ce = T[oe].split("@");
          if (ce[0] = Ce(ce[0]), N.unicodeSupport)
            ce[1] = Ce(ce[1], N).toLowerCase();
          else
            try {
              ce[1] = j.toASCII(Ce(ce[1], N).toLowerCase());
            } catch (ct) {
              I.error = I.error || "Email address's domain name can not be converted to ASCII via punycode: " + ct;
            }
          T[oe] = ce.join("@");
        }
        return I;
      },
      serialize: function($, N) {
        var I = $, T = o($.to);
        if (T) {
          for (var B = 0, z = T.length; B < z; ++B) {
            var te = String(T[B]), ie = te.lastIndexOf("@"), de = te.slice(0, ie).replace(zt, gs).replace(zt, a).replace(ml, q), x = te.slice(ie + 1);
            try {
              x = N.iri ? j.toUnicode(x) : j.toASCII(Ce(x, N).toLowerCase());
            } catch (oe) {
              I.error = I.error || "Email address's domain name can not be converted to " + (N.iri ? "Unicode" : "ASCII") + " via punycode: " + oe;
            }
            T[B] = de + "@" + x;
          }
          I.path = T.join(",");
        }
        var ne = $.headers = $.headers || {};
        $.subject && (ne.subject = $.subject), $.body && (ne.body = $.body);
        var he = [];
        for (var Y in ne)
          ne[Y] !== ol[Y] && he.push(Y.replace(zt, gs).replace(zt, a).replace(ya, q) + "=" + ne[Y].replace(zt, gs).replace(zt, a).replace(pl, q));
        return he.length && (I.query = he.join("&")), I;
      }
    }, yl = /^([^\:]+)\:(.*)/, $a = {
      scheme: "urn",
      parse: function($, N) {
        var I = $.path && $.path.match(yl), T = $;
        if (I) {
          var B = N.scheme || T.scheme || "urn", z = I[1].toLowerCase(), te = I[2], ie = B + ":" + (N.nid || z), de = F[ie];
          T.nid = z, T.nss = te, T.path = void 0, de && (T = de.parse(T, N));
        } else
          T.error = T.error || "URN can not be parsed.";
        return T;
      },
      serialize: function($, N) {
        var I = N.scheme || $.scheme || "urn", T = $.nid, B = I + ":" + (N.nid || T), z = F[B];
        z && ($ = z.serialize($, N));
        var te = $, ie = $.nss;
        return te.path = (T || N.nid) + ":" + ie, te;
      }
    }, gl = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, va = {
      scheme: "urn:uuid",
      parse: function($, N) {
        var I = $;
        return I.uuid = I.nss, I.nss = void 0, !N.tolerant && (!I.uuid || !I.uuid.match(gl)) && (I.error = I.error || "UUID is not valid."), I;
      },
      serialize: function($, N) {
        var I = $;
        return I.nss = ($.uuid || "").toLowerCase(), I;
      }
    };
    F[_t.scheme] = _t, F[da.scheme] = da, F[Tn.scheme] = Tn, F[ma.scheme] = ma, F[ga.scheme] = ga, F[$a.scheme] = $a, F[va.scheme] = va, n.SCHEMES = F, n.pctEncChar = q, n.pctDecChars = Z, n.parse = ke, n.removeDotSegments = Ge, n.serialize = Oe, n.resolveComponents = Bt, n.resolve = kn, n.normalize = bt, n.equal = An, n.escapeComponent = lr, n.unescapeComponent = Ce, Object.defineProperty(n, "__esModule", { value: !0 });
  });
})(Fs, Fs.exports);
var tf = Fs.exports;
Object.defineProperty(ui, "__esModule", { value: !0 });
const qo = tf;
qo.code = 'require("ajv/dist/runtime/uri").default';
ui.default = qo;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  var e = Me;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return e.KeywordCxt;
  } });
  var n = H;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return n.CodeGen;
  } });
  const r = ln, s = un, i = jt, a = Ee, o = H, c = ve, l = Zn, f = X, d = ef, g = ui, v = (L, k) => new RegExp(L, k);
  v.code = "new RegExp";
  const w = ["removeAdditional", "useDefaults", "coerceTypes"], y = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), h = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, u = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, p = 200;
  function b(L) {
    var k, M, A, m, O, j, F, q, Z, ee, fe, ze, Ft, En, On, ke, Nn, Ut, qt, Kt, Pn, Ge, Oe, Bt, kn;
    const bt = L.strict, An = (k = L.code) === null || k === void 0 ? void 0 : k.optimize, lr = An === !0 || An === void 0 ? 1 : An || 0, Ce = (A = (M = L.code) === null || M === void 0 ? void 0 : M.regExp) !== null && A !== void 0 ? A : v, _t = (m = L.uriResolver) !== null && m !== void 0 ? m : g.default;
    return {
      strictSchema: (j = (O = L.strictSchema) !== null && O !== void 0 ? O : bt) !== null && j !== void 0 ? j : !0,
      strictNumbers: (q = (F = L.strictNumbers) !== null && F !== void 0 ? F : bt) !== null && q !== void 0 ? q : !0,
      strictTypes: (ee = (Z = L.strictTypes) !== null && Z !== void 0 ? Z : bt) !== null && ee !== void 0 ? ee : "log",
      strictTuples: (ze = (fe = L.strictTuples) !== null && fe !== void 0 ? fe : bt) !== null && ze !== void 0 ? ze : "log",
      strictRequired: (En = (Ft = L.strictRequired) !== null && Ft !== void 0 ? Ft : bt) !== null && En !== void 0 ? En : !1,
      code: L.code ? { ...L.code, optimize: lr, regExp: Ce } : { optimize: lr, regExp: Ce },
      loopRequired: (On = L.loopRequired) !== null && On !== void 0 ? On : p,
      loopEnum: (ke = L.loopEnum) !== null && ke !== void 0 ? ke : p,
      meta: (Nn = L.meta) !== null && Nn !== void 0 ? Nn : !0,
      messages: (Ut = L.messages) !== null && Ut !== void 0 ? Ut : !0,
      inlineRefs: (qt = L.inlineRefs) !== null && qt !== void 0 ? qt : !0,
      schemaId: (Kt = L.schemaId) !== null && Kt !== void 0 ? Kt : "$id",
      addUsedSchema: (Pn = L.addUsedSchema) !== null && Pn !== void 0 ? Pn : !0,
      validateSchema: (Ge = L.validateSchema) !== null && Ge !== void 0 ? Ge : !0,
      validateFormats: (Oe = L.validateFormats) !== null && Oe !== void 0 ? Oe : !0,
      unicodeRegExp: (Bt = L.unicodeRegExp) !== null && Bt !== void 0 ? Bt : !0,
      int32range: (kn = L.int32range) !== null && kn !== void 0 ? kn : !0,
      uriResolver: _t
    };
  }
  class E {
    constructor(k = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), k = this.opts = { ...k, ...b(k) };
      const { es5: M, lines: A } = this.opts.code;
      this.scope = new o.ValueScope({ scope: {}, prefixes: y, es5: M, lines: A }), this.logger = U(k.logger);
      const m = k.validateFormats;
      k.validateFormats = !1, this.RULES = (0, i.getRules)(), C.call(this, h, k, "NOT SUPPORTED"), C.call(this, u, k, "DEPRECATED", "warn"), this._metaOpts = V.call(this), k.formats && R.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), k.keywords && D.call(this, k.keywords), typeof k.meta == "object" && this.addMetaSchema(k.meta), P.call(this), k.validateFormats = m;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: k, meta: M, schemaId: A } = this.opts;
      let m = d;
      A === "id" && (m = { ...d }, m.id = m.$id, delete m.$id), M && k && this.addMetaSchema(m, m[A], !1);
    }
    defaultMeta() {
      const { meta: k, schemaId: M } = this.opts;
      return this.opts.defaultMeta = typeof k == "object" ? k[M] || k : void 0;
    }
    validate(k, M) {
      let A;
      if (typeof k == "string") {
        if (A = this.getSchema(k), !A)
          throw new Error(`no schema with key or ref "${k}"`);
      } else
        A = this.compile(k);
      const m = A(M);
      return "$async" in A || (this.errors = A.errors), m;
    }
    compile(k, M) {
      const A = this._addSchema(k, M);
      return A.validate || this._compileSchemaEnv(A);
    }
    compileAsync(k, M) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: A } = this.opts;
      return m.call(this, k, M);
      async function m(ee, fe) {
        await O.call(this, ee.$schema);
        const ze = this._addSchema(ee, fe);
        return ze.validate || j.call(this, ze);
      }
      async function O(ee) {
        ee && !this.getSchema(ee) && await m.call(this, { $ref: ee }, !0);
      }
      async function j(ee) {
        try {
          return this._compileSchemaEnv(ee);
        } catch (fe) {
          if (!(fe instanceof s.default))
            throw fe;
          return F.call(this, fe), await q.call(this, fe.missingSchema), j.call(this, ee);
        }
      }
      function F({ missingSchema: ee, missingRef: fe }) {
        if (this.refs[ee])
          throw new Error(`AnySchema ${ee} is loaded but ${fe} cannot be resolved`);
      }
      async function q(ee) {
        const fe = await Z.call(this, ee);
        this.refs[ee] || await O.call(this, fe.$schema), this.refs[ee] || this.addSchema(fe, ee, M);
      }
      async function Z(ee) {
        const fe = this._loading[ee];
        if (fe)
          return fe;
        try {
          return await (this._loading[ee] = A(ee));
        } finally {
          delete this._loading[ee];
        }
      }
    }
    // Adds schema to the instance
    addSchema(k, M, A, m = this.opts.validateSchema) {
      if (Array.isArray(k)) {
        for (const j of k)
          this.addSchema(j, void 0, A, m);
        return this;
      }
      let O;
      if (typeof k == "object") {
        const { schemaId: j } = this.opts;
        if (O = k[j], O !== void 0 && typeof O != "string")
          throw new Error(`schema ${j} must be string`);
      }
      return M = (0, c.normalizeId)(M || O), this._checkUnique(M), this.schemas[M] = this._addSchema(k, A, M, m, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(k, M, A = this.opts.validateSchema) {
      return this.addSchema(k, M, !0, A), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(k, M) {
      if (typeof k == "boolean")
        return !0;
      let A;
      if (A = k.$schema, A !== void 0 && typeof A != "string")
        throw new Error("$schema must be a string");
      if (A = A || this.opts.defaultMeta || this.defaultMeta(), !A)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const m = this.validate(A, k);
      if (!m && M) {
        const O = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(O);
        else
          throw new Error(O);
      }
      return m;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(k) {
      let M;
      for (; typeof (M = _.call(this, k)) == "string"; )
        k = M;
      if (M === void 0) {
        const { schemaId: A } = this.opts, m = new a.SchemaEnv({ schema: {}, schemaId: A });
        if (M = a.resolveSchema.call(this, m, k), !M)
          return;
        this.refs[k] = M;
      }
      return M.validate || this._compileSchemaEnv(M);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(k) {
      if (k instanceof RegExp)
        return this._removeAllSchemas(this.schemas, k), this._removeAllSchemas(this.refs, k), this;
      switch (typeof k) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const M = _.call(this, k);
          return typeof M == "object" && this._cache.delete(M.schema), delete this.schemas[k], delete this.refs[k], this;
        }
        case "object": {
          const M = k;
          this._cache.delete(M);
          let A = k[this.opts.schemaId];
          return A && (A = (0, c.normalizeId)(A), delete this.schemas[A], delete this.refs[A]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(k) {
      for (const M of k)
        this.addKeyword(M);
      return this;
    }
    addKeyword(k, M) {
      let A;
      if (typeof k == "string")
        A = k, typeof M == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), M.keyword = A);
      else if (typeof k == "object" && M === void 0) {
        if (M = k, A = M.keyword, Array.isArray(A) && !A.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (se.call(this, A, M), !M)
        return (0, f.eachItem)(A, (O) => Ie.call(this, O)), this;
      Lt.call(this, M);
      const m = {
        ...M,
        type: (0, l.getJSONTypes)(M.type),
        schemaType: (0, l.getJSONTypes)(M.schemaType)
      };
      return (0, f.eachItem)(A, m.type.length === 0 ? (O) => Ie.call(this, O, m) : (O) => m.type.forEach((j) => Ie.call(this, O, m, j))), this;
    }
    getKeyword(k) {
      const M = this.RULES.all[k];
      return typeof M == "object" ? M.definition : !!M;
    }
    // Remove keyword
    removeKeyword(k) {
      const { RULES: M } = this;
      delete M.keywords[k], delete M.all[k];
      for (const A of M.rules) {
        const m = A.rules.findIndex((O) => O.keyword === k);
        m >= 0 && A.rules.splice(m, 1);
      }
      return this;
    }
    // Add format
    addFormat(k, M) {
      return typeof M == "string" && (M = new RegExp(M)), this.formats[k] = M, this;
    }
    errorsText(k = this.errors, { separator: M = ", ", dataVar: A = "data" } = {}) {
      return !k || k.length === 0 ? "No errors" : k.map((m) => `${A}${m.instancePath} ${m.message}`).reduce((m, O) => m + M + O);
    }
    $dataMetaSchema(k, M) {
      const A = this.RULES.all;
      k = JSON.parse(JSON.stringify(k));
      for (const m of M) {
        const O = m.split("/").slice(1);
        let j = k;
        for (const F of O)
          j = j[F];
        for (const F in A) {
          const q = A[F];
          if (typeof q != "object")
            continue;
          const { $data: Z } = q.definition, ee = j[F];
          Z && ee && (j[F] = Vt(ee));
        }
      }
      return k;
    }
    _removeAllSchemas(k, M) {
      for (const A in k) {
        const m = k[A];
        (!M || M.test(A)) && (typeof m == "string" ? delete k[A] : m && !m.meta && (this._cache.delete(m.schema), delete k[A]));
      }
    }
    _addSchema(k, M, A, m = this.opts.validateSchema, O = this.opts.addUsedSchema) {
      let j;
      const { schemaId: F } = this.opts;
      if (typeof k == "object")
        j = k[F];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof k != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let q = this._cache.get(k);
      if (q !== void 0)
        return q;
      A = (0, c.normalizeId)(j || A);
      const Z = c.getSchemaRefs.call(this, k, A);
      return q = new a.SchemaEnv({ schema: k, schemaId: F, meta: M, baseId: A, localRefs: Z }), this._cache.set(q.schema, q), O && !A.startsWith("#") && (A && this._checkUnique(A), this.refs[A] = q), m && this.validateSchema(k, !0), q;
    }
    _checkUnique(k) {
      if (this.schemas[k] || this.refs[k])
        throw new Error(`schema with key or id "${k}" already exists`);
    }
    _compileSchemaEnv(k) {
      if (k.meta ? this._compileMetaSchema(k) : a.compileSchema.call(this, k), !k.validate)
        throw new Error("ajv implementation error");
      return k.validate;
    }
    _compileMetaSchema(k) {
      const M = this.opts;
      this.opts = this._metaOpts;
      try {
        a.compileSchema.call(this, k);
      } finally {
        this.opts = M;
      }
    }
  }
  t.default = E, E.ValidationError = r.default, E.MissingRefError = s.default;
  function C(L, k, M, A = "error") {
    for (const m in L) {
      const O = m;
      O in k && this.logger[A](`${M}: option ${m}. ${L[O]}`);
    }
  }
  function _(L) {
    return L = (0, c.normalizeId)(L), this.schemas[L] || this.refs[L];
  }
  function P() {
    const L = this.opts.schemas;
    if (L)
      if (Array.isArray(L))
        this.addSchema(L);
      else
        for (const k in L)
          this.addSchema(L[k], k);
  }
  function R() {
    for (const L in this.opts.formats) {
      const k = this.opts.formats[L];
      k && this.addFormat(L, k);
    }
  }
  function D(L) {
    if (Array.isArray(L)) {
      this.addVocabulary(L);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const k in L) {
      const M = L[k];
      M.keyword || (M.keyword = k), this.addKeyword(M);
    }
  }
  function V() {
    const L = { ...this.opts };
    for (const k of w)
      delete L[k];
    return L;
  }
  const G = { log() {
  }, warn() {
  }, error() {
  } };
  function U(L) {
    if (L === !1)
      return G;
    if (L === void 0)
      return console;
    if (L.log && L.warn && L.error)
      return L;
    throw new Error("logger must implement log, warn and error methods");
  }
  const ye = /^[a-z_$][a-z0-9_$:-]*$/i;
  function se(L, k) {
    const { RULES: M } = this;
    if ((0, f.eachItem)(L, (A) => {
      if (M.keywords[A])
        throw new Error(`Keyword ${A} is already defined`);
      if (!ye.test(A))
        throw new Error(`Keyword ${A} has invalid name`);
    }), !!k && k.$data && !("code" in k || "validate" in k))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function Ie(L, k, M) {
    var A;
    const m = k == null ? void 0 : k.post;
    if (M && m)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: O } = this;
    let j = m ? O.post : O.rules.find(({ type: q }) => q === M);
    if (j || (j = { type: M, rules: [] }, O.rules.push(j)), O.keywords[L] = !0, !k)
      return;
    const F = {
      keyword: L,
      definition: {
        ...k,
        type: (0, l.getJSONTypes)(k.type),
        schemaType: (0, l.getJSONTypes)(k.schemaType)
      }
    };
    k.before ? vt.call(this, j, F, k.before) : j.rules.push(F), O.all[L] = F, (A = k.implements) === null || A === void 0 || A.forEach((q) => this.addKeyword(q));
  }
  function vt(L, k, M) {
    const A = L.rules.findIndex((m) => m.keyword === M);
    A >= 0 ? L.rules.splice(A, 0, k) : (L.rules.push(k), this.logger.warn(`rule ${M} is not defined`));
  }
  function Lt(L) {
    let { metaSchema: k } = L;
    k !== void 0 && (L.$data && this.opts.$data && (k = Vt(k)), L.validateSchema = this.compile(k, !0));
  }
  const Sn = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function Vt(L) {
    return { anyOf: [L, Sn] };
  }
})(Ct);
var fi = {}, qr = {}, di = {};
Object.defineProperty(di, "__esModule", { value: !0 });
const nf = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
di.default = nf;
var et = {};
Object.defineProperty(et, "__esModule", { value: !0 });
et.callRef = et.getValidate = void 0;
const rf = un, Ia = Q, Ne = H, Ht = Te, Ca = Ee, hr = X, sf = {
  keyword: "$ref",
  schemaType: "string",
  code(t) {
    const { gen: e, schema: n, it: r } = t, { baseId: s, schemaEnv: i, validateName: a, opts: o, self: c } = r, { root: l } = i;
    if ((n === "#" || n === "#/") && s === l.baseId)
      return d();
    const f = Ca.resolveRef.call(c, l, s, n);
    if (f === void 0)
      throw new rf.default(r.opts.uriResolver, s, n);
    if (f instanceof Ca.SchemaEnv)
      return g(f);
    return v(f);
    function d() {
      if (i === l)
        return wr(t, a, i, i.$async);
      const w = e.scopeValue("root", { ref: l });
      return wr(t, (0, Ne._)`${w}.validate`, l, l.$async);
    }
    function g(w) {
      const y = Ko(t, w);
      wr(t, y, w, w.$async);
    }
    function v(w) {
      const y = e.scopeValue("schema", o.code.source === !0 ? { ref: w, code: (0, Ne.stringify)(w) } : { ref: w }), h = e.name("valid"), u = t.subschema({
        schema: w,
        dataTypes: [],
        schemaPath: Ne.nil,
        topSchemaRef: y,
        errSchemaPath: n
      }, h);
      t.mergeEvaluated(u), t.ok(h);
    }
  }
};
function Ko(t, e) {
  const { gen: n } = t;
  return e.validate ? n.scopeValue("validate", { ref: e.validate }) : (0, Ne._)`${n.scopeValue("wrapper", { ref: e })}.validate`;
}
et.getValidate = Ko;
function wr(t, e, n, r) {
  const { gen: s, it: i } = t, { allErrors: a, schemaEnv: o, opts: c } = i, l = c.passContext ? Ht.default.this : Ne.nil;
  r ? f() : d();
  function f() {
    if (!o.$async)
      throw new Error("async schema referenced by sync schema");
    const w = s.let("valid");
    s.try(() => {
      s.code((0, Ne._)`await ${(0, Ia.callValidateCode)(t, e, l)}`), v(e), a || s.assign(w, !0);
    }, (y) => {
      s.if((0, Ne._)`!(${y} instanceof ${i.ValidationError})`, () => s.throw(y)), g(y), a || s.assign(w, !1);
    }), t.ok(w);
  }
  function d() {
    t.result((0, Ia.callValidateCode)(t, e, l), () => v(e), () => g(e));
  }
  function g(w) {
    const y = (0, Ne._)`${w}.errors`;
    s.assign(Ht.default.vErrors, (0, Ne._)`${Ht.default.vErrors} === null ? ${y} : ${Ht.default.vErrors}.concat(${y})`), s.assign(Ht.default.errors, (0, Ne._)`${Ht.default.vErrors}.length`);
  }
  function v(w) {
    var y;
    if (!i.opts.unevaluated)
      return;
    const h = (y = n == null ? void 0 : n.validate) === null || y === void 0 ? void 0 : y.evaluated;
    if (i.props !== !0)
      if (h && !h.dynamicProps)
        h.props !== void 0 && (i.props = hr.mergeEvaluated.props(s, h.props, i.props));
      else {
        const u = s.var("props", (0, Ne._)`${w}.evaluated.props`);
        i.props = hr.mergeEvaluated.props(s, u, i.props, Ne.Name);
      }
    if (i.items !== !0)
      if (h && !h.dynamicItems)
        h.items !== void 0 && (i.items = hr.mergeEvaluated.items(s, h.items, i.items));
      else {
        const u = s.var("items", (0, Ne._)`${w}.evaluated.items`);
        i.items = hr.mergeEvaluated.items(s, u, i.items, Ne.Name);
      }
  }
}
et.callRef = wr;
et.default = sf;
Object.defineProperty(qr, "__esModule", { value: !0 });
const af = di, of = et, cf = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  af.default,
  of.default
];
qr.default = cf;
var Kr = {}, hi = {};
Object.defineProperty(hi, "__esModule", { value: !0 });
const Tr = H, ut = Tr.operators, Ir = {
  maximum: { okStr: "<=", ok: ut.LTE, fail: ut.GT },
  minimum: { okStr: ">=", ok: ut.GTE, fail: ut.LT },
  exclusiveMaximum: { okStr: "<", ok: ut.LT, fail: ut.GTE },
  exclusiveMinimum: { okStr: ">", ok: ut.GT, fail: ut.LTE }
}, lf = {
  message: ({ keyword: t, schemaCode: e }) => (0, Tr.str)`must be ${Ir[t].okStr} ${e}`,
  params: ({ keyword: t, schemaCode: e }) => (0, Tr._)`{comparison: ${Ir[t].okStr}, limit: ${e}}`
}, uf = {
  keyword: Object.keys(Ir),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: lf,
  code(t) {
    const { keyword: e, data: n, schemaCode: r } = t;
    t.fail$data((0, Tr._)`${n} ${Ir[e].fail} ${r} || isNaN(${n})`);
  }
};
hi.default = uf;
var Br = {};
Object.defineProperty(Br, "__esModule", { value: !0 });
const qn = H, ff = {
  message: ({ schemaCode: t }) => (0, qn.str)`must be multiple of ${t}`,
  params: ({ schemaCode: t }) => (0, qn._)`{multipleOf: ${t}}`
}, df = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: ff,
  code(t) {
    const { gen: e, data: n, schemaCode: r, it: s } = t, i = s.opts.multipleOfPrecision, a = e.let("res"), o = i ? (0, qn._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${i}` : (0, qn._)`${a} !== parseInt(${a})`;
    t.fail$data((0, qn._)`(${r} === 0 || (${a} = ${n}/${r}, ${o}))`);
  }
};
Br.default = df;
var zr = {}, mi = {};
Object.defineProperty(mi, "__esModule", { value: !0 });
function Bo(t) {
  const e = t.length;
  let n = 0, r = 0, s;
  for (; r < e; )
    n++, s = t.charCodeAt(r++), s >= 55296 && s <= 56319 && r < e && (s = t.charCodeAt(r), (s & 64512) === 56320 && r++);
  return n;
}
mi.default = Bo;
Bo.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(zr, "__esModule", { value: !0 });
const Nt = H, hf = X, mf = mi, pf = {
  message({ keyword: t, schemaCode: e }) {
    const n = t === "maxLength" ? "more" : "fewer";
    return (0, Nt.str)`must NOT have ${n} than ${e} characters`;
  },
  params: ({ schemaCode: t }) => (0, Nt._)`{limit: ${t}}`
}, yf = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: pf,
  code(t) {
    const { keyword: e, data: n, schemaCode: r, it: s } = t, i = e === "maxLength" ? Nt.operators.GT : Nt.operators.LT, a = s.opts.unicode === !1 ? (0, Nt._)`${n}.length` : (0, Nt._)`${(0, hf.useFunc)(t.gen, mf.default)}(${n})`;
    t.fail$data((0, Nt._)`${a} ${i} ${r}`);
  }
};
zr.default = yf;
var Gr = {};
Object.defineProperty(Gr, "__esModule", { value: !0 });
const gf = Q, Cr = H, $f = {
  message: ({ schemaCode: t }) => (0, Cr.str)`must match pattern "${t}"`,
  params: ({ schemaCode: t }) => (0, Cr._)`{pattern: ${t}}`
}, vf = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: $f,
  code(t) {
    const { data: e, $data: n, schema: r, schemaCode: s, it: i } = t, a = i.opts.unicodeRegExp ? "u" : "", o = n ? (0, Cr._)`(new RegExp(${s}, ${a}))` : (0, gf.usePattern)(t, r);
    t.fail$data((0, Cr._)`!${o}.test(${e})`);
  }
};
Gr.default = vf;
var Jr = {};
Object.defineProperty(Jr, "__esModule", { value: !0 });
const Kn = H, bf = {
  message({ keyword: t, schemaCode: e }) {
    const n = t === "maxProperties" ? "more" : "fewer";
    return (0, Kn.str)`must NOT have ${n} than ${e} properties`;
  },
  params: ({ schemaCode: t }) => (0, Kn._)`{limit: ${t}}`
}, _f = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: bf,
  code(t) {
    const { keyword: e, data: n, schemaCode: r } = t, s = e === "maxProperties" ? Kn.operators.GT : Kn.operators.LT;
    t.fail$data((0, Kn._)`Object.keys(${n}).length ${s} ${r}`);
  }
};
Jr.default = _f;
var Hr = {};
Object.defineProperty(Hr, "__esModule", { value: !0 });
const Rn = Q, Bn = H, wf = X, Sf = {
  message: ({ params: { missingProperty: t } }) => (0, Bn.str)`must have required property '${t}'`,
  params: ({ params: { missingProperty: t } }) => (0, Bn._)`{missingProperty: ${t}}`
}, Ef = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: Sf,
  code(t) {
    const { gen: e, schema: n, schemaCode: r, data: s, $data: i, it: a } = t, { opts: o } = a;
    if (!i && n.length === 0)
      return;
    const c = n.length >= o.loopRequired;
    if (a.allErrors ? l() : f(), o.strictRequired) {
      const v = t.parentSchema.properties, { definedProperties: w } = t.it;
      for (const y of n)
        if ((v == null ? void 0 : v[y]) === void 0 && !w.has(y)) {
          const h = a.schemaEnv.baseId + a.errSchemaPath, u = `required property "${y}" is not defined at "${h}" (strictRequired)`;
          (0, wf.checkStrictMode)(a, u, a.opts.strictRequired);
        }
    }
    function l() {
      if (c || i)
        t.block$data(Bn.nil, d);
      else
        for (const v of n)
          (0, Rn.checkReportMissingProp)(t, v);
    }
    function f() {
      const v = e.let("missing");
      if (c || i) {
        const w = e.let("valid", !0);
        t.block$data(w, () => g(v, w)), t.ok(w);
      } else
        e.if((0, Rn.checkMissingProp)(t, n, v)), (0, Rn.reportMissingProp)(t, v), e.else();
    }
    function d() {
      e.forOf("prop", r, (v) => {
        t.setParams({ missingProperty: v }), e.if((0, Rn.noPropertyInData)(e, s, v, o.ownProperties), () => t.error());
      });
    }
    function g(v, w) {
      t.setParams({ missingProperty: v }), e.forOf(v, r, () => {
        e.assign(w, (0, Rn.propertyInData)(e, s, v, o.ownProperties)), e.if((0, Bn.not)(w), () => {
          t.error(), e.break();
        });
      }, Bn.nil);
    }
  }
};
Hr.default = Ef;
var Yr = {};
Object.defineProperty(Yr, "__esModule", { value: !0 });
const zn = H, Of = {
  message({ keyword: t, schemaCode: e }) {
    const n = t === "maxItems" ? "more" : "fewer";
    return (0, zn.str)`must NOT have ${n} than ${e} items`;
  },
  params: ({ schemaCode: t }) => (0, zn._)`{limit: ${t}}`
}, Nf = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: Of,
  code(t) {
    const { keyword: e, data: n, schemaCode: r } = t, s = e === "maxItems" ? zn.operators.GT : zn.operators.LT;
    t.fail$data((0, zn._)`${n}.length ${s} ${r}`);
  }
};
Yr.default = Nf;
var Wr = {}, xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
const zo = Eo;
zo.code = 'require("ajv/dist/runtime/equal").default';
xn.default = zo;
Object.defineProperty(Wr, "__esModule", { value: !0 });
const _s = Zn, $e = H, Pf = X, kf = xn, Af = {
  message: ({ params: { i: t, j: e } }) => (0, $e.str)`must NOT have duplicate items (items ## ${e} and ${t} are identical)`,
  params: ({ params: { i: t, j: e } }) => (0, $e._)`{i: ${t}, j: ${e}}`
}, Tf = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: Af,
  code(t) {
    const { gen: e, data: n, $data: r, schema: s, parentSchema: i, schemaCode: a, it: o } = t;
    if (!r && !s)
      return;
    const c = e.let("valid"), l = i.items ? (0, _s.getSchemaTypes)(i.items) : [];
    t.block$data(c, f, (0, $e._)`${a} === false`), t.ok(c);
    function f() {
      const w = e.let("i", (0, $e._)`${n}.length`), y = e.let("j");
      t.setParams({ i: w, j: y }), e.assign(c, !0), e.if((0, $e._)`${w} > 1`, () => (d() ? g : v)(w, y));
    }
    function d() {
      return l.length > 0 && !l.some((w) => w === "object" || w === "array");
    }
    function g(w, y) {
      const h = e.name("item"), u = (0, _s.checkDataTypes)(l, h, o.opts.strictNumbers, _s.DataType.Wrong), p = e.const("indices", (0, $e._)`{}`);
      e.for((0, $e._)`;${w}--;`, () => {
        e.let(h, (0, $e._)`${n}[${w}]`), e.if(u, (0, $e._)`continue`), l.length > 1 && e.if((0, $e._)`typeof ${h} == "string"`, (0, $e._)`${h} += "_"`), e.if((0, $e._)`typeof ${p}[${h}] == "number"`, () => {
          e.assign(y, (0, $e._)`${p}[${h}]`), t.error(), e.assign(c, !1).break();
        }).code((0, $e._)`${p}[${h}] = ${w}`);
      });
    }
    function v(w, y) {
      const h = (0, Pf.useFunc)(e, kf.default), u = e.name("outer");
      e.label(u).for((0, $e._)`;${w}--;`, () => e.for((0, $e._)`${y} = ${w}; ${y}--;`, () => e.if((0, $e._)`${h}(${n}[${w}], ${n}[${y}])`, () => {
        t.error(), e.assign(c, !1).break(u);
      })));
    }
  }
};
Wr.default = Tf;
var Qr = {};
Object.defineProperty(Qr, "__esModule", { value: !0 });
const Us = H, If = X, Cf = xn, jf = {
  message: "must be equal to constant",
  params: ({ schemaCode: t }) => (0, Us._)`{allowedValue: ${t}}`
}, Rf = {
  keyword: "const",
  $data: !0,
  error: jf,
  code(t) {
    const { gen: e, data: n, $data: r, schemaCode: s, schema: i } = t;
    r || i && typeof i == "object" ? t.fail$data((0, Us._)`!${(0, If.useFunc)(e, Cf.default)}(${n}, ${s})`) : t.fail((0, Us._)`${i} !== ${n}`);
  }
};
Qr.default = Rf;
var Xr = {};
Object.defineProperty(Xr, "__esModule", { value: !0 });
const Mn = H, Df = X, Mf = xn, Lf = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: t }) => (0, Mn._)`{allowedValues: ${t}}`
}, Vf = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: Lf,
  code(t) {
    const { gen: e, data: n, $data: r, schema: s, schemaCode: i, it: a } = t;
    if (!r && s.length === 0)
      throw new Error("enum must have non-empty array");
    const o = s.length >= a.opts.loopEnum;
    let c;
    const l = () => c ?? (c = (0, Df.useFunc)(e, Mf.default));
    let f;
    if (o || r)
      f = e.let("valid"), t.block$data(f, d);
    else {
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      const v = e.const("vSchema", i);
      f = (0, Mn.or)(...s.map((w, y) => g(v, y)));
    }
    t.pass(f);
    function d() {
      e.assign(f, !1), e.forOf("v", i, (v) => e.if((0, Mn._)`${l()}(${n}, ${v})`, () => e.assign(f, !0).break()));
    }
    function g(v, w) {
      const y = s[w];
      return typeof y == "object" && y !== null ? (0, Mn._)`${l()}(${n}, ${v}[${w}])` : (0, Mn._)`${n} === ${y}`;
    }
  }
};
Xr.default = Vf;
Object.defineProperty(Kr, "__esModule", { value: !0 });
const Ff = hi, Uf = Br, qf = zr, Kf = Gr, Bf = Jr, zf = Hr, Gf = Yr, Jf = Wr, Hf = Qr, Yf = Xr, Wf = [
  // number
  Ff.default,
  Uf.default,
  // string
  qf.default,
  Kf.default,
  // object
  Bf.default,
  zf.default,
  // array
  Gf.default,
  Jf.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  Hf.default,
  Yf.default
];
Kr.default = Wf;
var er = {}, fn = {};
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.validateAdditionalItems = void 0;
const Pt = H, qs = X, Qf = {
  message: ({ params: { len: t } }) => (0, Pt.str)`must NOT have more than ${t} items`,
  params: ({ params: { len: t } }) => (0, Pt._)`{limit: ${t}}`
}, Xf = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: Qf,
  code(t) {
    const { parentSchema: e, it: n } = t, { items: r } = e;
    if (!Array.isArray(r)) {
      (0, qs.checkStrictMode)(n, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    Go(t, r);
  }
};
function Go(t, e) {
  const { gen: n, schema: r, data: s, keyword: i, it: a } = t;
  a.items = !0;
  const o = n.const("len", (0, Pt._)`${s}.length`);
  if (r === !1)
    t.setParams({ len: e.length }), t.pass((0, Pt._)`${o} <= ${e.length}`);
  else if (typeof r == "object" && !(0, qs.alwaysValidSchema)(a, r)) {
    const l = n.var("valid", (0, Pt._)`${o} <= ${e.length}`);
    n.if((0, Pt.not)(l), () => c(l)), t.ok(l);
  }
  function c(l) {
    n.forRange("i", e.length, o, (f) => {
      t.subschema({ keyword: i, dataProp: f, dataPropType: qs.Type.Num }, l), a.allErrors || n.if((0, Pt.not)(l), () => n.break());
    });
  }
}
fn.validateAdditionalItems = Go;
fn.default = Xf;
var pi = {}, dn = {};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.validateTuple = void 0;
const ja = H, Sr = X, Zf = Q, xf = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(t) {
    const { schema: e, it: n } = t;
    if (Array.isArray(e))
      return Jo(t, "additionalItems", e);
    n.items = !0, !(0, Sr.alwaysValidSchema)(n, e) && t.ok((0, Zf.validateArray)(t));
  }
};
function Jo(t, e, n = t.schema) {
  const { gen: r, parentSchema: s, data: i, keyword: a, it: o } = t;
  f(s), o.opts.unevaluated && n.length && o.items !== !0 && (o.items = Sr.mergeEvaluated.items(r, n.length, o.items));
  const c = r.name("valid"), l = r.const("len", (0, ja._)`${i}.length`);
  n.forEach((d, g) => {
    (0, Sr.alwaysValidSchema)(o, d) || (r.if((0, ja._)`${l} > ${g}`, () => t.subschema({
      keyword: a,
      schemaProp: g,
      dataProp: g
    }, c)), t.ok(c));
  });
  function f(d) {
    const { opts: g, errSchemaPath: v } = o, w = n.length, y = w === d.minItems && (w === d.maxItems || d[e] === !1);
    if (g.strictTuples && !y) {
      const h = `"${a}" is ${w}-tuple, but minItems or maxItems/${e} are not specified or different at path "${v}"`;
      (0, Sr.checkStrictMode)(o, h, g.strictTuples);
    }
  }
}
dn.validateTuple = Jo;
dn.default = xf;
Object.defineProperty(pi, "__esModule", { value: !0 });
const ed = dn, td = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (t) => (0, ed.validateTuple)(t, "items")
};
pi.default = td;
var yi = {};
Object.defineProperty(yi, "__esModule", { value: !0 });
const Ra = H, nd = X, rd = Q, sd = fn, id = {
  message: ({ params: { len: t } }) => (0, Ra.str)`must NOT have more than ${t} items`,
  params: ({ params: { len: t } }) => (0, Ra._)`{limit: ${t}}`
}, ad = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: id,
  code(t) {
    const { schema: e, parentSchema: n, it: r } = t, { prefixItems: s } = n;
    r.items = !0, !(0, nd.alwaysValidSchema)(r, e) && (s ? (0, sd.validateAdditionalItems)(t, s) : t.ok((0, rd.validateArray)(t)));
  }
};
yi.default = ad;
var gi = {};
Object.defineProperty(gi, "__esModule", { value: !0 });
const De = H, mr = X, od = {
  message: ({ params: { min: t, max: e } }) => e === void 0 ? (0, De.str)`must contain at least ${t} valid item(s)` : (0, De.str)`must contain at least ${t} and no more than ${e} valid item(s)`,
  params: ({ params: { min: t, max: e } }) => e === void 0 ? (0, De._)`{minContains: ${t}}` : (0, De._)`{minContains: ${t}, maxContains: ${e}}`
}, cd = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: od,
  code(t) {
    const { gen: e, schema: n, parentSchema: r, data: s, it: i } = t;
    let a, o;
    const { minContains: c, maxContains: l } = r;
    i.opts.next ? (a = c === void 0 ? 1 : c, o = l) : a = 1;
    const f = e.const("len", (0, De._)`${s}.length`);
    if (t.setParams({ min: a, max: o }), o === void 0 && a === 0) {
      (0, mr.checkStrictMode)(i, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (o !== void 0 && a > o) {
      (0, mr.checkStrictMode)(i, '"minContains" > "maxContains" is always invalid'), t.fail();
      return;
    }
    if ((0, mr.alwaysValidSchema)(i, n)) {
      let y = (0, De._)`${f} >= ${a}`;
      o !== void 0 && (y = (0, De._)`${y} && ${f} <= ${o}`), t.pass(y);
      return;
    }
    i.items = !0;
    const d = e.name("valid");
    o === void 0 && a === 1 ? v(d, () => e.if(d, () => e.break())) : a === 0 ? (e.let(d, !0), o !== void 0 && e.if((0, De._)`${s}.length > 0`, g)) : (e.let(d, !1), g()), t.result(d, () => t.reset());
    function g() {
      const y = e.name("_valid"), h = e.let("count", 0);
      v(y, () => e.if(y, () => w(h)));
    }
    function v(y, h) {
      e.forRange("i", 0, f, (u) => {
        t.subschema({
          keyword: "contains",
          dataProp: u,
          dataPropType: mr.Type.Num,
          compositeRule: !0
        }, y), h();
      });
    }
    function w(y) {
      e.code((0, De._)`${y}++`), o === void 0 ? e.if((0, De._)`${y} >= ${a}`, () => e.assign(d, !0).break()) : (e.if((0, De._)`${y} > ${o}`, () => e.assign(d, !1).break()), a === 1 ? e.assign(d, !0) : e.if((0, De._)`${y} >= ${a}`, () => e.assign(d, !0)));
    }
  }
};
gi.default = cd;
var Zr = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0;
  const e = H, n = X, r = Q;
  t.error = {
    message: ({ params: { property: c, depsCount: l, deps: f } }) => {
      const d = l === 1 ? "property" : "properties";
      return (0, e.str)`must have ${d} ${f} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: l, deps: f, missingProperty: d } }) => (0, e._)`{property: ${c},
    missingProperty: ${d},
    depsCount: ${l},
    deps: ${f}}`
    // TODO change to reference
  };
  const s = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: t.error,
    code(c) {
      const [l, f] = i(c);
      a(c, l), o(c, f);
    }
  };
  function i({ schema: c }) {
    const l = {}, f = {};
    for (const d in c) {
      if (d === "__proto__")
        continue;
      const g = Array.isArray(c[d]) ? l : f;
      g[d] = c[d];
    }
    return [l, f];
  }
  function a(c, l = c.schema) {
    const { gen: f, data: d, it: g } = c;
    if (Object.keys(l).length === 0)
      return;
    const v = f.let("missing");
    for (const w in l) {
      const y = l[w];
      if (y.length === 0)
        continue;
      const h = (0, r.propertyInData)(f, d, w, g.opts.ownProperties);
      c.setParams({
        property: w,
        depsCount: y.length,
        deps: y.join(", ")
      }), g.allErrors ? f.if(h, () => {
        for (const u of y)
          (0, r.checkReportMissingProp)(c, u);
      }) : (f.if((0, e._)`${h} && (${(0, r.checkMissingProp)(c, y, v)})`), (0, r.reportMissingProp)(c, v), f.else());
    }
  }
  t.validatePropertyDeps = a;
  function o(c, l = c.schema) {
    const { gen: f, data: d, keyword: g, it: v } = c, w = f.name("valid");
    for (const y in l)
      (0, n.alwaysValidSchema)(v, l[y]) || (f.if(
        (0, r.propertyInData)(f, d, y, v.opts.ownProperties),
        () => {
          const h = c.subschema({ keyword: g, schemaProp: y }, w);
          c.mergeValidEvaluated(h, w);
        },
        () => f.var(w, !0)
        // TODO var
      ), c.ok(w));
  }
  t.validateSchemaDeps = o, t.default = s;
})(Zr);
var $i = {};
Object.defineProperty($i, "__esModule", { value: !0 });
const Ho = H, ld = X, ud = {
  message: "property name must be valid",
  params: ({ params: t }) => (0, Ho._)`{propertyName: ${t.propertyName}}`
}, fd = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: ud,
  code(t) {
    const { gen: e, schema: n, data: r, it: s } = t;
    if ((0, ld.alwaysValidSchema)(s, n))
      return;
    const i = e.name("valid");
    e.forIn("key", r, (a) => {
      t.setParams({ propertyName: a }), t.subschema({
        keyword: "propertyNames",
        data: a,
        dataTypes: ["string"],
        propertyName: a,
        compositeRule: !0
      }, i), e.if((0, Ho.not)(i), () => {
        t.error(!0), s.allErrors || e.break();
      });
    }), t.ok(i);
  }
};
$i.default = fd;
var xr = {};
Object.defineProperty(xr, "__esModule", { value: !0 });
const pr = Q, Ue = H, dd = Te, yr = X, hd = {
  message: "must NOT have additional properties",
  params: ({ params: t }) => (0, Ue._)`{additionalProperty: ${t.additionalProperty}}`
}, md = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: hd,
  code(t) {
    const { gen: e, schema: n, parentSchema: r, data: s, errsCount: i, it: a } = t;
    if (!i)
      throw new Error("ajv implementation error");
    const { allErrors: o, opts: c } = a;
    if (a.props = !0, c.removeAdditional !== "all" && (0, yr.alwaysValidSchema)(a, n))
      return;
    const l = (0, pr.allSchemaProperties)(r.properties), f = (0, pr.allSchemaProperties)(r.patternProperties);
    d(), t.ok((0, Ue._)`${i} === ${dd.default.errors}`);
    function d() {
      e.forIn("key", s, (h) => {
        !l.length && !f.length ? w(h) : e.if(g(h), () => w(h));
      });
    }
    function g(h) {
      let u;
      if (l.length > 8) {
        const p = (0, yr.schemaRefOrVal)(a, r.properties, "properties");
        u = (0, pr.isOwnProperty)(e, p, h);
      } else
        l.length ? u = (0, Ue.or)(...l.map((p) => (0, Ue._)`${h} === ${p}`)) : u = Ue.nil;
      return f.length && (u = (0, Ue.or)(u, ...f.map((p) => (0, Ue._)`${(0, pr.usePattern)(t, p)}.test(${h})`))), (0, Ue.not)(u);
    }
    function v(h) {
      e.code((0, Ue._)`delete ${s}[${h}]`);
    }
    function w(h) {
      if (c.removeAdditional === "all" || c.removeAdditional && n === !1) {
        v(h);
        return;
      }
      if (n === !1) {
        t.setParams({ additionalProperty: h }), t.error(), o || e.break();
        return;
      }
      if (typeof n == "object" && !(0, yr.alwaysValidSchema)(a, n)) {
        const u = e.name("valid");
        c.removeAdditional === "failing" ? (y(h, u, !1), e.if((0, Ue.not)(u), () => {
          t.reset(), v(h);
        })) : (y(h, u), o || e.if((0, Ue.not)(u), () => e.break()));
      }
    }
    function y(h, u, p) {
      const b = {
        keyword: "additionalProperties",
        dataProp: h,
        dataPropType: yr.Type.Str
      };
      p === !1 && Object.assign(b, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), t.subschema(b, u);
    }
  }
};
xr.default = md;
var vi = {};
Object.defineProperty(vi, "__esModule", { value: !0 });
const pd = Me, Da = Q, ws = X, Ma = xr, yd = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(t) {
    const { gen: e, schema: n, parentSchema: r, data: s, it: i } = t;
    i.opts.removeAdditional === "all" && r.additionalProperties === void 0 && Ma.default.code(new pd.KeywordCxt(i, Ma.default, "additionalProperties"));
    const a = (0, Da.allSchemaProperties)(n);
    for (const d of a)
      i.definedProperties.add(d);
    i.opts.unevaluated && a.length && i.props !== !0 && (i.props = ws.mergeEvaluated.props(e, (0, ws.toHash)(a), i.props));
    const o = a.filter((d) => !(0, ws.alwaysValidSchema)(i, n[d]));
    if (o.length === 0)
      return;
    const c = e.name("valid");
    for (const d of o)
      l(d) ? f(d) : (e.if((0, Da.propertyInData)(e, s, d, i.opts.ownProperties)), f(d), i.allErrors || e.else().var(c, !0), e.endIf()), t.it.definedProperties.add(d), t.ok(c);
    function l(d) {
      return i.opts.useDefaults && !i.compositeRule && n[d].default !== void 0;
    }
    function f(d) {
      t.subschema({
        keyword: "properties",
        schemaProp: d,
        dataProp: d
      }, c);
    }
  }
};
vi.default = yd;
var bi = {};
Object.defineProperty(bi, "__esModule", { value: !0 });
const La = Q, gr = H, Va = X, Fa = X, gd = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(t) {
    const { gen: e, schema: n, data: r, parentSchema: s, it: i } = t, { opts: a } = i, o = (0, La.allSchemaProperties)(n), c = o.filter((y) => (0, Va.alwaysValidSchema)(i, n[y]));
    if (o.length === 0 || c.length === o.length && (!i.opts.unevaluated || i.props === !0))
      return;
    const l = a.strictSchema && !a.allowMatchingProperties && s.properties, f = e.name("valid");
    i.props !== !0 && !(i.props instanceof gr.Name) && (i.props = (0, Fa.evaluatedPropsToName)(e, i.props));
    const { props: d } = i;
    g();
    function g() {
      for (const y of o)
        l && v(y), i.allErrors ? w(y) : (e.var(f, !0), w(y), e.if(f));
    }
    function v(y) {
      for (const h in l)
        new RegExp(y).test(h) && (0, Va.checkStrictMode)(i, `property ${h} matches pattern ${y} (use allowMatchingProperties)`);
    }
    function w(y) {
      e.forIn("key", r, (h) => {
        e.if((0, gr._)`${(0, La.usePattern)(t, y)}.test(${h})`, () => {
          const u = c.includes(y);
          u || t.subschema({
            keyword: "patternProperties",
            schemaProp: y,
            dataProp: h,
            dataPropType: Fa.Type.Str
          }, f), i.opts.unevaluated && d !== !0 ? e.assign((0, gr._)`${d}[${h}]`, !0) : !u && !i.allErrors && e.if((0, gr.not)(f), () => e.break());
        });
      });
    }
  }
};
bi.default = gd;
var _i = {};
Object.defineProperty(_i, "__esModule", { value: !0 });
const $d = X, vd = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(t) {
    const { gen: e, schema: n, it: r } = t;
    if ((0, $d.alwaysValidSchema)(r, n)) {
      t.fail();
      return;
    }
    const s = e.name("valid");
    t.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, s), t.failResult(s, () => t.reset(), () => t.error());
  },
  error: { message: "must NOT be valid" }
};
_i.default = vd;
var wi = {};
Object.defineProperty(wi, "__esModule", { value: !0 });
const bd = Q, _d = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: bd.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
wi.default = _d;
var Si = {};
Object.defineProperty(Si, "__esModule", { value: !0 });
const Er = H, wd = X, Sd = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: t }) => (0, Er._)`{passingSchemas: ${t.passing}}`
}, Ed = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: Sd,
  code(t) {
    const { gen: e, schema: n, parentSchema: r, it: s } = t;
    if (!Array.isArray(n))
      throw new Error("ajv implementation error");
    if (s.opts.discriminator && r.discriminator)
      return;
    const i = n, a = e.let("valid", !1), o = e.let("passing", null), c = e.name("_valid");
    t.setParams({ passing: o }), e.block(l), t.result(a, () => t.reset(), () => t.error(!0));
    function l() {
      i.forEach((f, d) => {
        let g;
        (0, wd.alwaysValidSchema)(s, f) ? e.var(c, !0) : g = t.subschema({
          keyword: "oneOf",
          schemaProp: d,
          compositeRule: !0
        }, c), d > 0 && e.if((0, Er._)`${c} && ${a}`).assign(a, !1).assign(o, (0, Er._)`[${o}, ${d}]`).else(), e.if(c, () => {
          e.assign(a, !0), e.assign(o, d), g && t.mergeEvaluated(g, Er.Name);
        });
      });
    }
  }
};
Si.default = Ed;
var Ei = {};
Object.defineProperty(Ei, "__esModule", { value: !0 });
const Od = X, Nd = {
  keyword: "allOf",
  schemaType: "array",
  code(t) {
    const { gen: e, schema: n, it: r } = t;
    if (!Array.isArray(n))
      throw new Error("ajv implementation error");
    const s = e.name("valid");
    n.forEach((i, a) => {
      if ((0, Od.alwaysValidSchema)(r, i))
        return;
      const o = t.subschema({ keyword: "allOf", schemaProp: a }, s);
      t.ok(s), t.mergeEvaluated(o);
    });
  }
};
Ei.default = Nd;
var Oi = {};
Object.defineProperty(Oi, "__esModule", { value: !0 });
const jr = H, Yo = X, Pd = {
  message: ({ params: t }) => (0, jr.str)`must match "${t.ifClause}" schema`,
  params: ({ params: t }) => (0, jr._)`{failingKeyword: ${t.ifClause}}`
}, kd = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: Pd,
  code(t) {
    const { gen: e, parentSchema: n, it: r } = t;
    n.then === void 0 && n.else === void 0 && (0, Yo.checkStrictMode)(r, '"if" without "then" and "else" is ignored');
    const s = Ua(r, "then"), i = Ua(r, "else");
    if (!s && !i)
      return;
    const a = e.let("valid", !0), o = e.name("_valid");
    if (c(), t.reset(), s && i) {
      const f = e.let("ifClause");
      t.setParams({ ifClause: f }), e.if(o, l("then", f), l("else", f));
    } else
      s ? e.if(o, l("then")) : e.if((0, jr.not)(o), l("else"));
    t.pass(a, () => t.error(!0));
    function c() {
      const f = t.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, o);
      t.mergeEvaluated(f);
    }
    function l(f, d) {
      return () => {
        const g = t.subschema({ keyword: f }, o);
        e.assign(a, o), t.mergeValidEvaluated(g, a), d ? e.assign(d, (0, jr._)`${f}`) : t.setParams({ ifClause: f });
      };
    }
  }
};
function Ua(t, e) {
  const n = t.schema[e];
  return n !== void 0 && !(0, Yo.alwaysValidSchema)(t, n);
}
Oi.default = kd;
var Ni = {};
Object.defineProperty(Ni, "__esModule", { value: !0 });
const Ad = X, Td = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: t, parentSchema: e, it: n }) {
    e.if === void 0 && (0, Ad.checkStrictMode)(n, `"${t}" without "if" is ignored`);
  }
};
Ni.default = Td;
Object.defineProperty(er, "__esModule", { value: !0 });
const Id = fn, Cd = pi, jd = dn, Rd = yi, Dd = gi, Md = Zr, Ld = $i, Vd = xr, Fd = vi, Ud = bi, qd = _i, Kd = wi, Bd = Si, zd = Ei, Gd = Oi, Jd = Ni;
function Hd(t = !1) {
  const e = [
    // any
    qd.default,
    Kd.default,
    Bd.default,
    zd.default,
    Gd.default,
    Jd.default,
    // object
    Ld.default,
    Vd.default,
    Md.default,
    Fd.default,
    Ud.default
  ];
  return t ? e.push(Cd.default, Rd.default) : e.push(Id.default, jd.default), e.push(Dd.default), e;
}
er.default = Hd;
var tr = {}, Pi = {};
Object.defineProperty(Pi, "__esModule", { value: !0 });
const me = H, Yd = {
  message: ({ schemaCode: t }) => (0, me.str)`must match format "${t}"`,
  params: ({ schemaCode: t }) => (0, me._)`{format: ${t}}`
}, Wd = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: Yd,
  code(t, e) {
    const { gen: n, data: r, $data: s, schema: i, schemaCode: a, it: o } = t, { opts: c, errSchemaPath: l, schemaEnv: f, self: d } = o;
    if (!c.validateFormats)
      return;
    s ? g() : v();
    function g() {
      const w = n.scopeValue("formats", {
        ref: d.formats,
        code: c.code.formats
      }), y = n.const("fDef", (0, me._)`${w}[${a}]`), h = n.let("fType"), u = n.let("format");
      n.if((0, me._)`typeof ${y} == "object" && !(${y} instanceof RegExp)`, () => n.assign(h, (0, me._)`${y}.type || "string"`).assign(u, (0, me._)`${y}.validate`), () => n.assign(h, (0, me._)`"string"`).assign(u, y)), t.fail$data((0, me.or)(p(), b()));
      function p() {
        return c.strictSchema === !1 ? me.nil : (0, me._)`${a} && !${u}`;
      }
      function b() {
        const E = f.$async ? (0, me._)`(${y}.async ? await ${u}(${r}) : ${u}(${r}))` : (0, me._)`${u}(${r})`, C = (0, me._)`(typeof ${u} == "function" ? ${E} : ${u}.test(${r}))`;
        return (0, me._)`${u} && ${u} !== true && ${h} === ${e} && !${C}`;
      }
    }
    function v() {
      const w = d.formats[i];
      if (!w) {
        p();
        return;
      }
      if (w === !0)
        return;
      const [y, h, u] = b(w);
      y === e && t.pass(E());
      function p() {
        if (c.strictSchema === !1) {
          d.logger.warn(C());
          return;
        }
        throw new Error(C());
        function C() {
          return `unknown format "${i}" ignored in schema at path "${l}"`;
        }
      }
      function b(C) {
        const _ = C instanceof RegExp ? (0, me.regexpCode)(C) : c.code.formats ? (0, me._)`${c.code.formats}${(0, me.getProperty)(i)}` : void 0, P = n.scopeValue("formats", { key: i, ref: C, code: _ });
        return typeof C == "object" && !(C instanceof RegExp) ? [C.type || "string", C.validate, (0, me._)`${P}.validate`] : ["string", C, P];
      }
      function E() {
        if (typeof w == "object" && !(w instanceof RegExp) && w.async) {
          if (!f.$async)
            throw new Error("async format in sync schema");
          return (0, me._)`await ${u}(${r})`;
        }
        return typeof h == "function" ? (0, me._)`${u}(${r})` : (0, me._)`${u}.test(${r})`;
      }
    }
  }
};
Pi.default = Wd;
Object.defineProperty(tr, "__esModule", { value: !0 });
const Qd = Pi, Xd = [Qd.default];
tr.default = Xd;
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: !0 });
Rt.contentVocabulary = Rt.metadataVocabulary = void 0;
Rt.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
Rt.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(fi, "__esModule", { value: !0 });
const Zd = qr, xd = Kr, eh = er, th = tr, qa = Rt, nh = [
  Zd.default,
  xd.default,
  (0, eh.default)(),
  th.default,
  qa.metadataVocabulary,
  qa.contentVocabulary
];
fi.default = nh;
var nr = {}, Wo = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DiscrError = void 0, function(e) {
    e.Tag = "tag", e.Mapping = "mapping";
  }(t.DiscrError || (t.DiscrError = {}));
})(Wo);
Object.defineProperty(nr, "__esModule", { value: !0 });
const Xt = H, Ks = Wo, Ka = Ee, rh = X, sh = {
  message: ({ params: { discrError: t, tagName: e } }) => t === Ks.DiscrError.Tag ? `tag "${e}" must be string` : `value of tag "${e}" must be in oneOf`,
  params: ({ params: { discrError: t, tag: e, tagName: n } }) => (0, Xt._)`{error: ${t}, tag: ${n}, tagValue: ${e}}`
}, ih = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: sh,
  code(t) {
    const { gen: e, data: n, schema: r, parentSchema: s, it: i } = t, { oneOf: a } = s;
    if (!i.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const o = r.propertyName;
    if (typeof o != "string")
      throw new Error("discriminator: requires propertyName");
    if (r.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!a)
      throw new Error("discriminator: requires oneOf keyword");
    const c = e.let("valid", !1), l = e.const("tag", (0, Xt._)`${n}${(0, Xt.getProperty)(o)}`);
    e.if((0, Xt._)`typeof ${l} == "string"`, () => f(), () => t.error(!1, { discrError: Ks.DiscrError.Tag, tag: l, tagName: o })), t.ok(c);
    function f() {
      const v = g();
      e.if(!1);
      for (const w in v)
        e.elseIf((0, Xt._)`${l} === ${w}`), e.assign(c, d(v[w]));
      e.else(), t.error(!1, { discrError: Ks.DiscrError.Mapping, tag: l, tagName: o }), e.endIf();
    }
    function d(v) {
      const w = e.name("valid"), y = t.subschema({ keyword: "oneOf", schemaProp: v }, w);
      return t.mergeEvaluated(y, Xt.Name), w;
    }
    function g() {
      var v;
      const w = {}, y = u(s);
      let h = !0;
      for (let E = 0; E < a.length; E++) {
        let C = a[E];
        C != null && C.$ref && !(0, rh.schemaHasRulesButRef)(C, i.self.RULES) && (C = Ka.resolveRef.call(i.self, i.schemaEnv.root, i.baseId, C == null ? void 0 : C.$ref), C instanceof Ka.SchemaEnv && (C = C.schema));
        const _ = (v = C == null ? void 0 : C.properties) === null || v === void 0 ? void 0 : v[o];
        if (typeof _ != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`);
        h = h && (y || u(C)), p(_, E);
      }
      if (!h)
        throw new Error(`discriminator: "${o}" must be required`);
      return w;
      function u({ required: E }) {
        return Array.isArray(E) && E.includes(o);
      }
      function p(E, C) {
        if (E.const)
          b(E.const, C);
        else if (E.enum)
          for (const _ of E.enum)
            b(_, C);
        else
          throw new Error(`discriminator: "properties/${o}" must have "const" or "enum"`);
      }
      function b(E, C) {
        if (typeof E != "string" || E in w)
          throw new Error(`discriminator: "${o}" values must be unique strings`);
        w[E] = C;
      }
    }
  }
};
nr.default = ih;
const ah = "http://json-schema.org/draft-07/schema#", oh = "http://json-schema.org/draft-07/schema#", ch = "Core schema meta-schema", lh = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, uh = [
  "object",
  "boolean"
], fh = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, dh = {
  $schema: ah,
  $id: oh,
  title: ch,
  definitions: lh,
  type: uh,
  properties: fh,
  default: !0
};
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const n = Ct, r = fi, s = nr, i = dh, a = ["/properties"], o = "http://json-schema.org/draft-07/schema";
  class c extends n.default {
    _addVocabularies() {
      super._addVocabularies(), r.default.forEach((w) => this.addVocabulary(w)), this.opts.discriminator && this.addKeyword(s.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const w = this.opts.$data ? this.$dataMetaSchema(i, a) : i;
      this.addMetaSchema(w, o, !1), this.refs["http://json-schema.org/schema"] = o;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
    }
  }
  t.exports = e = c, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = c;
  var l = Me;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return l.KeywordCxt;
  } });
  var f = H;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return f._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return f.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return f.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return f.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return f.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return f.CodeGen;
  } });
  var d = ln;
  Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var g = un;
  Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
    return g.default;
  } });
})(Ms, Ms.exports);
var hh = Ms.exports;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.formatLimitDefinition = void 0;
  const e = hh, n = H, r = n.operators, s = {
    formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
    formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
    formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE }
  }, i = {
    message: ({ keyword: o, schemaCode: c }) => n.str`should be ${s[o].okStr} ${c}`,
    params: ({ keyword: o, schemaCode: c }) => n._`{comparison: ${s[o].okStr}, limit: ${c}}`
  };
  t.formatLimitDefinition = {
    keyword: Object.keys(s),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: i,
    code(o) {
      const { gen: c, data: l, schemaCode: f, keyword: d, it: g } = o, { opts: v, self: w } = g;
      if (!v.validateFormats)
        return;
      const y = new e.KeywordCxt(g, w.RULES.all.format.definition, "format");
      y.$data ? h() : u();
      function h() {
        const b = c.scopeValue("formats", {
          ref: w.formats,
          code: v.code.formats
        }), E = c.const("fmt", n._`${b}[${y.schemaCode}]`);
        o.fail$data(n.or(n._`typeof ${E} != "object"`, n._`${E} instanceof RegExp`, n._`typeof ${E}.compare != "function"`, p(E)));
      }
      function u() {
        const b = y.schema, E = w.formats[b];
        if (!E || E === !0)
          return;
        if (typeof E != "object" || E instanceof RegExp || typeof E.compare != "function")
          throw new Error(`"${d}": format "${b}" does not define "compare" function`);
        const C = c.scopeValue("formats", {
          key: b,
          ref: E,
          code: v.code.formats ? n._`${v.code.formats}${n.getProperty(b)}` : void 0
        });
        o.fail$data(p(C));
      }
      function p(b) {
        return n._`${b}.compare(${l}, ${f}) ${s[d].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const a = (o) => (o.addKeyword(t.formatLimitDefinition), o);
  t.default = a;
})(yo);
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const n = po, r = yo, s = H, i = new s.Name("fullFormats"), a = new s.Name("fastFormats"), o = (l, f = { keywords: !0 }) => {
    if (Array.isArray(f))
      return c(l, f, n.fullFormats, i), l;
    const [d, g] = f.mode === "fast" ? [n.fastFormats, a] : [n.fullFormats, i], v = f.formats || n.formatNames;
    return c(l, v, d, g), f.keywords && r.default(l), l;
  };
  o.get = (l, f = "full") => {
    const g = (f === "fast" ? n.fastFormats : n.fullFormats)[l];
    if (!g)
      throw new Error(`Unknown format "${l}"`);
    return g;
  };
  function c(l, f, d, g) {
    var v, w;
    (v = (w = l.opts.code).formats) !== null && v !== void 0 || (w.formats = s._`require("ajv-formats/dist/formats").${g}`);
    for (const y of f)
      l.addFormat(y, d[y]);
  }
  t.exports = e = o, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = o;
})(Ds, Ds.exports);
var mh = Ds.exports;
const ph = /* @__PURE__ */ ri(mh);
var Bs = { exports: {} }, ki = {}, Ai = {};
Object.defineProperty(Ai, "__esModule", { value: !0 });
const yh = et, gh = [
  "$schema",
  "id",
  "$defs",
  { keyword: "$comment" },
  "definitions",
  yh.default
];
Ai.default = gh;
var Ti = {}, Ii = {};
Object.defineProperty(Ii, "__esModule", { value: !0 });
const zs = Ct, $h = H, ft = $h.operators, Gs = {
  maximum: {
    exclusive: "exclusiveMaximum",
    ops: [
      { okStr: "<=", ok: ft.LTE, fail: ft.GT },
      { okStr: "<", ok: ft.LT, fail: ft.GTE }
    ]
  },
  minimum: {
    exclusive: "exclusiveMinimum",
    ops: [
      { okStr: ">=", ok: ft.GTE, fail: ft.LT },
      { okStr: ">", ok: ft.GT, fail: ft.LTE }
    ]
  }
}, vh = {
  message: (t) => zs.str`must be ${Js(t).okStr} ${t.schemaCode}`,
  params: (t) => zs._`{comparison: ${Js(t).okStr}, limit: ${t.schemaCode}}`
}, bh = {
  keyword: Object.keys(Gs),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: vh,
  code(t) {
    const { data: e, schemaCode: n } = t;
    t.fail$data(zs._`${e} ${Js(t).fail} ${n} || isNaN(${e})`);
  }
};
function Js(t) {
  var e;
  const n = t.keyword, r = !((e = t.parentSchema) === null || e === void 0) && e[Gs[n].exclusive] ? 1 : 0;
  return Gs[n].ops[r];
}
Ii.default = bh;
var Ci = {};
Object.defineProperty(Ci, "__esModule", { value: !0 });
const Ba = {
  exclusiveMaximum: "maximum",
  exclusiveMinimum: "minimum"
}, _h = {
  keyword: Object.keys(Ba),
  type: "number",
  schemaType: "boolean",
  code({ keyword: t, parentSchema: e }) {
    const n = Ba[t];
    if (e[n] === void 0)
      throw new Error(`${t} can only be used with ${n}`);
  }
};
Ci.default = _h;
Object.defineProperty(Ti, "__esModule", { value: !0 });
const wh = Ii, Sh = Ci, Eh = Br, Oh = zr, Nh = Gr, Ph = Jr, kh = Hr, Ah = Yr, Th = Wr, Ih = Qr, Ch = Xr, jh = [
  // number
  wh.default,
  Sh.default,
  Eh.default,
  // string
  Oh.default,
  Nh.default,
  // object
  Ph.default,
  kh.default,
  // array
  Ah.default,
  Th.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  Ih.default,
  Ch.default
];
Ti.default = jh;
Object.defineProperty(ki, "__esModule", { value: !0 });
const Rh = Ai, Dh = Ti, Mh = er, Lh = tr, Vh = ["title", "description", "default"], Fh = [
  Rh.default,
  Dh.default,
  Mh.default(),
  Lh.default,
  Vh
];
ki.default = Fh;
const Uh = "http://json-schema.org/draft-04/schema#", qh = "http://json-schema.org/draft-04/schema#", Kh = "Core schema meta-schema", Bh = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: !0
  }
}, zh = "object", Gh = {
  id: {
    type: "string",
    format: "uri"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: !0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: !1
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: !1
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, Jh = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, Hh = {
  id: Uh,
  $schema: qh,
  description: Kh,
  definitions: Bh,
  type: zh,
  properties: Gh,
  dependencies: Jh,
  default: {}
};
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const n = Ct, r = ki, s = nr, i = Hh, a = ["/properties"], o = "http://json-schema.org/draft-04/schema";
  class c extends n.default {
    constructor(g = {}) {
      super({
        ...g,
        schemaId: "id"
      });
    }
    _addVocabularies() {
      super._addVocabularies(), r.default.forEach((g) => this.addVocabulary(g)), this.opts.discriminator && this.addKeyword(s.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const g = this.opts.$data ? this.$dataMetaSchema(i, a) : i;
      this.addMetaSchema(g, o, !1), this.refs["http://json-schema.org/schema"] = o;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
    }
  }
  t.exports = e = c, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = c;
  var l = Ct;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return l.KeywordCxt;
  } });
  var f = Ct;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return f._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return f.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return f.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return f.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return f.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return f.CodeGen;
  } });
})(Bs, Bs.exports);
var Yh = Bs.exports;
const Wh = /* @__PURE__ */ ri(Yh);
var Hs = { exports: {} }, ji = {}, Ri = {}, hn = {};
Object.defineProperty(hn, "__esModule", { value: !0 });
hn.dynamicAnchor = void 0;
const Ss = H, Qh = Te, za = Ee, Xh = et, Zh = {
  keyword: "$dynamicAnchor",
  schemaType: "string",
  code: (t) => Qo(t, t.schema)
};
function Qo(t, e) {
  const { gen: n, it: r } = t;
  r.schemaEnv.root.dynamicAnchors[e] = !0;
  const s = (0, Ss._)`${Qh.default.dynamicAnchors}${(0, Ss.getProperty)(e)}`, i = r.errSchemaPath === "#" ? r.validateName : xh(t);
  n.if((0, Ss._)`!${s}`, () => n.assign(s, i));
}
hn.dynamicAnchor = Qo;
function xh(t) {
  const { schemaEnv: e, schema: n, self: r } = t.it, { root: s, baseId: i, localRefs: a, meta: o } = e.root, { schemaId: c } = r.opts, l = new za.SchemaEnv({ schema: n, schemaId: c, root: s, baseId: i, localRefs: a, meta: o });
  return za.compileSchema.call(r, l), (0, Xh.getValidate)(t, l);
}
hn.default = Zh;
var mn = {};
Object.defineProperty(mn, "__esModule", { value: !0 });
mn.dynamicRef = void 0;
const Ga = H, em = Te, Ja = et, tm = {
  keyword: "$dynamicRef",
  schemaType: "string",
  code: (t) => Xo(t, t.schema)
};
function Xo(t, e) {
  const { gen: n, keyword: r, it: s } = t;
  if (e[0] !== "#")
    throw new Error(`"${r}" only supports hash fragment reference`);
  const i = e.slice(1);
  if (s.allErrors)
    a();
  else {
    const c = n.let("valid", !1);
    a(c), t.ok(c);
  }
  function a(c) {
    if (s.schemaEnv.root.dynamicAnchors[i]) {
      const l = n.let("_v", (0, Ga._)`${em.default.dynamicAnchors}${(0, Ga.getProperty)(i)}`);
      n.if(l, o(l, c), o(s.validateName, c));
    } else
      o(s.validateName, c)();
  }
  function o(c, l) {
    return l ? () => n.block(() => {
      (0, Ja.callRef)(t, c), n.let(l, !0);
    }) : () => (0, Ja.callRef)(t, c);
  }
}
mn.dynamicRef = Xo;
mn.default = tm;
var Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 });
const nm = hn, rm = X, sm = {
  keyword: "$recursiveAnchor",
  schemaType: "boolean",
  code(t) {
    t.schema ? (0, nm.dynamicAnchor)(t, "") : (0, rm.checkStrictMode)(t.it, "$recursiveAnchor: false is ignored");
  }
};
Di.default = sm;
var Mi = {};
Object.defineProperty(Mi, "__esModule", { value: !0 });
const im = mn, am = {
  keyword: "$recursiveRef",
  schemaType: "string",
  code: (t) => (0, im.dynamicRef)(t, t.schema)
};
Mi.default = am;
Object.defineProperty(Ri, "__esModule", { value: !0 });
const om = hn, cm = mn, lm = Di, um = Mi, fm = [om.default, cm.default, lm.default, um.default];
Ri.default = fm;
var Li = {}, Vi = {};
Object.defineProperty(Vi, "__esModule", { value: !0 });
const Ha = Zr, dm = {
  keyword: "dependentRequired",
  type: "object",
  schemaType: "object",
  error: Ha.error,
  code: (t) => (0, Ha.validatePropertyDeps)(t)
};
Vi.default = dm;
var Fi = {};
Object.defineProperty(Fi, "__esModule", { value: !0 });
const hm = Zr, mm = {
  keyword: "dependentSchemas",
  type: "object",
  schemaType: "object",
  code: (t) => (0, hm.validateSchemaDeps)(t)
};
Fi.default = mm;
var Ui = {};
Object.defineProperty(Ui, "__esModule", { value: !0 });
const pm = X, ym = {
  keyword: ["maxContains", "minContains"],
  type: "array",
  schemaType: "number",
  code({ keyword: t, parentSchema: e, it: n }) {
    e.contains === void 0 && (0, pm.checkStrictMode)(n, `"${t}" without "contains" is ignored`);
  }
};
Ui.default = ym;
Object.defineProperty(Li, "__esModule", { value: !0 });
const gm = Vi, $m = Fi, vm = Ui, bm = [gm.default, $m.default, vm.default];
Li.default = bm;
var qi = {}, Ki = {};
Object.defineProperty(Ki, "__esModule", { value: !0 });
const dt = H, Ya = X, _m = Te, wm = {
  message: "must NOT have unevaluated properties",
  params: ({ params: t }) => (0, dt._)`{unevaluatedProperty: ${t.unevaluatedProperty}}`
}, Sm = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: !0,
  error: wm,
  code(t) {
    const { gen: e, schema: n, data: r, errsCount: s, it: i } = t;
    if (!s)
      throw new Error("ajv implementation error");
    const { allErrors: a, props: o } = i;
    o instanceof dt.Name ? e.if((0, dt._)`${o} !== true`, () => e.forIn("key", r, (d) => e.if(l(o, d), () => c(d)))) : o !== !0 && e.forIn("key", r, (d) => o === void 0 ? c(d) : e.if(f(o, d), () => c(d))), i.props = !0, t.ok((0, dt._)`${s} === ${_m.default.errors}`);
    function c(d) {
      if (n === !1) {
        t.setParams({ unevaluatedProperty: d }), t.error(), a || e.break();
        return;
      }
      if (!(0, Ya.alwaysValidSchema)(i, n)) {
        const g = e.name("valid");
        t.subschema({
          keyword: "unevaluatedProperties",
          dataProp: d,
          dataPropType: Ya.Type.Str
        }, g), a || e.if((0, dt.not)(g), () => e.break());
      }
    }
    function l(d, g) {
      return (0, dt._)`!${d} || !${d}[${g}]`;
    }
    function f(d, g) {
      const v = [];
      for (const w in d)
        d[w] === !0 && v.push((0, dt._)`${g} !== ${w}`);
      return (0, dt.and)(...v);
    }
  }
};
Ki.default = Sm;
var Bi = {};
Object.defineProperty(Bi, "__esModule", { value: !0 });
const kt = H, Wa = X, Em = {
  message: ({ params: { len: t } }) => (0, kt.str)`must NOT have more than ${t} items`,
  params: ({ params: { len: t } }) => (0, kt._)`{limit: ${t}}`
}, Om = {
  keyword: "unevaluatedItems",
  type: "array",
  schemaType: ["boolean", "object"],
  error: Em,
  code(t) {
    const { gen: e, schema: n, data: r, it: s } = t, i = s.items || 0;
    if (i === !0)
      return;
    const a = e.const("len", (0, kt._)`${r}.length`);
    if (n === !1)
      t.setParams({ len: i }), t.fail((0, kt._)`${a} > ${i}`);
    else if (typeof n == "object" && !(0, Wa.alwaysValidSchema)(s, n)) {
      const c = e.var("valid", (0, kt._)`${a} <= ${i}`);
      e.if((0, kt.not)(c), () => o(c, i)), t.ok(c);
    }
    s.items = !0;
    function o(c, l) {
      e.forRange("i", l, a, (f) => {
        t.subschema({ keyword: "unevaluatedItems", dataProp: f, dataPropType: Wa.Type.Num }, c), s.allErrors || e.if((0, kt.not)(c), () => e.break());
      });
    }
  }
};
Bi.default = Om;
Object.defineProperty(qi, "__esModule", { value: !0 });
const Nm = Ki, Pm = Bi, km = [Nm.default, Pm.default];
qi.default = km;
Object.defineProperty(ji, "__esModule", { value: !0 });
const Am = qr, Tm = Kr, Im = er, Cm = Ri, jm = Li, Rm = qi, Dm = tr, Qa = Rt, Mm = [
  Cm.default,
  Am.default,
  Tm.default,
  (0, Im.default)(!0),
  Dm.default,
  Qa.metadataVocabulary,
  Qa.contentVocabulary,
  jm.default,
  Rm.default
];
ji.default = Mm;
var zi = {};
const Lm = "https://json-schema.org/draft/2020-12/schema", Vm = "https://json-schema.org/draft/2020-12/schema", Fm = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, Um = "meta", qm = "Core and Validation specifications meta-schema", Km = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], Bm = [
  "object",
  "boolean"
], zm = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", Gm = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: !0,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: !0,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: !0
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: !0
  }
}, Jm = {
  $schema: Lm,
  $id: Vm,
  $vocabulary: Fm,
  $dynamicAnchor: Um,
  title: qm,
  allOf: Km,
  type: Bm,
  $comment: zm,
  properties: Gm
}, Hm = "https://json-schema.org/draft/2020-12/schema", Ym = "https://json-schema.org/draft/2020-12/meta/applicator", Wm = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0
}, Qm = "meta", Xm = "Applicator vocabulary meta-schema", Zm = [
  "object",
  "boolean"
], xm = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, ep = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, tp = {
  $schema: Hm,
  $id: Ym,
  $vocabulary: Wm,
  $dynamicAnchor: Qm,
  title: Xm,
  type: Zm,
  properties: xm,
  $defs: ep
}, np = "https://json-schema.org/draft/2020-12/schema", rp = "https://json-schema.org/draft/2020-12/meta/unevaluated", sp = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, ip = "meta", ap = "Unevaluated applicator vocabulary meta-schema", op = [
  "object",
  "boolean"
], cp = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, lp = {
  $schema: np,
  $id: rp,
  $vocabulary: sp,
  $dynamicAnchor: ip,
  title: ap,
  type: op,
  properties: cp
}, up = "https://json-schema.org/draft/2020-12/schema", fp = "https://json-schema.org/draft/2020-12/meta/content", dp = {
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, hp = "meta", mp = "Content vocabulary meta-schema", pp = [
  "object",
  "boolean"
], yp = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, gp = {
  $schema: up,
  $id: fp,
  $vocabulary: dp,
  $dynamicAnchor: hp,
  title: mp,
  type: pp,
  properties: yp
}, $p = "https://json-schema.org/draft/2020-12/schema", vp = "https://json-schema.org/draft/2020-12/meta/core", bp = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0
}, _p = "meta", wp = "Core vocabulary meta-schema", Sp = [
  "object",
  "boolean"
], Ep = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, Op = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, Np = {
  $schema: $p,
  $id: vp,
  $vocabulary: bp,
  $dynamicAnchor: _p,
  title: wp,
  type: Sp,
  properties: Ep,
  $defs: Op
}, Pp = "https://json-schema.org/draft/2020-12/schema", kp = "https://json-schema.org/draft/2020-12/meta/format-annotation", Ap = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0
}, Tp = "meta", Ip = "Format vocabulary meta-schema for annotation results", Cp = [
  "object",
  "boolean"
], jp = {
  format: {
    type: "string"
  }
}, Rp = {
  $schema: Pp,
  $id: kp,
  $vocabulary: Ap,
  $dynamicAnchor: Tp,
  title: Ip,
  type: Cp,
  properties: jp
}, Dp = "https://json-schema.org/draft/2020-12/schema", Mp = "https://json-schema.org/draft/2020-12/meta/meta-data", Lp = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0
}, Vp = "meta", Fp = "Meta-data vocabulary meta-schema", Up = [
  "object",
  "boolean"
], qp = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  deprecated: {
    type: "boolean",
    default: !1
  },
  readOnly: {
    type: "boolean",
    default: !1
  },
  writeOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  }
}, Kp = {
  $schema: Dp,
  $id: Mp,
  $vocabulary: Lp,
  $dynamicAnchor: Vp,
  title: Fp,
  type: Up,
  properties: qp
}, Bp = "https://json-schema.org/draft/2020-12/schema", zp = "https://json-schema.org/draft/2020-12/meta/validation", Gp = {
  "https://json-schema.org/draft/2020-12/vocab/validation": !0
}, Jp = "meta", Hp = "Validation vocabulary meta-schema", Yp = [
  "object",
  "boolean"
], Wp = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  const: !0,
  enum: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, Qp = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, Xp = {
  $schema: Bp,
  $id: zp,
  $vocabulary: Gp,
  $dynamicAnchor: Jp,
  title: Hp,
  type: Yp,
  properties: Wp,
  $defs: Qp
};
Object.defineProperty(zi, "__esModule", { value: !0 });
const Zp = Jm, xp = tp, ey = lp, ty = gp, ny = Np, ry = Rp, sy = Kp, iy = Xp, ay = ["/properties"];
function oy(t) {
  return [
    Zp,
    xp,
    ey,
    ty,
    ny,
    e(this, ry),
    sy,
    e(this, iy)
  ].forEach((n) => this.addMetaSchema(n, void 0, !1)), this;
  function e(n, r) {
    return t ? n.$dataMetaSchema(r, ay) : r;
  }
}
zi.default = oy;
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const n = Ct, r = ji, s = nr, i = zi, a = "https://json-schema.org/draft/2020-12/schema";
  class o extends n.default {
    constructor(v = {}) {
      super({
        ...v,
        dynamicRef: !0,
        next: !0,
        unevaluated: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), r.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(s.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      const { $data: v, meta: w } = this.opts;
      w && (i.default.call(this, v), this.refs["http://json-schema.org/schema"] = a);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  t.exports = e = o, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = o;
  var c = Me;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var l = H;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
  var f = ln;
  Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
    return f.default;
  } });
  var d = un;
  Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
    return d.default;
  } });
})(Hs, Hs.exports);
var cy = Hs.exports;
const ly = /* @__PURE__ */ ri(cy), Zo = ["2.0", "3.0", "3.1"], uy = {
  "http://json-schema.org/draft-04/schema#": Wh,
  "https://json-schema.org/draft/2020-12/schema": ly
}, Ys = {
  EMPTY_OR_INVALID: "Cannot find JSON, YAML or filename in data",
  // URI_MUST_BE_STRING: 'uri parameter or $id attribute must be a string',
  OPENAPI_VERSION_NOT_SUPPORTED: "Cannot find supported Swagger/OpenAPI version in specification, version must be a string.",
  INVALID_REFERENCE: "Cant resolve URI: %s",
  EXTERNAL_REFERENCE_NOT_SUPPORTED: "External references are not supported yet: %s"
}, fy = "x-inlined-refs";
function Qe(t, e) {
  const n = {};
  for (const [r, s] of Object.entries(t))
    Array.isArray(s) ? n[r] = s.map((i) => typeof i == "object" && i !== null ? Qe(i, e) : i) : typeof s == "object" && s !== null ? n[r] = Qe(s, e) : n[r] = s;
  return e(n);
}
function dy(t, e) {
  return Qe(t, (n) => e(n) ? n : void 0);
}
function xo(t) {
  return typeof t !== void 0 && Array.isArray(t) && t.length > 0 && t.some((e) => e.isEntrypoint === !0);
}
const Yt = {};
function Ws(t) {
  const e = [];
  return !t || typeof t != "object" || Qe(t, (n) => (n.$ref && typeof n.$ref == "string" && !n.$ref.startsWith("#") && e.push(n.$ref.split("#")[0]), n)), e;
}
const Gi = Symbol.for("yaml.alias"), Qs = Symbol.for("yaml.document"), yt = Symbol.for("yaml.map"), ec = Symbol.for("yaml.pair"), ot = Symbol.for("yaml.scalar"), pn = Symbol.for("yaml.seq"), Ve = Symbol.for("yaml.node.type"), Mt = (t) => !!t && typeof t == "object" && t[Ve] === Gi, yn = (t) => !!t && typeof t == "object" && t[Ve] === Qs, gn = (t) => !!t && typeof t == "object" && t[Ve] === yt, le = (t) => !!t && typeof t == "object" && t[Ve] === ec, re = (t) => !!t && typeof t == "object" && t[Ve] === ot, $n = (t) => !!t && typeof t == "object" && t[Ve] === pn;
function ue(t) {
  if (t && typeof t == "object")
    switch (t[Ve]) {
      case yt:
      case pn:
        return !0;
    }
  return !1;
}
function pe(t) {
  if (t && typeof t == "object")
    switch (t[Ve]) {
      case Gi:
      case yt:
      case ot:
      case pn:
        return !0;
    }
  return !1;
}
const hy = (t) => (re(t) || ue(t)) && !!t.anchor, Pe = Symbol("break visit"), tc = Symbol("skip children"), xe = Symbol("remove node");
function gt(t, e) {
  const n = nc(e);
  yn(t) ? Zt(null, t.contents, n, Object.freeze([t])) === xe && (t.contents = null) : Zt(null, t, n, Object.freeze([]));
}
gt.BREAK = Pe;
gt.SKIP = tc;
gt.REMOVE = xe;
function Zt(t, e, n, r) {
  const s = rc(t, e, n, r);
  if (pe(s) || le(s))
    return sc(t, r, s), Zt(t, s, n, r);
  if (typeof s != "symbol") {
    if (ue(e)) {
      r = Object.freeze(r.concat(e));
      for (let i = 0; i < e.items.length; ++i) {
        const a = Zt(i, e.items[i], n, r);
        if (typeof a == "number")
          i = a - 1;
        else {
          if (a === Pe)
            return Pe;
          a === xe && (e.items.splice(i, 1), i -= 1);
        }
      }
    } else if (le(e)) {
      r = Object.freeze(r.concat(e));
      const i = Zt("key", e.key, n, r);
      if (i === Pe)
        return Pe;
      i === xe && (e.key = null);
      const a = Zt("value", e.value, n, r);
      if (a === Pe)
        return Pe;
      a === xe && (e.value = null);
    }
  }
  return s;
}
async function es(t, e) {
  const n = nc(e);
  yn(t) ? await xt(null, t.contents, n, Object.freeze([t])) === xe && (t.contents = null) : await xt(null, t, n, Object.freeze([]));
}
es.BREAK = Pe;
es.SKIP = tc;
es.REMOVE = xe;
async function xt(t, e, n, r) {
  const s = await rc(t, e, n, r);
  if (pe(s) || le(s))
    return sc(t, r, s), xt(t, s, n, r);
  if (typeof s != "symbol") {
    if (ue(e)) {
      r = Object.freeze(r.concat(e));
      for (let i = 0; i < e.items.length; ++i) {
        const a = await xt(i, e.items[i], n, r);
        if (typeof a == "number")
          i = a - 1;
        else {
          if (a === Pe)
            return Pe;
          a === xe && (e.items.splice(i, 1), i -= 1);
        }
      }
    } else if (le(e)) {
      r = Object.freeze(r.concat(e));
      const i = await xt("key", e.key, n, r);
      if (i === Pe)
        return Pe;
      i === xe && (e.key = null);
      const a = await xt("value", e.value, n, r);
      if (a === Pe)
        return Pe;
      a === xe && (e.value = null);
    }
  }
  return s;
}
function nc(t) {
  return typeof t == "object" && (t.Collection || t.Node || t.Value) ? Object.assign({
    Alias: t.Node,
    Map: t.Node,
    Scalar: t.Node,
    Seq: t.Node
  }, t.Value && {
    Map: t.Value,
    Scalar: t.Value,
    Seq: t.Value
  }, t.Collection && {
    Map: t.Collection,
    Seq: t.Collection
  }, t) : t;
}
function rc(t, e, n, r) {
  var s, i, a, o, c;
  if (typeof n == "function")
    return n(t, e, r);
  if (gn(e))
    return (s = n.Map) == null ? void 0 : s.call(n, t, e, r);
  if ($n(e))
    return (i = n.Seq) == null ? void 0 : i.call(n, t, e, r);
  if (le(e))
    return (a = n.Pair) == null ? void 0 : a.call(n, t, e, r);
  if (re(e))
    return (o = n.Scalar) == null ? void 0 : o.call(n, t, e, r);
  if (Mt(e))
    return (c = n.Alias) == null ? void 0 : c.call(n, t, e, r);
}
function sc(t, e, n) {
  const r = e[e.length - 1];
  if (ue(r))
    r.items[t] = n;
  else if (le(r))
    t === "key" ? r.key = n : r.value = n;
  else if (yn(r))
    r.contents = n;
  else {
    const s = Mt(r) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${s} parent`);
  }
}
const my = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, py = (t) => t.replace(/[!,[\]{}]/g, (e) => my[e]);
class Se {
  constructor(e, n) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Se.defaultYaml, e), this.tags = Object.assign({}, Se.defaultTags, n);
  }
  clone() {
    const e = new Se(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new Se(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Se.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Se.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, n) {
    this.atNextDocument && (this.yaml = { explicit: Se.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Se.defaultTags), this.atNextDocument = !1);
    const r = e.trim().split(/[ \t]+/), s = r.shift();
    switch (s) {
      case "%TAG": {
        if (r.length !== 2 && (n(0, "%TAG directive should contain exactly two parts"), r.length < 2))
          return !1;
        const [i, a] = r;
        return this.tags[i] = a, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, r.length !== 1)
          return n(0, "%YAML directive should contain exactly one part"), !1;
        const [i] = r;
        if (i === "1.1" || i === "1.2")
          return this.yaml.version = i, !0;
        {
          const a = /^\d+\.\d+$/.test(i);
          return n(6, `Unsupported YAML version ${i}`, a), !1;
        }
      }
      default:
        return n(0, `Unknown directive ${s}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, n) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return n(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const a = e.slice(2, -1);
      return a === "!" || a === "!!" ? (n(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && n("Verbatim tags must end with a >"), a);
    }
    const [, r, s] = e.match(/^(.*!)([^!]*)$/s);
    s || n(`The ${e} tag has no suffix`);
    const i = this.tags[r];
    if (i)
      try {
        return i + decodeURIComponent(s);
      } catch (a) {
        return n(String(a)), null;
      }
    return r === "!" ? e : (n(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [n, r] of Object.entries(this.tags))
      if (e.startsWith(r))
        return n + py(e.substring(r.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const n = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], r = Object.entries(this.tags);
    let s;
    if (e && r.length > 0 && pe(e.contents)) {
      const i = {};
      gt(e.contents, (a, o) => {
        pe(o) && o.tag && (i[o.tag] = !0);
      }), s = Object.keys(i);
    } else
      s = [];
    for (const [i, a] of r)
      i === "!!" && a === "tag:yaml.org,2002:" || (!e || s.some((o) => o.startsWith(a))) && n.push(`%TAG ${i} ${a}`);
    return n.join(`
`);
  }
}
Se.defaultYaml = { explicit: !1, version: "1.2" };
Se.defaultTags = { "!!": "tag:yaml.org,2002:" };
function ic(t) {
  if (/[\x00-\x19\s,[\]{}]/.test(t)) {
    const n = `Anchor must not contain whitespace or control characters: ${JSON.stringify(t)}`;
    throw new Error(n);
  }
  return !0;
}
function ac(t) {
  const e = /* @__PURE__ */ new Set();
  return gt(t, {
    Value(n, r) {
      r.anchor && e.add(r.anchor);
    }
  }), e;
}
function oc(t, e) {
  for (let n = 1; ; ++n) {
    const r = `${t}${n}`;
    if (!e.has(r))
      return r;
  }
}
function yy(t, e) {
  const n = [], r = /* @__PURE__ */ new Map();
  let s = null;
  return {
    onAnchor: (i) => {
      n.push(i), s || (s = ac(t));
      const a = oc(e, s);
      return s.add(a), a;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const i of n) {
        const a = r.get(i);
        if (typeof a == "object" && a.anchor && (re(a.node) || ue(a.node)))
          a.node.anchor = a.anchor;
        else {
          const o = new Error("Failed to resolve repeated object (this should not happen)");
          throw o.source = i, o;
        }
      }
    },
    sourceObjects: r
  };
}
function en(t, e, n, r) {
  if (r && typeof r == "object")
    if (Array.isArray(r))
      for (let s = 0, i = r.length; s < i; ++s) {
        const a = r[s], o = en(t, r, String(s), a);
        o === void 0 ? delete r[s] : o !== a && (r[s] = o);
      }
    else if (r instanceof Map)
      for (const s of Array.from(r.keys())) {
        const i = r.get(s), a = en(t, r, s, i);
        a === void 0 ? r.delete(s) : a !== i && r.set(s, a);
      }
    else if (r instanceof Set)
      for (const s of Array.from(r)) {
        const i = en(t, r, s, s);
        i === void 0 ? r.delete(s) : i !== s && (r.delete(s), r.add(i));
      }
    else
      for (const [s, i] of Object.entries(r)) {
        const a = en(t, r, s, i);
        a === void 0 ? delete r[s] : a !== i && (r[s] = a);
      }
  return t.call(e, n, r);
}
function Le(t, e, n) {
  if (Array.isArray(t))
    return t.map((r, s) => Le(r, String(s), n));
  if (t && typeof t.toJSON == "function") {
    if (!n || !hy(t))
      return t.toJSON(e, n);
    const r = { aliasCount: 0, count: 1, res: void 0 };
    n.anchors.set(t, r), n.onCreate = (i) => {
      r.res = i, delete n.onCreate;
    };
    const s = t.toJSON(e, n);
    return n.onCreate && n.onCreate(s), s;
  }
  return typeof t == "bigint" && !(n != null && n.keep) ? Number(t) : t;
}
class Ji {
  constructor(e) {
    Object.defineProperty(this, Ve, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: n, maxAliasCount: r, onAnchor: s, reviver: i } = {}) {
    if (!yn(e))
      throw new TypeError("A document argument is required");
    const a = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: !0,
      mapAsMap: n === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof r == "number" ? r : 100
    }, o = Le(this, "", a);
    if (typeof s == "function")
      for (const { count: c, res: l } of a.anchors.values())
        s(l, c);
    return typeof i == "function" ? en(i, { "": o }, "", o) : o;
  }
}
class ts extends Ji {
  constructor(e) {
    super(Gi), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e) {
    let n;
    return gt(e, {
      Node: (r, s) => {
        if (s === this)
          return gt.BREAK;
        s.anchor === this.source && (n = s);
      }
    }), n;
  }
  toJSON(e, n) {
    if (!n)
      return { source: this.source };
    const { anchors: r, doc: s, maxAliasCount: i } = n, a = this.resolve(s);
    if (!a) {
      const c = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(c);
    }
    let o = r.get(a);
    if (o || (Le(a, null, n), o = r.get(a)), !o || o.res === void 0) {
      const c = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(c);
    }
    if (i >= 0 && (o.count += 1, o.aliasCount === 0 && (o.aliasCount = Or(s, a, r)), o.count * o.aliasCount > i)) {
      const c = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(c);
    }
    return o.res;
  }
  toString(e, n, r) {
    const s = `*${this.source}`;
    if (e) {
      if (ic(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const i = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(i);
      }
      if (e.implicitKey)
        return `${s} `;
    }
    return s;
  }
}
function Or(t, e, n) {
  if (Mt(e)) {
    const r = e.resolve(t), s = n && r && n.get(r);
    return s ? s.count * s.aliasCount : 0;
  } else if (ue(e)) {
    let r = 0;
    for (const s of e.items) {
      const i = Or(t, s, n);
      i > r && (r = i);
    }
    return r;
  } else if (le(e)) {
    const r = Or(t, e.key, n), s = Or(t, e.value, n);
    return Math.max(r, s);
  }
  return 1;
}
const cc = (t) => !t || typeof t != "function" && typeof t != "object";
class W extends Ji {
  constructor(e) {
    super(ot), this.value = e;
  }
  toJSON(e, n) {
    return n != null && n.keep ? this.value : Le(this.value, e, n);
  }
  toString() {
    return String(this.value);
  }
}
W.BLOCK_FOLDED = "BLOCK_FOLDED";
W.BLOCK_LITERAL = "BLOCK_LITERAL";
W.PLAIN = "PLAIN";
W.QUOTE_DOUBLE = "QUOTE_DOUBLE";
W.QUOTE_SINGLE = "QUOTE_SINGLE";
const gy = "tag:yaml.org,2002:";
function $y(t, e, n) {
  if (e) {
    const r = n.filter((i) => i.tag === e), s = r.find((i) => !i.format) ?? r[0];
    if (!s)
      throw new Error(`Tag ${e} not found`);
    return s;
  }
  return n.find((r) => {
    var s;
    return ((s = r.identify) == null ? void 0 : s.call(r, t)) && !r.format;
  });
}
function Hn(t, e, n) {
  var d, g, v;
  if (yn(t) && (t = t.contents), pe(t))
    return t;
  if (le(t)) {
    const w = (g = (d = n.schema[yt]).createNode) == null ? void 0 : g.call(d, n.schema, null, n);
    return w.items.push(t), w;
  }
  (t instanceof String || t instanceof Number || t instanceof Boolean || typeof BigInt < "u" && t instanceof BigInt) && (t = t.valueOf());
  const { aliasDuplicateObjects: r, onAnchor: s, onTagObj: i, schema: a, sourceObjects: o } = n;
  let c;
  if (r && t && typeof t == "object") {
    if (c = o.get(t), c)
      return c.anchor || (c.anchor = s(t)), new ts(c.anchor);
    c = { anchor: null, node: null }, o.set(t, c);
  }
  e != null && e.startsWith("!!") && (e = gy + e.slice(2));
  let l = $y(t, e, a.tags);
  if (!l) {
    if (t && typeof t.toJSON == "function" && (t = t.toJSON()), !t || typeof t != "object") {
      const w = new W(t);
      return c && (c.node = w), w;
    }
    l = t instanceof Map ? a[yt] : Symbol.iterator in Object(t) ? a[pn] : a[yt];
  }
  i && (i(l), delete n.onTagObj);
  const f = l != null && l.createNode ? l.createNode(n.schema, t, n) : typeof ((v = l == null ? void 0 : l.nodeClass) == null ? void 0 : v.from) == "function" ? l.nodeClass.from(n.schema, t, n) : new W(t);
  return e ? f.tag = e : l.default || (f.tag = l.tag), c && (c.node = f), f;
}
function Rr(t, e, n) {
  let r = n;
  for (let s = e.length - 1; s >= 0; --s) {
    const i = e[s];
    if (typeof i == "number" && Number.isInteger(i) && i >= 0) {
      const a = [];
      a[i] = r, r = a;
    } else
      r = /* @__PURE__ */ new Map([[i, r]]);
  }
  return Hn(r, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: t,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const Ln = (t) => t == null || typeof t == "object" && !!t[Symbol.iterator]().next().done;
class Hi extends Ji {
  constructor(e, n) {
    super(e), Object.defineProperty(this, "schema", {
      value: n,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const n = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (n.schema = e), n.items = n.items.map((r) => pe(r) || le(r) ? r.clone(e) : r), this.range && (n.range = this.range.slice()), n;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, n) {
    if (Ln(e))
      this.add(n);
    else {
      const [r, ...s] = e, i = this.get(r, !0);
      if (ue(i))
        i.addIn(s, n);
      else if (i === void 0 && this.schema)
        this.set(r, Rr(this.schema, s, n));
      else
        throw new Error(`Expected YAML collection at ${r}. Remaining path: ${s}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [n, ...r] = e;
    if (r.length === 0)
      return this.delete(n);
    const s = this.get(n, !0);
    if (ue(s))
      return s.deleteIn(r);
    throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, n) {
    const [r, ...s] = e, i = this.get(r, !0);
    return s.length === 0 ? !n && re(i) ? i.value : i : ue(i) ? i.getIn(s, n) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((n) => {
      if (!le(n))
        return !1;
      const r = n.value;
      return r == null || e && re(r) && r.value == null && !r.commentBefore && !r.comment && !r.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [n, ...r] = e;
    if (r.length === 0)
      return this.has(n);
    const s = this.get(n, !0);
    return ue(s) ? s.hasIn(r) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, n) {
    const [r, ...s] = e;
    if (s.length === 0)
      this.set(r, n);
    else {
      const i = this.get(r, !0);
      if (ue(i))
        i.setIn(s, n);
      else if (i === void 0 && this.schema)
        this.set(r, Rr(this.schema, s, n));
      else
        throw new Error(`Expected YAML collection at ${r}. Remaining path: ${s}`);
    }
  }
}
Hi.maxFlowStringSingleLineLength = 60;
const vy = (t) => t.replace(/^(?!$)(?: $)?/gm, "#");
function st(t, e) {
  return /^\n+$/.test(t) ? t.substring(1) : e ? t.replace(/^(?! *$)/gm, e) : t;
}
const At = (t, e, n) => t.endsWith(`
`) ? st(n, e) : n.includes(`
`) ? `
` + st(n, e) : (t.endsWith(" ") ? "" : " ") + n, lc = "flow", Xs = "block", Nr = "quoted";
function ns(t, e, n = "flow", { indentAtStart: r, lineWidth: s = 80, minContentWidth: i = 20, onFold: a, onOverflow: o } = {}) {
  if (!s || s < 0)
    return t;
  const c = Math.max(1 + i, 1 + s - e.length);
  if (t.length <= c)
    return t;
  const l = [], f = {};
  let d = s - e.length;
  typeof r == "number" && (r > s - Math.max(2, i) ? l.push(0) : d = s - r);
  let g, v, w = !1, y = -1, h = -1, u = -1;
  n === Xs && (y = Xa(t, y, e.length), y !== -1 && (d = y + c));
  for (let b; b = t[y += 1]; ) {
    if (n === Nr && b === "\\") {
      switch (h = y, t[y + 1]) {
        case "x":
          y += 3;
          break;
        case "u":
          y += 5;
          break;
        case "U":
          y += 9;
          break;
        default:
          y += 1;
      }
      u = y;
    }
    if (b === `
`)
      n === Xs && (y = Xa(t, y, e.length)), d = y + e.length + c, g = void 0;
    else {
      if (b === " " && v && v !== " " && v !== `
` && v !== "	") {
        const E = t[y + 1];
        E && E !== " " && E !== `
` && E !== "	" && (g = y);
      }
      if (y >= d)
        if (g)
          l.push(g), d = g + c, g = void 0;
        else if (n === Nr) {
          for (; v === " " || v === "	"; )
            v = b, b = t[y += 1], w = !0;
          const E = y > u + 1 ? y - 2 : h - 1;
          if (f[E])
            return t;
          l.push(E), f[E] = !0, d = E + c, g = void 0;
        } else
          w = !0;
    }
    v = b;
  }
  if (w && o && o(), l.length === 0)
    return t;
  a && a();
  let p = t.slice(0, l[0]);
  for (let b = 0; b < l.length; ++b) {
    const E = l[b], C = l[b + 1] || t.length;
    E === 0 ? p = `
${e}${t.slice(0, C)}` : (n === Nr && f[E] && (p += `${t[E]}\\`), p += `
${e}${t.slice(E + 1, C)}`);
  }
  return p;
}
function Xa(t, e, n) {
  let r = e, s = e + 1, i = t[s];
  for (; i === " " || i === "	"; )
    if (e < s + n)
      i = t[++e];
    else {
      do
        i = t[++e];
      while (i && i !== `
`);
      r = e, s = e + 1, i = t[s];
    }
  return r;
}
const rs = (t, e) => ({
  indentAtStart: e ? t.indent.length : t.indentAtStart,
  lineWidth: t.options.lineWidth,
  minContentWidth: t.options.minContentWidth
}), ss = (t) => /^(%|---|\.\.\.)/m.test(t);
function by(t, e, n) {
  if (!e || e < 0)
    return !1;
  const r = e - n, s = t.length;
  if (s <= r)
    return !1;
  for (let i = 0, a = 0; i < s; ++i)
    if (t[i] === `
`) {
      if (i - a > r)
        return !0;
      if (a = i + 1, s - a <= r)
        return !1;
    }
  return !0;
}
function Gn(t, e) {
  const n = JSON.stringify(t);
  if (e.options.doubleQuotedAsJSON)
    return n;
  const { implicitKey: r } = e, s = e.options.doubleQuotedMinMultiLineLength, i = e.indent || (ss(t) ? "  " : "");
  let a = "", o = 0;
  for (let c = 0, l = n[c]; l; l = n[++c])
    if (l === " " && n[c + 1] === "\\" && n[c + 2] === "n" && (a += n.slice(o, c) + "\\ ", c += 1, o = c, l = "\\"), l === "\\")
      switch (n[c + 1]) {
        case "u":
          {
            a += n.slice(o, c);
            const f = n.substr(c + 2, 4);
            switch (f) {
              case "0000":
                a += "\\0";
                break;
              case "0007":
                a += "\\a";
                break;
              case "000b":
                a += "\\v";
                break;
              case "001b":
                a += "\\e";
                break;
              case "0085":
                a += "\\N";
                break;
              case "00a0":
                a += "\\_";
                break;
              case "2028":
                a += "\\L";
                break;
              case "2029":
                a += "\\P";
                break;
              default:
                f.substr(0, 2) === "00" ? a += "\\x" + f.substr(2) : a += n.substr(c, 6);
            }
            c += 5, o = c + 1;
          }
          break;
        case "n":
          if (r || n[c + 2] === '"' || n.length < s)
            c += 1;
          else {
            for (a += n.slice(o, c) + `

`; n[c + 2] === "\\" && n[c + 3] === "n" && n[c + 4] !== '"'; )
              a += `
`, c += 2;
            a += i, n[c + 2] === " " && (a += "\\"), c += 1, o = c + 1;
          }
          break;
        default:
          c += 1;
      }
  return a = o ? a + n.slice(o) : n, r ? a : ns(a, i, Nr, rs(e, !1));
}
function Zs(t, e) {
  if (e.options.singleQuote === !1 || e.implicitKey && t.includes(`
`) || /[ \t]\n|\n[ \t]/.test(t))
    return Gn(t, e);
  const n = e.indent || (ss(t) ? "  " : ""), r = "'" + t.replace(/'/g, "''").replace(/\n+/g, `$&
${n}`) + "'";
  return e.implicitKey ? r : ns(r, n, lc, rs(e, !1));
}
function tn(t, e) {
  const { singleQuote: n } = e.options;
  let r;
  if (n === !1)
    r = Gn;
  else {
    const s = t.includes('"'), i = t.includes("'");
    s && !i ? r = Zs : i && !s ? r = Gn : r = n ? Zs : Gn;
  }
  return r(t, e);
}
let xs;
try {
  xs = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  xs = /\n+(?!\n|$)/g;
}
function Pr({ comment: t, type: e, value: n }, r, s, i) {
  const { blockQuote: a, commentString: o, lineWidth: c } = r.options;
  if (!a || /\n[\t ]+$/.test(n) || /^\s*$/.test(n))
    return tn(n, r);
  const l = r.indent || (r.forceBlockIndent || ss(n) ? "  " : ""), f = a === "literal" ? !0 : a === "folded" || e === W.BLOCK_FOLDED ? !1 : e === W.BLOCK_LITERAL ? !0 : !by(n, c, l.length);
  if (!n)
    return f ? `|
` : `>
`;
  let d, g;
  for (g = n.length; g > 0; --g) {
    const _ = n[g - 1];
    if (_ !== `
` && _ !== "	" && _ !== " ")
      break;
  }
  let v = n.substring(g);
  const w = v.indexOf(`
`);
  w === -1 ? d = "-" : n === v || w !== v.length - 1 ? (d = "+", i && i()) : d = "", v && (n = n.slice(0, -v.length), v[v.length - 1] === `
` && (v = v.slice(0, -1)), v = v.replace(xs, `$&${l}`));
  let y = !1, h, u = -1;
  for (h = 0; h < n.length; ++h) {
    const _ = n[h];
    if (_ === " ")
      y = !0;
    else if (_ === `
`)
      u = h;
    else
      break;
  }
  let p = n.substring(0, u < h ? u + 1 : h);
  p && (n = n.substring(p.length), p = p.replace(/\n+/g, `$&${l}`));
  let E = (f ? "|" : ">") + (y ? l ? "2" : "1" : "") + d;
  if (t && (E += " " + o(t.replace(/ ?[\r\n]+/g, " ")), s && s()), f)
    return n = n.replace(/\n+/g, `$&${l}`), `${E}
${l}${p}${n}${v}`;
  n = n.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${l}`);
  const C = ns(`${p}${n}${v}`, l, Xs, rs(r, !0));
  return `${E}
${l}${C}`;
}
function _y(t, e, n, r) {
  const { type: s, value: i } = t, { actualString: a, implicitKey: o, indent: c, indentStep: l, inFlow: f } = e;
  if (o && i.includes(`
`) || f && /[[\]{},]/.test(i))
    return tn(i, e);
  if (!i || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(i))
    return o || f || !i.includes(`
`) ? tn(i, e) : Pr(t, e, n, r);
  if (!o && !f && s !== W.PLAIN && i.includes(`
`))
    return Pr(t, e, n, r);
  if (ss(i)) {
    if (c === "")
      return e.forceBlockIndent = !0, Pr(t, e, n, r);
    if (o && c === l)
      return tn(i, e);
  }
  const d = i.replace(/\n+/g, `$&
${c}`);
  if (a) {
    const g = (y) => {
      var h;
      return y.default && y.tag !== "tag:yaml.org,2002:str" && ((h = y.test) == null ? void 0 : h.test(d));
    }, { compat: v, tags: w } = e.doc.schema;
    if (w.some(g) || v != null && v.some(g))
      return tn(i, e);
  }
  return o ? d : ns(d, c, lc, rs(e, !1));
}
function rr(t, e, n, r) {
  const { implicitKey: s, inFlow: i } = e, a = typeof t.value == "string" ? t : Object.assign({}, t, { value: String(t.value) });
  let { type: o } = t;
  o !== W.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(a.value) && (o = W.QUOTE_DOUBLE);
  const c = (f) => {
    switch (f) {
      case W.BLOCK_FOLDED:
      case W.BLOCK_LITERAL:
        return s || i ? tn(a.value, e) : Pr(a, e, n, r);
      case W.QUOTE_DOUBLE:
        return Gn(a.value, e);
      case W.QUOTE_SINGLE:
        return Zs(a.value, e);
      case W.PLAIN:
        return _y(a, e, n, r);
      default:
        return null;
    }
  };
  let l = c(o);
  if (l === null) {
    const { defaultKeyType: f, defaultStringType: d } = e.options, g = s && f || d;
    if (l = c(g), l === null)
      throw new Error(`Unsupported default string type ${g}`);
  }
  return l;
}
function uc(t, e) {
  const n = Object.assign({
    blockQuote: !0,
    commentString: vy,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, t.schema.toStringOptions, e);
  let r;
  switch (n.collectionStyle) {
    case "block":
      r = !1;
      break;
    case "flow":
      r = !0;
      break;
    default:
      r = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: t,
    flowCollectionPadding: n.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof n.indent == "number" ? " ".repeat(n.indent) : "  ",
    inFlow: r,
    options: n
  };
}
function wy(t, e) {
  var s;
  if (e.tag) {
    const i = t.filter((a) => a.tag === e.tag);
    if (i.length > 0)
      return i.find((a) => a.format === e.format) ?? i[0];
  }
  let n, r;
  if (re(e)) {
    r = e.value;
    const i = t.filter((a) => {
      var o;
      return (o = a.identify) == null ? void 0 : o.call(a, r);
    });
    n = i.find((a) => a.format === e.format) ?? i.find((a) => !a.format);
  } else
    r = e, n = t.find((i) => i.nodeClass && r instanceof i.nodeClass);
  if (!n) {
    const i = ((s = r == null ? void 0 : r.constructor) == null ? void 0 : s.name) ?? typeof r;
    throw new Error(`Tag not resolved for ${i} value`);
  }
  return n;
}
function Sy(t, e, { anchors: n, doc: r }) {
  if (!r.directives)
    return "";
  const s = [], i = (re(t) || ue(t)) && t.anchor;
  i && ic(i) && (n.add(i), s.push(`&${i}`));
  const a = t.tag ? t.tag : e.default ? null : e.tag;
  return a && s.push(r.directives.tagString(a)), s.join(" ");
}
function on(t, e, n, r) {
  var c;
  if (le(t))
    return t.toString(e, n, r);
  if (Mt(t)) {
    if (e.doc.directives)
      return t.toString(e);
    if ((c = e.resolvedAliases) != null && c.has(t))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(t) : e.resolvedAliases = /* @__PURE__ */ new Set([t]), t = t.resolve(e.doc);
  }
  let s;
  const i = pe(t) ? t : e.doc.createNode(t, { onTagObj: (l) => s = l });
  s || (s = wy(e.doc.schema.tags, i));
  const a = Sy(i, s, e);
  a.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + a.length + 1);
  const o = typeof s.stringify == "function" ? s.stringify(i, e, n, r) : re(i) ? rr(i, e, n, r) : i.toString(e, n, r);
  return a ? re(i) || o[0] === "{" || o[0] === "[" ? `${a} ${o}` : `${a}
${e.indent}${o}` : o;
}
function Ey({ key: t, value: e }, n, r, s) {
  const { allNullValues: i, doc: a, indent: o, indentStep: c, options: { commentString: l, indentSeq: f, simpleKeys: d } } = n;
  let g = pe(t) && t.comment || null;
  if (d) {
    if (g)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (ue(t)) {
      const P = "With simple keys, collection cannot be used as a key value";
      throw new Error(P);
    }
  }
  let v = !d && (!t || g && e == null && !n.inFlow || ue(t) || (re(t) ? t.type === W.BLOCK_FOLDED || t.type === W.BLOCK_LITERAL : typeof t == "object"));
  n = Object.assign({}, n, {
    allNullValues: !1,
    implicitKey: !v && (d || !i),
    indent: o + c
  });
  let w = !1, y = !1, h = on(t, n, () => w = !0, () => y = !0);
  if (!v && !n.inFlow && h.length > 1024) {
    if (d)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    v = !0;
  }
  if (n.inFlow) {
    if (i || e == null)
      return w && r && r(), h === "" ? "?" : v ? `? ${h}` : h;
  } else if (i && !d || e == null && v)
    return h = `? ${h}`, g && !w ? h += At(h, n.indent, l(g)) : y && s && s(), h;
  w && (g = null), v ? (g && (h += At(h, n.indent, l(g))), h = `? ${h}
${o}:`) : (h = `${h}:`, g && (h += At(h, n.indent, l(g))));
  let u, p, b;
  pe(e) ? (u = !!e.spaceBefore, p = e.commentBefore, b = e.comment) : (u = !1, p = null, b = null, e && typeof e == "object" && (e = a.createNode(e))), n.implicitKey = !1, !v && !g && re(e) && (n.indentAtStart = h.length + 1), y = !1, !f && c.length >= 2 && !n.inFlow && !v && $n(e) && !e.flow && !e.tag && !e.anchor && (n.indent = n.indent.substring(2));
  let E = !1;
  const C = on(e, n, () => E = !0, () => y = !0);
  let _ = " ";
  if (g || u || p) {
    if (_ = u ? `
` : "", p) {
      const P = l(p);
      _ += `
${st(P, n.indent)}`;
    }
    C === "" && !n.inFlow ? _ === `
` && (_ = `

`) : _ += `
${n.indent}`;
  } else if (!v && ue(e)) {
    const P = C[0], R = C.indexOf(`
`), D = R !== -1, V = n.inFlow ?? e.flow ?? e.items.length === 0;
    if (D || !V) {
      let G = !1;
      if (D && (P === "&" || P === "!")) {
        let U = C.indexOf(" ");
        P === "&" && U !== -1 && U < R && C[U + 1] === "!" && (U = C.indexOf(" ", U + 1)), (U === -1 || R < U) && (G = !0);
      }
      G || (_ = `
${n.indent}`);
    }
  } else
    (C === "" || C[0] === `
`) && (_ = "");
  return h += _ + C, n.inFlow ? E && r && r() : b && !E ? h += At(h, n.indent, l(b)) : y && s && s(), h;
}
function fc(t, e) {
  (t === "debug" || t === "warn") && (typeof process < "u" && process.emitWarning ? process.emitWarning(e) : console.warn(e));
}
const Za = "<<";
function dc(t, e, { key: n, value: r }) {
  if (t != null && t.doc.schema.merge && Oy(n))
    if (r = Mt(r) ? r.resolve(t.doc) : r, $n(r))
      for (const s of r.items)
        Es(t, e, s);
    else if (Array.isArray(r))
      for (const s of r)
        Es(t, e, s);
    else
      Es(t, e, r);
  else {
    const s = Le(n, "", t);
    if (e instanceof Map)
      e.set(s, Le(r, s, t));
    else if (e instanceof Set)
      e.add(s);
    else {
      const i = Ny(n, s, t), a = Le(r, i, t);
      i in e ? Object.defineProperty(e, i, {
        value: a,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : e[i] = a;
    }
  }
  return e;
}
const Oy = (t) => t === Za || re(t) && t.value === Za && (!t.type || t.type === W.PLAIN);
function Es(t, e, n) {
  const r = t && Mt(n) ? n.resolve(t.doc) : n;
  if (!gn(r))
    throw new Error("Merge sources must be maps or map aliases");
  const s = r.toJSON(null, t, Map);
  for (const [i, a] of s)
    e instanceof Map ? e.has(i) || e.set(i, a) : e instanceof Set ? e.add(i) : Object.prototype.hasOwnProperty.call(e, i) || Object.defineProperty(e, i, {
      value: a,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return e;
}
function Ny(t, e, n) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (pe(t) && (n != null && n.doc)) {
    const r = uc(n.doc, {});
    r.anchors = /* @__PURE__ */ new Set();
    for (const i of n.anchors.keys())
      r.anchors.add(i.anchor);
    r.inFlow = !0, r.inStringifyKey = !0;
    const s = t.toString(r);
    if (!n.mapKeyWarned) {
      let i = JSON.stringify(s);
      i.length > 40 && (i = i.substring(0, 36) + '..."'), fc(n.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${i}. Set mapAsMap: true to use object keys.`), n.mapKeyWarned = !0;
    }
    return s;
  }
  return JSON.stringify(e);
}
function Yi(t, e, n) {
  const r = Hn(t, void 0, n), s = Hn(e, void 0, n);
  return new _e(r, s);
}
class _e {
  constructor(e, n = null) {
    Object.defineProperty(this, Ve, { value: ec }), this.key = e, this.value = n;
  }
  clone(e) {
    let { key: n, value: r } = this;
    return pe(n) && (n = n.clone(e)), pe(r) && (r = r.clone(e)), new _e(n, r);
  }
  toJSON(e, n) {
    const r = n != null && n.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return dc(n, r, this);
  }
  toString(e, n, r) {
    return e != null && e.doc ? Ey(this, e, n, r) : JSON.stringify(this);
  }
}
function hc(t, e, n) {
  return (e.inFlow ?? t.flow ? ky : Py)(t, e, n);
}
function Py({ comment: t, items: e }, n, { blockItemPrefix: r, flowChars: s, itemIndent: i, onChompKeep: a, onComment: o }) {
  const { indent: c, options: { commentString: l } } = n, f = Object.assign({}, n, { indent: i, type: null });
  let d = !1;
  const g = [];
  for (let w = 0; w < e.length; ++w) {
    const y = e[w];
    let h = null;
    if (pe(y))
      !d && y.spaceBefore && g.push(""), Dr(n, g, y.commentBefore, d), y.comment && (h = y.comment);
    else if (le(y)) {
      const p = pe(y.key) ? y.key : null;
      p && (!d && p.spaceBefore && g.push(""), Dr(n, g, p.commentBefore, d));
    }
    d = !1;
    let u = on(y, f, () => h = null, () => d = !0);
    h && (u += At(u, i, l(h))), d && h && (d = !1), g.push(r + u);
  }
  let v;
  if (g.length === 0)
    v = s.start + s.end;
  else {
    v = g[0];
    for (let w = 1; w < g.length; ++w) {
      const y = g[w];
      v += y ? `
${c}${y}` : `
`;
    }
  }
  return t ? (v += `
` + st(l(t), c), o && o()) : d && a && a(), v;
}
function ky({ items: t }, e, { flowChars: n, itemIndent: r }) {
  const { indent: s, indentStep: i, flowCollectionPadding: a, options: { commentString: o } } = e;
  r += i;
  const c = Object.assign({}, e, {
    indent: r,
    inFlow: !0,
    type: null
  });
  let l = !1, f = 0;
  const d = [];
  for (let w = 0; w < t.length; ++w) {
    const y = t[w];
    let h = null;
    if (pe(y))
      y.spaceBefore && d.push(""), Dr(e, d, y.commentBefore, !1), y.comment && (h = y.comment);
    else if (le(y)) {
      const p = pe(y.key) ? y.key : null;
      p && (p.spaceBefore && d.push(""), Dr(e, d, p.commentBefore, !1), p.comment && (l = !0));
      const b = pe(y.value) ? y.value : null;
      b ? (b.comment && (h = b.comment), b.commentBefore && (l = !0)) : y.value == null && (p != null && p.comment) && (h = p.comment);
    }
    h && (l = !0);
    let u = on(y, c, () => h = null);
    w < t.length - 1 && (u += ","), h && (u += At(u, r, o(h))), !l && (d.length > f || u.includes(`
`)) && (l = !0), d.push(u), f = d.length;
  }
  const { start: g, end: v } = n;
  if (d.length === 0)
    return g + v;
  if (!l) {
    const w = d.reduce((y, h) => y + h.length + 2, 2);
    l = e.options.lineWidth > 0 && w > e.options.lineWidth;
  }
  if (l) {
    let w = g;
    for (const y of d)
      w += y ? `
${i}${s}${y}` : `
`;
    return `${w}
${s}${v}`;
  } else
    return `${g}${a}${d.join(" ")}${a}${v}`;
}
function Dr({ indent: t, options: { commentString: e } }, n, r, s) {
  if (r && s && (r = r.replace(/^\n+/, "")), r) {
    const i = st(e(r), t);
    n.push(i.trimStart());
  }
}
function Tt(t, e) {
  const n = re(e) ? e.value : e;
  for (const r of t)
    if (le(r) && (r.key === e || r.key === n || re(r.key) && r.key.value === n))
      return r;
}
class Ae extends Hi {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(yt, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, n, r) {
    const { keepUndefined: s, replacer: i } = r, a = new this(e), o = (c, l) => {
      if (typeof i == "function")
        l = i.call(n, c, l);
      else if (Array.isArray(i) && !i.includes(c))
        return;
      (l !== void 0 || s) && a.items.push(Yi(c, l, r));
    };
    if (n instanceof Map)
      for (const [c, l] of n)
        o(c, l);
    else if (n && typeof n == "object")
      for (const c of Object.keys(n))
        o(c, n[c]);
    return typeof e.sortMapEntries == "function" && a.items.sort(e.sortMapEntries), a;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, n) {
    var a;
    let r;
    le(e) ? r = e : !e || typeof e != "object" || !("key" in e) ? r = new _e(e, e == null ? void 0 : e.value) : r = new _e(e.key, e.value);
    const s = Tt(this.items, r.key), i = (a = this.schema) == null ? void 0 : a.sortMapEntries;
    if (s) {
      if (!n)
        throw new Error(`Key ${r.key} already set`);
      re(s.value) && cc(r.value) ? s.value.value = r.value : s.value = r.value;
    } else if (i) {
      const o = this.items.findIndex((c) => i(r, c) < 0);
      o === -1 ? this.items.push(r) : this.items.splice(o, 0, r);
    } else
      this.items.push(r);
  }
  delete(e) {
    const n = Tt(this.items, e);
    return n ? this.items.splice(this.items.indexOf(n), 1).length > 0 : !1;
  }
  get(e, n) {
    const r = Tt(this.items, e), s = r == null ? void 0 : r.value;
    return (!n && re(s) ? s.value : s) ?? void 0;
  }
  has(e) {
    return !!Tt(this.items, e);
  }
  set(e, n) {
    this.add(new _e(e, n), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, n, r) {
    const s = r ? new r() : n != null && n.mapAsMap ? /* @__PURE__ */ new Map() : {};
    n != null && n.onCreate && n.onCreate(s);
    for (const i of this.items)
      dc(n, s, i);
    return s;
  }
  toString(e, n, r) {
    if (!e)
      return JSON.stringify(this);
    for (const s of this.items)
      if (!le(s))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(s)} instead`);
    return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), hc(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: r,
      onComment: n
    });
  }
}
const vn = {
  collection: "map",
  default: !0,
  nodeClass: Ae,
  tag: "tag:yaml.org,2002:map",
  resolve(t, e) {
    return gn(t) || e("Expected a mapping for this tag"), t;
  },
  createNode: (t, e, n) => Ae.from(t, e, n)
};
class $t extends Hi {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(pn, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const n = $r(e);
    return typeof n != "number" ? !1 : this.items.splice(n, 1).length > 0;
  }
  get(e, n) {
    const r = $r(e);
    if (typeof r != "number")
      return;
    const s = this.items[r];
    return !n && re(s) ? s.value : s;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const n = $r(e);
    return typeof n == "number" && n < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, n) {
    const r = $r(e);
    if (typeof r != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const s = this.items[r];
    re(s) && cc(n) ? s.value = n : this.items[r] = n;
  }
  toJSON(e, n) {
    const r = [];
    n != null && n.onCreate && n.onCreate(r);
    let s = 0;
    for (const i of this.items)
      r.push(Le(i, String(s++), n));
    return r;
  }
  toString(e, n, r) {
    return e ? hc(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: r,
      onComment: n
    }) : JSON.stringify(this);
  }
  static from(e, n, r) {
    const { replacer: s } = r, i = new this(e);
    if (n && Symbol.iterator in Object(n)) {
      let a = 0;
      for (let o of n) {
        if (typeof s == "function") {
          const c = n instanceof Set ? o : String(a++);
          o = s.call(n, c, o);
        }
        i.items.push(Hn(o, void 0, r));
      }
    }
    return i;
  }
}
function $r(t) {
  let e = re(t) ? t.value : t;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
const bn = {
  collection: "seq",
  default: !0,
  nodeClass: $t,
  tag: "tag:yaml.org,2002:seq",
  resolve(t, e) {
    return $n(t) || e("Expected a sequence for this tag"), t;
  },
  createNode: (t, e, n) => $t.from(t, e, n)
}, is = {
  identify: (t) => typeof t == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (t) => t,
  stringify(t, e, n, r) {
    return e = Object.assign({ actualString: !0 }, e), rr(t, e, n, r);
  }
}, as = {
  identify: (t) => t == null,
  createNode: () => new W(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new W(null),
  stringify: ({ source: t }, e) => typeof t == "string" && as.test.test(t) ? t : e.options.nullStr
}, Wi = {
  identify: (t) => typeof t == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (t) => new W(t[0] === "t" || t[0] === "T"),
  stringify({ source: t, value: e }, n) {
    if (t && Wi.test.test(t)) {
      const r = t[0] === "t" || t[0] === "T";
      if (e === r)
        return t;
    }
    return e ? n.options.trueStr : n.options.falseStr;
  }
};
function Be({ format: t, minFractionDigits: e, tag: n, value: r }) {
  if (typeof r == "bigint")
    return String(r);
  const s = typeof r == "number" ? r : Number(r);
  if (!isFinite(s))
    return isNaN(s) ? ".nan" : s < 0 ? "-.inf" : ".inf";
  let i = JSON.stringify(r);
  if (!t && e && (!n || n === "tag:yaml.org,2002:float") && /^\d/.test(i)) {
    let a = i.indexOf(".");
    a < 0 && (a = i.length, i += ".");
    let o = e - (i.length - a - 1);
    for (; o-- > 0; )
      i += "0";
  }
  return i;
}
const mc = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Be
}, pc = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : Be(t);
  }
}, yc = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(t) {
    const e = new W(parseFloat(t)), n = t.indexOf(".");
    return n !== -1 && t[t.length - 1] === "0" && (e.minFractionDigits = t.length - n - 1), e;
  },
  stringify: Be
}, os = (t) => typeof t == "bigint" || Number.isInteger(t), Qi = (t, e, n, { intAsBigInt: r }) => r ? BigInt(t) : parseInt(t.substring(e), n);
function gc(t, e, n) {
  const { value: r } = t;
  return os(r) && r >= 0 ? n + r.toString(e) : Be(t);
}
const $c = {
  identify: (t) => os(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (t, e, n) => Qi(t, 2, 8, n),
  stringify: (t) => gc(t, 8, "0o")
}, vc = {
  identify: os,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (t, e, n) => Qi(t, 0, 10, n),
  stringify: Be
}, bc = {
  identify: (t) => os(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (t, e, n) => Qi(t, 2, 16, n),
  stringify: (t) => gc(t, 16, "0x")
}, Ay = [
  vn,
  bn,
  is,
  as,
  Wi,
  $c,
  vc,
  bc,
  mc,
  pc,
  yc
];
function xa(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}
const vr = ({ value: t }) => JSON.stringify(t), Ty = [
  {
    identify: (t) => typeof t == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (t) => t,
    stringify: vr
  },
  {
    identify: (t) => t == null,
    createNode: () => new W(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: vr
  },
  {
    identify: (t) => typeof t == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (t) => t === "true",
    stringify: vr
  },
  {
    identify: xa,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (t, e, { intAsBigInt: n }) => n ? BigInt(t) : parseInt(t, 10),
    stringify: ({ value: t }) => xa(t) ? t.toString() : JSON.stringify(t)
  },
  {
    identify: (t) => typeof t == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (t) => parseFloat(t),
    stringify: vr
  }
], Iy = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(t, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(t)}`), t;
  }
}, Cy = [vn, bn].concat(Ty, Iy), Xi = {
  identify: (t) => t instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(t, e) {
    if (typeof Buffer == "function")
      return Buffer.from(t, "base64");
    if (typeof atob == "function") {
      const n = atob(t.replace(/[\n\r]/g, "")), r = new Uint8Array(n.length);
      for (let s = 0; s < n.length; ++s)
        r[s] = n.charCodeAt(s);
      return r;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), t;
  },
  stringify({ comment: t, type: e, value: n }, r, s, i) {
    const a = n;
    let o;
    if (typeof Buffer == "function")
      o = a instanceof Buffer ? a.toString("base64") : Buffer.from(a.buffer).toString("base64");
    else if (typeof btoa == "function") {
      let c = "";
      for (let l = 0; l < a.length; ++l)
        c += String.fromCharCode(a[l]);
      o = btoa(c);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e || (e = W.BLOCK_LITERAL), e !== W.QUOTE_DOUBLE) {
      const c = Math.max(r.options.lineWidth - r.indent.length, r.options.minContentWidth), l = Math.ceil(o.length / c), f = new Array(l);
      for (let d = 0, g = 0; d < l; ++d, g += c)
        f[d] = o.substr(g, c);
      o = f.join(e === W.BLOCK_LITERAL ? `
` : " ");
    }
    return rr({ comment: t, type: e, value: o }, r, s, i);
  }
};
function _c(t, e) {
  if ($n(t))
    for (let n = 0; n < t.items.length; ++n) {
      let r = t.items[n];
      if (!le(r)) {
        if (gn(r)) {
          r.items.length > 1 && e("Each pair must have its own sequence indicator");
          const s = r.items[0] || new _e(new W(null));
          if (r.commentBefore && (s.key.commentBefore = s.key.commentBefore ? `${r.commentBefore}
${s.key.commentBefore}` : r.commentBefore), r.comment) {
            const i = s.value ?? s.key;
            i.comment = i.comment ? `${r.comment}
${i.comment}` : r.comment;
          }
          r = s;
        }
        t.items[n] = le(r) ? r : new _e(r);
      }
    }
  else
    e("Expected a sequence for this tag");
  return t;
}
function wc(t, e, n) {
  const { replacer: r } = n, s = new $t(t);
  s.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (e && Symbol.iterator in Object(e))
    for (let a of e) {
      typeof r == "function" && (a = r.call(e, String(i++), a));
      let o, c;
      if (Array.isArray(a))
        if (a.length === 2)
          o = a[0], c = a[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${a}`);
      else if (a && a instanceof Object) {
        const l = Object.keys(a);
        if (l.length === 1)
          o = l[0], c = a[o];
        else
          throw new TypeError(`Expected tuple with one key, not ${l.length} keys`);
      } else
        o = a;
      s.items.push(Yi(o, c, n));
    }
  return s;
}
const Zi = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: _c,
  createNode: wc
};
class rn extends $t {
  constructor() {
    super(), this.add = Ae.prototype.add.bind(this), this.delete = Ae.prototype.delete.bind(this), this.get = Ae.prototype.get.bind(this), this.has = Ae.prototype.has.bind(this), this.set = Ae.prototype.set.bind(this), this.tag = rn.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, n) {
    if (!n)
      return super.toJSON(e);
    const r = /* @__PURE__ */ new Map();
    n != null && n.onCreate && n.onCreate(r);
    for (const s of this.items) {
      let i, a;
      if (le(s) ? (i = Le(s.key, "", n), a = Le(s.value, i, n)) : i = Le(s, "", n), r.has(i))
        throw new Error("Ordered maps must not include duplicate keys");
      r.set(i, a);
    }
    return r;
  }
  static from(e, n, r) {
    const s = wc(e, n, r), i = new this();
    return i.items = s.items, i;
  }
}
rn.tag = "tag:yaml.org,2002:omap";
const xi = {
  collection: "seq",
  identify: (t) => t instanceof Map,
  nodeClass: rn,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(t, e) {
    const n = _c(t, e), r = [];
    for (const { key: s } of n.items)
      re(s) && (r.includes(s.value) ? e(`Ordered maps must not include duplicate keys: ${s.value}`) : r.push(s.value));
    return Object.assign(new rn(), n);
  },
  createNode: (t, e, n) => rn.from(t, e, n)
};
function Sc({ value: t, source: e }, n) {
  return e && (t ? Ec : Oc).test.test(e) ? e : t ? n.options.trueStr : n.options.falseStr;
}
const Ec = {
  identify: (t) => t === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new W(!0),
  stringify: Sc
}, Oc = {
  identify: (t) => t === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new W(!1),
  stringify: Sc
}, jy = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Be
}, Ry = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t.replace(/_/g, "")),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : Be(t);
  }
}, Dy = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(t) {
    const e = new W(parseFloat(t.replace(/_/g, ""))), n = t.indexOf(".");
    if (n !== -1) {
      const r = t.substring(n + 1).replace(/_/g, "");
      r[r.length - 1] === "0" && (e.minFractionDigits = r.length);
    }
    return e;
  },
  stringify: Be
}, sr = (t) => typeof t == "bigint" || Number.isInteger(t);
function cs(t, e, n, { intAsBigInt: r }) {
  const s = t[0];
  if ((s === "-" || s === "+") && (e += 1), t = t.substring(e).replace(/_/g, ""), r) {
    switch (n) {
      case 2:
        t = `0b${t}`;
        break;
      case 8:
        t = `0o${t}`;
        break;
      case 16:
        t = `0x${t}`;
        break;
    }
    const a = BigInt(t);
    return s === "-" ? BigInt(-1) * a : a;
  }
  const i = parseInt(t, n);
  return s === "-" ? -1 * i : i;
}
function ea(t, e, n) {
  const { value: r } = t;
  if (sr(r)) {
    const s = r.toString(e);
    return r < 0 ? "-" + n + s.substr(1) : n + s;
  }
  return Be(t);
}
const My = {
  identify: sr,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (t, e, n) => cs(t, 2, 2, n),
  stringify: (t) => ea(t, 2, "0b")
}, Ly = {
  identify: sr,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (t, e, n) => cs(t, 1, 8, n),
  stringify: (t) => ea(t, 8, "0")
}, Vy = {
  identify: sr,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (t, e, n) => cs(t, 0, 10, n),
  stringify: Be
}, Fy = {
  identify: sr,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (t, e, n) => cs(t, 2, 16, n),
  stringify: (t) => ea(t, 16, "0x")
};
class sn extends Ae {
  constructor(e) {
    super(e), this.tag = sn.tag;
  }
  add(e) {
    let n;
    le(e) ? n = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? n = new _e(e.key, null) : n = new _e(e, null), Tt(this.items, n.key) || this.items.push(n);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, n) {
    const r = Tt(this.items, e);
    return !n && le(r) ? re(r.key) ? r.key.value : r.key : r;
  }
  set(e, n) {
    if (typeof n != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof n}`);
    const r = Tt(this.items, e);
    r && !n ? this.items.splice(this.items.indexOf(r), 1) : !r && n && this.items.push(new _e(e));
  }
  toJSON(e, n) {
    return super.toJSON(e, n, Set);
  }
  toString(e, n, r) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, e, { allNullValues: !0 }), n, r);
    throw new Error("Set items must all have null values");
  }
  static from(e, n, r) {
    const { replacer: s } = r, i = new this(e);
    if (n && Symbol.iterator in Object(n))
      for (let a of n)
        typeof s == "function" && (a = s.call(n, a, a)), i.items.push(Yi(a, null, r));
    return i;
  }
}
sn.tag = "tag:yaml.org,2002:set";
const ta = {
  collection: "map",
  identify: (t) => t instanceof Set,
  nodeClass: sn,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (t, e, n) => sn.from(t, e, n),
  resolve(t, e) {
    if (gn(t)) {
      if (t.hasAllNullValues(!0))
        return Object.assign(new sn(), t);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return t;
  }
};
function na(t, e) {
  const n = t[0], r = n === "-" || n === "+" ? t.substring(1) : t, s = (a) => e ? BigInt(a) : Number(a), i = r.replace(/_/g, "").split(":").reduce((a, o) => a * s(60) + s(o), s(0));
  return n === "-" ? s(-1) * i : i;
}
function Nc(t) {
  let { value: e } = t, n = (a) => a;
  if (typeof e == "bigint")
    n = (a) => BigInt(a);
  else if (isNaN(e) || !isFinite(e))
    return Be(t);
  let r = "";
  e < 0 && (r = "-", e *= n(-1));
  const s = n(60), i = [e % s];
  return e < 60 ? i.unshift(0) : (e = (e - i[0]) / s, i.unshift(e % s), e >= 60 && (e = (e - i[0]) / s, i.unshift(e))), r + i.map((a) => String(a).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const Pc = {
  identify: (t) => typeof t == "bigint" || Number.isInteger(t),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (t, e, { intAsBigInt: n }) => na(t, n),
  stringify: Nc
}, kc = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (t) => na(t, !1),
  stringify: Nc
}, ls = {
  identify: (t) => t instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(t) {
    const e = t.match(ls.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, n, r, s, i, a, o] = e.map(Number), c = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let l = Date.UTC(n, r - 1, s, i || 0, a || 0, o || 0, c);
    const f = e[8];
    if (f && f !== "Z") {
      let d = na(f, !1);
      Math.abs(d) < 30 && (d *= 60), l -= 6e4 * d;
    }
    return new Date(l);
  },
  stringify: ({ value: t }) => t.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
}, eo = [
  vn,
  bn,
  is,
  as,
  Ec,
  Oc,
  My,
  Ly,
  Vy,
  Fy,
  jy,
  Ry,
  Dy,
  Xi,
  xi,
  Zi,
  ta,
  Pc,
  kc,
  ls
], to = /* @__PURE__ */ new Map([
  ["core", Ay],
  ["failsafe", [vn, bn, is]],
  ["json", Cy],
  ["yaml11", eo],
  ["yaml-1.1", eo]
]), no = {
  binary: Xi,
  bool: Wi,
  float: yc,
  floatExp: pc,
  floatNaN: mc,
  floatTime: kc,
  int: vc,
  intHex: bc,
  intOct: $c,
  intTime: Pc,
  map: vn,
  null: as,
  omap: xi,
  pairs: Zi,
  seq: bn,
  set: ta,
  timestamp: ls
}, Uy = {
  "tag:yaml.org,2002:binary": Xi,
  "tag:yaml.org,2002:omap": xi,
  "tag:yaml.org,2002:pairs": Zi,
  "tag:yaml.org,2002:set": ta,
  "tag:yaml.org,2002:timestamp": ls
};
function Os(t, e) {
  let n = to.get(e);
  if (!n)
    if (Array.isArray(t))
      n = [];
    else {
      const r = Array.from(to.keys()).filter((s) => s !== "yaml11").map((s) => JSON.stringify(s)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${r} or define customTags array`);
    }
  if (Array.isArray(t))
    for (const r of t)
      n = n.concat(r);
  else
    typeof t == "function" && (n = t(n.slice()));
  return n.map((r) => {
    if (typeof r != "string")
      return r;
    const s = no[r];
    if (s)
      return s;
    const i = Object.keys(no).map((a) => JSON.stringify(a)).join(", ");
    throw new Error(`Unknown custom tag "${r}"; use one of ${i}`);
  });
}
const qy = (t, e) => t.key < e.key ? -1 : t.key > e.key ? 1 : 0;
class us {
  constructor({ compat: e, customTags: n, merge: r, resolveKnownTags: s, schema: i, sortMapEntries: a, toStringDefaults: o }) {
    this.compat = Array.isArray(e) ? Os(e, "compat") : e ? Os(null, e) : null, this.merge = !!r, this.name = typeof i == "string" && i || "core", this.knownTags = s ? Uy : {}, this.tags = Os(n, this.name), this.toStringOptions = o ?? null, Object.defineProperty(this, yt, { value: vn }), Object.defineProperty(this, ot, { value: is }), Object.defineProperty(this, pn, { value: bn }), this.sortMapEntries = typeof a == "function" ? a : a === !0 ? qy : null;
  }
  clone() {
    const e = Object.create(us.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
}
function Ky(t, e) {
  var c;
  const n = [];
  let r = e.directives === !0;
  if (e.directives !== !1 && t.directives) {
    const l = t.directives.toString(t);
    l ? (n.push(l), r = !0) : t.directives.docStart && (r = !0);
  }
  r && n.push("---");
  const s = uc(t, e), { commentString: i } = s.options;
  if (t.commentBefore) {
    n.length !== 1 && n.unshift("");
    const l = i(t.commentBefore);
    n.unshift(st(l, ""));
  }
  let a = !1, o = null;
  if (t.contents) {
    if (pe(t.contents)) {
      if (t.contents.spaceBefore && r && n.push(""), t.contents.commentBefore) {
        const d = i(t.contents.commentBefore);
        n.push(st(d, ""));
      }
      s.forceBlockIndent = !!t.comment, o = t.contents.comment;
    }
    const l = o ? void 0 : () => a = !0;
    let f = on(t.contents, s, () => o = null, l);
    o && (f += At(f, "", i(o))), (f[0] === "|" || f[0] === ">") && n[n.length - 1] === "---" ? n[n.length - 1] = `--- ${f}` : n.push(f);
  } else
    n.push(on(t.contents, s));
  if ((c = t.directives) != null && c.docEnd)
    if (t.comment) {
      const l = i(t.comment);
      l.includes(`
`) ? (n.push("..."), n.push(st(l, ""))) : n.push(`... ${l}`);
    } else
      n.push("...");
  else {
    let l = t.comment;
    l && a && (l = l.replace(/^\n+/, "")), l && ((!a || o) && n[n.length - 1] !== "" && n.push(""), n.push(st(i(l), "")));
  }
  return n.join(`
`) + `
`;
}
class _n {
  constructor(e, n, r) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, Ve, { value: Qs });
    let s = null;
    typeof n == "function" || Array.isArray(n) ? s = n : r === void 0 && n && (r = n, n = void 0);
    const i = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      uniqueKeys: !0,
      version: "1.2"
    }, r);
    this.options = i;
    let { version: a } = i;
    r != null && r._directives ? (this.directives = r._directives.atDocument(), this.directives.yaml.explicit && (a = this.directives.yaml.version)) : this.directives = new Se({ version: a }), this.setSchema(a, r), this.contents = e === void 0 ? null : this.createNode(e, s, r);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(_n.prototype, {
      [Ve]: { value: Qs }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = pe(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    Wt(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, n) {
    Wt(this.contents) && this.contents.addIn(e, n);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, n) {
    if (!e.anchor) {
      const r = ac(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !n || r.has(n) ? oc(n || "a", r) : n;
    }
    return new ts(e.anchor);
  }
  createNode(e, n, r) {
    let s;
    if (typeof n == "function")
      e = n.call({ "": e }, "", e), s = n;
    else if (Array.isArray(n)) {
      const h = (p) => typeof p == "number" || p instanceof String || p instanceof Number, u = n.filter(h).map(String);
      u.length > 0 && (n = n.concat(u)), s = n;
    } else
      r === void 0 && n && (r = n, n = void 0);
    const { aliasDuplicateObjects: i, anchorPrefix: a, flow: o, keepUndefined: c, onTagObj: l, tag: f } = r ?? {}, { onAnchor: d, setAnchors: g, sourceObjects: v } = yy(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      a || "a"
    ), w = {
      aliasDuplicateObjects: i ?? !0,
      keepUndefined: c ?? !1,
      onAnchor: d,
      onTagObj: l,
      replacer: s,
      schema: this.schema,
      sourceObjects: v
    }, y = Hn(e, f, w);
    return o && ue(y) && (y.flow = !0), g(), y;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, n, r = {}) {
    const s = this.createNode(e, null, r), i = this.createNode(n, null, r);
    return new _e(s, i);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return Wt(this.contents) ? this.contents.delete(e) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return Ln(e) ? this.contents == null ? !1 : (this.contents = null, !0) : Wt(this.contents) ? this.contents.deleteIn(e) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, n) {
    return ue(this.contents) ? this.contents.get(e, n) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, n) {
    return Ln(e) ? !n && re(this.contents) ? this.contents.value : this.contents : ue(this.contents) ? this.contents.getIn(e, n) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return ue(this.contents) ? this.contents.has(e) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return Ln(e) ? this.contents !== void 0 : ue(this.contents) ? this.contents.hasIn(e) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, n) {
    this.contents == null ? this.contents = Rr(this.schema, [e], n) : Wt(this.contents) && this.contents.set(e, n);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, n) {
    Ln(e) ? this.contents = n : this.contents == null ? this.contents = Rr(this.schema, Array.from(e), n) : Wt(this.contents) && this.contents.setIn(e, n);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, n = {}) {
    typeof e == "number" && (e = String(e));
    let r;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Se({ version: "1.1" }), r = { merge: !0, resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Se({ version: e }), r = { merge: !1, resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, r = null;
        break;
      default: {
        const s = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${s}`);
      }
    }
    if (n.schema instanceof Object)
      this.schema = n.schema;
    else if (r)
      this.schema = new us(Object.assign(r, n));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: n, mapAsMap: r, maxAliasCount: s, onAnchor: i, reviver: a } = {}) {
    const o = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: r === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof s == "number" ? s : 100
    }, c = Le(this.contents, n ?? "", o);
    if (typeof i == "function")
      for (const { count: l, res: f } of o.anchors.values())
        i(f, l);
    return typeof a == "function" ? en(a, { "": c }, "", c) : c;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, n) {
    return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: n });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const n = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${n}`);
    }
    return Ky(this, e);
  }
}
function Wt(t) {
  if (ue(t))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class ra extends Error {
  constructor(e, n, r, s) {
    super(), this.name = e, this.code = r, this.message = s, this.pos = n;
  }
}
class It extends ra {
  constructor(e, n, r) {
    super("YAMLParseError", e, n, r);
  }
}
class Ac extends ra {
  constructor(e, n, r) {
    super("YAMLWarning", e, n, r);
  }
}
const Mr = (t, e) => (n) => {
  if (n.pos[0] === -1)
    return;
  n.linePos = n.pos.map((o) => e.linePos(o));
  const { line: r, col: s } = n.linePos[0];
  n.message += ` at line ${r}, column ${s}`;
  let i = s - 1, a = t.substring(e.lineStarts[r - 1], e.lineStarts[r]).replace(/[\n\r]+$/, "");
  if (i >= 60 && a.length > 80) {
    const o = Math.min(i - 39, a.length - 79);
    a = "" + a.substring(o), i -= o - 1;
  }
  if (a.length > 80 && (a = a.substring(0, 79) + ""), r > 1 && /^ *$/.test(a.substring(0, i))) {
    let o = t.substring(e.lineStarts[r - 2], e.lineStarts[r - 1]);
    o.length > 80 && (o = o.substring(0, 79) + `
`), a = o + a;
  }
  if (/[^ ]/.test(a)) {
    let o = 1;
    const c = n.linePos[1];
    c && c.line === r && c.col > s && (o = Math.max(1, Math.min(c.col - s, 80 - i)));
    const l = " ".repeat(i) + "^".repeat(o);
    n.message += `:

${a}
${l}
`;
  }
};
function cn(t, { flow: e, indicator: n, next: r, offset: s, onError: i, startOnNewline: a }) {
  let o = !1, c = a, l = a, f = "", d = "", g = !1, v = !1, w = !1, y = null, h = null, u = null, p = null, b = null;
  for (const _ of t)
    switch (w && (_.type !== "space" && _.type !== "newline" && _.type !== "comma" && i(_.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), w = !1), _.type) {
      case "space":
        !e && c && n !== "doc-start" && _.source[0] === "	" && i(_, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), l = !0;
        break;
      case "comment": {
        l || i(_, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const P = _.source.substring(1) || " ";
        f ? f += d + P : f = P, d = "", c = !1;
        break;
      }
      case "newline":
        c ? f ? f += _.source : o = !0 : d += _.source, c = !0, g = !0, (y || h) && (v = !0), l = !0;
        break;
      case "anchor":
        y && i(_, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), _.source.endsWith(":") && i(_.offset + _.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), y = _, b === null && (b = _.offset), c = !1, l = !1, w = !0;
        break;
      case "tag": {
        h && i(_, "MULTIPLE_TAGS", "A node can have at most one tag"), h = _, b === null && (b = _.offset), c = !1, l = !1, w = !0;
        break;
      }
      case n:
        (y || h) && i(_, "BAD_PROP_ORDER", `Anchors and tags must be after the ${_.source} indicator`), p && i(_, "UNEXPECTED_TOKEN", `Unexpected ${_.source} in ${e ?? "collection"}`), p = _, c = !1, l = !1;
        break;
      case "comma":
        if (e) {
          u && i(_, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), u = _, c = !1, l = !1;
          break;
        }
      default:
        i(_, "UNEXPECTED_TOKEN", `Unexpected ${_.type} token`), c = !1, l = !1;
    }
  const E = t[t.length - 1], C = E ? E.offset + E.source.length : s;
  return w && r && r.type !== "space" && r.type !== "newline" && r.type !== "comma" && (r.type !== "scalar" || r.source !== "") && i(r.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), {
    comma: u,
    found: p,
    spaceBefore: o,
    comment: f,
    hasNewline: g,
    hasNewlineAfterProp: v,
    anchor: y,
    tag: h,
    end: C,
    start: b ?? C
  };
}
function Yn(t) {
  if (!t)
    return null;
  switch (t.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (t.source.includes(`
`))
        return !0;
      if (t.end) {
        for (const e of t.end)
          if (e.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const e of t.items) {
        for (const n of e.start)
          if (n.type === "newline")
            return !0;
        if (e.sep) {
          for (const n of e.sep)
            if (n.type === "newline")
              return !0;
        }
        if (Yn(e.key) || Yn(e.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function ei(t, e, n) {
  if ((e == null ? void 0 : e.type) === "flow-collection") {
    const r = e.end[0];
    r.indent === t && (r.source === "]" || r.source === "}") && Yn(e) && n(r, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function Tc(t, e, n) {
  const { uniqueKeys: r } = t.options;
  if (r === !1)
    return !1;
  const s = typeof r == "function" ? r : (i, a) => i === a || re(i) && re(a) && i.value === a.value && !(i.value === "<<" && t.schema.merge);
  return e.some((i) => s(i.key, n));
}
const ro = "All mapping items must start at the same column";
function By({ composeNode: t, composeEmptyNode: e }, n, r, s, i) {
  var f;
  const a = (i == null ? void 0 : i.nodeClass) ?? Ae, o = new a(n.schema);
  n.atRoot && (n.atRoot = !1);
  let c = r.offset, l = null;
  for (const d of r.items) {
    const { start: g, key: v, sep: w, value: y } = d, h = cn(g, {
      indicator: "explicit-key-ind",
      next: v ?? (w == null ? void 0 : w[0]),
      offset: c,
      onError: s,
      startOnNewline: !0
    }), u = !h.found;
    if (u) {
      if (v && (v.type === "block-seq" ? s(c, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in v && v.indent !== r.indent && s(c, "BAD_INDENT", ro)), !h.anchor && !h.tag && !w) {
        l = h.end, h.comment && (o.comment ? o.comment += `
` + h.comment : o.comment = h.comment);
        continue;
      }
      (h.hasNewlineAfterProp || Yn(v)) && s(v ?? g[g.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else
      ((f = h.found) == null ? void 0 : f.indent) !== r.indent && s(c, "BAD_INDENT", ro);
    const p = h.end, b = v ? t(n, v, h, s) : e(n, p, g, null, h, s);
    n.schema.compat && ei(r.indent, v, s), Tc(n, o.items, b) && s(p, "DUPLICATE_KEY", "Map keys must be unique");
    const E = cn(w ?? [], {
      indicator: "map-value-ind",
      next: y,
      offset: b.range[2],
      onError: s,
      startOnNewline: !v || v.type === "block-scalar"
    });
    if (c = E.end, E.found) {
      u && ((y == null ? void 0 : y.type) === "block-map" && !E.hasNewline && s(c, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), n.options.strict && h.start < E.found.offset - 1024 && s(b.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const C = y ? t(n, y, E, s) : e(n, c, w, null, E, s);
      n.schema.compat && ei(r.indent, y, s), c = C.range[2];
      const _ = new _e(b, C);
      n.options.keepSourceTokens && (_.srcToken = d), o.items.push(_);
    } else {
      u && s(b.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), E.comment && (b.comment ? b.comment += `
` + E.comment : b.comment = E.comment);
      const C = new _e(b);
      n.options.keepSourceTokens && (C.srcToken = d), o.items.push(C);
    }
  }
  return l && l < c && s(l, "IMPOSSIBLE", "Map comment with trailing content"), o.range = [r.offset, c, l ?? c], o;
}
function zy({ composeNode: t, composeEmptyNode: e }, n, r, s, i) {
  const a = (i == null ? void 0 : i.nodeClass) ?? $t, o = new a(n.schema);
  n.atRoot && (n.atRoot = !1);
  let c = r.offset, l = null;
  for (const { start: f, value: d } of r.items) {
    const g = cn(f, {
      indicator: "seq-item-ind",
      next: d,
      offset: c,
      onError: s,
      startOnNewline: !0
    });
    if (!g.found)
      if (g.anchor || g.tag || d)
        d && d.type === "block-seq" ? s(g.end, "BAD_INDENT", "All sequence items must start at the same column") : s(c, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        l = g.end, g.comment && (o.comment = g.comment);
        continue;
      }
    const v = d ? t(n, d, g, s) : e(n, g.end, f, null, g, s);
    n.schema.compat && ei(r.indent, d, s), c = v.range[2], o.items.push(v);
  }
  return o.range = [r.offset, c, l ?? c], o;
}
function ir(t, e, n, r) {
  let s = "";
  if (t) {
    let i = !1, a = "";
    for (const o of t) {
      const { source: c, type: l } = o;
      switch (l) {
        case "space":
          i = !0;
          break;
        case "comment": {
          n && !i && r(o, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const f = c.substring(1) || " ";
          s ? s += a + f : s = f, a = "";
          break;
        }
        case "newline":
          s && (a += c), i = !0;
          break;
        default:
          r(o, "UNEXPECTED_TOKEN", `Unexpected ${l} at node end`);
      }
      e += c.length;
    }
  }
  return { comment: s, offset: e };
}
const Ns = "Block collections are not allowed within flow collections", Ps = (t) => t && (t.type === "block-map" || t.type === "block-seq");
function Gy({ composeNode: t, composeEmptyNode: e }, n, r, s, i) {
  const a = r.start.source === "{", o = a ? "flow map" : "flow sequence", c = (i == null ? void 0 : i.nodeClass) ?? (a ? Ae : $t), l = new c(n.schema);
  l.flow = !0;
  const f = n.atRoot;
  f && (n.atRoot = !1);
  let d = r.offset + r.start.source.length;
  for (let h = 0; h < r.items.length; ++h) {
    const u = r.items[h], { start: p, key: b, sep: E, value: C } = u, _ = cn(p, {
      flow: o,
      indicator: "explicit-key-ind",
      next: b ?? (E == null ? void 0 : E[0]),
      offset: d,
      onError: s,
      startOnNewline: !1
    });
    if (!_.found) {
      if (!_.anchor && !_.tag && !E && !C) {
        h === 0 && _.comma ? s(_.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${o}`) : h < r.items.length - 1 && s(_.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${o}`), _.comment && (l.comment ? l.comment += `
` + _.comment : l.comment = _.comment), d = _.end;
        continue;
      }
      !a && n.options.strict && Yn(b) && s(
        b,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (h === 0)
      _.comma && s(_.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${o}`);
    else if (_.comma || s(_.start, "MISSING_CHAR", `Missing , between ${o} items`), _.comment) {
      let P = "";
      e:
        for (const R of p)
          switch (R.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              P = R.source.substring(1);
              break e;
            default:
              break e;
          }
      if (P) {
        let R = l.items[l.items.length - 1];
        le(R) && (R = R.value ?? R.key), R.comment ? R.comment += `
` + P : R.comment = P, _.comment = _.comment.substring(P.length + 1);
      }
    }
    if (!a && !E && !_.found) {
      const P = C ? t(n, C, _, s) : e(n, _.end, E, null, _, s);
      l.items.push(P), d = P.range[2], Ps(C) && s(P.range, "BLOCK_IN_FLOW", Ns);
    } else {
      const P = _.end, R = b ? t(n, b, _, s) : e(n, P, p, null, _, s);
      Ps(b) && s(R.range, "BLOCK_IN_FLOW", Ns);
      const D = cn(E ?? [], {
        flow: o,
        indicator: "map-value-ind",
        next: C,
        offset: R.range[2],
        onError: s,
        startOnNewline: !1
      });
      if (D.found) {
        if (!a && !_.found && n.options.strict) {
          if (E)
            for (const U of E) {
              if (U === D.found)
                break;
              if (U.type === "newline") {
                s(U, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          _.start < D.found.offset - 1024 && s(D.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else
        C && ("source" in C && C.source && C.source[0] === ":" ? s(C, "MISSING_CHAR", `Missing space after : in ${o}`) : s(D.start, "MISSING_CHAR", `Missing , or : between ${o} items`));
      const V = C ? t(n, C, D, s) : D.found ? e(n, D.end, E, null, D, s) : null;
      V ? Ps(C) && s(V.range, "BLOCK_IN_FLOW", Ns) : D.comment && (R.comment ? R.comment += `
` + D.comment : R.comment = D.comment);
      const G = new _e(R, V);
      if (n.options.keepSourceTokens && (G.srcToken = u), a) {
        const U = l;
        Tc(n, U.items, R) && s(P, "DUPLICATE_KEY", "Map keys must be unique"), U.items.push(G);
      } else {
        const U = new Ae(n.schema);
        U.flow = !0, U.items.push(G), l.items.push(U);
      }
      d = V ? V.range[2] : D.end;
    }
  }
  const g = a ? "}" : "]", [v, ...w] = r.end;
  let y = d;
  if (v && v.source === g)
    y = v.offset + v.source.length;
  else {
    const h = o[0].toUpperCase() + o.substring(1), u = f ? `${h} must end with a ${g}` : `${h} in block collection must be sufficiently indented and end with a ${g}`;
    s(d, f ? "MISSING_CHAR" : "BAD_INDENT", u), v && v.source.length !== 1 && w.unshift(v);
  }
  if (w.length > 0) {
    const h = ir(w, y, n.options.strict, s);
    h.comment && (l.comment ? l.comment += `
` + h.comment : l.comment = h.comment), l.range = [r.offset, y, h.offset];
  } else
    l.range = [r.offset, y, y];
  return l;
}
function ks(t, e, n, r, s, i) {
  const a = n.type === "block-map" ? By(t, e, n, r, i) : n.type === "block-seq" ? zy(t, e, n, r, i) : Gy(t, e, n, r, i), o = a.constructor;
  return s === "!" || s === o.tagName ? (a.tag = o.tagName, a) : (s && (a.tag = s), a);
}
function Jy(t, e, n, r, s) {
  var d;
  const i = r ? e.directives.tagName(r.source, (g) => s(r, "TAG_RESOLVE_FAILED", g)) : null, a = n.type === "block-map" ? "map" : n.type === "block-seq" ? "seq" : n.start.source === "{" ? "map" : "seq";
  if (!r || !i || i === "!" || i === Ae.tagName && a === "map" || i === $t.tagName && a === "seq" || !a)
    return ks(t, e, n, s, i);
  let o = e.schema.tags.find((g) => g.tag === i && g.collection === a);
  if (!o) {
    const g = e.schema.knownTags[i];
    if (g && g.collection === a)
      e.schema.tags.push(Object.assign({}, g, { default: !1 })), o = g;
    else
      return g != null && g.collection ? s(r, "BAD_COLLECTION_TYPE", `${g.tag} used for ${a} collection, but expects ${g.collection}`, !0) : s(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${i}`, !0), ks(t, e, n, s, i);
  }
  const c = ks(t, e, n, s, i, o), l = ((d = o.resolve) == null ? void 0 : d.call(o, c, (g) => s(r, "TAG_RESOLVE_FAILED", g), e.options)) ?? c, f = pe(l) ? l : new W(l);
  return f.range = c.range, f.tag = i, o != null && o.format && (f.format = o.format), f;
}
function Ic(t, e, n) {
  const r = t.offset, s = Hy(t, e, n);
  if (!s)
    return { value: "", type: null, comment: "", range: [r, r, r] };
  const i = s.mode === ">" ? W.BLOCK_FOLDED : W.BLOCK_LITERAL, a = t.source ? Yy(t.source) : [];
  let o = a.length;
  for (let y = a.length - 1; y >= 0; --y) {
    const h = a[y][1];
    if (h === "" || h === "\r")
      o = y;
    else
      break;
  }
  if (o === 0) {
    const y = s.chomp === "+" && a.length > 0 ? `
`.repeat(Math.max(1, a.length - 1)) : "";
    let h = r + s.length;
    return t.source && (h += t.source.length), { value: y, type: i, comment: s.comment, range: [r, h, h] };
  }
  let c = t.indent + s.indent, l = t.offset + s.length, f = 0;
  for (let y = 0; y < o; ++y) {
    const [h, u] = a[y];
    if (u === "" || u === "\r")
      s.indent === 0 && h.length > c && (c = h.length);
    else {
      h.length < c && n(l + h.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), s.indent === 0 && (c = h.length), f = y;
      break;
    }
    l += h.length + u.length + 1;
  }
  for (let y = a.length - 1; y >= o; --y)
    a[y][0].length > c && (o = y + 1);
  let d = "", g = "", v = !1;
  for (let y = 0; y < f; ++y)
    d += a[y][0].slice(c) + `
`;
  for (let y = f; y < o; ++y) {
    let [h, u] = a[y];
    l += h.length + u.length + 1;
    const p = u[u.length - 1] === "\r";
    if (p && (u = u.slice(0, -1)), u && h.length < c) {
      const E = `Block scalar lines must not be less indented than their ${s.indent ? "explicit indentation indicator" : "first line"}`;
      n(l - u.length - (p ? 2 : 1), "BAD_INDENT", E), h = "";
    }
    i === W.BLOCK_LITERAL ? (d += g + h.slice(c) + u, g = `
`) : h.length > c || u[0] === "	" ? (g === " " ? g = `
` : !v && g === `
` && (g = `

`), d += g + h.slice(c) + u, g = `
`, v = !0) : u === "" ? g === `
` ? d += `
` : g = `
` : (d += g + u, g = " ", v = !1);
  }
  switch (s.chomp) {
    case "-":
      break;
    case "+":
      for (let y = o; y < a.length; ++y)
        d += `
` + a[y][0].slice(c);
      d[d.length - 1] !== `
` && (d += `
`);
      break;
    default:
      d += `
`;
  }
  const w = r + s.length + t.source.length;
  return { value: d, type: i, comment: s.comment, range: [r, w, w] };
}
function Hy({ offset: t, props: e }, n, r) {
  if (e[0].type !== "block-scalar-header")
    return r(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: s } = e[0], i = s[0];
  let a = 0, o = "", c = -1;
  for (let g = 1; g < s.length; ++g) {
    const v = s[g];
    if (!o && (v === "-" || v === "+"))
      o = v;
    else {
      const w = Number(v);
      !a && w ? a = w : c === -1 && (c = t + g);
    }
  }
  c !== -1 && r(c, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${s}`);
  let l = !1, f = "", d = s.length;
  for (let g = 1; g < e.length; ++g) {
    const v = e[g];
    switch (v.type) {
      case "space":
        l = !0;
      case "newline":
        d += v.source.length;
        break;
      case "comment":
        n && !l && r(v, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), d += v.source.length, f = v.source.substring(1);
        break;
      case "error":
        r(v, "UNEXPECTED_TOKEN", v.message), d += v.source.length;
        break;
      default: {
        const w = `Unexpected token in block scalar header: ${v.type}`;
        r(v, "UNEXPECTED_TOKEN", w);
        const y = v.source;
        y && typeof y == "string" && (d += y.length);
      }
    }
  }
  return { mode: i, indent: a, chomp: o, comment: f, length: d };
}
function Yy(t) {
  const e = t.split(/\n( *)/), n = e[0], r = n.match(/^( *)/), i = [r != null && r[1] ? [r[1], n.slice(r[1].length)] : ["", n]];
  for (let a = 1; a < e.length; a += 2)
    i.push([e[a], e[a + 1]]);
  return i;
}
function Cc(t, e, n) {
  const { offset: r, type: s, source: i, end: a } = t;
  let o, c;
  const l = (g, v, w) => n(r + g, v, w);
  switch (s) {
    case "scalar":
      o = W.PLAIN, c = Wy(i, l);
      break;
    case "single-quoted-scalar":
      o = W.QUOTE_SINGLE, c = Qy(i, l);
      break;
    case "double-quoted-scalar":
      o = W.QUOTE_DOUBLE, c = Xy(i, l);
      break;
    default:
      return n(t, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${s}`), {
        value: "",
        type: null,
        comment: "",
        range: [r, r + i.length, r + i.length]
      };
  }
  const f = r + i.length, d = ir(a, f, e, n);
  return {
    value: c,
    type: o,
    comment: d.comment,
    range: [r, f, d.offset]
  };
}
function Wy(t, e) {
  let n = "";
  switch (t[0]) {
    case "	":
      n = "a tab character";
      break;
    case ",":
      n = "flow indicator character ,";
      break;
    case "%":
      n = "directive indicator character %";
      break;
    case "|":
    case ">": {
      n = `block scalar indicator ${t[0]}`;
      break;
    }
    case "@":
    case "`": {
      n = `reserved character ${t[0]}`;
      break;
    }
  }
  return n && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${n}`), jc(t);
}
function Qy(t, e) {
  return (t[t.length - 1] !== "'" || t.length === 1) && e(t.length, "MISSING_CHAR", "Missing closing 'quote"), jc(t.slice(1, -1)).replace(/''/g, "'");
}
function jc(t) {
  let e, n;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), n = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, n = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let r = e.exec(t);
  if (!r)
    return t;
  let s = r[1], i = " ", a = e.lastIndex;
  for (n.lastIndex = a; r = n.exec(t); )
    r[1] === "" ? i === `
` ? s += i : i = `
` : (s += i + r[1], i = " "), a = n.lastIndex;
  const o = /[ \t]*(.*)/sy;
  return o.lastIndex = a, r = o.exec(t), s + i + ((r == null ? void 0 : r[1]) ?? "");
}
function Xy(t, e) {
  let n = "";
  for (let r = 1; r < t.length - 1; ++r) {
    const s = t[r];
    if (!(s === "\r" && t[r + 1] === `
`))
      if (s === `
`) {
        const { fold: i, offset: a } = Zy(t, r);
        n += i, r = a;
      } else if (s === "\\") {
        let i = t[++r];
        const a = xy[i];
        if (a)
          n += a;
        else if (i === `
`)
          for (i = t[r + 1]; i === " " || i === "	"; )
            i = t[++r + 1];
        else if (i === "\r" && t[r + 1] === `
`)
          for (i = t[++r + 1]; i === " " || i === "	"; )
            i = t[++r + 1];
        else if (i === "x" || i === "u" || i === "U") {
          const o = { x: 2, u: 4, U: 8 }[i];
          n += eg(t, r + 1, o, e), r += o;
        } else {
          const o = t.substr(r - 1, 2);
          e(r - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${o}`), n += o;
        }
      } else if (s === " " || s === "	") {
        const i = r;
        let a = t[r + 1];
        for (; a === " " || a === "	"; )
          a = t[++r + 1];
        a !== `
` && !(a === "\r" && t[r + 2] === `
`) && (n += r > i ? t.slice(i, r + 1) : s);
      } else
        n += s;
  }
  return (t[t.length - 1] !== '"' || t.length === 1) && e(t.length, "MISSING_CHAR", 'Missing closing "quote'), n;
}
function Zy(t, e) {
  let n = "", r = t[e + 1];
  for (; (r === " " || r === "	" || r === `
` || r === "\r") && !(r === "\r" && t[e + 2] !== `
`); )
    r === `
` && (n += `
`), e += 1, r = t[e + 1];
  return n || (n = " "), { fold: n, offset: e };
}
const xy = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: "",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function eg(t, e, n, r) {
  const s = t.substr(e, n), a = s.length === n && /^[0-9a-fA-F]+$/.test(s) ? parseInt(s, 16) : NaN;
  if (isNaN(a)) {
    const o = t.substr(e - 2, n + 2);
    return r(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${o}`), o;
  }
  return String.fromCodePoint(a);
}
function Rc(t, e, n, r) {
  const { value: s, type: i, comment: a, range: o } = e.type === "block-scalar" ? Ic(e, t.options.strict, r) : Cc(e, t.options.strict, r), c = n ? t.directives.tagName(n.source, (d) => r(n, "TAG_RESOLVE_FAILED", d)) : null, l = n && c ? tg(t.schema, s, c, n, r) : e.type === "scalar" ? ng(t, s, e, r) : t.schema[ot];
  let f;
  try {
    const d = l.resolve(s, (g) => r(n ?? e, "TAG_RESOLVE_FAILED", g), t.options);
    f = re(d) ? d : new W(d);
  } catch (d) {
    const g = d instanceof Error ? d.message : String(d);
    r(n ?? e, "TAG_RESOLVE_FAILED", g), f = new W(s);
  }
  return f.range = o, f.source = s, i && (f.type = i), c && (f.tag = c), l.format && (f.format = l.format), a && (f.comment = a), f;
}
function tg(t, e, n, r, s) {
  var o;
  if (n === "!")
    return t[ot];
  const i = [];
  for (const c of t.tags)
    if (!c.collection && c.tag === n)
      if (c.default && c.test)
        i.push(c);
      else
        return c;
  for (const c of i)
    if ((o = c.test) != null && o.test(e))
      return c;
  const a = t.knownTags[n];
  return a && !a.collection ? (t.tags.push(Object.assign({}, a, { default: !1, test: void 0 })), a) : (s(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${n}`, n !== "tag:yaml.org,2002:str"), t[ot]);
}
function ng({ directives: t, schema: e }, n, r, s) {
  const i = e.tags.find((a) => {
    var o;
    return a.default && ((o = a.test) == null ? void 0 : o.test(n));
  }) || e[ot];
  if (e.compat) {
    const a = e.compat.find((o) => {
      var c;
      return o.default && ((c = o.test) == null ? void 0 : c.test(n));
    }) ?? e[ot];
    if (i.tag !== a.tag) {
      const o = t.tagString(i.tag), c = t.tagString(a.tag), l = `Value may be parsed as either ${o} or ${c}`;
      s(r, "TAG_RESOLVE_FAILED", l, !0);
    }
  }
  return i;
}
function rg(t, e, n) {
  if (e) {
    n === null && (n = e.length);
    for (let r = n - 1; r >= 0; --r) {
      let s = e[r];
      switch (s.type) {
        case "space":
        case "comment":
        case "newline":
          t -= s.source.length;
          continue;
      }
      for (s = e[++r]; (s == null ? void 0 : s.type) === "space"; )
        t += s.source.length, s = e[++r];
      break;
    }
  }
  return t;
}
const sg = { composeNode: Dc, composeEmptyNode: sa };
function Dc(t, e, n, r) {
  const { spaceBefore: s, comment: i, anchor: a, tag: o } = n;
  let c, l = !0;
  switch (e.type) {
    case "alias":
      c = ig(t, e, r), (a || o) && r(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      c = Rc(t, e, o, r), a && (c.anchor = a.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      c = Jy(sg, t, e, o, r), a && (c.anchor = a.source.substring(1));
      break;
    default: {
      const f = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      r(e, "UNEXPECTED_TOKEN", f), c = sa(t, e.offset, void 0, null, n, r), l = !1;
    }
  }
  return a && c.anchor === "" && r(a, "BAD_ALIAS", "Anchor cannot be an empty string"), s && (c.spaceBefore = !0), i && (e.type === "scalar" && e.source === "" ? c.comment = i : c.commentBefore = i), t.options.keepSourceTokens && l && (c.srcToken = e), c;
}
function sa(t, e, n, r, { spaceBefore: s, comment: i, anchor: a, tag: o, end: c }, l) {
  const f = {
    type: "scalar",
    offset: rg(e, n, r),
    indent: -1,
    source: ""
  }, d = Rc(t, f, o, l);
  return a && (d.anchor = a.source.substring(1), d.anchor === "" && l(a, "BAD_ALIAS", "Anchor cannot be an empty string")), s && (d.spaceBefore = !0), i && (d.comment = i, d.range[2] = c), d;
}
function ig({ options: t }, { offset: e, source: n, end: r }, s) {
  const i = new ts(n.substring(1));
  i.source === "" && s(e, "BAD_ALIAS", "Alias cannot be an empty string"), i.source.endsWith(":") && s(e + n.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const a = e + n.length, o = ir(r, a, t.strict, s);
  return i.range = [e, a, o.offset], o.comment && (i.comment = o.comment), i;
}
function ag(t, e, { offset: n, start: r, value: s, end: i }, a) {
  const o = Object.assign({ _directives: e }, t), c = new _n(void 0, o), l = {
    atRoot: !0,
    directives: c.directives,
    options: c.options,
    schema: c.schema
  }, f = cn(r, {
    indicator: "doc-start",
    next: s ?? (i == null ? void 0 : i[0]),
    offset: n,
    onError: a,
    startOnNewline: !0
  });
  f.found && (c.directives.docStart = !0, s && (s.type === "block-map" || s.type === "block-seq") && !f.hasNewline && a(f.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), c.contents = s ? Dc(l, s, f, a) : sa(l, f.end, r, null, f, a);
  const d = c.contents.range[2], g = ir(i, d, !1, a);
  return g.comment && (c.comment = g.comment), c.range = [n, d, g.offset], c;
}
function Dn(t) {
  if (typeof t == "number")
    return [t, t + 1];
  if (Array.isArray(t))
    return t.length === 2 ? t : [t[0], t[1]];
  const { offset: e, source: n } = t;
  return [e, e + (typeof n == "string" ? n.length : 1)];
}
function so(t) {
  var s;
  let e = "", n = !1, r = !1;
  for (let i = 0; i < t.length; ++i) {
    const a = t[i];
    switch (a[0]) {
      case "#":
        e += (e === "" ? "" : r ? `

` : `
`) + (a.substring(1) || " "), n = !0, r = !1;
        break;
      case "%":
        ((s = t[i + 1]) == null ? void 0 : s[0]) !== "#" && (i += 1), n = !1;
        break;
      default:
        n || (r = !0), n = !1;
    }
  }
  return { comment: e, afterEmptyLine: r };
}
class ia {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (n, r, s, i) => {
      const a = Dn(n);
      i ? this.warnings.push(new Ac(a, r, s)) : this.errors.push(new It(a, r, s));
    }, this.directives = new Se({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, n) {
    const { comment: r, afterEmptyLine: s } = so(this.prelude);
    if (r) {
      const i = e.contents;
      if (n)
        e.comment = e.comment ? `${e.comment}
${r}` : r;
      else if (s || e.directives.docStart || !i)
        e.commentBefore = r;
      else if (ue(i) && !i.flow && i.items.length > 0) {
        let a = i.items[0];
        le(a) && (a = a.key);
        const o = a.commentBefore;
        a.commentBefore = o ? `${r}
${o}` : r;
      } else {
        const a = i.commentBefore;
        i.commentBefore = a ? `${r}
${a}` : r;
      }
    }
    n ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: so(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, n = !1, r = -1) {
    for (const s of e)
      yield* this.next(s);
    yield* this.end(n, r);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (n, r, s) => {
          const i = Dn(e);
          i[0] += n, this.onError(i, "BAD_DIRECTIVE", r, s);
        }), this.prelude.push(e.source), this.atDirectives = !0;
        break;
      case "document": {
        const n = ag(this.options, this.directives, e, this.onError);
        this.atDirectives && !n.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(n, !1), this.doc && (yield this.doc), this.doc = n, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const n = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, r = new It(Dn(e), "UNEXPECTED_TOKEN", n);
        this.atDirectives || !this.doc ? this.errors.push(r) : this.doc.errors.push(r);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const r = "Unexpected doc-end without preceding document";
          this.errors.push(new It(Dn(e), "UNEXPECTED_TOKEN", r));
          break;
        }
        this.doc.directives.docEnd = !0;
        const n = ir(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), n.comment) {
          const r = this.doc.comment;
          this.doc.comment = r ? `${r}
${n.comment}` : n.comment;
        }
        this.doc.range[2] = n.offset;
        break;
      }
      default:
        this.errors.push(new It(Dn(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = !1, n = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (e) {
      const r = Object.assign({ _directives: this.directives }, this.options), s = new _n(void 0, r);
      this.atDirectives && this.onError(n, "MISSING_CHAR", "Missing directives-end indicator line"), s.range = [0, n, n], this.decorate(s, !1), yield s;
    }
  }
}
function og(t, e = !0, n) {
  if (t) {
    const r = (s, i, a) => {
      const o = typeof s == "number" ? s : Array.isArray(s) ? s[0] : s.offset;
      if (n)
        n(o, i, a);
      else
        throw new It([o, o + 1], i, a);
    };
    switch (t.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return Cc(t, e, r);
      case "block-scalar":
        return Ic(t, e, r);
    }
  }
  return null;
}
function cg(t, e) {
  const { implicitKey: n = !1, indent: r, inFlow: s = !1, offset: i = -1, type: a = "PLAIN" } = e, o = rr({ type: a, value: t }, {
    implicitKey: n,
    indent: r > 0 ? " ".repeat(r) : "",
    inFlow: s,
    options: { blockQuote: !0, lineWidth: -1 }
  }), c = e.end ?? [
    { type: "newline", offset: -1, indent: r, source: `
` }
  ];
  switch (o[0]) {
    case "|":
    case ">": {
      const l = o.indexOf(`
`), f = o.substring(0, l), d = o.substring(l + 1) + `
`, g = [
        { type: "block-scalar-header", offset: i, indent: r, source: f }
      ];
      return Mc(g, c) || g.push({ type: "newline", offset: -1, indent: r, source: `
` }), { type: "block-scalar", offset: i, indent: r, props: g, source: d };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: i, indent: r, source: o, end: c };
    case "'":
      return { type: "single-quoted-scalar", offset: i, indent: r, source: o, end: c };
    default:
      return { type: "scalar", offset: i, indent: r, source: o, end: c };
  }
}
function lg(t, e, n = {}) {
  let { afterKey: r = !1, implicitKey: s = !1, inFlow: i = !1, type: a } = n, o = "indent" in t ? t.indent : null;
  if (r && typeof o == "number" && (o += 2), !a)
    switch (t.type) {
      case "single-quoted-scalar":
        a = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        a = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const l = t.props[0];
        if (l.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        a = l.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        a = "PLAIN";
    }
  const c = rr({ type: a, value: e }, {
    implicitKey: s || o === null,
    indent: o !== null && o > 0 ? " ".repeat(o) : "",
    inFlow: i,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (c[0]) {
    case "|":
    case ">":
      ug(t, c);
      break;
    case '"':
      As(t, c, "double-quoted-scalar");
      break;
    case "'":
      As(t, c, "single-quoted-scalar");
      break;
    default:
      As(t, c, "scalar");
  }
}
function ug(t, e) {
  const n = e.indexOf(`
`), r = e.substring(0, n), s = e.substring(n + 1) + `
`;
  if (t.type === "block-scalar") {
    const i = t.props[0];
    if (i.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    i.source = r, t.source = s;
  } else {
    const { offset: i } = t, a = "indent" in t ? t.indent : -1, o = [
      { type: "block-scalar-header", offset: i, indent: a, source: r }
    ];
    Mc(o, "end" in t ? t.end : void 0) || o.push({ type: "newline", offset: -1, indent: a, source: `
` });
    for (const c of Object.keys(t))
      c !== "type" && c !== "offset" && delete t[c];
    Object.assign(t, { type: "block-scalar", indent: a, props: o, source: s });
  }
}
function Mc(t, e) {
  if (e)
    for (const n of e)
      switch (n.type) {
        case "space":
        case "comment":
          t.push(n);
          break;
        case "newline":
          return t.push(n), !0;
      }
  return !1;
}
function As(t, e, n) {
  switch (t.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      t.type = n, t.source = e;
      break;
    case "block-scalar": {
      const r = t.props.slice(1);
      let s = e.length;
      t.props[0].type === "block-scalar-header" && (s -= t.props[0].source.length);
      for (const i of r)
        i.offset += s;
      delete t.props, Object.assign(t, { type: n, source: e, end: r });
      break;
    }
    case "block-map":
    case "block-seq": {
      const s = { type: "newline", offset: t.offset + e.length, indent: t.indent, source: `
` };
      delete t.items, Object.assign(t, { type: n, source: e, end: [s] });
      break;
    }
    default: {
      const r = "indent" in t ? t.indent : -1, s = "end" in t && Array.isArray(t.end) ? t.end.filter((i) => i.type === "space" || i.type === "comment" || i.type === "newline") : [];
      for (const i of Object.keys(t))
        i !== "type" && i !== "offset" && delete t[i];
      Object.assign(t, { type: n, indent: r, source: e, end: s });
    }
  }
}
const fg = (t) => "type" in t ? Lr(t) : kr(t);
function Lr(t) {
  switch (t.type) {
    case "block-scalar": {
      let e = "";
      for (const n of t.props)
        e += Lr(n);
      return e + t.source;
    }
    case "block-map":
    case "block-seq": {
      let e = "";
      for (const n of t.items)
        e += kr(n);
      return e;
    }
    case "flow-collection": {
      let e = t.start.source;
      for (const n of t.items)
        e += kr(n);
      for (const n of t.end)
        e += n.source;
      return e;
    }
    case "document": {
      let e = kr(t);
      if (t.end)
        for (const n of t.end)
          e += n.source;
      return e;
    }
    default: {
      let e = t.source;
      if ("end" in t && t.end)
        for (const n of t.end)
          e += n.source;
      return e;
    }
  }
}
function kr({ start: t, key: e, sep: n, value: r }) {
  let s = "";
  for (const i of t)
    s += i.source;
  if (e && (s += Lr(e)), n)
    for (const i of n)
      s += i.source;
  return r && (s += Lr(r)), s;
}
const ti = Symbol("break visit"), dg = Symbol("skip children"), Lc = Symbol("remove item");
function Dt(t, e) {
  "type" in t && t.type === "document" && (t = { start: t.start, value: t.value }), Vc(Object.freeze([]), t, e);
}
Dt.BREAK = ti;
Dt.SKIP = dg;
Dt.REMOVE = Lc;
Dt.itemAtPath = (t, e) => {
  let n = t;
  for (const [r, s] of e) {
    const i = n == null ? void 0 : n[r];
    if (i && "items" in i)
      n = i.items[s];
    else
      return;
  }
  return n;
};
Dt.parentCollection = (t, e) => {
  const n = Dt.itemAtPath(t, e.slice(0, -1)), r = e[e.length - 1][0], s = n == null ? void 0 : n[r];
  if (s && "items" in s)
    return s;
  throw new Error("Parent collection not found");
};
function Vc(t, e, n) {
  let r = n(e, t);
  if (typeof r == "symbol")
    return r;
  for (const s of ["key", "value"]) {
    const i = e[s];
    if (i && "items" in i) {
      for (let a = 0; a < i.items.length; ++a) {
        const o = Vc(Object.freeze(t.concat([[s, a]])), i.items[a], n);
        if (typeof o == "number")
          a = o - 1;
        else {
          if (o === ti)
            return ti;
          o === Lc && (i.items.splice(a, 1), a -= 1);
        }
      }
      typeof r == "function" && s === "key" && (r = r(e, t));
    }
  }
  return typeof r == "function" ? r(e, t) : r;
}
const fs = "\uFEFF", ds = "", hs = "", Wn = "", hg = (t) => !!t && "items" in t, mg = (t) => !!t && (t.type === "scalar" || t.type === "single-quoted-scalar" || t.type === "double-quoted-scalar" || t.type === "block-scalar");
function pg(t) {
  switch (t) {
    case fs:
      return "<BOM>";
    case ds:
      return "<DOC>";
    case hs:
      return "<FLOW_END>";
    case Wn:
      return "<SCALAR>";
    default:
      return JSON.stringify(t);
  }
}
function Fc(t) {
  switch (t) {
    case fs:
      return "byte-order-mark";
    case ds:
      return "doc-mode";
    case hs:
      return "flow-error-end";
    case Wn:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (t[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const yg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM: fs,
  DOCUMENT: ds,
  FLOW_END: hs,
  SCALAR: Wn,
  createScalarToken: cg,
  isCollection: hg,
  isScalar: mg,
  prettyToken: pg,
  resolveAsScalar: og,
  setScalarValue: lg,
  stringify: fg,
  tokenType: Fc,
  visit: Dt
}, Symbol.toStringTag, { value: "Module" }));
function Re(t) {
  switch (t) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const io = "0123456789ABCDEFabcdef".split(""), gg = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split(""), Ts = ",[]{}".split(""), $g = ` ,[]{}
\r	`.split(""), Is = (t) => !t || $g.includes(t);
class Uc {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, n = !1) {
    e && (this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null), this.atEnd = !n;
    let r = this.next ?? "stream";
    for (; r && (n || this.hasChars(1)); )
      r = yield* this.parseNext(r);
  }
  atLineEnd() {
    let e = this.pos, n = this.buffer[e];
    for (; n === " " || n === "	"; )
      n = this.buffer[++e];
    return !n || n === "#" || n === `
` ? !0 : n === "\r" ? this.buffer[e + 1] === `
` : !1;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let n = this.buffer[e];
    if (this.indentNext > 0) {
      let r = 0;
      for (; n === " "; )
        n = this.buffer[++r + e];
      if (n === "\r") {
        const s = this.buffer[r + e + 1];
        if (s === `
` || !s && !this.atEnd)
          return e + r + 1;
      }
      return n === `
` || r >= this.indentNext || !n && !this.atEnd ? e + r : -1;
    }
    if (n === "-" || n === ".") {
      const r = this.buffer.substr(e, 3);
      if ((r === "---" || r === "...") && Re(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === fs && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let n = e.length;
      const r = e.indexOf("#");
      if (r !== -1) {
        const i = e[r - 1];
        (i === " " || i === "	") && (n = r - 1);
      }
      for (; ; ) {
        const i = e[n - 1];
        if (i === " " || i === "	")
          n -= 1;
        else
          break;
      }
      const s = (yield* this.pushCount(n)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(e.length - s), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const n = yield* this.pushSpaces(!0);
      return yield* this.pushCount(e.length - n), yield* this.pushNewline(), "stream";
    }
    return yield ds, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const n = this.peek(3);
      if (n === "---" && Re(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, "doc";
      if (n === "..." && Re(this.charAt(3)))
        return yield* this.pushCount(3), "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !Re(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, n] = this.peek(2);
    if (!n && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && Re(n)) {
      const r = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += r, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (e[n]) {
      case "#":
        yield* this.pushCount(e.length - n);
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(Is), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return n += yield* this.parseBlockScalarHeader(), n += yield* this.pushSpaces(!0), yield* this.pushCount(e.length - n), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, n, r = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (n = yield* this.pushSpaces(!1), this.indentValue = r = n) : n = 0, n += yield* this.pushSpaces(!0);
    while (e + n > 0);
    const s = this.getLine();
    if (s === null)
      return this.setNext("flow");
    if ((r !== -1 && r < this.indentNext && s[0] !== "#" || r === 0 && (s.startsWith("---") || s.startsWith("...")) && Re(s[3])) && !(r === this.indentNext - 1 && this.flowLevel === 1 && (s[0] === "]" || s[0] === "}")))
      return this.flowLevel = 0, yield hs, yield* this.parseLineStart();
    let i = 0;
    for (; s[i] === ","; )
      i += yield* this.pushCount(1), i += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (i += yield* this.pushIndicators(), s[i]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(s.length - i), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(Is), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const a = this.charAt(1);
        if (this.flowKey || Re(a) || a === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let n = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; n !== -1 && this.buffer[n + 1] === "'"; )
        n = this.buffer.indexOf("'", n + 2);
    else
      for (; n !== -1; ) {
        let i = 0;
        for (; this.buffer[n - 1 - i] === "\\"; )
          i += 1;
        if (i % 2 === 0)
          break;
        n = this.buffer.indexOf('"', n + 1);
      }
    const r = this.buffer.substring(0, n);
    let s = r.indexOf(`
`, this.pos);
    if (s !== -1) {
      for (; s !== -1; ) {
        const i = this.continueScalar(s + 1);
        if (i === -1)
          break;
        s = r.indexOf(`
`, i);
      }
      s !== -1 && (n = s - (r[s - 1] === "\r" ? 2 : 1));
    }
    if (n === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      n = this.buffer.length;
    }
    return yield* this.pushToIndex(n + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let e = this.pos;
    for (; ; ) {
      const n = this.buffer[++e];
      if (n === "+")
        this.blockScalarKeep = !0;
      else if (n > "0" && n <= "9")
        this.blockScalarIndent = Number(n) - 1;
      else if (n !== "-")
        break;
    }
    return yield* this.pushUntil((n) => Re(n) || n === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, n = 0, r;
    e:
      for (let s = this.pos; r = this.buffer[s]; ++s)
        switch (r) {
          case " ":
            n += 1;
            break;
          case `
`:
            e = s, n = 0;
            break;
          case "\r": {
            const i = this.buffer[s + 1];
            if (!i && !this.atEnd)
              return this.setNext("block-scalar");
            if (i === `
`)
              break;
          }
          default:
            break e;
        }
    if (!r && !this.atEnd)
      return this.setNext("block-scalar");
    if (n >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = n : this.indentNext += this.blockScalarIndent;
      do {
        const s = this.continueScalar(e + 1);
        if (s === -1)
          break;
        e = this.buffer.indexOf(`
`, s);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep)
      do {
        let s = e - 1, i = this.buffer[s];
        i === "\r" && (i = this.buffer[--s]);
        const a = s;
        for (; i === " " || i === "	"; )
          i = this.buffer[--s];
        if (i === `
` && s >= this.pos && s + 1 + n > a)
          e = s;
        else
          break;
      } while (!0);
    return yield Wn, yield* this.pushToIndex(e + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let n = this.pos - 1, r = this.pos - 1, s;
    for (; s = this.buffer[++r]; )
      if (s === ":") {
        const i = this.buffer[r + 1];
        if (Re(i) || e && i === ",")
          break;
        n = r;
      } else if (Re(s)) {
        let i = this.buffer[r + 1];
        if (s === "\r" && (i === `
` ? (r += 1, s = `
`, i = this.buffer[r + 1]) : n = r), i === "#" || e && Ts.includes(i))
          break;
        if (s === `
`) {
          const a = this.continueScalar(r + 1);
          if (a === -1)
            break;
          r = Math.max(r, a - 2);
        }
      } else {
        if (e && Ts.includes(s))
          break;
        n = r;
      }
    return !s && !this.atEnd ? this.setNext("plain-scalar") : (yield Wn, yield* this.pushToIndex(n + 1, !0), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, n) {
    const r = this.buffer.slice(this.pos, e);
    return r ? (yield r, this.pos += r.length, r.length) : (n && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(Is)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const e = this.flowLevel > 0, n = this.charAt(1);
        if (Re(n) || e && Ts.includes(n))
          return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, n = this.buffer[e];
      for (; !Re(n) && n !== ">"; )
        n = this.buffer[++e];
      return yield* this.pushToIndex(n === ">" ? e + 1 : e, !1);
    } else {
      let e = this.pos + 1, n = this.buffer[e];
      for (; n; )
        if (gg.includes(n))
          n = this.buffer[++e];
        else if (n === "%" && io.includes(this.buffer[e + 1]) && io.includes(this.buffer[e + 2]))
          n = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, !1);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let n = this.pos - 1, r;
    do
      r = this.buffer[++n];
    while (r === " " || e && r === "	");
    const s = n - this.pos;
    return s > 0 && (yield this.buffer.substr(this.pos, s), this.pos = n), s;
  }
  *pushUntil(e) {
    let n = this.pos, r = this.buffer[n];
    for (; !e(r); )
      r = this.buffer[++n];
    return yield* this.pushToIndex(n, !1);
  }
}
class qc {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let n = 0, r = this.lineStarts.length;
      for (; n < r; ) {
        const i = n + r >> 1;
        this.lineStarts[i] < e ? n = i + 1 : r = i;
      }
      if (this.lineStarts[n] === e)
        return { line: n + 1, col: 1 };
      if (n === 0)
        return { line: 0, col: e };
      const s = this.lineStarts[n - 1];
      return { line: n, col: e - s + 1 };
    };
  }
}
function qe(t, e) {
  for (let n = 0; n < t.length; ++n)
    if (t[n].type === e)
      return !0;
  return !1;
}
function ao(t) {
  for (let e = 0; e < t.length; ++e)
    switch (t[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function Kc(t) {
  switch (t == null ? void 0 : t.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function br(t) {
  switch (t.type) {
    case "document":
      return t.start;
    case "block-map": {
      const e = t.items[t.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return t.items[t.items.length - 1].start;
    default:
      return [];
  }
}
function Qt(t) {
  var n;
  if (t.length === 0)
    return [];
  let e = t.length;
  e:
    for (; --e >= 0; )
      switch (t[e].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break e;
      }
  for (; ((n = t[++e]) == null ? void 0 : n.type) === "space"; )
    ;
  return t.splice(e, t.length);
}
function oo(t) {
  if (t.start.type === "flow-seq-start")
    for (const e of t.items)
      e.sep && !e.value && !qe(e.start, "explicit-key-ind") && !qe(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, Kc(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
class aa {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new Uc(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, n = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const r of this.lexer.lex(e, n))
      yield* this.next(r);
    n || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += e.length;
      return;
    }
    const n = Fc(e);
    if (n)
      if (n === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = n, yield* this.step(), n) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += e.length;
      }
    else {
      const r = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: r, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const n = e ?? this.stack.pop();
    if (!n)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield n;
    else {
      const r = this.peek(1);
      switch (n.type === "block-scalar" ? n.indent = "indent" in r ? r.indent : 0 : n.type === "flow-collection" && r.type === "document" && (n.indent = 0), n.type === "flow-collection" && oo(n), r.type) {
        case "document":
          r.value = n;
          break;
        case "block-scalar":
          r.props.push(n);
          break;
        case "block-map": {
          const s = r.items[r.items.length - 1];
          if (s.value) {
            r.items.push({ start: [], key: n, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (s.sep)
            s.value = n;
          else {
            Object.assign(s, { key: n, sep: [] }), this.onKeyLine = !qe(s.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const s = r.items[r.items.length - 1];
          s.value ? r.items.push({ start: [], value: n }) : s.value = n;
          break;
        }
        case "flow-collection": {
          const s = r.items[r.items.length - 1];
          !s || s.value ? r.items.push({ start: [], key: n, sep: [] }) : s.sep ? s.value = n : Object.assign(s, { key: n, sep: [] });
          return;
        }
        default:
          yield* this.pop(), yield* this.pop(n);
      }
      if ((r.type === "document" || r.type === "block-map" || r.type === "block-seq") && (n.type === "block-map" || n.type === "block-seq")) {
        const s = n.items[n.items.length - 1];
        s && !s.sep && !s.value && s.start.length > 0 && ao(s.start) === -1 && (n.indent === 0 || s.start.every((i) => i.type !== "comment" || i.indent < n.indent)) && (r.type === "document" ? r.end = s.start : r.items.push({ start: s.start }), n.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        ao(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const n = this.startBlockValue(e);
    n ? this.stack.push(n) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const n = br(this.peek(2)), r = Qt(n);
      let s;
      e.end ? (s = e.end, s.push(this.sourceToken), delete e.end) : s = [this.sourceToken];
      const i = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: r, key: e, sep: s }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = i;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let n = this.source.indexOf(`
`) + 1;
          for (; n !== 0; )
            this.onNewLine(this.offset + n), n = this.source.indexOf(`
`, n) + 1;
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    var r;
    const n = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, n.value) {
          const s = "end" in n.value ? n.value.end : void 0, i = Array.isArray(s) ? s[s.length - 1] : void 0;
          (i == null ? void 0 : i.type) === "comment" ? s == null || s.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (n.value)
          e.items.push({ start: [this.sourceToken] });
        else if (n.sep)
          n.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(n.start, e.indent)) {
            const s = e.items[e.items.length - 2], i = (r = s == null ? void 0 : s.value) == null ? void 0 : r.end;
            if (Array.isArray(i)) {
              Array.prototype.push.apply(i, n.start), i.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          n.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const s = !this.onKeyLine && this.indent === e.indent && n.sep && this.type !== "seq-item-ind";
      let i = [];
      if (s && n.sep && !n.value) {
        const a = [];
        for (let o = 0; o < n.sep.length; ++o) {
          const c = n.sep[o];
          switch (c.type) {
            case "newline":
              a.push(o);
              break;
            case "space":
              break;
            case "comment":
              c.indent > e.indent && (a.length = 0);
              break;
            default:
              a.length = 0;
          }
        }
        a.length >= 2 && (i = n.sep.splice(a[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          s || n.value ? (i.push(this.sourceToken), e.items.push({ start: i }), this.onKeyLine = !0) : n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !n.sep && !qe(n.start, "explicit-key-ind") ? n.start.push(this.sourceToken) : s || n.value ? (i.push(this.sourceToken), e.items.push({ start: i })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (qe(n.start, "explicit-key-ind"))
            if (n.sep)
              if (n.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (qe(n.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: i, key: null, sep: [this.sourceToken] }]
                });
              else if (Kc(n.key) && !qe(n.sep, "newline")) {
                const a = Qt(n.start), o = n.key, c = n.sep;
                c.push(this.sourceToken), delete n.key, delete n.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: a, key: o, sep: c }]
                });
              } else
                i.length > 0 ? n.sep = n.sep.concat(i, this.sourceToken) : n.sep.push(this.sourceToken);
            else if (qe(n.start, "newline"))
              Object.assign(n, { key: null, sep: [this.sourceToken] });
            else {
              const a = Qt(n.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: a, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            n.sep ? n.value || s ? e.items.push({ start: i, key: null, sep: [this.sourceToken] }) : qe(n.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : n.sep.push(this.sourceToken) : Object.assign(n, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const a = this.flowScalar(this.type);
          s || n.value ? (e.items.push({ start: i, key: a, sep: [] }), this.onKeyLine = !0) : n.sep ? this.stack.push(a) : (Object.assign(n, { key: a, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const a = this.startBlockValue(e);
          if (a) {
            s && a.type !== "block-seq" && qe(n.start, "explicit-key-ind") && e.items.push({ start: i }), this.stack.push(a);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    var r;
    const n = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (n.value) {
          const s = "end" in n.value ? n.value.end : void 0, i = Array.isArray(s) ? s[s.length - 1] : void 0;
          (i == null ? void 0 : i.type) === "comment" ? s == null || s.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          n.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (n.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(n.start, e.indent)) {
            const s = e.items[e.items.length - 2], i = (r = s == null ? void 0 : s.value) == null ? void 0 : r.end;
            if (Array.isArray(i)) {
              Array.prototype.push.apply(i, n.start), i.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          n.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (n.value || this.indent <= e.indent)
          break;
        n.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        n.value || qe(n.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : n.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const s = this.startBlockValue(e);
      if (s) {
        this.stack.push(s);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const n = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let r;
      do
        yield* this.pop(), r = this.peek(1);
      while (r && r.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !n || n.sep ? e.items.push({ start: [this.sourceToken] }) : n.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !n || n.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : n.sep ? n.sep.push(this.sourceToken) : Object.assign(n, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !n || n.value ? e.items.push({ start: [this.sourceToken] }) : n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const s = this.flowScalar(this.type);
          !n || n.value ? e.items.push({ start: [], key: s, sep: [] }) : n.sep ? this.stack.push(s) : Object.assign(n, { key: s, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const r = this.startBlockValue(e);
      r ? this.stack.push(r) : (yield* this.pop(), yield* this.step());
    } else {
      const r = this.peek(2);
      if (r.type === "block-map" && (this.type === "map-value-ind" && r.indent === e.indent || this.type === "newline" && !r.items[r.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && r.type !== "flow-collection") {
        const s = br(r), i = Qt(s);
        oo(e);
        const a = e.end.splice(1, e.end.length);
        a.push(this.sourceToken);
        const o = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: i, key: e, sep: a }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = o;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let n = this.source.indexOf(`
`) + 1;
      for (; n !== 0; )
        this.onNewLine(this.offset + n), n = this.source.indexOf(`
`, n) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const n = br(e), r = Qt(n);
        return r.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: r }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const n = br(e), r = Qt(n);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: r, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, n) {
    return this.type !== "comment" || this.indent <= n ? !1 : e.every((r) => r.type === "newline" || r.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function Bc(t) {
  const e = t.prettyErrors !== !1;
  return { lineCounter: t.lineCounter || e && new qc() || null, prettyErrors: e };
}
function vg(t, e = {}) {
  const { lineCounter: n, prettyErrors: r } = Bc(e), s = new aa(n == null ? void 0 : n.addNewLine), i = new ia(e), a = Array.from(i.compose(s.parse(t)));
  if (r && n)
    for (const o of a)
      o.errors.forEach(Mr(t, n)), o.warnings.forEach(Mr(t, n));
  return a.length > 0 ? a : Object.assign([], { empty: !0 }, i.streamInfo());
}
function zc(t, e = {}) {
  const { lineCounter: n, prettyErrors: r } = Bc(e), s = new aa(n == null ? void 0 : n.addNewLine), i = new ia(e);
  let a = null;
  for (const o of i.compose(s.parse(t), !0, t.length))
    if (!a)
      a = o;
    else if (a.options.logLevel !== "silent") {
      a.errors.push(new It(o.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return r && n && (a.errors.forEach(Mr(t, n)), a.warnings.forEach(Mr(t, n))), a;
}
function bg(t, e, n) {
  let r;
  typeof e == "function" ? r = e : n === void 0 && e && typeof e == "object" && (n = e);
  const s = zc(t, n);
  if (!s)
    return null;
  if (s.warnings.forEach((i) => fc(s.options.logLevel, i)), s.errors.length > 0) {
    if (s.options.logLevel !== "silent")
      throw s.errors[0];
    s.errors = [];
  }
  return s.toJS(Object.assign({ reviver: r }, n));
}
function _g(t, e, n) {
  let r = null;
  if (typeof e == "function" || Array.isArray(e) ? r = e : n === void 0 && e && (n = e), typeof n == "string" && (n = n.length), typeof n == "number") {
    const s = Math.round(n);
    n = s < 1 ? void 0 : s > 8 ? { indent: 8 } : { indent: s };
  }
  if (t === void 0) {
    const { keepUndefined: s } = n ?? e ?? {};
    if (!s)
      return;
  }
  return new _n(t, r, n).toString(n);
}
const Gc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: ts,
  CST: yg,
  Composer: ia,
  Document: _n,
  Lexer: Uc,
  LineCounter: qc,
  Pair: _e,
  Parser: aa,
  Scalar: W,
  Schema: us,
  YAMLError: ra,
  YAMLMap: Ae,
  YAMLParseError: It,
  YAMLSeq: $t,
  YAMLWarning: Ac,
  isAlias: Mt,
  isCollection: ue,
  isDocument: yn,
  isMap: gn,
  isNode: pe,
  isPair: le,
  isScalar: re,
  isSeq: $n,
  parse: bg,
  parseAllDocuments: vg,
  parseDocument: zc,
  stringify: _g,
  visit: gt,
  visitAsync: es
}, Symbol.toStringTag, { value: "Module" }));
function oa(t) {
  if (xo(t))
    return t;
  if (typeof t == "string")
    try {
      return JSON.parse(t);
    } catch {
      return Gc.parse(t);
    }
  return t;
}
function wg(t, e) {
  const n = !e, r = [];
  if (!Yt.existsSync(t))
    throw new Error(`File not found: ${t}`);
  const s = Yt.readFileSync(t, "utf-8"), i = Yt.dirname(t), a = n ? Yt.basename(t) : Yt.relative(e, t), o = oa(s), c = Ws(o);
  r.push({
    dir: i,
    isEntrypoint: n,
    references: Ws(o),
    filename: a,
    specification: o
  });
  for (const l of c) {
    const f = Yt.resolve(i, l);
    try {
      r.push(...wg(f, e || i));
    } catch {
    }
  }
  return r;
}
function Jc(t) {
  if (xo(t))
    return t;
  const e = oa(t);
  return [
    {
      isEntrypoint: !0,
      specification: e,
      filename: "openapi.json",
      dir: "./",
      references: Ws(e)
    }
  ];
}
async function Sg(t) {
  const e = new ua(), n = Jc(t), r = await e.validate(n), s = structuredClone(
    e.specification
  ), i = e.resolveReferences(n);
  return {
    valid: r.valid,
    version: e.version,
    errors: r.errors,
    specification: s,
    schema: i
  };
}
const Eg = (t) => JSON.stringify(t, null, 2), Og = (t) => Gc.stringify(t);
function Ng(t) {
  var e;
  if ((e = t.openapi) != null && e.startsWith("3.0"))
    t.openapi = "3.1.0";
  else
    return t;
  return t = Qe(t, (n) => (n.type !== "undefined" && n.nullable === !0 && (n.type = ["null", n.type], delete n.nullable), n)), t = Qe(t, (n) => (n.exclusiveMinimum === !0 ? (n.exclusiveMinimum = n.minimum, delete n.minimum) : n.exclusiveMinimum === !1 && delete n.exclusiveMinimum, n.exclusiveMaximum === !0 ? (n.exclusiveMaximum = n.maximum, delete n.maximum) : n.exclusiveMaximum === !1 && delete n.exclusiveMaximum, n)), t = Qe(t, (n) => (n.example !== void 0 && (n.examples = {
    default: n.example
  }, delete n.example), n)), t = Qe(t, (n) => {
    if (n.type === "object" && n.properties !== void 0)
      for (const [r, s] of Object.entries(n.properties))
        s !== void 0 && // @ts-ignore
        s.type === "string" && // @ts-ignore
        s.format === "binary" && (s.contentEncoding = "application/octet-stream", delete s.format);
    return n;
  }), t = Qe(t, (n) => {
    if (!(n.type === "string" && n.format === "binary"))
      return n;
  }), t = Qe(t, (n) => n.type === "string" && n.format === "base64" ? {
    type: "string",
    contentEncoding: "base64"
  } : n), t;
}
function Pg(t) {
  return t;
}
function kg(t) {
  return [Pg, Ng].reduce(
    (n, r) => r(n),
    t
  );
}
async function Ag(t) {
  const e = new ua(), n = Jc(t);
  return {
    ...await e.validate(n),
    specification: e.specification,
    version: e.version
  };
}
function Hc(t) {
  for (const e of new Set(Zo)) {
    const n = e === "2.0" ? "swagger" : "openapi", r = t[n];
    if (typeof r == "string" && r.startsWith(e))
      return {
        version: e,
        specificationType: n,
        specificationVersion: r
      };
  }
  return {
    version: void 0,
    specificationType: void 0,
    specificationVersion: void 0
  };
}
function Tg(t) {
  return decodeURI(t.replace(/~1/g, "/").replace(/~0/g, "~"));
}
function Yc(t) {
  const e = structuredClone(t);
  return n(e), n(e), e;
  function n(r) {
    Object.entries(r ?? {}).forEach(([s, i]) => {
      if (r.$ref !== void 0) {
        const a = Cg(e, r.$ref);
        delete r.$ref, typeof a == "object" && Object.keys(a).forEach((o) => {
          r[o] === void 0 && (r[o] = a[o]);
        });
      }
      typeof i == "object" && !Ig(i) && n(i);
    });
  }
}
function Ig(t) {
  try {
    return JSON.stringify(t), !1;
  } catch {
    return !0;
  }
}
function Cg(t, e) {
  if (typeof e != "string")
    return;
  const [n, r] = e.split("#", 2);
  if (n)
    throw new Error(Ys.EXTERNAL_REFERENCE_NOT_SUPPORTED.replace("%s", e));
  return Tg(r).split("/").slice(1).reduce((i, a) => i[a], t);
}
const jg = "[", Rg = "]", Dg = "{", Mg = "}", Lg = ":", Vg = ",", Wc = "true", Qc = "false", Xc = "null", co = '"', Fg = /* @__PURE__ */ new Map([
  ["t", Wc],
  ["f", Qc],
  ["n", Xc]
]), ni = /* @__PURE__ */ new Map([
  [co, co],
  ["\\", "\\"],
  ["/", "/"],
  ["b", "\b"],
  ["n", `
`],
  ["f", "\f"],
  ["r", "\r"],
  ["t", "	"]
]), Cs = /* @__PURE__ */ new Map([
  [jg, "LBracket"],
  [Rg, "RBracket"],
  [Dg, "LBrace"],
  [Mg, "RBrace"],
  [Lg, "Colon"],
  [Vg, "Comma"],
  [Wc, "Boolean"],
  [Qc, "Boolean"],
  [Xc, "Null"]
]);
class Qn extends Error {
  /**
   * Creates a new instance.
   * @param {string} message The error message to report. 
   * @param {Location} loc The location information for the error.
   */
  constructor(e, { line: n, column: r, offset: s }) {
    super(`${e} (${n}:${r})`), this.line = n, this.column = r, this.offset = s;
  }
}
class Ug extends Qn {
  /**
   * Creates a new instance.
   * @param {string} unexpected The character that was found.
   * @param {Location} loc The location information for the found character.
   */
  constructor(e, n) {
    super(`Unexpected character '${e}' found.`, n);
  }
}
class js extends Qn {
  /**
   * Creates a new instance.
   * @param {Token} token The token that was found. 
   */
  constructor(e) {
    super(`Unexpected token ${e.type} found.`, e.loc.start);
  }
}
class qg extends Qn {
  /**
   * Creates a new instance.
   * @param {Location} loc The location information for the found character.
   */
  constructor(e) {
    super("Unexpected end of input found.", e);
  }
}
const lo = '"', uo = "/", fo = "*", Kg = {
  mode: "json",
  ranges: !1
};
function Bg(t) {
  return /[\s\n]/.test(t);
}
function ht(t) {
  return t >= "0" && t <= "9";
}
function zg(t) {
  return ht(t) || /[a-f]/i.test(t);
}
function Gg(t) {
  return t >= "1" && t <= "9";
}
function Jg(t) {
  return /[tfn]/.test(t);
}
function Hg(t) {
  return ht(t) || t === "." || t === "-";
}
function Yg(t, e) {
  e = Object.freeze({
    ...Kg,
    ...e
  });
  let n = -1, r = 1, s = 0, i = !1;
  const a = [];
  function o(u, p, b, E) {
    const C = b.offset + p.length;
    let _ = e.ranges ? {
      range: [b.offset, C]
    } : void 0;
    return {
      type: u,
      loc: {
        start: b,
        end: E || {
          line: b.line,
          column: b.column + p.length,
          offset: C
        }
      },
      ..._
    };
  }
  function c() {
    let u = t.charAt(++n);
    return i ? (r++, s = 1, i = !1) : s++, u === "\r" ? (i = !0, t.charAt(n + 1) === `
` && n++) : u === `
` && (i = !0), u;
  }
  function l() {
    return {
      line: r,
      column: s,
      offset: n
    };
  }
  function f(u) {
    let p = Fg.get(u);
    if (t.slice(n, n + p.length) === p)
      return n += p.length - 1, s += p.length - 1, { value: p, c: c() };
    for (let b = 1; b < p.length; b++)
      p[b] !== t.charAt(n + b) && w(c());
  }
  function d(u) {
    let p = u;
    for (u = c(); u && u !== lo; ) {
      if (u === "\\")
        if (p += u, u = c(), ni.has(u))
          p += u;
        else if (u === "u") {
          p += u;
          for (let b = 0; b < 4; b++)
            u = c(), zg(u) ? p += u : w(u);
        } else
          w(u);
      else
        p += u;
      u = c();
    }
    return u || y(), p += u, { value: p, c: c() };
  }
  function g(u) {
    let p = "";
    if (u === "-" && (p += u, u = c(), ht(u) || w(u)), u === "0")
      p += u, u = c(), ht(u) && w(u);
    else {
      Gg(u) || w(u);
      do
        p += u, u = c();
      while (ht(u));
    }
    if (u === ".")
      do
        p += u, u = c();
      while (ht(u));
    if (u === "e" || u === "E")
      for (p += u, u = c(), (u === "+" || u === "-") && (p += u, u = c()), u || y(), ht(u) || w(u); ht(u); )
        p += u, u = c();
    return { value: p, c: u };
  }
  function v(u) {
    let p = u;
    if (u = c(), u === "/") {
      do
        p += u, u = c();
      while (u && u !== "\r" && u !== `
`);
      return { value: p, c: u };
    }
    if (u === fo) {
      for (; u; )
        if (p += u, u = c(), u === fo && (p += u, u = c(), u === uo))
          return p += u, u = c(), { value: p, c: u };
      y();
    }
    w(u);
  }
  function w(u) {
    throw new Ug(u, l());
  }
  function y() {
    throw new qg(l());
  }
  let h = c();
  for (; n < t.length; ) {
    for (; Bg(h); )
      h = c();
    if (!h)
      break;
    const u = l();
    if (Cs.has(h))
      a.push(o(Cs.get(h), h, u)), h = c();
    else if (Jg(h)) {
      const p = f(h);
      let b = p.value;
      h = p.c, a.push(o(Cs.get(b), b, u));
    } else if (Hg(h)) {
      const p = g(h);
      let b = p.value;
      h = p.c, a.push(o("Number", b, u));
    } else if (h === lo) {
      const p = d(h);
      let b = p.value;
      h = p.c, a.push(o("String", b, u));
    } else if (h === uo && e.mode === "jsonc") {
      const p = v(h);
      let b = p.value;
      h = p.c, a.push(o(b.startsWith("//") ? "LineComment" : "BlockComment", b, u, l()));
    } else
      w(h);
  }
  return a;
}
const rt = {
  /**
   * Creates a document node.
   * @param {ValueNode} body The body of the document.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {DocumentNode} The document node.
   */
  document(t, e = {}) {
    return {
      type: "Document",
      body: t,
      ...e
    };
  },
  /**
   * Creates a string node.
   * @param {string} value The value for the string.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {StringNode} The string node.
   */
  string(t, e = {}) {
    return {
      type: "String",
      value: t,
      ...e
    };
  },
  /**
   * Creates a number node.
   * @param {number} value The value for the number.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {NumberNode} The number node.
   */
  number(t, e = {}) {
    return {
      type: "Number",
      value: t,
      ...e
    };
  },
  /**
   * Creates a boolean node.
   * @param {boolean} value The value for the boolean.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {BooleanNode} The boolean node.
   */
  boolean(t, e = {}) {
    return {
      type: "Boolean",
      value: t,
      ...e
    };
  },
  /**
   * Creates a null node.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {NullNode} The null node.
   */
  null(t = {}) {
    return {
      type: "Null",
      ...t
    };
  },
  /**
   * Creates an array node.
   * @param {Array<ElementNode>} elements The elements to add.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ArrayNode} The array node.
   */
  array(t, e = {}) {
    return {
      type: "Array",
      elements: t,
      ...e
    };
  },
  /**
   * Creates an element node.
   * @param {ValueNode} value The value for the element.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ElementNode} The element node.
   */
  element(t, e = {}) {
    return {
      type: "Element",
      value: t,
      ...e
    };
  },
  /**
   * Creates an object node.
   * @param {Array<MemberNode>} members The members to add.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ObjectNode} The object node.
   */
  object(t, e = {}) {
    return {
      type: "Object",
      members: t,
      ...e
    };
  },
  /**
   * Creates a member node.
   * @param {StringNode} name The name for the member.
   * @param {ValueNode} value The value for the member.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {MemberNode} The member node.
   */
  member(t, e, n = {}) {
    return {
      type: "Member",
      name: t,
      value: e,
      ...n
    };
  }
}, Wg = {
  mode: "json",
  ranges: !1,
  tokens: !1
};
function Qg(t, e) {
  let n = "", r = t.indexOf("\\"), s = 0;
  for (; r >= 0; ) {
    n += t.slice(s, r);
    const i = t.charAt(r + 1);
    if (ni.has(i))
      n += ni.get(i), s = r + 2;
    else if (i === "u") {
      const a = t.slice(r + 2, r + 6);
      if (a.length < 4 || /[^0-9a-f]/i.test(a))
        throw new Qn(
          `Invalid unicode escape \\u${a}.`,
          {
            line: e.loc.start.line,
            column: e.loc.start.column + r,
            offset: e.loc.start.offset + r
          }
        );
      n += String.fromCharCode(parseInt(a, 16)), s = r + 6;
    } else
      throw new Qn(
        `Invalid escape \\${i}.`,
        {
          line: e.loc.start.line,
          column: e.loc.start.column + r,
          offset: e.loc.start.offset + r
        }
      );
    r = t.indexOf("\\", s);
  }
  return n += t.slice(s), n;
}
function Xg(t, e) {
  switch (e.type) {
    case "Boolean":
      return t === "true";
    case "Number":
      return Number(t);
    case "String":
      return Qg(t.slice(1, -1), e);
    default:
      throw new TypeError(`Unknown token type "${e.type}.`);
  }
}
function Zg(t, e) {
  e = Object.freeze({
    ...Wg,
    ...e
  });
  const n = Yg(t, {
    mode: e.mode,
    ranges: e.ranges
  });
  let r = 0;
  function s() {
    return n[r++];
  }
  function i() {
    const p = n[r++];
    return p && p.type.endsWith("Comment") ? i() : p;
  }
  const a = e.mode === "jsonc" ? i : s;
  function o(p, b) {
    if (!p || p.type !== b)
      throw new js(p);
  }
  function c(p, b) {
    return e.ranges ? {
      range: [p.offset, b.offset]
    } : void 0;
  }
  function l(p) {
    const b = c(p.loc.start, p.loc.end), E = Xg(
      t.slice(p.loc.start.offset, p.loc.end.offset),
      p
    ), _ = { loc: {
      start: {
        ...p.loc.start
      },
      end: {
        ...p.loc.end
      }
    }, ...b };
    switch (p.type) {
      case "String":
        return rt.string(
          /** @type {string} */
          E,
          _
        );
      case "Number":
        return rt.number(
          /** @type {number} */
          E,
          _
        );
      case "Boolean":
        return rt.boolean(
          /** @type {boolean} */
          E,
          _
        );
      default:
        throw new TypeError(`Unknown token type ${p.type}.`);
    }
  }
  function f(p) {
    const b = c(p.loc.start, p.loc.end);
    return rt.null({
      loc: {
        start: {
          ...p.loc.start
        },
        end: {
          ...p.loc.end
        }
      },
      ...b
    });
  }
  function d(p) {
    o(p, "String");
    const b = l(p);
    p = a(), o(p, "Colon");
    const E = w(), C = c(b.loc.start, E.loc.end);
    return rt.member(
      /** @type {StringNode} */
      b,
      E,
      {
        loc: {
          start: {
            ...b.loc.start
          },
          end: {
            ...E.loc.end
          }
        },
        ...C
      }
    );
  }
  function g(p) {
    o(p, "LBrace");
    const b = [];
    let E = a();
    if (E && E.type !== "RBrace")
      do
        if (b.push(d(E)), E = a(), E.type === "Comma")
          E = a();
        else
          break;
      while (E);
    o(E, "RBrace");
    const C = c(p.loc.start, E.loc.end);
    return rt.object(b, {
      loc: {
        start: {
          ...p.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...C
    });
  }
  function v(p) {
    o(p, "LBracket");
    const b = [];
    let E = a();
    if (E && E.type !== "RBracket")
      do {
        const _ = w(E);
        if (b.push(rt.element(
          _,
          { loc: _.loc }
        )), E = a(), E.type === "Comma")
          E = a();
        else
          break;
      } while (E);
    o(E, "RBracket");
    const C = c(p.loc.start, E.loc.end);
    return rt.array(b, {
      loc: {
        start: {
          ...p.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...C
    });
  }
  function w(p) {
    switch (p = p || a(), p.type) {
      case "String":
      case "Boolean":
      case "Number":
        return l(p);
      case "Null":
        return f(p);
      case "LBrace":
        return g(p);
      case "LBracket":
        return v(p);
      default:
        throw new js(p);
    }
  }
  const y = w(), h = a();
  if (h)
    throw new js(h);
  const u = {
    loc: {
      start: {
        line: 1,
        column: 1,
        offset: 0
      },
      end: {
        ...y.loc.end
      }
    }
  };
  return e.tokens && (u.tokens = n), e.ranges && (u.range = [
    u.loc.start.offset,
    u.loc.end.offset
  ]), rt.document(y, u);
}
const xg = (t) => (e) => t === e, e0 = (t) => (e) => !t(e), t0 = (t) => Object.values(t), n0 = (t) => t !== void 0, ca = (t) => (e) => e.keyword === t, r0 = ca("required"), s0 = ca("anyOf"), Zc = ca("enum"), Vn = (t) => t && t.errors || [], xc = (t) => t && t0(t.children) || [], i0 = (t) => (e) => xc(t).filter(e0(xg(e))), ho = (
  /* ::<T> */
  (t) => (e) => e.reduce((n, r) => n.concat(r), t)
), el = (t) => {
  const e = t.split("/").slice(1);
  for (const n in e)
    e[n] = e[n].split("~1").join("/").split("~0").join("~");
  return e;
};
function a0(t, e, n) {
  const r = el(e), s = r.length - 1;
  return r.reduce((i, a, o) => {
    switch (i == null ? void 0 : i.type) {
      case "Object": {
        const c = i.members.filter(
          (d) => d.name.value === a
        );
        if (c.length !== 1)
          throw new Error(`Couldn't find property ${a} of ${e}`);
        const { name: l, value: f } = c[0];
        return n && o === s ? l : f;
      }
      case "Array":
        return i.elements[a];
      default:
        if (i.loc)
          return i;
    }
  }, t.body);
}
function o0(t) {
  if (!t || !t.elements)
    return "";
  const e = t.elements.filter(
    (n) => n && n.name && n.name.value === "type"
  );
  return e.length && e[0].value && `:${e[0].value.value}` || "";
}
function c0(t, e) {
  let n = "";
  return el(e).reduce((r, s) => {
    switch (r == null ? void 0 : r.type) {
      case "Object": {
        n += `/${s}`;
        const i = r.members.filter(
          (a) => a.name.value === s
        );
        if (i.length !== 1)
          throw new Error(`Couldn't find property ${s} of ${e}`);
        return i[0].value;
      }
      case "Array":
        return n += `/${s}${o0(r.elements[s])}`, r.elements[s];
    }
  }, t.body), n;
}
class wn {
  // eslint-disable-next-line default-param-last
  constructor(e = { isIdentifierLocation: !1 }, { colorize: n, data: r, schema: s, jsonAst: i, jsonRaw: a }) {
    this.options = e, this.colorize = !!(n || n === void 0), this.data = r, this.schema = s, this.jsonAst = i, this.jsonRaw = a;
  }
  getChalk() {
    return this.colorize ? chalk : new chalk.Instance({ level: 0 });
  }
  getLocation(e = this.instancePath) {
    const { isIdentifierLocation: n, isSkipEndLocation: r } = this.options, { loc: s } = a0(
      this.jsonAst,
      e,
      n
    );
    return {
      start: s.start,
      end: r ? void 0 : s.end
    };
  }
  getDecoratedPath(e = this.instancePath) {
    return c0(this.jsonAst, e);
  }
  getCodeFrame(e, n = this.instancePath) {
    return codeFrameColumns(this.jsonRaw, this.getLocation(n), {
      /**
       * `@babel/highlight`, by way of `@babel/code-frame`, highlights out entire block of raw JSON
       * instead of just our `location` block -- so if you have a block of raw JSON that's upwards
       * of 2mb+ and have a lot of errors to generate code frames for then we're re-highlighting
       * the same huge chunk of code over and over and over and over again, all just so
       * `@babel/code-frame` will eventually extract a small <10 line chunk out of it to return to
       * us.
       *
       * Disabling `highlightCode` here will only disable highlighting the code we're showing users;
       * if `options.colorize` is supplied to this library then the error message we're adding will
       * still be highlighted.
       */
      highlightCode: !1,
      message: e
    });
  }
  /**
   * @return {string}
   */
  get instancePath() {
    return typeof this.options.instancePath < "u" ? this.options.instancePath : this.options.dataPath;
  }
  print() {
    throw new Error(
      `Implement the 'print' method inside ${this.constructor.name}!`
    );
  }
  getError() {
    throw new Error(
      `Implement the 'getError' method inside ${this.constructor.name}!`
    );
  }
}
class l0 extends wn {
  constructor(...e) {
    super(...e), this.name = "AdditionalPropValidationError", this.options.isIdentifierLocation = !0;
  }
  print() {
    const { message: e, params: n } = this.options, r = this.getChalk();
    return [r`{red {bold ADDITIONAL PROPERTY} ${e}}\n`].concat(
      this.getCodeFrame(
        r`  {magentaBright ${n.additionalProperty}} is not expected to be here!`,
        `${this.instancePath}/${n.additionalProperty}`
      )
    );
  }
  getError() {
    const { params: e } = this.options;
    return {
      ...this.getLocation(`${this.instancePath}/${e.additionalProperty}`),
      error: `${this.getDecoratedPath()} Property ${e.additionalProperty} is not expected to be here`,
      path: this.instancePath
    };
  }
}
class u0 extends wn {
  constructor(...e) {
    super(...e), this.name = "DefaultValidationError", this.options.isSkipEndLocation = !0;
  }
  print() {
    const { keyword: e, message: n } = this.options, r = this.getChalk();
    return [r`{red {bold ${e.toUpperCase()}} ${n}}\n`].concat(
      this.getCodeFrame(r`  {magentaBright ${e}} ${n}`)
    );
  }
  getError() {
    const { keyword: e, message: n } = this.options;
    return {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()}: ${e} ${n}`,
      path: this.instancePath
    };
  }
}
var ms = {}, f0 = /~/, d0 = /~[01]/g;
function h0(t) {
  switch (t) {
    case "~1":
      return "/";
    case "~0":
      return "~";
  }
  throw new Error("Invalid tilde escape: " + t);
}
function tl(t) {
  return f0.test(t) ? t.replace(d0, h0) : t;
}
function m0(t, e, n) {
  for (var r, s, i = 1, a = e.length; i < a; ) {
    if (e[i] === "constructor" || e[i] === "prototype" || e[i] === "__proto__")
      return t;
    if (r = tl(e[i++]), s = a > i, typeof t[r] > "u" && (Array.isArray(t) && r === "-" && (r = t.length), s && (e[i] !== "" && e[i] < 1 / 0 || e[i] === "-" ? t[r] = [] : t[r] = {})), !s)
      break;
    t = t[r];
  }
  var o = t[r];
  return n === void 0 ? delete t[r] : t[r] = n, o;
}
function la(t) {
  if (typeof t == "string") {
    if (t = t.split("/"), t[0] === "")
      return t;
    throw new Error("Invalid JSON pointer.");
  } else if (Array.isArray(t)) {
    for (const e of t)
      if (typeof e != "string" && typeof e != "number")
        throw new Error("Invalid JSON pointer. Must be of type string or number.");
    return t;
  }
  throw new Error("Invalid JSON pointer.");
}
function nl(t, e) {
  if (typeof t != "object")
    throw new Error("Invalid input object.");
  e = la(e);
  var n = e.length;
  if (n === 1)
    return t;
  for (var r = 1; r < n; ) {
    if (t = t[tl(e[r++])], n === r)
      return t;
    if (typeof t != "object" || t === null)
      return;
  }
}
function rl(t, e, n) {
  if (typeof t != "object")
    throw new Error("Invalid input object.");
  if (e = la(e), e.length === 0)
    throw new Error("Invalid JSON pointer for set.");
  return m0(t, e, n);
}
function p0(t) {
  var e = la(t);
  return {
    get: function(n) {
      return nl(n, e);
    },
    set: function(n, r) {
      return rl(n, e, r);
    }
  };
}
ms.get = nl;
ms.set = rl;
ms.compile = p0;
const Rs = [], mo = [];
function y0(t, e) {
  if (t === e)
    return 0;
  const n = t;
  t.length > e.length && (t = e, e = n);
  let r = t.length, s = e.length;
  for (; r > 0 && t.charCodeAt(~-r) === e.charCodeAt(~-s); )
    r--, s--;
  let i = 0;
  for (; i < r && t.charCodeAt(i) === e.charCodeAt(i); )
    i++;
  if (r -= i, s -= i, r === 0)
    return s;
  let a, o, c, l, f = 0, d = 0;
  for (; f < r; )
    mo[f] = t.charCodeAt(i + f), Rs[f] = ++f;
  for (; d < s; )
    for (a = e.charCodeAt(i + d), c = d++, o = d, f = 0; f < r; f++)
      l = a === mo[f] ? c : c + 1, c = Rs[f], o = Rs[f] = c > o ? l > o ? o + 1 : l : l > c ? c + 1 : l;
  return o;
}
class g0 extends wn {
  constructor(...e) {
    super(...e), this.name = "EnumValidationError";
  }
  print() {
    const {
      message: e,
      params: { allowedValues: n }
    } = this.options, r = this.getChalk(), s = this.findBestMatch();
    return [
      r`{red {bold ENUM} ${e}}`,
      r`{red (${n.join(", ")})}\n`
    ].concat(
      this.getCodeFrame(
        s !== null ? r`  Did you mean {magentaBright ${s}} here?` : r`  Unexpected value, should be equal to one of the allowed values`
      )
    );
  }
  getError() {
    const { message: e, params: n } = this.options, r = this.findBestMatch(), s = n.allowedValues.join(", "), i = {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()} ${e}: ${s}`,
      path: this.instancePath
    };
    return r !== null && (i.suggestion = `Did you mean ${r}?`), i;
  }
  findBestMatch() {
    const {
      params: { allowedValues: e }
    } = this.options, n = this.instancePath === "" ? this.data : ms.get(this.data, this.instancePath);
    if (!n)
      return null;
    const r = e.map((s) => ({
      value: s,
      weight: y0(s, n.toString())
    })).sort(
      (s, i) => s.weight > i.weight ? 1 : s.weight < i.weight ? -1 : 0
    )[0];
    return e.length === 1 || r.weight < r.value.length ? r.value : null;
  }
}
class $0 extends wn {
  constructor(...e) {
    super(...e), this.name = "PatternValidationError", this.options.isIdentifierLocation = !0;
  }
  print() {
    const { message: e, params: n, propertyName: r } = this.options, s = this.getChalk();
    return [s`{red {bold PROPERTY} ${e}}\n`].concat(
      this.getCodeFrame(
        s`  must match pattern {magentaBright ${n.pattern}}`,
        `${this.instancePath}/${r}`
      )
    );
  }
  getError() {
    const { params: e, propertyName: n } = this.options;
    return {
      // ...this.getLocation(`${this.instancePath}/${params.propertyName}`),
      ...this.getLocation(),
      error: `${this.getDecoratedPath()} Property "${n}" must match pattern ${e.pattern}`,
      path: this.instancePath
    };
  }
}
class v0 extends wn {
  constructor(...e) {
    super(...e), this.name = "RequiredValidationError";
  }
  getLocation(e = this.instancePath) {
    const { start: n } = super.getLocation(e);
    return { start: n };
  }
  print() {
    const { message: e, params: n } = this.options, r = this.getChalk();
    return [r`{red {bold REQUIRED} ${e}}\n`].concat(
      this.getCodeFrame(
        r`  {magentaBright ${n.missingProperty}} is missing here!`
      )
    );
  }
  getError() {
    const { message: e } = this.options;
    return {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()} ${e}`,
      path: this.instancePath
    };
  }
}
class b0 extends wn {
  constructor(...e) {
    super(...e), this.name = "UnevaluatedPropValidationError", this.options.isIdentifierLocation = !0;
  }
  print() {
    const { message: e, params: n } = this.options, r = this.getChalk();
    return [r`{red {bold UNEVALUATED PROPERTY} ${e}}\n`].concat(
      this.getCodeFrame(
        r`  {magentaBright ${n.unevaluatedProperty}} is not expected to be here!`,
        `${this.instancePath}/${n.unevaluatedProperty}`
      )
    );
  }
  getError() {
    const { params: e } = this.options;
    return {
      ...this.getLocation(`${this.instancePath}/${e.unevaluatedProperty}`),
      error: `${this.getDecoratedPath()} Property ${e.unevaluatedProperty} is not expected to be here`,
      path: this.instancePath
    };
  }
}
const _0 = /\/[\w_-]+(\/\d+)?/g;
function w0(t = []) {
  const e = { children: {} };
  return t.forEach((n) => {
    const r = typeof n.instancePath < "u" ? n.instancePath : n.dataPath, s = r === "" ? [""] : r.match(_0);
    s && s.reduce((i, a, o) => (i.children[a] = i.children[a] || { children: {}, errors: [] }, o === s.length - 1 && i.children[a].errors.push(n), i.children[a]), e);
  }), e;
}
function sl(t, e, n) {
  Vn(t).forEach((r) => {
    r0(r) && (t.errors = [r], t.children = {});
  }), Vn(t).some(s0) && Object.keys(t.children).length > 0 && delete t.errors, t.errors && t.errors.length && Vn(t).every(Zc) && i0(e)(t).filter(n0).some(Vn) && delete e.children[n], Object.entries(t.children).forEach(
    ([r, s]) => sl(s, t, r)
  );
}
function il(t, e) {
  const n = Vn(t);
  if (n.length && n.every(Zc)) {
    const s = [...new Set(
      ho([])(n.map((a) => a.params.allowedValues))
    )], i = n[0];
    return [
      new g0(
        {
          ...i,
          params: { allowedValues: s }
        },
        e
      )
    ];
  }
  return ho(
    n.reduce((r, s) => {
      switch (s.keyword) {
        case "additionalProperties":
          return r.concat(new l0(s, e));
        case "pattern":
          return r.concat(new $0(s, e));
        case "required":
          return r.concat(new v0(s, e));
        case "unevaluatedProperties":
          return r.concat(new b0(s, e));
        default:
          return r.concat(new u0(s, e));
      }
    }, [])
  )(xc(t).map((r) => il(r, e)));
}
function S0(t, e) {
  const n = w0(t || []);
  return sl(n), il(n, e);
}
function E0(t, e, n, r = {}) {
  const {
    colorize: s = !0,
    format: i = "cli",
    indent: a = null,
    json: o = null
  } = r, c = o || JSON.stringify(e, null, a), l = Zg(c), f = (v) => v.print().join(`
`), d = (v) => v.getError(), g = S0(n, {
    colorize: s,
    data: e,
    schema: t,
    jsonAst: l,
    jsonRaw: c
  });
  return i === "cli" ? g.map(f).join(`

`) : g.map(d);
}
function Fn(t, e) {
  return typeof e == "string" ? [
    {
      start: {
        line: 1,
        column: 1,
        offset: 0
      },
      error: e,
      path: ""
    }
  ] : E0(t, null, e, {
    format: "js",
    indent: 2,
    colorize: !1
  }).map((n) => (n.error = n.error.trim(), n));
}
function O0(t) {
  try {
    return Yc(t), {
      valid: !0
    };
  } catch (e) {
    return {
      valid: !1,
      errors: Fn(t, e.message)
    };
  }
}
class ua {
  constructor() {
    nt(this, "version");
    // Object with function *or* object { errors: string }
    nt(this, "ajvValidators", {});
    nt(this, "externalRefs", {});
    nt(this, "errors");
    nt(this, "specificationVersion");
    nt(this, "specificationType");
    nt(this, "specification");
  }
  resolveReferences(e) {
    return Yc(
      e.find((n) => n.isEntrypoint === !0).specification
    );
  }
  /**
   * Checks whether a specification is valid and all references can be resolved.
   */
  async validate(e) {
    var s;
    const n = e.find((i) => i.isEntrypoint), r = n == null ? void 0 : n.specification;
    this.specification = r, (s = this.specification) != null && s.info && !this.specification.info.version && (this.specification.info.version = "0.0.1");
    try {
      if (r == null)
        return {
          valid: !1,
          errors: Fn(n, Ys.EMPTY_OR_INVALID)
        };
      Object.keys(this.externalRefs).length > 0 && (r[fy] = this.externalRefs);
      const { version: i, specificationType: a, specificationVersion: o } = Hc(r);
      if (this.version = i, this.specificationVersion = o, this.specificationType = a, !i)
        return {
          valid: !1,
          errors: Fn(
            n,
            Ys.OPENAPI_VERSION_NOT_SUPPORTED
          )
        };
      const c = await this.getAjvValidator(i);
      return c(r) ? O0(n.specification) : c.errors && c.errors.length > 0 ? {
        valid: !1,
        errors: Fn(n, c.errors)
      } : {
        valid: !1
      };
    } catch (i) {
      return {
        valid: !1,
        errors: Fn(n, i.message ?? i)
      };
    }
  }
  /**
   * Ajv JSON schema validator
   */
  async getAjvValidator(e) {
    if (this.ajvValidators[e])
      return this.ajvValidators[e];
    const n = await bl(/* @__PURE__ */ Object.assign({ "../../../schemas/v2.0/schema.json": () => import("./schema-BQQoKgNw.js"), "../../../schemas/v3.0/schema.json": () => import("./schema-BjykgtPd.js"), "../../../schemas/v3.1/schema.json": () => import("./schema-ZROhtp0X.js") }), `../../../schemas/v${e}/schema.json`), r = uy[n.$schema], s = new r({
      // Ajv is a bit too strict in its strict validation of OpenAPI schemas.
      // Switch strict mode off.
      strict: !1
    });
    return ph(s), e === "3.1" && s.addFormat("media-range", !0), this.ajvValidators[e] = s.compile(n);
  }
}
nt(ua, "supportedVersions", Zo);
function k0() {
  return {
    load: N0
  };
}
function N0(t) {
  const e = oa(t);
  return {
    get: () => e,
    details: () => ys(e),
    filter: (n) => ar(e, n),
    upgrade: () => al(e),
    validate: () => fa(e),
    resolve: () => ps(e),
    toJson: () => or(e),
    toYaml: () => cr(e)
  };
}
function al(t) {
  const e = kg(t);
  return {
    get: () => e,
    details: () => ys(e),
    filter: (n) => ar(e, n),
    validate: () => fa(e),
    resolve: () => ps(e),
    toJson: () => or(e),
    toYaml: () => cr(e)
  };
}
async function fa(t) {
  return {
    ...await Ag(t),
    filter: (e) => ar(t, e),
    get: () => t,
    details: () => ys(t),
    resolve: () => ps(t),
    toJson: () => or(t),
    toYaml: () => cr(t)
  };
}
async function ps(t) {
  return {
    ...await Sg(t),
    filter: (e) => ar(t, e),
    toJson: () => or(t),
    toYaml: () => cr(t)
  };
}
function ar(t, e) {
  const n = dy(t, e);
  return {
    get: () => n,
    details: () => ys(n),
    filter: () => ar(n, e),
    upgrade: () => al(n),
    validate: () => fa(n),
    resolve: () => ps(n),
    toJson: () => or(n),
    toYaml: () => cr(n)
  };
}
function ys(t) {
  return Hc(t);
}
function or(t) {
  return Eg(t);
}
function cr(t) {
  return Og(t);
}
export {
  ua as Validator,
  Hc as details,
  dy as filter,
  Ws as getListOfReferences,
  xo as isFilesystem,
  wg as loadFiles,
  oa as normalize,
  k0 as openapi,
  Sg as resolve,
  Yc as resolveReferences,
  Eg as toJson,
  Og as toYaml,
  Qe as traverse,
  kg as upgrade,
  Ng as upgradeFromThreeToThreeOne,
  Pg as upgradeFromTwoToThree,
  Ag as validate
};
